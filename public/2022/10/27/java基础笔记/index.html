<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ninoLOG.png">
  
  <title>java基础笔记 | nino&#39;sBlog</title>
  <meta name="author" content="John Doe" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="java" />
  
  <meta name="description" content="[TOC] java基础这是快速复习java基础的笔记 重要编程思想化繁为简：现将复杂的功能转变成简单的需求。 先死后活：有限考虑固定的值，再考虑变量。 java概述知识点： 快速练习 使用黑窗口编译.java文件时，注意要把需要编译的java文件编码设置与cmd黑窗口编码相同  javac hello.java &#x2F;&#x2F;编译指令			 12343. &#96;&#96;&#96;java   java hello &#x2F;&#x2F;运行">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础笔记">
<meta property="og:url" content="http://example.com/2022/10/27/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="nino&#39;sBlog">
<meta property="og:description" content="[TOC] java基础这是快速复习java基础的笔记 重要编程思想化繁为简：现将复杂的功能转变成简单的需求。 先死后活：有限考虑固定的值，再考虑变量。 java概述知识点： 快速练习 使用黑窗口编译.java文件时，注意要把需要编译的java文件编码设置与cmd黑窗口编码相同  javac hello.java &#x2F;&#x2F;编译指令			 12343. &#96;&#96;&#96;java   java hello &#x2F;&#x2F;运行">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ninoLOG.png">
<meta property="article:published_time" content="2022-10-27T04:40:00.000Z">
<meta property="article:modified_time" content="2022-10-27T05:23:58.499Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ninoLOG.png">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/wxjb.webp');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
  </style>
  
<meta name="generator" content="Hexo 6.3.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">nino&#39;sBlog</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>nino&#39;sBlog</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/27/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">java基础笔记</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2022-10-27T04:40:00.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2022-10-27</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">John Doe</span>
                </li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~152.66K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1666848238499"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">1.1.</span> <span class="toc-text">重要编程思想</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">java概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E7%BB%83%E4%B9%A0"><span class="toc-number">2.1.</span> <span class="toc-text">快速练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B6%E8%A1%A8%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">制表符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.1.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="toc-number">3.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-2"><span class="toc-number">3.1.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.算数运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.关系运算符（比较运算符）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.4.</span> <span class="toc-text">4.逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-x3D-%EF%BC%89%E3%80%81"><span class="toc-number">3.1.5.</span> <span class="toc-text">5.赋值运算符（&#x3D;）、</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.6.</span> <span class="toc-text">6.三元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.1.7.</span> <span class="toc-text">7.运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">进制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.3.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amp-11011101"><span class="toc-number">3.4.</span> <span class="toc-text">  &amp;11011101</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">程序控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%EF%BC%88if-else-switch%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">顺序控制（if,else,switch）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">4.1.2.</span> <span class="toc-text">分支控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%8D%95%E5%88%86%E6%94%AF"><span class="toc-number">4.1.3.</span> <span class="toc-text">1）单分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%8F%8C%E5%88%86%E6%94%AF"><span class="toc-number">4.1.4.</span> <span class="toc-text">2）双分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%A4%9A%E5%88%86%E6%94%AF"><span class="toc-number">4.1.5.</span> <span class="toc-text">3）多分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%B5%8C%E5%A5%97%E5%88%86%E6%94%AF"><span class="toc-number">4.1.6.</span> <span class="toc-text">4）嵌套分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89switch%E5%88%86%E6%94%AF"><span class="toc-number">4.1.7.</span> <span class="toc-text">5）switch分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%EF%BC%88for-while-dowhile-%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF-%E9%87%8D%E7%82%B9-%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">循环控制（for,while,dowhile,多重循环[重点]）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89for%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.1.</span> <span class="toc-text">1）for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">注意事项：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">编程技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89while%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.2.</span> <span class="toc-text">2）while循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-1"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89do%E2%80%A6while%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-number">4.2.3.</span> <span class="toc-text">3）do…while循环控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-2"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.4.</span> <span class="toc-text">4）多重循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">练习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#continue-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">continue-跳转控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#return-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.4.</span> <span class="toc-text">return-跳转控制语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">数组【重点】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.1.1.</span> <span class="toc-text">动态初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F1"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">使用方式1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F2"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">使用方式2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.1.2.</span> <span class="toc-text">静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">5.1.3.</span> <span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6"><span class="toc-number">5.1.4.</span> <span class="toc-text">数组赋值机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.1.5.</span> <span class="toc-text">数组拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="toc-number">5.1.6.</span> <span class="toc-text">数组翻转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9"><span class="toc-number">5.1.7.</span> <span class="toc-text">数组扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">5.2.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">5.3.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">1）顺序查找：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">5.3.2.</span> <span class="toc-text">2）二分查找：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">5.4.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE%EF%BC%9A"><span class="toc-number">5.4.1.</span> <span class="toc-text">二维数组内存原理图：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.4.2.</span> <span class="toc-text">二维数组的使用方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.</span> <span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BD%A2%E5%BC%8F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">6.1.1.</span> <span class="toc-text">对象在内存中存在的形式（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">6.1.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.3.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.4.</span> <span class="toc-text">类对象的内存分配机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">6.2.1.</span> <span class="toc-text">内存分析流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.2.2.</span> <span class="toc-text">成员方法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">6.2.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">成员方法传参（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%9C%BA%E5%88%B6%EF%BC%88recursion%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">递归机制（recursion）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E4%B9%98%EF%BC%88factorial%EF%BC%89"><span class="toc-number">6.4.1.</span> <span class="toc-text">阶乘（factorial）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">6.4.2.</span> <span class="toc-text">递归调用的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E7%BB%83%E4%B9%A0"><span class="toc-number">6.4.3.</span> <span class="toc-text">斐波拉契数练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88overload%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">重载（overload）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">6.6.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.7.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-constructor"><span class="toc-number">6.8.</span> <span class="toc-text">构造器(constructor)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">6.9.</span> <span class="toc-text">this</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">面向对象（中级）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#idea"><span class="toc-number">7.1.</span> <span class="toc-text">idea</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">7.1.1.</span> <span class="toc-text">快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">7.1.2.</span> <span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">7.2.</span> <span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-number">7.2.1.</span> <span class="toc-text">包的命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85"><span class="toc-number">7.2.2.</span> <span class="toc-text">java常用的包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.3.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">封装（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89extends"><span class="toc-number">7.5.</span> <span class="toc-text">继承（重要）extends</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">7.5.1.</span> <span class="toc-text">继承作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-number">7.5.2.</span> <span class="toc-text">介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">7.5.3.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-number">7.5.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%88%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-number">7.5.5.</span> <span class="toc-text">继承的本质（分析）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE%EF%BC%9A"><span class="toc-number">7.5.6.</span> <span class="toc-text">内存原理图：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Super"><span class="toc-number">7.6.</span> <span class="toc-text">Super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.6.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">7.6.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">7.6.3.</span> <span class="toc-text">细节和注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">7.6.4.</span> <span class="toc-text">注意事项和使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.6.5.</span> <span class="toc-text">重写与重载的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">多态（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">7.7.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%93%E7%8E%B0"><span class="toc-number">7.7.2.</span> <span class="toc-text">多态的具体体现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8A%E4%BD%93%E7%8E%B0"><span class="toc-number">7.7.2.1.</span> <span class="toc-text">方法上体现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E6%80%81%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%8C%E9%9A%BE%E7%82%B9%EF%BC%8C%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">7.7.3.</span> <span class="toc-text">对象的多态（核心，难点，重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-1"><span class="toc-number">7.7.4.</span> <span class="toc-text">注意事项和细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">7.7.4.1.</span> <span class="toc-text">多态的向上转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">7.7.4.2.</span> <span class="toc-text">多态的向下转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%B2%A1%E6%9C%89%E9%87%8D%E5%86%99%E4%B9%8B%E8%AF%B4"><span class="toc-number">7.7.4.3.</span> <span class="toc-text">属性没有重写之说</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceOf%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%8C"><span class="toc-number">7.7.4.4.</span> <span class="toc-text">instanceOf比较操作符，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6-%E9%87%8D%E8%A6%81"><span class="toc-number">7.7.4.5.</span> <span class="toc-text">java动态绑定机制(重要)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.7.4.6.</span> <span class="toc-text">多态的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">7.7.4.7.</span> <span class="toc-text">多态参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashCode"><span class="toc-number">7.7.4.8.</span> <span class="toc-text">hashCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-NaN"><span class="toc-number">7.7.4.9.</span> <span class="toc-text">toString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finalize"><span class="toc-number">7.7.4.10.</span> <span class="toc-text">finalize()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%EF%BC%88debug%EF%BC%89"><span class="toc-number">7.8.</span> <span class="toc-text">断点调试（debug）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA%EF%BC%9A"><span class="toc-number">7.8.0.1.</span> <span class="toc-text">提示：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A-1"><span class="toc-number">7.8.0.2.</span> <span class="toc-text">介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE-1"><span class="toc-number">7.8.0.3.</span> <span class="toc-text">快捷键</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">面向对象（高级）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">类变量和类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">8.1.1.</span> <span class="toc-text">一、类变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">内存分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%B3%95"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">定义语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE"><span class="toc-number">8.1.1.3.</span> <span class="toc-text">类变量访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">8.1.1.4.</span> <span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.2.</span> <span class="toc-text">二、类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.1.3.</span> <span class="toc-text">格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">8.1.3.1.</span> <span class="toc-text">类方法调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.1.3.2.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-1"><span class="toc-number">8.1.3.3.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">8.1.3.4.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">理解main方法语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.0.1.</span> <span class="toc-text">深入理解main方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-number">8.2.0.2.</span> <span class="toc-text">提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">8.2.0.3.</span> <span class="toc-text">注意：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">8.2.0.4.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">8.2.0.5.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-2"><span class="toc-number">8.2.0.6.</span> <span class="toc-text">使用细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.3.</span> <span class="toc-text">单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">8.3.0.1.</span> <span class="toc-text">介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.4.</span> <span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">8.4.0.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-3"><span class="toc-number">8.4.0.2.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">8.4.0.3.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">8.4.0.4.</span> <span class="toc-text">细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AE%9E%E8%B7%B5-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.4.0.5.</span> <span class="toc-text">抽象类实践-模板设计模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">8.5.</span> <span class="toc-text">接口（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">8.5.0.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">8.5.0.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="toc-number">8.5.0.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">8.6.</span> <span class="toc-text">内部类（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A-2"><span class="toc-number">8.6.0.1.</span> <span class="toc-text">介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-number">8.6.0.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">8.6.0.3.</span> <span class="toc-text">内部类的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E6%9C%89%E7%B1%BB%E5%90%8D%EF%BC%89"><span class="toc-number">8.6.0.3.1.</span> <span class="toc-text">1）局部内部类（有类名）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA"><span class="toc-number">8.6.0.3.1.1.</span> <span class="toc-text">演示</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%BB%86%E8%8A%82"><span class="toc-number">8.6.0.3.1.2.</span> <span class="toc-text">注意细节</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E6%B2%A1%E7%94%A8static%E4%BF%AE%E9%A5%B0%EF%BC%89"><span class="toc-number">8.6.0.3.2.</span> <span class="toc-text">1）成员内部类（没用static修饰）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E4%BD%BF%E7%94%A8static%E4%BF%AE%E9%A5%B0%EF%BC%89"><span class="toc-number">8.6.0.3.3.</span> <span class="toc-text">2）静态内部类（使用static修饰）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">8.6.0.3.3.1.</span> <span class="toc-text">介绍</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.</span> <span class="toc-text">枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%88enum%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">枚举（enum）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-9"><span class="toc-number">9.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">9.1.2.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE"><span class="toc-number">9.1.2.1.</span> <span class="toc-text">1）自定义枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%BD%BF%E7%94%A8enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.1.2.2.</span> <span class="toc-text">2）使用enum关键字实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="toc-number">9.1.2.2.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="toc-number">9.1.3.</span> <span class="toc-text">enum常用方法说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-4"><span class="toc-number">9.1.4.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Switch%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE"><span class="toc-number">9.1.5.</span> <span class="toc-text">Switch中使用枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">9.1.6.</span> <span class="toc-text">元注解（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89Retention-x2F-x2F-%E6%8C%87%E5%AE%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%B8%89%E7%A7%8DSOURCE-CLASS-RUNTIME"><span class="toc-number">9.1.6.1.</span> <span class="toc-text">1）Retention &#x2F;&#x2F;指定注解的作用范围，三种SOURCE,CLASS,RUNTIME</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89Target-x2F-x2F-%E6%8C%87%E5%AE%9A%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BD%BF%E7%94%A8"><span class="toc-number">9.1.6.2.</span> <span class="toc-text">2）Target     &#x2F;&#x2F;指定注解可以在哪些地方使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89Documented-x2F-x2F-%E6%8C%87%E5%AE%9A%E8%AF%A5%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%90%A6%E4%BC%9A%E5%9C%A8javadoc%E4%B8%AD%E4%BD%93%E7%8E%B0"><span class="toc-number">9.1.6.3.</span> <span class="toc-text">3）Documented    &#x2F;&#x2F;指定该注解是否会在javadoc中体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89Inherited-x2F-x2F-%E5%AD%90%E7%B1%BB%E4%BC%9A%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.1.6.4.</span> <span class="toc-text">4）Inherited    &#x2F;&#x2F;子类会继承父类注解</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">10.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">异常的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-10"><span class="toc-number">10.1.1.</span> <span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">异常体系图（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">10.3.</span> <span class="toc-text">常见的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">10.3.1.</span> <span class="toc-text">常见的运行异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89NullPoniterException-%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8"><span class="toc-number">10.3.1.1.</span> <span class="toc-text">1）NullPoniterException 空指针异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ArithmeticException%E6%95%B0%E5%AD%97%E8%BF%90%E7%AE%97%E5%BC%82%E5%B8%B8"><span class="toc-number">10.3.1.2.</span> <span class="toc-text">2 ) ArithmeticException	数字运算异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89ArrayIndexOutOfBoundsException%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E5%BC%82%E5%B8%B8"><span class="toc-number">10.3.1.3.</span> <span class="toc-text">3）ArrayIndexOutOfBoundsException	数组下标异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89ClassCastException%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%BC%82%E5%B8%B8"><span class="toc-number">10.3.1.4.</span> <span class="toc-text">4）ClassCastException	类型转换异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89NumberFormatException%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E7%A1%AE%E5%BC%82%E5%B8%B8"><span class="toc-number">10.3.1.5.</span> <span class="toc-text">5）NumberFormatException	数字格式不正确异常[]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8"><span class="toc-number">10.3.2.</span> <span class="toc-text">常见的编译异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-11"><span class="toc-number">10.3.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8-1"><span class="toc-number">10.3.2.2.</span> <span class="toc-text">常见的编译异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-number">10.4.</span> <span class="toc-text">异常处理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">10.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">10.4.2.</span> <span class="toc-text">异常处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89try-catch-finally"><span class="toc-number">10.4.2.1.</span> <span class="toc-text">1）try-catch-finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89throws"><span class="toc-number">10.4.2.2.</span> <span class="toc-text">2）throws</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%9B%BE"><span class="toc-number">10.4.2.2.1.</span> <span class="toc-text">处理机制图</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%88%86%E7%B1%BB"><span class="toc-number">10.5.</span> <span class="toc-text">异常处理分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="toc-number">10.5.1.</span> <span class="toc-text">try-catch方式处理异常说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89java%E6%8F%90%E4%BE%9Btry%E5%92%8Ccatch%E5%9D%97%E6%9D%A5%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">10.5.1.1.</span> <span class="toc-text">1）java提供try和catch块来处理异常。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">10.5.1.2.</span> <span class="toc-text">2）基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-6"><span class="toc-number">10.5.1.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">10.6.</span> <span class="toc-text">throw和throws的对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">11.1.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB-Wrapper"><span class="toc-number">11.1.1.</span> <span class="toc-text">包装类的分类   Wrapper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.1.2.</span> <span class="toc-text">包装类和基本数据的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">11.1.2.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8CString%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.1.3.</span> <span class="toc-text">包装类型和String类型的相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">11.1.3.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer%E7%B1%BB%E5%92%8CCharacter%E7%B1%BB%E5%B8%B8%E6%96%B9%E6%B3%95"><span class="toc-number">11.1.4.</span> <span class="toc-text">Integer类和Character类常方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">11.1.5.</span> <span class="toc-text">Integer面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E9%87%8D%E8%A6%81"><span class="toc-number">11.2.</span> <span class="toc-text">String(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3"><span class="toc-number">11.2.1.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">11.2.2.</span> <span class="toc-text">创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BCString-s-x3D-%E2%80%9Cxxx%E2%80%9D"><span class="toc-number">11.2.2.1.</span> <span class="toc-text">1）方式一：直接赋值String s &#x3D; “xxx”;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8-String-s-x3D-new-String-%E2%80%9Cxxx%E2%80%9D-%EF%BC%9B"><span class="toc-number">11.2.2.2.</span> <span class="toc-text">2）方式二：调用构造器 String s &#x3D; new String(“xxx”)；</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">11.2.3.</span> <span class="toc-text">String字符串的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%81"><span class="toc-number">11.2.3.1.</span> <span class="toc-text">面试题、</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.4.</span> <span class="toc-text">String类的常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">11.2.4.1.</span> <span class="toc-text">说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Strng%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.4.2.</span> <span class="toc-text">Strng常见的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer-%E9%87%8D%E8%A6%81"><span class="toc-number">11.3.</span> <span class="toc-text">StringBuffer(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">11.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%AF%B9%E6%AF%94StringBuffer"><span class="toc-number">11.3.2.</span> <span class="toc-text">String 对比StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">11.3.3.</span> <span class="toc-text">StringBuffer构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer-gt-String"><span class="toc-number">11.3.3.1.</span> <span class="toc-text">StringBuffer-&gt;String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StirngBuffer%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">11.3.4.</span> <span class="toc-text">StirngBuffer类常见方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder-%E9%87%8D%E8%A6%81"><span class="toc-number">11.4.</span> <span class="toc-text">StringBuilder(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">11.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">11.4.2.</span> <span class="toc-text">StringBuilder常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E6%AF%94%E8%BE%83%E2%98%86"><span class="toc-number">11.5.</span> <span class="toc-text">String、StringBuffer、StringBuilder的比较☆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E7%8E%87"><span class="toc-number">11.5.1.</span> <span class="toc-text">效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%8C%E7%BB%93%E8%AE%BA"><span class="toc-number">11.5.2.</span> <span class="toc-text">使用原则，结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math"><span class="toc-number">11.6.</span> <span class="toc-text">Math</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">11.6.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Match%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">11.6.2.</span> <span class="toc-text">Match常用的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date-Calender-LoaclDate"><span class="toc-number">11.7.</span> <span class="toc-text">Date,Calender,LoaclDate.</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date-%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E6%9F%A5%EF%BC%8C%E6%80%8E%E4%B9%88%E7%94%A8%E5%8D%B3%E5%8F%AF"><span class="toc-number">11.7.1.</span> <span class="toc-text">Date[知道怎么查，怎么用即可]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">11.7.1.1.</span> <span class="toc-text">第一代日期类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar-%E6%97%A5%E5%8E%86"><span class="toc-number">11.7.2.</span> <span class="toc-text">Calendar(日历)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">11.7.2.1.</span> <span class="toc-text">第二代日期类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">11.7.3.</span> <span class="toc-text">第三代日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB-1"><span class="toc-number">11.7.3.1.</span> <span class="toc-text">第三代日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89DateTimeFormatter%E6%A0%BC%E5%BC%8F%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">11.7.3.1.1.</span> <span class="toc-text">2）DateTimeFormatter格式日期类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instant-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-number">11.7.3.2.</span> <span class="toc-text">Instant 时间戳</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System"><span class="toc-number">11.8.</span> <span class="toc-text">System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">11.8.1.</span> <span class="toc-text">常见方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">11.9.</span> <span class="toc-text">Arrays类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-12"><span class="toc-number">11.9.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">11.9.2.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89-toString%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BD%A2%E5%BC%8F%EF%BC%8C%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%BC%E6%8E%A5%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%94%E5%9B%9E"><span class="toc-number">11.9.2.1.</span> <span class="toc-text">1） toString返回数组的字符串形式，将数组拼接成字符串返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-sort%E6%8E%92%E5%BA%8F%EF%BC%88%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">11.9.2.2.</span> <span class="toc-text">2)sort排序（自然排序和定制排序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89binarySearch-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">11.9.2.3.</span> <span class="toc-text">3）binarySearch 二分搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89copyOf%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">11.9.2.4.</span> <span class="toc-text">4）copyOf数组元素的复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-fill%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%A1%AB%E5%85%85"><span class="toc-number">11.9.2.5.</span> <span class="toc-text">5)fill数组元素的填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-equals-%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4"><span class="toc-number">11.9.2.6.</span> <span class="toc-text">6)equals 比较两个数组元素内容是否完全一致</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-asList-%E5%B0%86%E4%B8%80%E7%BB%84%E5%80%BC%EF%BC%8C%E8%BD%AC%E6%8D%A2%E6%88%90list"><span class="toc-number">11.9.2.7.</span> <span class="toc-text">7)asList 将一组值，转换成list</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E5%92%8CBigDecimal%E7%B1%BB"><span class="toc-number">11.10.</span> <span class="toc-text">Integer和BigDecimal类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">11.10.1.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">12.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">12.1.</span> <span class="toc-text">集合框架体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">12.1.1.</span> <span class="toc-text">集合体系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection"><span class="toc-number">12.2.</span> <span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">12.2.0.1.</span> <span class="toc-text">Collection接口实现类的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.0.2.</span> <span class="toc-text">Collection接口和常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Iterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89"><span class="toc-number">12.2.0.3.</span> <span class="toc-text">使用Iterator（迭代器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">12.2.0.3.1.</span> <span class="toc-text">基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F"><span class="toc-number">12.2.0.3.1.1.</span> <span class="toc-text">迭代器的运行原</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E5%A2%9E%E5%BC%BA"><span class="toc-number">12.2.0.4.</span> <span class="toc-text">for循环增强</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="toc-number">12.2.0.4.0.1.</span> <span class="toc-text">基本语法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">12.3.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">12.3.0.0.1.</span> <span class="toc-text">List接口的常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-7"><span class="toc-number">12.3.0.0.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-number">12.3.0.1.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">12.3.0.1.1.</span> <span class="toc-text">ArrayList底层机制和源码分析（重点）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector"><span class="toc-number">12.3.0.2.</span> <span class="toc-text">Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-13"><span class="toc-number">12.3.0.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector-%E5%92%8CArrayList%E6%AF%94%E8%BE%83"><span class="toc-number">12.3.0.2.2.</span> <span class="toc-text">Vector 和ArrayList比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList"><span class="toc-number">12.3.0.3.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">12.3.0.3.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-number">12.3.0.3.2.</span> <span class="toc-text">LinkedList底层机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList-%E5%92%8CLinkedList%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">12.3.0.3.3.</span> <span class="toc-text">ArrayList 和LinkedList的比较</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-number">12.4.</span> <span class="toc-text">set</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">12.4.0.0.1.</span> <span class="toc-text">Set接口和常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">12.4.0.0.2.</span> <span class="toc-text">set接口遍历方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-number">12.4.0.0.3.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet"><span class="toc-number">12.4.0.1.</span> <span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">12.4.0.1.1.</span> <span class="toc-text">HashSet底层机制说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet%E7%9A%84%E6%89%A9%E5%AE%B9%E5%92%8C%E8%BD%AC%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9C%BA%E5%88%B6"><span class="toc-number">12.4.0.1.2.</span> <span class="toc-text">HashSet的扩容和转成红黑树机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet"><span class="toc-number">12.4.1.</span> <span class="toc-text">LinkedHashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-number">12.4.1.1.</span> <span class="toc-text">TreeSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">12.4.1.2.</span> <span class="toc-text">map接口和常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">12.4.1.3.</span> <span class="toc-text">Map遍历方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">12.4.1.4.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-number">12.4.1.5.</span> <span class="toc-text">HashMap底层机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable"><span class="toc-number">12.4.1.6.</span> <span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties"><span class="toc-number">12.4.1.7.</span> <span class="toc-text">Properties</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections"><span class="toc-number">12.5.</span> <span class="toc-text">Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">12.5.1.</span> <span class="toc-text">Collections工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9D%87%E4%B8%BAstatic%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">12.5.2.</span> <span class="toc-text">排序操作（均为static方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2"><span class="toc-number">12.5.3.</span> <span class="toc-text">查找、替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-14"><span class="toc-number">12.5.4.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">12.5.5.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-5"><span class="toc-number">12.5.6.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">12.5.7.</span> <span class="toc-text">泛型方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85"><span class="toc-number">13.</span> <span class="toc-text">知识点补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JUnit"><span class="toc-number">13.1.</span> <span class="toc-text">JUnit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A-3"><span class="toc-number">13.1.1.</span> <span class="toc-text">介绍：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%83%A8%E5%88%86"><span class="toc-number">14.</span> <span class="toc-text">练习部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E9%83%A8%E5%88%86"><span class="toc-number">14.1.</span> <span class="toc-text">快速入门部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E9%83%A8%E5%88%86"><span class="toc-number">14.2.</span> <span class="toc-text">进制部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%BB%83%E4%B9%A0"><span class="toc-number">14.3.</span> <span class="toc-text">位运算练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E7%BB%83%E4%B9%A0"><span class="toc-number">14.4.</span> <span class="toc-text">switch练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%83%A8%E5%88%86"><span class="toc-number">14.4.1.</span> <span class="toc-text">二维数组部分</span></a></li></ol></li></ol></li></ol>
                </div>
            
            <hr />
            <div itemprop="articleBody"><p>[TOC]</p>
<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><p>这是快速复习java基础的笔记</p>
<h2 id="重要编程思想"><a href="#重要编程思想" class="headerlink" title="重要编程思想"></a>重要编程思想</h2><p><strong>化繁为简</strong>：现将复杂的功能转变成简单的需求。</p>
<p>先死后活：有限考虑固定的值，再考虑变量。</p>
<h1 id="java概述"><a href="#java概述" class="headerlink" title="java概述"></a>java概述</h1><p>知识点：</p>
<h2 id="快速练习"><a href="#快速练习" class="headerlink" title="快速练习"></a><a href="##%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E9%83%A8%E5%88%86">快速练习</a></h2><ol>
<li><p>使用黑窗口编译.java文件时，注意要把需要编译的java文件编码设置与cmd黑窗口编码相同</p>
</li>
<li><pre><code class="java">javac hello.java //编译指令			
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. ```java</span><br><span class="line">   java hello //运行指令	</span><br><span class="line">   //注意不要带文件后缀，否则报错</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>java执行流程分析</p>
<ol>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204113338135.png" alt="image-20220204113338135"></li>
</ol>
</li>
</ol>
<h2 id="制表符"><a href="#制表符" class="headerlink" title="制表符"></a><a href="##%E5%88%B6%E8%A1%A8%E7%AC%A6%E9%83%A8%E5%88%86">制表符</a></h2><ol>
<li><pre><code>\t 一个制表位，实现对其功能
\n 换行符，
\\ 第一个斜杠代表转义，第二个代表结果 所以要输入\\两个斜杠
\	\将&quot;&quot;：号输出显示出来，在前面添加\&quot; \&quot; 也可转义其他符号例如&#39;
// \r 表示一个回车 例如：System.out.println(&quot;韩顺平教育\r北京&quot;);
        // 执行步骤：
        // 	1. 先输出韩顺平教育
        //  2. 执行回车后，相当于光标来到了最开头
        //  3. 再输出北京
        //  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了
        可以加个\n换行防止覆盖

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ````java</span><br><span class="line">   class ChangeChar&#123;</span><br><span class="line">   	public static void main(String[] args)&#123;</span><br><span class="line">   		// \t 一个制表位，实现对其功能</span><br><span class="line">   		System.out.println(&quot;beijing\tshanghai\tguangzhou&quot;);</span><br><span class="line">   		// \n换行</span><br><span class="line">   		System.out.println(&quot;jack\nlisa\nnino&quot;);</span><br><span class="line">   		// \\ 输出一个斜杠\ </span><br><span class="line">   		// 第一个斜杠代表转义，第二个代表结果 所以要输入\\两个斜杠</span><br><span class="line">   		System.out.println(&quot;c\\a\\v\\b.exe&quot;);</span><br><span class="line">   		// \将&quot;&quot;：号输出显示出来，在前面添加\&quot; \&quot;</span><br><span class="line">   		System.out.println(&quot;老王说：\&quot;hello\&quot;&quot;);</span><br><span class="line">   		// \r 表示一个回车 System.out.println(&quot;韩顺平教育\r北京&quot;);</span><br><span class="line">   		// 执行步骤：</span><br><span class="line">   		// 	1. 先输出韩顺平教育</span><br><span class="line">   		//  2. 执行回车后，相当于光标来到了最开头</span><br><span class="line">   		//  3. 再输出北京</span><br><span class="line">   		//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了</span><br><span class="line">   		System.out.println(&quot;韩顺平教育\r\n北京&quot;);</span><br><span class="line">   </span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ````</span><br><span class="line"></span><br><span class="line"># 注释</span><br><span class="line"></span><br><span class="line">1. 文档注释</span><br><span class="line"></span><br><span class="line">   1. ```</span><br><span class="line">      javadoc -d 路径文件 -xx -yy xxx.java</span><br><span class="line">      生成文档命令</span><br><span class="line">      xx yy 分别代码javadoc标签命令 例如-auther -version等</span><br></pre></td></tr></table></figure>

2. ```java
   @author 标明开发该类模块的作者 
   @version 标明该类模块的版本 
   @see 参考转向，也就是相关主题 
   @param 对方法中某参数的说明 
   @return 对方法返回值的说明 
   @exception 对方法可能抛出的异常进行说明 
   
   @author 作者名 
   @version 版本号
   其中，@author 可以多次使用，以指明多个作者，生成的文档中每个作者之间使用逗号 (,) 隔开。@version 也可以使用多次，只有第一次有效 
   
   使用 @param、@return 和 @exception 说明方法 
   这三个标记都是只用于方法的。@param 描述方法的参数，@return 描述方法的返回值，@exception 描述方法可能抛出的异常。它们的句法如下： 
   @param 参数名 参数说明 
   @return 返回值说明 
   @exception 异常类名 说明 
   
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 变量</span><br><span class="line"></span><br><span class="line">## 数据类型</span><br><span class="line"></span><br><span class="line">### 变量</span><br><span class="line"></span><br><span class="line">1. 变量本质就是一个变化的值。</span><br><span class="line"></span><br><span class="line">2. 变量有三个基本要素</span><br><span class="line"></span><br><span class="line">   1. 类型</span><br><span class="line">   2. 名称</span><br><span class="line">   3. 值</span><br><span class="line"></span><br><span class="line">3. ```java</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">   	int a=1;</span><br><span class="line">   	//定义了一个变量，类型为int，名称为a，值为1</span><br><span class="line">   	a=89;</span><br><span class="line">       //把89这个值赋给了a变量</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>注意事项：</p>
<ul>
<li>变量表示内存中的一个储存区域，[不同的变量，类型不同，占用的空间大小不同，比如：int 4个字节，double 8个字节]</li>
<li>该区域有自己的名称[变量名]和类型[数据类型]</li>
<li>变量必须先声明，后使用，有着自身的顺序</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量在同一个作用域内不能重名</li>
<li>变量&#x3D;变量名+值+数据类型，变量三要素</li>
</ul>
</li>
</ol>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol>
<li>+号的使用<ul>
<li>当左右两边为数值类型的时候，做加法运算</li>
<li>当左右两边有一方为字符串类型时，做拼接运算</li>
</ul>
</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>java数据类型</p>
<ol>
<li><p>基本数据类型</p>
<ul>
<li>数值型<ul>
<li>整数类型，存放整数（byte[1],short[2],int[4],long[8])</li>
<li>浮点（小数）类型（float[4]，double[8])</li>
</ul>
</li>
<li>字符型（char[2]），存放单个字符’a’</li>
<li>布尔型（Boolean[1]），存放true，false</li>
</ul>
</li>
<li><p>引用数据类型（面向对象部分讲解）</p>
<ul>
<li>类（class）</li>
<li>接口（interface）</li>
<li>数组（[]）</li>
</ul>
</li>
<li><p>八大基本数据类型</p>
<p>【byte，short，int，long，float，double】，char，Boolean</p>
</li>
<li><p>浮点数据类型</p>
<ol>
<li><p>默认情况下输入的字符默认是double类型的</p>
</li>
<li><p>如果想改成float类型需要在数值后面加上f或F</p>
</li>
<li><p>&#96;&#96;&#96;java<br>float a &#x3D; 1.1 &#x2F;&#x2F;错误<br>float a &#x3D; 1.1F &#x2F;&#x2F;正确<br>double b &#x3D; 1.1	&#x2F;&#x2F;正确<br>double b &#x3D; 1.1F	&#x2F;&#x2F;正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 平时使用默认的double类型就行，因为更为精确</span><br><span class="line"></span><br><span class="line">5. 浮点数使用陷阱</span><br><span class="line"></span><br><span class="line">   * ```java</span><br><span class="line">     //例如</span><br><span class="line">     //2.7和8.1/3 比较</span><br><span class="line">     double a = 2.7 ;</span><br><span class="line">     double b = 8.1/3 ;//理论上数学得数是2.7</span><br><span class="line">     System.out.println(a);//2.7</span><br><span class="line">     System.out.println(b);//得数是一个接近2.7的一个小数，而不是2.7</span><br><span class="line">     //因为计算机计算机制的问题，不是数学的问题。</span><br><span class="line">     所以在做相等判断时需要小新</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;类似问题的解决方法<br>double a &#x3D; 2.7 ;<br>double b &#x3D; 8.1&#x2F;3 ;&#x2F;&#x2F;理论上数学得数是2.7<br>System.out.println(a);&#x2F;&#x2F;2.7<br>System.out.println(b);</p>
<p>if(a &#x3D;&#x3D; b){<br>&#x2F;&#x2F;这样的写法会出问题<br>System.out.println(“相等”);<br>}</p>
<p>&#x2F;&#x2F;可以使用计算其差值<br>if(Math.abs(a-b)&lt;0.001){<br>System.out.println(“差值非常小，到我规定的精度内，认为相等”);<br>   &#x2F;&#x2F; Math方法调用java API</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 字符类型</span><br><span class="line"></span><br><span class="line">   1. char的本质就是一个整数，默认用的是Unicode编码</span><br><span class="line">   2. 字符常量用单引号引出来，</span><br><span class="line">      * 例：char a = &#x27;a&#x27;;</span><br><span class="line">      * char b = &#x27;/n&#x27;;</span><br><span class="line">   3. 不能输入双引号，否则会认成字符串，会报错。</span><br><span class="line">   4. char类型时可以运算的。</span><br><span class="line"></span><br><span class="line">   字符型的本质</span><br><span class="line"></span><br><span class="line">   * 字符型储存到计算机中，需要将对应的码值（整数）找出来</span><br><span class="line"></span><br><span class="line">   * 字符和码值的对应关系是通过字符编码表决定的（是规定死的）</span><br><span class="line"></span><br><span class="line">   * ![image-20220205221255475](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220205221255475.png)</span><br><span class="line"></span><br><span class="line">6. 布尔类型</span><br><span class="line"></span><br><span class="line">   1. 只占一个字节，只允许true和false</span><br><span class="line">   2. 用于判断操作</span><br><span class="line">   3. 不可用0或非0 来代替true或false，c语言可以</span><br><span class="line"></span><br><span class="line">## 数据类型转换</span><br><span class="line"></span><br><span class="line">### 1、自动类型转换</span><br><span class="line"></span><br><span class="line">* 精度小的类型自动转换为精度大的数据类型，反之就会报错。</span><br><span class="line"></span><br><span class="line">* char &lt; int &lt; long &lt; float &lt; double </span><br><span class="line"></span><br><span class="line">* byte &lt; short &lt; int &lt; long &lt; float &lt; double</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  //例：</span><br><span class="line">  int num = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>注意事项</p>
<ol>
<li>多重类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的哪种数据类型，然后再进行计算</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">d1</span> <span class="operator">=</span> n1+<span class="number">1.1</span>;</span><br><span class="line"><span class="comment">//这是错误的，因为转换成最大单位，1.1默认的类型是double类型的，如果是n1＋1.1f 的话就是正确的</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> n1+<span class="number">1.1</span>;</span><br><span class="line"><span class="comment">// 这是正确的；</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>（ byte , short ) 和 char之间不会相互转换，当把一个具体的数赋给byte时。</p>
<ol>
<li>先判断该数是否在byte范围内，如果是就可以</li>
</ol>
</li>
<li><p>byte，short，char 三者可以进行计算，在计算时都会先转换成int类型</p>
<ul>
<li>&#96;&#96;&#96;java<br>byte b1 &#x3D; 1;<br>byte a1 &#x3D; 1;<br>short b2 &#x3D; 1;<br>short s2 &#x3D; b1 + b2&#x2F;&#x2F;错误<br>&#x2F;&#x2F;因为计算时会转换成int类型，int不能再赋给比它小的类型short<br>int s2 &#x3D; b1 + b2 &#x2F;&#x2F;正确<br>byte s3 &#x3D; a1 + b1&#x2F;&#x2F;错误<br>&#x2F;&#x2F;byte，short，char,只要涉及计算都会转换为int类型，所以错误<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   4. 布尔类型 ( boolean ) 不参与类型转换</span><br><span class="line"></span><br><span class="line">   5. 自动提升原则：表达式结果的类型自动提升为 操作数中最大的类型。</span><br><span class="line"></span><br><span class="line">### 2、强制类型转换</span><br><span class="line"></span><br><span class="line">1. 简介</span><br><span class="line"></span><br><span class="line">   1. 大的数据类型转换为小的数据类型</span><br><span class="line">   2. 使用时要加上强制转换字符（类型）</span><br><span class="line">   3. 可能会出现精度降低和溢出问题</span><br><span class="line"></span><br><span class="line">2. 注意细节</span><br><span class="line"></span><br><span class="line">   1. 将数据从大到小转换，需要强制转换</span><br><span class="line"></span><br><span class="line">   2. ```java</span><br><span class="line">      //强制转换符只对最近的操作数有效，也就是只对下边的10数字有效，转换后再进行计算又会转换成double类型。</span><br><span class="line">      int x = (int)10*3.5+6*1.5;//提示编译错误，类型是double -&gt;</span><br><span class="line">      </span><br><span class="line">      int x = (int)(10*3.5+6*1.5);//用小括号括起来即可完美解决上述问题</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
<p>3、基本数据类型和String类型的转换</p>
<ol>
<li><p>介绍</p>
<ol>
<li>在程序开发中，我们经常需要吧基本数据类型转换成String类型，或String转基本数据类型</li>
</ol>
</li>
<li><p>方式</p>
<ul>
<li><p>基本转String</p>
<ul>
<li><p>基本数据类型的值+” “ </p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;例<br>int n1 &#x3D; 123;<br>float f &#x3D; 2.3f;<br>double b &#x3D; 4.5;<br>String str1 &#x3D; n1 +” “;<br>String str2 &#x3D; f +””;<br>String str3 &#x3D; b +””;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* String 转基本</span><br><span class="line"></span><br><span class="line">  * 调用基本类型的包装类方法parseXXX 方法即可</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    String s5= &quot;123&quot;;</span><br><span class="line">    integer.parseInt(s5);</span><br><span class="line">    Double.parseDouble(s5);</span><br><span class="line">    Float.parseFloat(s5);</span><br><span class="line">    //怎么吧字符串转成字符char，含义是指吧字符串的第一个字符得到</span><br><span class="line">    system.out.println(s5.charAt(0));//获取字符串的第一个字符</span><br><span class="line">    //所以这个输出的值为1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<ol>
<li>string转换基本类型时，要确保string类型能够转成有效数据，可以吧’123’转换成一个整数，但不能吧”hello”转换成一个整数</li>
</ol>
</li>
</ol>
<h1 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h1><h2 id="运算符-2"><a href="#运算符-2" class="headerlink" title="运算符"></a>运算符</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><ol>
<li>是一种特殊符号，表示数据的运算、赋值和比较等</li>
<li>种类<ul>
<li>算数运算符</li>
<li>赋值运算符</li>
<li>关系运算符(比较运算符)</li>
<li>逻辑运算符</li>
<li>位运算符 [ 需要二进制基础 ]</li>
<li>三元运算符</li>
</ul>
</li>
</ol>
<h3 id="2-算数运算符"><a href="#2-算数运算符" class="headerlink" title="2.算数运算符"></a>2.算数运算符</h3><ol>
<li>对数值类型的变量进行运算的</li>
<li>预览：<img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220211161920431.png" alt="image-20220211161920431"></li>
<li>注意事项<ul>
<li>取模</li>
<li><span style="color:white;background:red;font-size:文字大小;font-family:字体;">再%的本质，看一个公式 a % b &#x3D; a-a &#x2F; b * b</span></li>
</ul>
</li>
<li>面试题<ol>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213151013682.png" alt="image-20220213151013682"><ol>
<li>答案为 1<ul>
<li>运行步骤为</li>
<li>(1)先把 i 的值赋给一个临时变量tmp</li>
<li>(2)再进行计算i++，结果为i&#x3D;2</li>
<li>(3)tmp的值重新赋给i，此时i &#x3D;1</li>
</ul>
</li>
<li>答案为2<ul>
<li>运行步骤为</li>
<li>(1)再进行计算i++，结果为i&#x3D;2</li>
<li>(2)再将2移到临时变量tmp</li>
<li>(3)tmp赋给 i</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="3-关系运算符（比较运算符）"><a href="#3-关系运算符（比较运算符）" class="headerlink" title="3.关系运算符（比较运算符）"></a>3.关系运算符（比较运算符）</h3><ol>
<li>介绍<ul>
<li>关系运算符的结果都是boolean型，</li>
<li>通常用在if条件语句结构条件中</li>
<li>关系运算符组成的表达式成为关系表达式</li>
</ul>
</li>
<li>预览图</li>
</ol>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213162614379.png" alt="image-20220213162614379"></p>
<h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4.逻辑运算符"></a>4.逻辑运算符</h3><p>预览：</p>
<ol>
<li><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170452994.png" alt="image-20220213170452994"></p>
</li>
<li><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170753311.png" alt="image-20220213170753311"></p>
</li>
<li><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170926798.png" alt="image-20220213170926798"></p>
</li>
<li><p>&#96;&#96;&#96;<br>&amp;&amp;（短路与）	只有两个条件都为true ，才为true	&#x2F;&#x2F;如果第一个条件为false，则后面的条件不执行，直接输出flase，效率高</p>
<p>&amp;	（逻辑与）	只有两个条件都为true ，才为true	&#x2F;&#x2F;两个条件都执行，效率低</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. ![image-20220214140501385](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220214140501385.png)</span><br><span class="line"></span><br><span class="line">6. ```java</span><br><span class="line">   取反</span><br><span class="line">   真变假，假变真</span><br><span class="line">   //a^b :叫逻辑异或，当a和b不同时，结果为true，否侧为false</span><br><span class="line">   例：</span><br><span class="line">   	boolean b = (10&gt;1) ^ (3&lt;5);</span><br><span class="line">   	System.out.println(&quot;b=&quot;+b);//f</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-赋值运算符（-x3D-）、"><a href="#5-赋值运算符（-x3D-）、" class="headerlink" title="5.赋值运算符（&#x3D;）、"></a>5.赋值运算符（&#x3D;）、</h3><p>分类：</p>
<ul>
<li><p>基本赋值运算符 &#x3D; 	int a &#x3D; 10；</p>
</li>
<li><p>复合赋值运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+=，-=，*=，/=，%=等等，</span><br><span class="line">例：a += b;[等价 a=a+b;]</span><br><span class="line">	a -=b;[等价 a = a-b;]</span><br><span class="line">一般情况加复合赋值运算符，前边都有基本赋值运算符</span><br></pre></td></tr></table></figure>
</li>
<li><p>复合运算符会进行类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">3</span>;</span><br><span class="line">a += <span class="number">2</span>; <span class="comment">//此时计算结果为int类型</span></span><br><span class="line"><span class="comment">//不会报错，因为会自动进行类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能直接写成</span></span><br><span class="line">a=a+<span class="number">2</span>; <span class="comment">//会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 像a++，++a这种会都进行自动的类型转换</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-三元运算符"><a href="#6-三元运算符" class="headerlink" title="6.三元运算符"></a>6.三元运算符</h3><ul>
<li><p>语法：条件表达式？ 表达式1: 表达式2；</p>
</li>
<li><p>运算规则：</p>
<ol>
<li><p>如果条件表达式为true，运算后的结果是表达式1；</p>
</li>
<li><p>如果条件表达式为false，运算后的结果是表达式2；</p>
<p>口诀：【一灯大师：一真大师（如果为真，返回1）】</p>
</li>
<li><p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> ;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">99</span> ;</span><br><span class="line"><span class="comment">// 1.如果 结果为false</span></span><br><span class="line"><span class="comment">// 2.返回b--，先返回b，再进行b-1。依旧按照之前的a++,++a的计算形式</span></span><br><span class="line"><span class="comment">// 3.结果为99</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a &gt; b ? a++; b--;</span><br><span class="line"><span class="comment">//如果a&gt;b 为真，返回a++，如果为false返回b--;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>本质就是if，else语句</p>
</li>
</ol>
</li>
</ul>
<h3 id="7-运算符优先级"><a href="#7-运算符优先级" class="headerlink" title="7.运算符优先级"></a>7.运算符优先级</h3><ul>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220215150928654.png" alt="image-20220215150928654"></li>
<li>小结：优先级排名<ol>
<li>() ，{}等优先级最高</li>
<li>单目运算&#x3D;&#x3D;a ，–a等；</li>
<li>算术运算符+-</li>
<li>位移运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>三元运算符</li>
<li>赋值运算符</li>
</ol>
</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><strong>标识符的规则和规范</strong></p>
<ol>
<li>java中对各种变量、方法和类的命名使用的字符成为标识符。</li>
</ol>
<ul>
<li>&#96;&#96;&#96;java<br>int num &#x3D;1;<br>&#x2F;&#x2F; num就是标识符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 标识符的命名规则必须遵守</span><br><span class="line">   * 标识符由26个字母的大小写，0-9，_或$符组成。</span><br><span class="line">   * 不可以用数字开头</span><br><span class="line">   * 不可以使用关键字和保留至，但能包含关键字和保留字</span><br><span class="line">   * 标识符不能包含空格</span><br><span class="line">3. 标识符命名规范</span><br><span class="line">   * 包名：多单词组成时，所有字母都小写。例：aaa.bbb.ccc</span><br><span class="line">   * 类名、接口名：多单词组成是，所有单词首字母大写，驼峰命名法</span><br><span class="line">   * 变量名、方法名：多单词组成时，第一个单词首字母小写，后面单词的首字母大写。例：aaBbCc</span><br><span class="line">   * 常量名：所有字母都大写。多单词时用下划线隔开。例：A_B_C</span><br><span class="line"></span><br><span class="line">##   键盘输入语句</span><br><span class="line"></span><br><span class="line">### 1.介绍</span><br><span class="line"></span><br><span class="line">在编程过程中需要接受用户的输入数据，可以使用键盘输入语句来获取。input.java，需要一个扫描器（对象），就是Scanner</span><br><span class="line"></span><br><span class="line">### 2.步骤</span><br><span class="line"></span><br><span class="line">1）导入该类所在的包，java.utill.*</span><br><span class="line"></span><br><span class="line">2）创建该类对象（声明变量）</span><br><span class="line"></span><br><span class="line">3）调用里面的功能</span><br><span class="line"></span><br><span class="line">### 3.案例</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class KeyboardInput &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        创建Scanner对象</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;请输入文本1&quot;);</span><br><span class="line">//        z字符串类型</span><br><span class="line">        scanner.next();</span><br><span class="line">        System.out.println(&quot;请输入age&quot;);</span><br><span class="line">//        nextint 代表接收一个int类型的输入</span><br><span class="line">        scanner.nextInt();</span><br><span class="line">//        接收double类型的</span><br><span class="line">        scanner.nextDouble();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>对于整数，有四种表达方式</p>
<ul>
<li><p>二进制（Bin&#x2F;B）：0,1，满2进1，以0b或0B开头</p>
</li>
<li><p>八进制（OCT&#x2F;O）：0-7，满8进1。以数字0开头表示</p>
</li>
<li><p>十进制（DEC&#x2F;D）：0-9，满10进1</p>
</li>
<li><p>十六进制（HEX&#x2F;H）：0-9及A(10)-F(15)，满16进1.以0x或0X开头表示。此处的A-F不区分大小写</p>
</li>
<li><p>&#96;&#96;&#96;java<br>int n1 &#x3D; 0b1010;<br>int n2 &#x3D; 01010;<br>int n3 &#x3D; 1010;<br>int n4 &#x3D; 0x10101;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 进制转换（基本功）*</span><br><span class="line"></span><br><span class="line">第一组</span><br><span class="line"></span><br><span class="line">1. 二进制转十进制</span><br><span class="line"></span><br><span class="line">   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和</span><br><span class="line"></span><br><span class="line">   * ```</span><br><span class="line">     例</span><br><span class="line">     0b 1011  =1*2^0+1*2^1+0*2^2+1*2^</span><br><span class="line">     = 1+2+0+8</span><br><span class="line">     =11</span><br><span class="line">     </span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>八进制转十进制</p>
<ul>
<li><p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和。</p>
</li>
<li><p>&#96;&#96;&#96;<br>例：0234转成十进制<br>0 234<br>&#x3D;4<em>8^0 + 3</em>8^1 + 2*8^2<br>&#x3D;4+24+128<br>&#x3D;156</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 十六进制转十进制</span><br><span class="line"></span><br><span class="line">   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和</span><br><span class="line"></span><br><span class="line">   * ```</span><br><span class="line">     例：0x 23A转成十六进制</span><br><span class="line">     =10*16^0 + 3*16^1 + 2*16^2</span><br><span class="line">     =10 + 48 + 512</span><br><span class="line">     =570</span><br><span class="line">     A(10),B(11),C(12),D(13),E(14),F(15)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><a href="###%E8%BF%9B%E5%88%B6%E9%83%A8%E5%88%86">第一部分练习</a></p>
<p>第二组</p>
<ol>
<li><p>十进制转二进制</p>
<ul>
<li><p>规则：将该数不断除2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制</p>
</li>
<li><p>&#96;&#96;&#96;<br>将34转换成二进制<br>34%2	余0<br>17%2  余1<br>8%2		余0<br>4%2		余0<br>2%2		余0<br>1%2		余1<br>反着读<br>结果：0b100010 &#x2F;&#x2F;前缀0b的意思为二进制<br>正确答案为：0b00100010<br>因为一个字节二进制的是八位，34的出的结果是六位所以前面需要多加两个0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 十进制转八进制</span><br><span class="line"></span><br><span class="line">   * 规则：将该数不断除8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的八进制</span><br><span class="line"></span><br><span class="line">   * ```</span><br><span class="line">     例：将131转为八进制</span><br><span class="line">     131%8		余3</span><br><span class="line">     16%8		余0</span><br><span class="line">     2%8			2</span><br><span class="line">     结果为0203前面的0代表的意思是八进制</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>十进制转十六进制</p>
<ul>
<li><p>规则：将该数不断除16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的十六进制</p>
</li>
<li><p>&#96;&#96;&#96;<br>例：237<br>答案为 ED</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   * ![image-20220216221217568](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220216221217568.png)</span><br><span class="line"></span><br><span class="line">第三组</span><br><span class="line"></span><br><span class="line">1. 二进制转八进制</span><br><span class="line"></span><br><span class="line">   * 规则：从低位开始，将二进制数的每三位一组，转成对应的八进制数即可</span><br><span class="line"></span><br><span class="line">   * ```</span><br><span class="line">     例：0b 11010101 每三个转成十进制再拼起来</span><br><span class="line">     =325</span><br><span class="line">     11100101</span><br><span class="line">     =345</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>二进制转十六进制</p>
<ul>
<li><p>从低位开始，将二进制数的每四位一组，转成对应的十六进制即可</p>
</li>
<li><p>&#96;&#96;&#96;<br>11010101<br>&#x3D;0xD5<br>1110010110<br>&#x3D;0x396	每四个转成十进制再拼起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">第四组</span><br><span class="line"></span><br><span class="line">1. 八进制转二进制</span><br><span class="line"></span><br><span class="line">   * 规则：将八进制数每一位，转成对应的3位的二进制数</span><br><span class="line"></span><br><span class="line">   * ```</span><br><span class="line">     237  每位以十进制转二进制转成对应的3位二进制数再连起来</span><br><span class="line">     2（010）3（011）7（111）</span><br><span class="line">     =010011111</span><br><span class="line">     </span><br><span class="line">     1230</span><br><span class="line">     =1(001)2(010)3(011)0(000)</span><br><span class="line">     =001010011000</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>十六进制转二进制</p>
<ul>
<li><p>规则：将八进制数每一位，转成对应的4位的二进制数</p>
</li>
<li><p>&#96;&#96;&#96;<br>23B<br>&#x3D;2(0010)3(0011)B(1011)<br>&#x3D;001000111011<br>AB29<br>&#x3D;A(1010)B(1011)2(0010)9(1001)<br>&#x3D;1010101100101001</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">源码，反码，补码（重点）</span><br><span class="line"></span><br><span class="line">对于有符号的数而言（八个规则）：</span><br><span class="line"></span><br><span class="line">1. 二进制的最高位是符号位：0表示正数，1表示负数（口诀：0 - &gt;0   1-&gt; -）</span><br><span class="line">2. 正数的原码，反码，补码都一样（三码合一）</span><br><span class="line">3. 负数的反码 = 它的原码符号位不变，其他位取反（0-&gt;1,1-&gt;0）0变1,1变0.</span><br><span class="line">4. 负数的补码 = 它的反码+1，负数的反码 = 负数的补码-1</span><br><span class="line">5. 0的反码，补码都是0</span><br><span class="line">6. java没有无符号的数，换而言之，java中的数都是有符号的</span><br><span class="line">7. 计算机运算的时候，都是以 &lt;span style=&quot;color:white;background:red;font-size:文字大小;font-family:字体;&quot;&gt;补码的方式来运算的&lt;/span&gt;</span><br><span class="line">8. &lt;span style=&quot;color:white;background:red;font-size:文字大小;font-family:字体;&quot;&gt;当我们看运算结果的时候，要看它的原码（！！！）&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 位运算</span><br><span class="line"></span><br><span class="line">* java中有七个位运算符（&amp;，|，^，~，&gt;&gt;，&lt;&lt;和&gt;&gt;&gt;）</span><br><span class="line"></span><br><span class="line">* 分别是：</span><br><span class="line"></span><br><span class="line">  * &amp;：按位与</span><br><span class="line"></span><br><span class="line">    * 规则：两位全为1，结果为1，否则为0</span><br><span class="line"></span><br><span class="line">    * ```</span><br><span class="line">      例：</span><br><span class="line">         10011010</span><br><span class="line">        &amp;11011101</span><br><span class="line">      -------------</span><br><span class="line">        =10011000// 两个都1结果才为1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li><p>|：按位或</p>
<ul>
<li><p>规则：两位有一个为1，结果为1，否则为0</p>
</li>
<li><p>&#96;&#96;&#96;<br>10011010</p>
<h2 id="amp-11011101"><a href="#amp-11011101" class="headerlink" title="  &amp;11011101"></a>  &amp;11011101</h2><p>  &#x3D;11011111&#x2F;&#x2F; 两个有一个1结果才为1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ^：按位异或</span><br><span class="line"></span><br><span class="line">  * 规则：两位一个为0，一个为1，结果为1，否则为0</span><br><span class="line"></span><br><span class="line">  * ```</span><br><span class="line">    10011010</span><br><span class="line">    &amp;11011101</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<pre><code>=01000111// 两位一个为0，一个为1，结果为1，否则为0
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p>~：按位取反</p>
<ul>
<li>规则：0为1,1为0</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//位移运算</span><br><span class="line">int a = 1&gt;&gt;2; // 1 向右位移2位</span><br><span class="line">int b = -1&gt;&gt;2;</span><br><span class="line">int c = 1&lt;&lt;2; //左移 2位</span><br><span class="line">int d = -1&lt;&lt;2;</span><br><span class="line">int e = 3&gt;&gt;&gt;2;//无符号右移</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="##%E4%BD%8D%E8%BF%90%E7%AE%97%E7%BB%83%E4%B9%A0">练习部分</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2&amp;3计算机计算流程（计算机是按照补码进行计算的）</span><br><span class="line">因为一个字节是八位，一个int类型有4个字节</span><br><span class="line">1.先得到2的补码 ===&gt;* 源码00000000 00000000 00000000 00000010 //得到原码</span><br><span class="line">* 转成补码（正数的三码都一样）</span><br><span class="line">00000000 00000000 00000000 00000010</span><br><span class="line">2. 得到3的补码 ====&gt;先获得原码00000000 00000000 00000000 00000011</span><br><span class="line">得到3的补码</span><br><span class="line">00000000 00000000 00000000 00000011</span><br><span class="line"></span><br><span class="line">3.计算2&amp;3</span><br><span class="line">补码结果为：00000000 00000000 00000000 00000010</span><br><span class="line">原码也为：00000000 00000000 00000000 00000010</span><br><span class="line">最终结果为：2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~-2计算过程</span><br><span class="line">1. 得到-2的原码10000000 00000000 00000000 00000010</span><br><span class="line">2. 算出-2的反码11111111 11111111 11111111 11111101（原符号位保持不变，其他取反）</span><br><span class="line">3. 算出-2的补码11111111 11111111 11111111 11111110</span><br><span class="line">4.再进行~-2操作00000000 00000000 00000000 00000001//运算后的补码</span><br><span class="line">5.转为原码00000000 00000000 00000000 00000001</span><br><span class="line">6.结果为1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~2的计算过程</span><br><span class="line">1.得到2的原码00000000 00000000 00000000 00000010</span><br><span class="line">2.获取补码：00000000 00000000 00000000 00000010</span><br><span class="line">3.计算~2:11111111 11111111 11111111 11111101</span><br><span class="line">3.转为反码（）负数的反码=补码-1</span><br><span class="line">11111111 11111111 11111111 11111100</span><br><span class="line">4.转为原码：10000000 00000000 00000000 00000011</span><br><span class="line">5.结果为-3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运算符&gt;&gt;，&lt;&lt;和&gt;&gt;&gt;运算规则</p>
<ul>
<li><p>算数右移&gt;&gt;；低位溢出，符号位不变，并用符号位补溢出的高位</p>
<ul>
<li><p>&#96;&#96;&#96;<br>int a &#x3D; 1&gt;&gt;2;<br>1:00000000 00000000 00000000 00000001<br>1 &gt;&gt;2 &#x2F;&#x2F;相当于把最后边的01去掉用符号位补上<br>结果：00000000 00000000 00000000 00000000<br>最后结果为0</p>
<p>简便的方法<br>1&gt;&gt;2 &#x3D; 1&#x2F;2&#x2F;2&#x3D; 0<br>15&gt;&gt;2 &#x3D; 15&#x2F;2&#x2F;2&#x3D;3  &#x2F;&#x2F;取整</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 算数左移&lt;&lt;; 符号位不变，低位补0</span><br><span class="line"></span><br><span class="line">  * ```</span><br><span class="line">    int a =1&lt;&lt;2;</span><br><span class="line">    1:00000000 00000000 00000000 00000001</span><br><span class="line">    1&lt;&lt;2</span><br><span class="line">    00000000 00000000 00000000 00000100</span><br><span class="line">    结果为4</span><br><span class="line">    </span><br><span class="line">    简便的方法</span><br><span class="line">    1&lt;&lt;2 =1*2*2 = 4</span><br><span class="line">    4&lt;&lt;3 = 4*2*2*2 = 32</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>3.&gt;&gt;&gt;逻辑右移，也叫无符号右移，运算规则是：低位溢出，高位补0</p>
</li>
</ul>
</li>
</ul>
<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><h2 id="顺序控制（if-else-switch）"><a href="#顺序控制（if-else-switch）" class="headerlink" title="顺序控制（if,else,switch）"></a>顺序控制（if,else,switch）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>程序从上到下逐行执行，中间没有任何判断和跳转</p>
<h3 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h3><h3 id="1）单分支"><a href="#1）单分支" class="headerlink" title="1）单分支"></a><strong>1）单分支</strong></h3><p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：当条件表达式为true时，则执行{}内的代码。false就不执行。如果只有一条执行语句，可以省略{}。但不建议省略</p>
<h3 id="2）双分支"><a href="#2）双分支" class="headerlink" title="2）双分支"></a><strong>2）双分支</strong></h3><p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行代码块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	执行代码块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3）多分支"><a href="#3）多分支" class="headerlink" title="3）多分支"></a><strong>3）多分支</strong></h3><p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行代码块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	执行代码块<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	执行代码块....;</span><br><span class="line">&#125;.....</span><br></pre></td></tr></table></figure>

<p>流程图：</p>
<p>else只能有一个执行入口</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220222162201564.png" alt="image-20220222162201564"></p>
<p>特别说明：</p>
<ol>
<li>多分支可以没有else，如果所有条件都不成立，则一个执行入口都没有</li>
<li>如果有else，如果所有的条件表达式都不成立，则默认执行else代码块。</li>
</ol>
<p>练习：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ifChapter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入0-100的数字&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (num&lt;<span class="number">1</span> &amp;&amp; num&gt;<span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num==<span class="number">100</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用极好&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num&gt;<span class="number">80</span> &amp;&amp; num &lt;= <span class="number">99</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用优秀&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num &gt;= <span class="number">60</span> &amp;&amp; num &lt;= <span class="number">80</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;信用一般&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num &lt;<span class="number">60</span>)&#123;<span class="comment">//或直接不写这个条件语句，但这个会有bug</span></span><br><span class="line">                System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入合法数字&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4）嵌套分支"><a href="#4）嵌套分支" class="headerlink" title="4）嵌套分支"></a><strong>4）嵌套分支</strong></h3><p>介绍：</p>
<p>一个分支完整的嵌套了另一个分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支。</p>
<p>规范：不建议超过三层（可读性不好）</p>
<p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">	<span class="keyword">if</span>()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>.....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5）switch分支"><a href="#5）switch分支" class="headerlink" title="5）switch分支"></a>5）switch分支</h3><p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123; <span class="comment">//表达式为具体的一个值</span></span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">语句块<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">语句块<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ······:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> ...........</span><br><span class="line">       </span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line"><span class="keyword">default</span>语句块</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>switch 关键字,表示swtich分支</li>
<li>表达式   对应一个值</li>
<li>case常量1：当表达式的值等于常量1，就执行语句块1</li>
<li>break：表示退出switch</li>
<li>如果case 常量1 匹配，就执行语句块1，如果没有则继续case 常量2；</li>
<li>如果一个都没有匹配上，就执行default</li>
</ol>
<p>Switch流程图：</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220224155515378.png" alt="image-20220224155515378"></p>
<p> 注意：</p>
<ul>
<li>穿透<ol>
<li>如果case1 没有break</li>
<li>则case不进行判断直接执行case2 的语句块</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span> week;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入字母&quot;</span>);</span><br><span class="line">        week = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">switch</span> (week)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Monday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Tuesday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Wednesday&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Thursday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Friday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Saturday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;sunday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输入有误，请输入a-g的字母&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意事项和细节</p>
<ol>
<li><p>表达式数据类型，应和case后的常量类型一致，或者是可以自动转换成可以相互比较的类型，比如输入的是字符，而常量是int</p>
</li>
<li><p>Switch(表达式)中表达式的返回值必须是：（byte，short，int，char，enum，String）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如下列例子，是不可以的</span></span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">switch</span>(a)&#123;<span class="comment">//错误</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1.1</span>:<span class="comment">//case后面不可以有变量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;···&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>case子句中的值必须是常量，不能是变量</p>
</li>
<li><p>default子句是可选的，当没有匹配的case时，执行default。default语句是可选的，当没有匹配的任何常量，则没有任何输出。</p>
</li>
<li><p>break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有则会出现穿透现象，使程序执行后面所有的case语句块，除非遇到break；</p>
</li>
<li><p><a href="##switch%E7%BB%83%E4%B9%A0">练习</a></p>
</li>
</ol>
<p><strong>switch 和if的比较</strong></p>
<ol>
<li>如果判断的具体数值不多，而且符合byte，short，int，char，enum，string类型虽然这两个语句都可以用，建议用switch</li>
<li>其他情况，对区间判断，对结果为boolean配型判断，使用if，if的使用范围更广</li>
</ol>
<h2 id="循环控制（for-while-dowhile-多重循环-重点-）"><a href="#循环控制（for-while-dowhile-多重循环-重点-）" class="headerlink" title="循环控制（for,while,dowhile,多重循环[重点]）"></a>循环控制（for,while,dowhile,多重循环[重点]）</h2><h3 id="1）for循环"><a href="#1）for循环" class="headerlink" title="1）for循环"></a>1）for循环</h3><ol>
<li><p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环变量初始化；循环条件；循环变量迭代)&#123;</span><br><span class="line">	循环操作；(可多条语句)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>说明</p>
<ol>
<li>for关键字，表示循环控制</li>
<li>for有四要素，1）循环变量初始化，2）循环条件，3）循环操作，4）循环变量迭代</li>
<li>循环操作，这里可以有很多条语句，也就是我们要执行的代码块</li>
<li>如果 循环操作(语句)只有一条语句，可以省略{}，建议不要省略</li>
</ol>
</li>
</ol>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//练习： 打印100句“韩顺平教育”</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;韩顺平教育&quot;</span> +i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>for循环流程图<ul>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227123857620.png" alt="image-20220227123857620"></li>
</ul>
</li>
</ul>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li><p>循环条件返回一个布尔值(Boolean)</p>
</li>
<li><p>for（；循环条件；）中的初始化和变量迭代可以写到其他地方，但两边的分号不能省略</p>
<ul>
<li><pre><code class="java">//演示
int i = 0;
for (i; i &lt; 10;) &#123;
            System.out.println(&quot;韩顺平教育&quot; +i);
             i++;
        &#125;

//补充
for(;;)&#123;//表示一个无限循环
   System.out.println(&quot;韩顺平教育&quot; +i);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 循环初始值，可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    //例</span><br><span class="line">    int count =3;</span><br><span class="line">    for (i =0 ,j = 0 ;i&lt;count; i++, j+=2)&#123;</span><br><span class="line">    	System.out.println(&quot;i=&quot;+i &quot;j=&quot; +j);</span><br><span class="line">    &#125;</span><br><span class="line">    输出 ：00 12 24</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>00 12 24</p>
</li>
</ul>
</li>
</ul>
<h4 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a><strong>编程技巧</strong></h4><ul>
<li>化繁为简：将复杂的需求拆解成简单的需求</li>
<li>先死后活：先考虑固定的值，然后转成可以灵活变化的值</li>
</ul>
<p><strong>练习</strong></p>
<ol>
<li><p>打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]</p>
<ul>
<li><p>&#96;&#96;&#96;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  //打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]</span><br><span class="line">        //1、先输出1-100循环</span><br><span class="line">        //2、在输出的过程中过滤9的倍数</span><br><span class="line">        //3、定义一个变量来累计计算个数</span><br><span class="line">        //4、定义一个变量来累计计算总和</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">          int count= 0;</span><br><span class="line">          int sum =0;</span><br><span class="line">          for (int i = 1; i &lt;=100 ; i++) &#123;</span><br><span class="line">              if (i%9==0)&#123;</span><br><span class="line">                  System.out.println(&quot;i=&quot;+i);</span><br><span class="line">                  count++;</span><br><span class="line">                  System.out.println(&quot;数量&quot;+count);</span><br><span class="line">                  sum+=i;// = sum + i</span><br><span class="line">                  System.out.println(&quot;sum=&quot;+sum);</span><br><span class="line">              &#125;</span><br><span class="line">  </span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="2）while循环"><a href="#2）while循环" class="headerlink" title="2）while循环"></a>2）while循环</h3><p>基础语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（循环条件）&#123;</span><br><span class="line">	循环体（语句）；</span><br><span class="line">	循环变量迭代；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>while循环也有四要素</li>
<li>只是四要素放的位置，和for不一样</li>
</ol>
<p><strong>流程图</strong></p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227143009846.png" alt="image-20220227143009846"></p>
<h4 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h4><ol>
<li>循环条件是返回布尔值</li>
<li>while循环是先判断再执行语句</li>
</ol>
<h3 id="3）do…while循环控制"><a href="#3）do…while循环控制" class="headerlink" title="3）do…while循环控制"></a>3）do…while循环控制</h3><p>基础语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	循环体(语句);</span><br><span class="line">	循环变量迭代;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 说明:</p>
<ol>
<li><p>do  while 是关键字</p>
</li>
<li><p>也有循环四要素，只是位置不一样</p>
</li>
<li><p>先执行，在判断，也就是说，一定会执行一次</p>
</li>
<li><p>最后有一个分号</p>
</li>
<li><p>while和do… while区别</p>
<ul>
<li><p>while是先判断再执行</p>
</li>
<li><p>do .. while是先执行再判断</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;阿巴阿巴&quot;</span>);</span><br><span class="line">            i++;<span class="comment">//不要忘记加上，否则容易死循环</span></span><br><span class="line">        &#125;<span class="keyword">while</span> (i&lt;=<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;exit dowhile&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>流程图：</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227163555197.png" alt="image-20220227163555197"></p>
<h4 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a>注意事项：</h4><ol>
<li>循环条件是返回一个布尔值的表达式</li>
<li>do…while 循环是先执行后判断，因此它至少执行一次</li>
</ol>
<h3 id="4）多重循环"><a href="#4）多重循环" class="headerlink" title="4）多重循环"></a>4）多重循环</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><ol>
<li><p>讲一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do …while均可以作为外层循环和内层循环 。【建议一般使用两层，最多不超过三层，否则代码可读性很差】</p>
</li>
<li><p>实质上，嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环</p>
</li>
<li><p>例：设外层循环次数为m次，内层为n次。则内层循环体实际上需要执行m*n次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i = &quot;</span>+i+ <span class="string">&quot;,&quot;</span>+<span class="string">&quot;j = &quot;</span>+j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">------------------------输出------------------------</span><br><span class="line">i = <span class="number">0</span> , j =<span class="number">0</span></span><br><span class="line">i = <span class="number">0</span> , j =<span class="number">1</span></span><br><span class="line">i = <span class="number">0</span> , j =<span class="number">2</span></span><br><span class="line">i = <span class="number">1</span> , j =<span class="number">0</span></span><br><span class="line">i = <span class="number">1</span> , j =<span class="number">1</span></span><br><span class="line">i = <span class="number">1</span> , j =<span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ol>
<li><p>统计3个班成绩情况，每个班有5名同学，求出各个班的平均成绩和所有班级的平均分【学生的成绩从键盘输入】</p>
<ul>
<li>&#96;&#96;&#96;java<br>Scanner scanner &#x3D; new Scanner(System.in);<br>&#x2F;&#x2F;        int clss &#x3D; 1;<br>        int stu &#x3D;0;<br>        double sum &#x3D; 0;<br>    for (int i &#x3D; 1; i &lt;&#x3D;3 ; i++) {<br>        for ( int j &#x3D; 1;j&lt;&#x3D;5;j++){<br><br>            System.out.println(“请输入”+i+”班”+j+”成绩”);<br>            int s &#x3D; scanner.nextInt();<br>            sum &#x3D; sum + s;<br>        }<br>        System.out.println(i+”班的平均分为：”+(sum &#x2F; 5));<br>        sum &#x3D;0;<br>    }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">2. 打印99乘法表</span><br><span class="line"></span><br><span class="line">   * ```java</span><br><span class="line">     for (int i = 1; i &lt;=9 ; i++) &#123;</span><br><span class="line">        </span><br><span class="line">                 for (int j = 1; j &lt;=i ; j++) &#123;</span><br><span class="line">                     System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+(i*j)+&quot;  &quot;);</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">                 &#125;</span><br><span class="line">                 System.out.println(&quot;&quot;);</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>打印空心金字塔</p>
<ul>
<li><pre><code class="java">//        实心金字塔
        for (int i = 1; i &lt;=5 ; i++) &#123;
            for (int k = 1; k &lt;=5-i ; k++) &#123;
//                在输出*之前，先输出对应的空格 = 总层数 - 当前层数
                System.out.print(&quot; &quot;);
            &#125;
//            控制每个打印的*的层数
            for (int j = 1; j &lt;=2*i-1 ; j++) &#123;

                System.out.print(&quot;*&quot;);
            &#125;
            System.out.println(&quot; &quot;);
        &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  空心金字塔 【难点】</span><br><span class="line">          for (int i = 1; i &lt;=5 ; i++) &#123;</span><br><span class="line">              for (int k = 1; k &lt;=5-i ; k++) &#123;</span><br><span class="line">  //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数</span><br><span class="line">                  System.out.print(&quot; &quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">  //            控制每个打印的*的层数</span><br><span class="line">              for (int j = 1; j &lt;=2*i-1 ; j++) &#123;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">  				//1.空心金字塔的第一层和最后一层的*全部输出</span><br><span class="line">  				//2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示</span><br><span class="line">  				//3.再加一个条件 i == 5</span><br><span class="line">  				if(j == 1 || j == 2*i-1 || i==5 )&#123;</span><br><span class="line">  					 System.out.print(&quot;*&quot;);</span><br><span class="line">  				&#125;else&#123;</span><br><span class="line">  					 System.out.print(&quot; &quot;);</span><br><span class="line">  				&#125;</span><br><span class="line">  </span><br><span class="line">  //可以将其中的5 提出来换成变量，实时控制金字塔的层数</span><br><span class="line">  </span><br><span class="line">                 </span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(&quot; &quot;);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;可手动修改的</p>
<pre><code>  Scanner scanner = new Scanner(System.in);
  System.out.println(&quot;请输入层数&quot;);
  int layer = scanner.nextInt();
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;=layer ; i++) &#123;</span><br><span class="line">            for (int k = 1; k &lt;=layer-i ; k++) &#123;</span><br><span class="line">    </span><br><span class="line">//                在输出*之前，先输出对应的空格 = 总层数 - 当前层数</span><br><span class="line">                System.out.print(&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">//            控制每个打印的*的层数</span><br><span class="line">            for (int j = 1; j &lt;=2*i-1 ; j++) &#123;</span><br><span class="line">    </span><br><span class="line">                //1.空心金字塔的第一层和最后一层的*全部输出</span><br><span class="line">                //2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示</span><br><span class="line">                //3.再加一个条件 i == 5</span><br><span class="line">                if(j == 1 || j == 2*i-1 || i==layer )&#123;</span><br><span class="line">                    System.out.print(&quot;*&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    System.out.print(&quot; &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
<li><p>改为菱形</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## break</span><br><span class="line"></span><br><span class="line">介绍</span><br><span class="line"></span><br><span class="line">1. 跳转控制语句-----&gt;break</span><br><span class="line">2. 当某个条件满足时，终止循环</span><br><span class="line">3. break语句用于终止某个语句块的执行，一般用于switch或者循环中</span><br><span class="line"></span><br><span class="line">基本语法：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">break;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>以while循环为例流程图：</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228111326348.png" alt="image-20220228111326348"></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p>break语句出现在多层嵌套语句块时，可以通过标签指明要终止的是哪一层语句块</p>
</li>
<li><p>标签的基本使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">label1:&#123;.....</span><br><span class="line">label2:		&#123;.....</span><br><span class="line">label3:			&#123;.....</span><br><span class="line">				<span class="keyword">break</span> label2;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>break语句可以指定退出哪层</li>
<li>label1是标签，由程序员决定</li>
<li>break后指定到哪个label就退出到哪里</li>
<li>在实际开发中，尽量不要使用标签</li>
<li>如果没有指定break，默认退出最近的循环体</li>
</ol>
</li>
</ol>
<h2 id="continue-跳转控制语句"><a href="#continue-跳转控制语句" class="headerlink" title="continue-跳转控制语句"></a>continue-跳转控制语句</h2><p>介绍：</p>
<ol>
<li><u><strong>continue语句用于结束本次循环，继续执行下次循环</strong>。</u></li>
<li>continue语句多出现在多层嵌套的循环语句中时，可以用过标签指明要跳过的是哪一环，这个和前面的标签使用一样</li>
</ol>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程图：</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228153036178.png" alt="image-20220228153036178"></p>
<h2 id="return-跳转控制语句"><a href="#return-跳转控制语句" class="headerlink" title="return-跳转控制语句"></a>return-跳转控制语句</h2><p>介绍：</p>
<p>return使用在方法，表示跳出所在的方法</p>
<p>注意：</p>
<ol>
<li>如果吧return放在main方法中会退出程序</li>
</ol>
<h1 id="数组【重点】"><a href="#数组【重点】" class="headerlink" title="数组【重点】"></a>数组【重点】</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>介绍</strong></p>
<p>数组可以存放 <u>多个</u><em><u>同一类型</u></em> 的数据。数组也是一种数据类型，是引用数据类型。</p>
<p>即：数（数据）组（一组）就是一组数据</p>
<p><span id = "数组案例01">案例</span>（快速入门）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   			<span class="type">double</span> <span class="variable">totalWeght</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span>[] hen = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">  <span class="comment">//可以通过 for循环访问数组的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;hen.length ; i++) &#123;</span><br><span class="line">          <span class="comment">//可以通过下标来访问数组的元素 hen[下标]</span></span><br><span class="line">          <span class="comment">//下标是从0开始的，比如【0，1，2，3】</span></span><br><span class="line">          <span class="comment">//第二个元素是hen[1]</span></span><br><span class="line">    </span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值为&quot;</span>+hen[i]);</span><br><span class="line">          totalWeght+=hen[i];</span><br><span class="line">        &#125;</span><br><span class="line">  		System.out.println(<span class="string">&quot;总体重为&quot;</span>+totalWeght+<span class="string">&quot;平均体重为=&quot;</span>+(totalWeght/hen.length));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><h4 id="使用方式1"><a href="#使用方式1" class="headerlink" title="使用方式1"></a>使用方式1</h4><p>先new出一个数组，再动态的给它赋值。</p>
<p>数组的定义：</p>
<p>数据类型	数组名[] &#x3D; new 数据类型[大小]</p>
<p>数据类型[]	数组名 &#x3D; new 数据类型[大小]</p>
<p>以上两种写法的效果都是等价的</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个数组，名字为a，长度为5个int</span></span><br></pre></td></tr></table></figure>

<p>内存图：</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302092916369.png" alt="image-20220302092916369"></p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smms.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">chapterArray01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//new数组类型时，记得加上数组的长度</span></span><br><span class="line">        <span class="type">double</span>[] doubles = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; doubles.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个数&quot;</span>);</span><br><span class="line">            doubles[i] = scanner.nextDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;========================================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;doubles.length ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的数为&quot;</span>+doubles[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用方式2"><a href="#使用方式2" class="headerlink" title="使用方式2"></a>使用方式2</h4><ol>
<li><em><strong><u>先声明数组</u></strong></em></li>
</ol>
<p>语法：</p>
<ul>
<li><p>数据类型 数组名[];	或		数据类型[] 	数组名;</p>
</li>
<li><p>int a[]  &#x2F; int[]  a;</p>
</li>
</ul>
<ol start="2">
<li><em><strong><u>创建数组</u></strong></em></li>
</ol>
<p>语法：</p>
<ul>
<li>数组名 &#x3D; new 数据类型 [ 大小 ];</li>
<li>a &#x3D; new int[5];</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        double[] doubles = new double[5];</span></span><br><span class="line"><span class="comment">//相当于吧使用方法1给拆分成两个</span></span><br><span class="line"><span class="comment">//	1.先声明</span></span><br><span class="line">        <span class="type">double</span> doubles[];</span><br><span class="line">        <span class="comment">//2.再创建</span></span><br><span class="line">        doubles = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>解释：1.先声明，在内存中相当于创建了一个空的变量，这时没有任何左右</p>
<p>2.再创建，才使得这个数组有意义。不写的话会报空指针异常</p>
<h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><p>语法：</p>
<p>数据类型	数组名[] &#x3D; {元素值，元素值，元素值，……}</p>
<p><a href="#%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B01">案例</a>跳转</p>
<h3 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><ol>
<li>数组是多核相同的数据类型的组合，实现对这些数据的统一管理</li>
<li>数组中的元素可以使任何数据类型，包括基本数据类型和引用数据类型，但不能混用</li>
<li>数组创建后，如果没有赋值，会有默认值：int 0 , short 0 , byte 0 ,long 0, float 0 ,double 0.0 , char \u0000, boolean false , String null;</li>
<li>使用数组的步骤：<ol>
<li>声明数组并开辟空间</li>
<li>给数组各个元素赋值</li>
<li>使用数组</li>
</ol>
</li>
<li>数组的下表是从0开始的 </li>
<li>数组下表必须在指定范围内使用，否则报：下标越界异常，比如: int[] arr &#x3D; new int [5] ; 则有效下标为0-4</li>
<li>数组属于引用数据类型，数组行数据是对象（object）</li>
<li>boolean 类型没有赋值的情况下默认false</li>
</ol>
<h3 id="数组赋值机制"><a href="#数组赋值机制" class="headerlink" title="数组赋值机制"></a>数组赋值机制</h3><ol>
<li><p>基本数据类型赋值，这个值就是具体的数据，而且相互不影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型赋值，复制方式为值拷贝</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">2</span> ; </span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> n1 ;</span><br><span class="line"></span><br><span class="line">n2的变化不会影响n1</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p>数组再默认情况下是引用传递，赋的值是地址。赋值方式为引用传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="type">int</span>[] array2 = array1; </span><br><span class="line"></span><br><span class="line">array2[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//此时运行的结果 array1的第0个元素会变成10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p> <img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302141207302.png" alt="image-20220302141207302"></p>
<h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//1. 创建一个新的数组arr2,开辟一个新的数据空间</span></span><br><span class="line"><span class="comment">//2. 大小 = arr1.length</span></span><br><span class="line"><span class="type">int</span> arr2[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历arr1到对应的位置</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">    arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jvm内存图分析:</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142048498.png" alt="image-20220302142048498"></p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142253236.png" alt="image-20220302142253236"></p>
<h3 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h3><p>案例：</p>
<p>要求：需要把数组的元素内容反转。</p>
<p>arr { 1 , 2 , 3 , 4 , 5 }–&gt;{5 , 4 , 3 , 2 , 1}</p>
<p>方式1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">11</span> , <span class="number">22</span> , <span class="number">33</span> , <span class="number">44</span> , <span class="number">55</span> , <span class="number">66</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 把 arr[0] 和 arr[5] 进行交换</span></span><br><span class="line"><span class="comment">//2. 把 arr[1] 和 arr[4] 进行交换</span></span><br><span class="line"><span class="comment">//3. 把 arr[2] 和 arr[3] 进行交换</span></span><br><span class="line"><span class="comment">//4. 一共要交换 3 次 = arr.length</span></span><br><span class="line"><span class="comment">//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;len/<span class="number">2</span> ; i++) &#123;</span><br><span class="line">            temp = arr[len-<span class="number">1</span>-i];</span><br><span class="line">            arr[len-<span class="number">1</span>-i] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>方式2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">11</span> , <span class="number">22</span> , <span class="number">33</span> , <span class="number">44</span> , <span class="number">55</span> , <span class="number">66</span>&#125;;</span><br><span class="line"><span class="comment">//1. 先创建一个arr2</span></span><br><span class="line">        <span class="comment">//2. 逆序遍历arr，再将每个元素赋给arr2的元素中</span></span><br><span class="line">        <span class="comment">//3. 增加一个循环变量j</span></span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j=arr.length-<span class="number">1</span> ; j&gt;=<span class="number">0</span>; i++,j--) &#123;</span><br><span class="line">            arr2[j] =arr[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//4.当for循环结束，arr2就是一个逆序数组，&#123;66 , 55 , 44 , 33 , 22 , 11&#125;</span></span><br><span class="line"><span class="comment">//5. 让arr指向arr2数据空间,此时arr原来的数据空间就没有变量引用</span></span><br><span class="line"><span class="comment">//会被当做垃圾处理</span></span><br><span class="line">arr = arr2</span><br><span class="line">    <span class="comment">//6. 遍历输出</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h3><p>数组缩减同理</p>
<p>数组添加</p>
<p>要求：实现动态的给数组添加元素效果，实现对数组扩容</p>
<p>1）原始数组使用静态分配int[] arr &#x3D; {1,2,3}</p>
<p>2）增加的元素4，直接放在数组的最后 arr &#x3D; {1,2,3,4}</p>
<p>3）用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y&#x2F;n</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smms.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">chapterArrayAdd</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">char</span> key ;</span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">                    arr2[i] = arr1[i];</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入一个要添加的值&quot;</span>);</span><br><span class="line">                arr2[arr2.length - <span class="number">1</span>] = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">            arr1 = arr2;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;是否继续添加？请输入y/n&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (key==<span class="string">&#x27;y&#x27;</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;继续增加&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key== <span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;跳出&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入不合法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            将arry1的地址指定到arry2的地址，此时原arry1的地址被没有变量引用，所以被jvm销毁</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arr1 = &quot;</span>+arr1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>介绍</p>
<p>排序的分类：</p>
<ol>
<li>内部排序：</li>
</ol>
<ul>
<li>指将需要处理的所有数据都加载到内部存储中进行排序。包括（交换式排序法，选择时排序法和插入式排序法）</li>
</ul>
<ol start="2">
<li>外部排序法：<ul>
<li>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。</li>
</ul>
</li>
</ol>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>基本思想：通过对待排序序列从后向前（从下标较大的元素开始），一次比较相邻元素的值若发现逆序则交换，使值较大的元素从前移向后部。像水下的气泡一样逐渐向上冒。</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220303105607719.png" alt="image-20220303105607719"></p>
<p>特点：</p>
<ol>
<li><p>一共有五个元素</p>
</li>
<li><p>一共进行了四轮排序，可以看成外层循环</p>
</li>
<li><p>每1轮排序可以确定一个数的位置，比如第一轮排序确最大数，第二轮确定第二大的数 的位置，依次类推</p>
</li>
<li><p>当进行比较时，如果前面的数大于后面的数，就交换</p>
</li>
</ol>
<p>案例说明:</p>
<p>将五个无序：24,69,80,57,13使用冒泡排序，从小到大排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smms.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">chapterBall</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] a  = &#123;<span class="number">24</span>,<span class="number">69</span>,<span class="number">80</span>,<span class="number">57</span>,<span class="number">13</span>&#125;;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j&gt;=a.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[j]&lt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;不做交换&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    tmp = a[j];</span><br><span class="line">                    a[j]  = a[j+<span class="number">1</span>];</span><br><span class="line">                    a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                    System.out.println(<span class="string">&quot;交换第&quot;</span>+j+<span class="string">&quot;个数为&quot;</span>+a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;a.length ; i++) &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="1）顺序查找："><a href="#1）顺序查找：" class="headerlink" title="1）顺序查找："></a>1）顺序查找：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smms.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exercisesSequence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*有一个数列：</span></span><br><span class="line"><span class="comment">        * 白眉鹰王，金毛狮王，紫衫龙王，青翼蝠王猜数游戏</span></span><br><span class="line"><span class="comment">        * 从键盘任意输入一个名称，判断数列中是否包含此名称（顺序查找）</span></span><br><span class="line"><span class="comment">        * 要求：如果找到了，就提示找到，并给出下标</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String[] a =&#123;<span class="string">&quot;白眉鹰王&quot;</span>,<span class="string">&quot;金毛狮王&quot;</span>,<span class="string">&quot;紫衫龙王&quot;</span>,<span class="string">&quot;青翼蝠王&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="comment">//用于判断是否没找到</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nub</span> <span class="operator">=</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;a.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next.equals(a[i]))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;找到了&quot;</span>);</span><br><span class="line">                <span class="comment">//如果找到了就把i的值赋给sub</span></span><br><span class="line">                nub = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//如果nub==-1就代表没找到</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nub == -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没找到&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2）二分查找："><a href="#2）二分查找：" class="headerlink" title="2）二分查找："></a>2）二分查找：</h3><p>算法部分讲解补充</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>介绍：一个数组内，还有数组</p>
<p>要理解的点：</p>
<ol>
<li>看到定义形式就可知道是不是二维数组</li>
<li>二维数组的每一个元素都是一维数组</li>
<li>二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历</li>
<li></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果需要访问第（i+<span class="number">1</span>)个一维数组，第（j+<span class="number">1</span>)个值。arr2d[i][j]</span><br><span class="line"> 或需要访问第i个一维数组，第j个值。arr2d[i-<span class="number">1</span>][j-<span class="number">1</span>]   </span><br></pre></td></tr></table></figure>



<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 请用二维数组输入如下图形</span></span><br><span class="line"><span class="comment">         0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">         0 0 1 0 0 0</span></span><br><span class="line"><span class="comment">         0 2 0 3 0 0</span></span><br><span class="line"><span class="comment">         0 0 0 0 0 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        1. 定义形式 int[][]</span></span><br><span class="line"><span class="comment">//        2.可以理解为一个数组内的每个元素都是一个数组</span></span><br><span class="line">        <span class="type">int</span>[][] arr2d= &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">   System.out.println(<span class="string">&quot;二维数组的元素个数&quot;</span>+arr2d.length);</span><br><span class="line"><span class="comment">//	二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//        获取多个少个一维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2d.length; i++) &#123;</span><br><span class="line"><span class="comment">//            遍历二维数组的每一个元素（数组）,</span></span><br><span class="line"><span class="comment">//            arr2d[i].length  获取二维数组内对应的每一个一维数组的长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr2d[i].length; j++) &#123;</span><br><span class="line">                System.out.print(arr2d[i][j]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组内存原理图："><a href="#二维数组内存原理图：" class="headerlink" title="二维数组内存原理图："></a>二维数组内存原理图：</h3><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165024843.png" alt="image-20220304165024843"></p>
<h3 id="二维数组的使用方式"><a href="#二维数组的使用方式" class="headerlink" title="二维数组的使用方式"></a>二维数组的使用方式</h3><p>方式1：动态初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.语法：类型[][] 数组名 = new 类型[大小][大小];</span><br><span class="line">例如： int[][] = new int[2][3];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方式2：动态初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 先声明：类型 数组名[][];</span><br><span class="line">2. 再定义（开辟空间）： 数组名 = new 类型[大小][大小];</span><br><span class="line">3. 赋值（有默认值，比如int 类型默认值就是0）</span><br></pre></td></tr></table></figure>

<p>方式3：动态初始化</p>
<ol>
<li>列数不确定</li>
<li>java不强制每个数组的长度都一样</li>
<li>例：<img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165929272.png" alt="image-20220304165929272"></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            动态创建下面二维数组，并输出</span></span><br><span class="line"><span class="comment">            i = 0 : 1</span></span><br><span class="line"><span class="comment">            i = 1 : 2 2</span></span><br><span class="line"><span class="comment">            i = 2 : 3 3 3</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//1. 创建一个二维数组，因为数组内的每一堆数组的元素都是不确定的，所以不填。</span></span><br><span class="line">        <span class="comment">// 填了的话相当于固定了长度</span></span><br><span class="line">        <span class="type">int</span>[][] arr= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line"><span class="comment">//            给数组内的一维数组开辟空间</span></span><br><span class="line"><span class="comment">//            如果没有给一堆数组开辟空间，那么这个空间的就是null</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//            遍历一维数组，给一堆数组的每个元素赋值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr[i].length ; j++) &#123;</span><br><span class="line">                arr[i][j]= i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历出这个二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;arr[i].length ; j++) &#123;</span><br><span class="line">                System.out.print(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>杨辉三角形</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220305143151743.png" alt="image-20220305143151743"></p>
<p>提示：</p>
<ol>
<li><p>第一行有一个元素，第n行有n个元素</p>
</li>
<li><p>第一行的第一个元素和最后一个元素都是1</p>
</li>
<li><p>从第三行开始，对于非第一个元素和最后一个元素的元素的值，arr[i],[j]</p>
</li>
<li><p>&#96;&#96;&#96;java<br>中间的数为：<br>arr[i][j]  &#x3D; arr[i-1][j]+ arr[i-1][j-1]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">package basics.chapterArray;</span><br><span class="line"></span><br><span class="line">public class exerciseArrayYangHuiTriangle &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[][] arr =  new int[10][];</span><br><span class="line">        for (int i = 0; i &lt;10 ; i++) &#123;</span><br><span class="line">            arr[i] = new int[i+1];</span><br><span class="line">            for (int j = 0; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">                if (j==0 || j == arr[i].length-1)&#123;</span><br><span class="line">                    arr[i][j] = 1;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    arr[i][j] = arr[i-1][j]+arr[i-1][j-1];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;arr[i].length ; j++) &#123;</span><br><span class="line">                System.out.print(arr[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>1）类是抽象的，概念的。代表一类事物，比如人类，猫类，狗类。。。。，即它是实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>&#123;</span><br><span class="line">    <span class="comment">//属性/也叫成员变量</span></span><br><span class="line">   <span class="comment">// 成员变量 =属性 = field(字段)</span></span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="type">cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ca</span>();</span><br></pre></td></tr></table></figure>

<p>2） 对象是具体的，实际的，代表一个具体事务，即是实例</p>
<p>3） 类是对象的模板，对象是类的一个个体，对应一个实例</p>
<p>属性可以使基本数据类型，也可以是引用数据类型(对象，数组)</p>
<h3 id="对象在内存中存在的形式（重要）"><a href="#对象在内存中存在的形式（重要）" class="headerlink" title="对象在内存中存在的形式（重要）"></a>对象在内存中存在的形式（重要）</h3><p>java内存的结构分析：</p>
<ol>
<li>栈：一般存放基本数据类型（局部变量）</li>
<li>堆：存放对象（Cat cat ，数组等）</li>
<li>方法区：常量池（常量，比如字符串），类加载信息</li>
<li>示意图：[Cat(name,age,price)]</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">p.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>先加载Person类信息（属性和方法信息，只会加载一次）</span><br><span class="line"><span class="number">2.</span>在堆中分配空间，进行默认初始化（看规则），</span><br><span class="line"><span class="number">3.</span>把堆中的地址返回给p，p就指向对象</span><br><span class="line"><span class="number">4.</span>进行指定初始化，比如：p.name = <span class="string">&quot;jack&quot;</span>,p.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>





<p>对象和数组都是引用类型</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307112129768.png" alt="image-20220307112129768"></p>
<p>如果存放的数据，类型是基本数据类型则存放在堆中，引用的数据类型则存放在方法区</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>1） 属性的定义语法同变量，示例：<span style="color:blue">访问修饰符</span><span style= "color:red" > 属性类型  属性名;</span></p>
<p>2） 属性的定义类型可以为任意类型，包含基本类型或引用类型</p>
<p>3） 属性如果不赋值，有默认值，规则和数组一致</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ol>
<li><p>先声明在创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CAT cat;</span><br><span class="line">cat  = <span class="keyword">new</span> <span class="title class_">CAT</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CAT</span> <span class="variable">cat</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CAT</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>访问属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.属性名；</span><br><span class="line">cat.xxx;</span><br></pre></td></tr></table></figure>

<h3 id="类对象的内存分配机制"><a href="#类对象的内存分配机制" class="headerlink" title="类对象的内存分配机制"></a>类对象的内存分配机制</h3><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307145803905.png" alt="image-20220307145803905"></p>
<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>介绍：</p>
<p>用于描述对象的行为，成为方法</p>
<p>案例：</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307161842380.png" alt="image-20220307161842380"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smms.demo.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exercisesMethod01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.speal();</span><br><span class="line">        person.cal01();</span><br><span class="line">        person.cal02(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//        调用getSum方法，并给了1,3的值</span></span><br><span class="line"><span class="comment">//        用returnsum接收getSum返回的值</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">returnsum</span> <span class="operator">=</span> person.getSum(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;returnsum=&quot;</span>+returnsum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">speal</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个好人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">cal01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1+~+1000=&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">cal02</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">            sum = sum+i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1+n=&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>&#123;</span><br><span class="line">        <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">        sum = a+b;</span><br><span class="line">        System.out.println(<span class="string">&quot;a+b=&quot;</span>+sum);</span><br><span class="line"><span class="comment">//        表示返回sum</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内存分析流程图"><a href="#内存分析流程图" class="headerlink" title="内存分析流程图"></a>内存分析流程图</h3><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220308162432089.png" alt="image-20220308162432089"></p>
<p>方法的优点：</p>
<ol>
<li>提高了代码的复用性</li>
<li>可将实现的细节封装起来，然后提供其他用户来调用</li>
</ol>
<h3 id="成员方法的定义"><a href="#成员方法的定义" class="headerlink" title="成员方法的定义"></a>成员方法的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 返回数据类型\<span class="keyword">void</span>（表示没有返回值）	方法名(形参列表...)&#123;<span class="comment">//方法体</span></span><br><span class="line">语句;</span><br><span class="line"><span class="keyword">return</span>；<span class="comment">//返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>参数列表：表示成员方法输入cal(int n)</li>
<li>数据类型(返回类型)：表示成员方法输出，void表示没有返回值</li>
<li>方法主体:表示为了实现某一功能代码块</li>
<li>return语句不是必须的</li>
</ol>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>访问修饰符</p>
</li>
<li><p>&#96;&#96;&#96; java<br>访问修饰符 返回数据类型\void（表示没有返回值）	方法名(形参列表…){&#x2F;&#x2F;方法体<br>语句;<br>return；&#x2F;&#x2F;返回值<br>}</p>
<ol>
<li>访问修饰符（作用是控制 方法的适用范围）<br> 如果不写默认访问，[有四种：public protected 默认]</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">3. 返回数据类型</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>一个方法最多有一个返回值<br> 返回多个结果，返回数组</p>
</li>
<li><p>返回类型可以为任意类型，包含基本类型和引用类型(数组，对象)</p>
</li>
<li><p>如果方法要求有返回数据类型，则方法体中最后执行的语句必须为return值；而且要求返回值类型必须和return的值的类型一致或兼容</p>
</li>
<li><p>如果方法是void，则方法体照片那个可以没有return语句，或者 只写 return；</p>
</li>
</ol>
<p>方法命名；使用驼峰命名法，最好见名知意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开。例：getSum(int a,int b)</span><br><span class="line"></span><br><span class="line">5. 参数类型可以为任意类型，包含基本类型或引用类型。</span><br><span class="line"></span><br><span class="line">6. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数</span><br><span class="line"></span><br><span class="line">7. 方法定义时的参数成为形式参数（形参）；方法调用时的参数成为实际参数，简称实参。实参和形参的类型要一致或兼容、个数、顺序必须一致</span><br><span class="line"></span><br><span class="line">   * ```java</span><br><span class="line">     public static void main()&#123;</span><br><span class="line">     	Method a = new Method();</span><br><span class="line">     	a.input(123,345//这里成为实参);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     class Method&#123;</span><br><span class="line">     	public int input(int a,int b//这里成为形参)&#123;</span><br><span class="line">     	system.out.print(&quot;xxx&quot;);</span><br><span class="line">     	return xxx;</span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>方法体</p>
<p>​	里面写完成功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义</p>
<p>调用细节</p>
<ol>
<li><p>同一类中的方法调用：直接调用即可</p>
<ul>
<li>直接输入：方法名（参数）即可</li>
</ul>
</li>
<li><p>跨类中的方法A类调用B类方法：需要通过对象名调用。比如：对象名.方法名(参数)</p>
</li>
</ol>
<h2 id="成员方法传参（重要）"><a href="#成员方法传参（重要）" class="headerlink" title="成员方法传参（重要）"></a>成员方法传参（重要）</h2><p>基本数据类型</p>
<ol>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310134944831.png" alt="image-20220310134944831"></li>
<li><span style = "color:red">基本数据类型</span>，传递的值（拷贝），形参的任何改变不影响实参！</li>
</ol>
<p>引用数据类型</p>
<ol>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310140041330.png" alt="image-20220310140041330"></li>
<li>引用类型传递的是地址（传递也是值，但值是地址），可以通过形参影响实参。</li>
</ol>
<h2 id="递归机制（recursion）"><a href="#递归机制（recursion）" class="headerlink" title="递归机制（recursion）"></a>递归机制（recursion）</h2><p>递归调用的本质，是方法的调用</p>
<ol>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310164428690.png" alt="image-20220310164428690"></li>
<li>栈是先进后出，先出后进（所以图中的test栈2先输出，然后是3，4）</li>
<li>每次这个栈内的方法执行完成后，外边的方法（图中test方法）都会执行一边</li>
<li>哪里调用就返回给哪里</li>
</ol>
<h3 id="阶乘（factorial）"><a href="#阶乘（factorial）" class="headerlink" title="阶乘（factorial）"></a>阶乘（factorial）</h3><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310203253490.png" alt="image-20220310203253490"></p>
<h3 id="递归调用的规则"><a href="#递归调用的规则" class="headerlink" title="递归调用的规则"></a>递归调用的规则</h3><ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li>
<li>方法的局部变量是独立的，不会相互影响，比如n变量</li>
<li>如果方法中使用的是引用类型变量（比如数组，或者对象），就会共享该引用类型的数据。</li>
<li>递归必须像退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:)</li>
<li>当一个方法执行完毕，或者遇到return，就会执行完毕或者返回时，该方法也就执行</li>
</ol>
<h3 id="斐波拉契数练习"><a href="#斐波拉契数练习" class="headerlink" title="斐波拉契数练习"></a>斐波拉契数练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exerciseRecursion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t.racursionNum(<span class="number">4</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">racursionNum</span><span class="params">(<span class="type">int</span> n1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="number">1</span> || n1 == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> racursionNum(n1 - <span class="number">1</span>) + racursionNum(n1 - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析图</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310225335626.png" alt="image-20220310225335626"></p>
<h2 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h2><p>介绍：java允许同一个类中，多个同名方法的存在，但要求形参列表不一致！！！</p>
<p>好处：</p>
<ol>
<li>减轻了起名的麻烦</li>
<li>减轻了记名的麻烦</li>
</ol>
<p>注意细节：</p>
<ol>
<li>方法名：必须相同</li>
<li>形参参列表：必须不同（参数类型或个数或顺序，至少有一样不同）</li>
<li>返回类型：无要求</li>
</ol>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>介绍：</p>
<p>java允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p>
<p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符	 返回类型	方法名（数据类型 .... 参数名）&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hasMestod</span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    public int sum(int a,int b)&#123;</span></span><br><span class="line"><span class="comment">        return a+b;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public int sum(int a,int b,int c)&#123;</span></span><br><span class="line"><span class="comment">        return a+b+c;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public int sum(int a,int b,int c,int d)&#123;</span></span><br><span class="line"><span class="comment">        return a+b+c+d;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">//    ........以此类推</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    可变参数优化</span></span><br><span class="line"><span class="comment">//    上面三个方法名称相同，功能相同，只是参数个数不同----&gt;使用可变参数优化</span></span><br><span class="line"><span class="comment">//    1.int...表示接收的是可变参数，类型时int，即可以接收多个int（0-多）</span></span><br><span class="line"><span class="comment">//    2.使用可变参数时，可以当做数组；来使用，即nums 可以当做数组使用</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">sum1</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收的个数为&quot;</span>+nums.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class="line">            sum=sum+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li><p>可变参数的实参可以为0或任意多个</p>
</li>
<li><p>可变参数的实参可以为数组</p>
</li>
<li><p>可变参数的本质就是数组</p>
</li>
<li><p>可变参数可以和普通类型的参数<u><em>一起放在形参列表</em></u>，但必须保证可变参数在最后</p>
</li>
<li><p>一个形参列表中只能出现一个可变参数</p>
</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol>
<li>在java中，主要的变量就是属性（成员变量）和局部变量</li>
<li>我们说的局部变量一般是指在成员方法中定义的变量</li>
<li>作用域的分类<ol>
<li>全局变量：也就是属性，作用域为整个整体</li>
<li>局部变量：也就是除了属性以外的其他变量，作用域为定义它的代码块中</li>
</ol>
</li>
<li>全局变量可以不赋值，直接使用，因为有默认值（也可指定值），局部变量必须赋值后，才能使用，因为没有默认值。    、</li>
</ol>
<p>注意事项和细节</p>
<ol>
<li>属性和局部变量可以重名，访问时遵循就近原则</li>
<li>在一个作用域中，比如在同一个成员方法中，两个局部变量，不能重</li>
<li>属性生命周期较长，伴随对象的创建而创建，伴随对象的死亡而死亡。局部变量，生命周期较短，伴随它的代码块的执行而创建，伴随代码块的结束而死亡</li>
<li>作用域范围不同：<ol>
<li>全集变量&#x2F;属性：可以被本类使用，或其他类使用（通过对象调用）</li>
<li>局部变量：智能在本类中对应的方法中使用</li>
</ol>
</li>
<li>修饰符不同<ol>
<li>全局变量&#x2F;属性可以加修饰符</li>
<li>局部变量不可以加修饰符</li>
</ol>
</li>
</ol>
<h2 id="构造器-constructor"><a href="#构造器-constructor" class="headerlink" title="构造器(constructor)"></a>构造器(constructor)</h2><p>基本介绍：构造方法又称构造器(constructor)，是类的一种特殊方法，它的主要作用是完成对<span style = "color:red">新的对象初始化。</span></p>
<p>特点：</p>
<ol>
<li>方法和类名相同</li>
<li>没有返回值</li>
<li>在创建对象时，系统会自动调用该类的构造器完成对对象的初始化</li>
</ol>
<p>需求案例：</p>
<p>案例1:创建一个人类的对象，显示把一个对象创建好后，再给他的年龄姓名等属性赋值，如果现在我要求，在创建人类对象的时候，就直接指定这个对象的年龄和姓名。 此时可以使用构造器</p>
<p>基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 方法名(形参列)&#123;</span><br><span class="line"></span><br><span class="line">	方法体;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>构造器的修饰符可以默认，也可是public，protected，private</li>
<li>构造器没有返回值,也不能写void</li>
<li>方法名和类名必须一样</li>
<li>参数列表和成员方法一样的规则</li>
<li>构造器的调用<span style = "color:red">系统完成</span></li>
</ol>
<p>细节：</p>
<ol>
<li>一个类可以定义多个不同的构造器，即构造器的重载<ul>
<li>比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄</li>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314163037454.png" alt="image-20220314163037454"></li>
</ul>
</li>
<li>构造器是完成对象的初始化，并不是创建对象</li>
<li>如果程序员没有定义构造器，系统会自动生成一个默认的无参构造器(也叫默认构造方法),比如Person(){ }</li>
<li>一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的午餐构造器，除非显示的定义一下，即自己再手写一边Person(){ }</li>
</ol>
<p>对象创建流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">90</span>;</span><br><span class="line">	String name;</span><br><span class="line">	Person(String n , <span class="type">int</span> a)&#123;</span><br><span class="line">	name = n;</span><br><span class="line">	age = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangsan&quot;</span> , <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png" alt="image-20220314215432778"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 先在方法区加载Person类</span><br><span class="line">2. 在堆中开辟一个空间，内部存放形参</span><br><span class="line">   1. 先初始化默认值，0和null，然后再将值赋进去</span><br><span class="line">   2. 当执行到构造器的时候，值才会赋进去</span><br><span class="line">   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值</span><br><span class="line">3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>加载Person.class，只会加载一次。</p>
</li>
<li><p>在堆中分配空间(地址)</p>
</li>
<li><p>完成对象初始化</p>
<p>3.1 默认初始化 age&#x3D;0	name &#x3D; null	</p>
<p>3.2 显示初始化 age&#x3D;90,name&#x3D;null,</p>
<p>3.3 构造器的初始化 age&#x3D;20，name&#x3D;zhangsan</p>
</li>
<li><p>在对象堆中的地址，返回给p(也可理解成对象的引用)</p>
</li>
</ol>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	旧方法：</span></span><br><span class="line"><span class="comment">		int age =90;</span></span><br><span class="line"><span class="comment">		String name;</span></span><br><span class="line"><span class="comment">		Person(String n , int a)&#123; //此时形参的起名不能与属性名一致</span></span><br><span class="line"><span class="comment">		name = n;</span></span><br><span class="line"><span class="comment">		age = a;</span></span><br><span class="line"><span class="comment">     1.如果可以将构造器的形参，直接写成属性名就好了</span></span><br><span class="line"><span class="comment">     2.但是会出现一个问题，根据变量的作用域原则</span></span><br><span class="line"><span class="comment">     3.构造器的name 是局部变量，而不是属性。相当于自己赋给自己</span></span><br><span class="line"><span class="comment">     4.构造器的age 是局部变量，而不是属性、</span></span><br><span class="line"><span class="comment">     5.==&gt;此时使用this关键字	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name<span class="comment">/*表示当前对象的属性*/</span> = name;<span class="comment">/*表示当前构造器的局部变量*/</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍：</p>
<p>java虚拟机会给每个对象分配this，代表当前对象。</p>
<p>分析图：</p>
<p>每一个对象都有一个隐藏的属性this</p>
<p>这个this它指向自己</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314222909415.png" alt="image-20220314222909415"></p>
<p>简单说，哪个对象调用this就指向哪个对象</p>
<p>注意事项：</p>
<ol>
<li><p>this关键字可以用来访问本类的属性，方法，构造器</p>
</li>
<li><p>this用于区分当前类的属性和局部变量</p>
</li>
<li><p>访问成员方法的语法：this.方法名(参数列表)；</p>
</li>
<li><p>访问构造器语法：this(参数列表);&#x2F;&#x2F;注意，只能在构造器中访问另外一个构造器(当有访问构造器的语法this时，必须放在构造器语句里的第一行 )</p>
<ul>
<li>&#96;&#96;&#96;java<br>class T{<br>String name;<br>int age;<br>&#x2F;&#x2F;无参构造器<br>public T(){<br>    &#x2F;&#x2F;当执行无参构造器时，我们想去访问有参构造器<br>    this(“zhangsan”,12);&#x2F;&#x2F;这样访问有参构造器<br>   &#x2F;&#x2F;当有访问构造器的语法this时，必须放在构造器语句里的第一行<br><br>    System.out.println(“T() 构造器”);<br><br><br><br>}<br><br>&#x2F;&#x2F;有参构造器<br>public T(String name,int age){<br>    System.out.println(“T(String name,int age) 构造器”);<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. this不能再类定义的外部使用，只能在类定义的范围中使用</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package chapterObject;</span><br><span class="line">/*</span><br><span class="line">* 创建一个employee类</span><br><span class="line">* 属性有（名字，性别，年龄，职位，薪水）</span><br><span class="line">* 提供三个构造器</span><br><span class="line">* 1.名字，性别，年龄，职位，薪水</span><br><span class="line">* 2.名字，性别，年龄</span><br><span class="line">* 3.职位，薪水*/</span><br><span class="line">public class ObjectHomeWork06 &#123;</span><br><span class="line">&#125;</span><br><span class="line">class Employee&#123;</span><br><span class="line">    String name;</span><br><span class="line">    char sex;</span><br><span class="line">    int age;</span><br><span class="line">    String post;</span><br><span class="line">    double salary;</span><br><span class="line"></span><br><span class="line">    public Employee(String name,char sex,int age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public Employee(String post,double salary)&#123;</span><br><span class="line"></span><br><span class="line">        this.post = post;</span><br><span class="line">        this.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    public Employee(String name,char sex,int age,String post,double salary)&#123;</span><br><span class="line">        this(name, sex, age);</span><br><span class="line">//        因为构造器调用只能放在第一行，所以最多只能调用一个构造器</span><br><span class="line">        this.post = post;</span><br><span class="line">        this.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    public Employee(String name,char sex,int age,String post,double salary)&#123;</span><br><span class="line">//        this.name = name;</span><br><span class="line">//        this.sex = sex;</span><br><span class="line">//        this.age = age;</span><br><span class="line">//        this.post = post;</span><br><span class="line">//        this.salary = salary;</span><br><span class="line">//</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="面向对象（中级）"><a href="#面向对象（中级）" class="headerlink" title="面向对象（中级）"></a>面向对象（中级）</h1><h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">自定义快捷键</span><br><span class="line">settings - - &gt; Keymap</span><br><span class="line">删除当前行 ctrl+y  自定义 alt+D</span><br><span class="line">复制当前行 ctrl+d</span><br><span class="line"></span><br><span class="line">快速格式化代码 ctrl + alt + L</span><br><span class="line">快速运行程序  自定义alt + R</span><br><span class="line"></span><br><span class="line">查看类的层级关系 ctrl + H</span><br><span class="line">将光标放在一个方法上，输入ctrl+b，可以定位到该方法的上</span><br><span class="line">自动分配变量名   在后面添加.var</span><br><span class="line">例：new Scanner(System.in).var+回车</span><br><span class="line">会生成Scanner scanner = new Scanner(System.in);</span><br></pre></td></tr></table></figure>

<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p> 设置路径</p>
<p>file -&gt; settings -&gt; editor -&gt; live templates-&gt;</p>
<p>可以自己自定义，也可查看预设的模板</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>三大作用：</p>
<ol>
<li>区分相同名字的类</li>
<li>当类不同的时候，可以很好的管理</li>
<li>控制访问范围</li>
</ol>
<p>基本语法：</p>
<p>package com.xxx;</p>
<ol>
<li>package 关键字，表示打包</li>
<li>com.xxx:表示包名</li>
</ol>
<p>包的本质</p>
<p>就是创建不同的文件&#x2F;目录保存文件</p>
<h3 id="包的命名"><a href="#包的命名" class="headerlink" title="包的命名"></a>包的命名</h3><p>规则：</p>
<p>智能包含数字，字母，下划线，小圆点，但不能用数字开头，不能是关键字或保留字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">demo.class.exec1 <span class="comment">//falsee不允许有关键字class</span></span><br><span class="line">demo<span class="number">.12</span>		<span class="comment">//false,不能数字开头</span></span><br><span class="line">demo.ad12.oa <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>规范</p>
<p>一般是小写字母+小圆点</p>
<p>com.公司名.项目名.业务模块名</p>
<p>例：com.alibaba.taobao.login</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.sina.crm.user</span><br><span class="line">等等</span><br></pre></td></tr></table></figure>

<h3 id="java常用的包"><a href="#java常用的包" class="headerlink" title="java常用的包"></a>java常用的包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang <span class="comment">// lang包是基础包，默认引入，不用手动输入</span></span><br><span class="line"></span><br><span class="line">java.util <span class="comment">//系统提供的工具包，工具类，例如Scanner类</span></span><br><span class="line"></span><br><span class="line">java.net <span class="comment">// 网络包，网络开发</span></span><br><span class="line"></span><br><span class="line">java.awt  <span class="comment">// 是做java的界面开发，GUI</span></span><br></pre></td></tr></table></figure>



<p>包的引入</p>
<p>建议需要什么类就引入什么类，不建议(java.util.* )全部引入</p>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>介绍</p>
<p>java提供了四种访问控制修饰符号控制方法和属性(成员变量)的访问权限(范围)</p>
<ol>
<li>公开级别：public 修饰，对外公开</li>
<li>受保护级别：用protected修饰，对子类和统一包中的类公开</li>
<li>默认级别：没有修饰符号，向同一包的内公开</li>
<li>私有级别：用private修饰，只有类本身可以访问，不对外公开</li>
</ol>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220317140746725.png" alt="image-20220317140746725"></p>
<p>注意事项：</p>
<ol>
<li>修饰符可以用修饰类中的属性，成员方法以及类</li>
<li>只有默认的和public才能修饰类，并且遵循上述访问权限的特点</li>
<li>成员方法访问规则和属性完全一样</li>
</ol>
<h2 id="封装（重要）"><a href="#封装（重要）" class="headerlink" title="封装（重要）"></a><u><em>封装</em></u>（重要）</h2><p>封装（encapsulation）就是把抽象出来的数据[<strong>属性</strong>]和对数据的操作[<strong>方法</strong>]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[<strong>方法</strong>]，才能对数据进行操作。</p>
<p><strong>封装的好处</strong></p>
<ol>
<li>隐藏实现细节  方法(连接数据库)&lt;—-调用(传入参数)</li>
<li>可对数据进行验证，保证安全合理</li>
</ol>
<p>封装的实现步骤 ( 三 步 ) </p>
<ol>
<li><p>将属性进行私有化，private</p>
</li>
<li><p>提供一个公共的set方法，对属性进行判断并赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXXX</span><span class="params">(类型	参数名)</span>&#123;</span><br><span class="line"><span class="comment">//加入数据验证的业务逻辑</span></span><br><span class="line">属性 = 参数名；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供一个公共的get方法，用于获取属性的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getXXX</span><span class="params">(类型	参数名)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="继承（重要）extends"><a href="#继承（重要）extends" class="headerlink" title="继承（重要）extends"></a><u><em>继承</em></u>（重要）extends</h2><h3 id="继承作用："><a href="#继承作用：" class="headerlink" title="继承作用："></a>继承作用：</h3><p>解决代码复用性</p>
<h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>相当多个类存在相同的属性（变量）  和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些属性和方法，只需通过extend来声明继承父类即可</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class 子类 extends 父类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> 子类会自动拥有父类定义的方法</span><br><span class="line"><span class="number">2.</span> 父类又叫超类，基类</span><br><span class="line"><span class="number">3.</span> 子类又叫派生类</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示意图</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318104942566.png" alt="image-20220318104942566"></p>
<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>子类继承了所有的属性和方法，但是私有属性不能再子类直接访问，需要通过公共方法访问</p>
</li>
<li><p>子类必须调用父类的构造器，完成父类的初始化</p>
</li>
<li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中调用super去指定使用父类的那个构造器完成对父类的初始化工作，否则编译不通过</p>
</li>
<li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下{super ( 参数 ) }</p>
</li>
<li><p>super在使用时，需要放在第一行。super只能在构造器中使用</p>
</li>
<li><p>super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器</p>
</li>
<li><p>java所有类都是Object的子类，是所有类的基类   Ctrl+H可以看到类的继承关系</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318165601997.png" alt="image-20220318165601997"></p>
</li>
<li><p>父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类)</p>
</li>
<li><p>子类对多只能继承一个父类(指直接传承)，即java中是单继承机制。</p>
</li>
<li><p>不能滥用继承，子类和父类之间必须满足is-a的逻辑关系</p>
<ol>
<li>person is a music</li>
<li>person music</li>
<li>music extends  person</li>
</ol>
</li>
</ol>
<h3 id="继承的本质（分析）"><a href="#继承的本质（分析）" class="headerlink" title="继承的本质（分析）"></a>继承的本质（分析）</h3><p>当子类创建号对象以后，建立查找关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandpa</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;爷爷&quot;</span>;</span><br><span class="line">	<span class="type">String</span> <span class="variable">hobby</span> <span class="operator">=</span> <span class="string">&quot;旅游&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_">GrandPa</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;大头爸爸&quot;</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"> 	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;儿子&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"> son.name=?      <span class="comment">//儿子</span></span><br><span class="line"> son.age = ?	 <span class="comment">//30	</span></span><br><span class="line"> son.hobby = ?	 <span class="comment">// 旅游</span></span><br><span class="line"> <span class="comment">//		1. 此时请注意，要按照查找关系返回信息</span></span><br><span class="line"> <span class="comment">/*     2. 首先看子类是否有该属性</span></span><br><span class="line"><span class="comment"> 		3. 如果子类有这个属性，并且可以访问，则返回信息</span></span><br><span class="line"><span class="comment"> 		4. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回)</span></span><br><span class="line"><span class="comment"> 		5. 如果父类没有4的规则，继续找上级，直到object</span></span><br><span class="line"><span class="comment">   */</span>  </span><br></pre></td></tr></table></figure>

<h3 id="内存原理图："><a href="#内存原理图：" class="headerlink" title="内存原理图："></a>内存原理图：</h3><p> <img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320170828664.png" alt="image-20220320170828664"></p>
<h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>super代表父类的构造器，用于访问父类的属性，方法，构造器</p>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>访问父类的属性，但不能访问父类的private属性[案例]<ul>
<li>super.属性名；</li>
</ul>
</li>
<li>访问父类的方法名，不能访问父类的private方法<ul>
<li>super.方法名(参数列表);</li>
</ul>
</li>
<li>访问父类的构造器(这点前面用过);<ul>
<li>super(参数列表);</li>
<li>只能放在构造器的第一句并只能出现一句</li>
</ul>
</li>
</ol>
<h3 id="细节和注意事项"><a href="#细节和注意事项" class="headerlink" title="细节和注意事项"></a>细节和注意事项</h3><ol>
<li><p>调用父类的构造器的好处（分工明确，弗雷属性由父类初始化，子类的属性由子类初始化）</p>
</li>
<li><p>当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果</p>
<ul>
<li>&#96;&#96;&#96;java<br>案例<br>class A{<br>public void cal(){<br>    System.out.println(“a类的cal方法”);<br>}<br>}<br>class B{<br>public void sum(){<br>    System.out.println(“b类的sum方法”);<br>&#x2F;*	<br>    此时有三种方法调用cal<br>    1. 找cal方法时，顺序是：先找本类，如果有，开始调用。<br>    2. 如果没有。则找父类（如果有则调用）<br>    3. 如果父类没有则继续找父类的父类。以此类推。直到Object类‘<br><br>    提示：如果查找的过程中找到了，但不能访问，则报错<br>         如果查找的过程中没找到。则提示没找到<br><em>&#x2F;<br>    cal();<br><br><br>    this.cal();&#x2F;&#x2F;等价cal（）；<br><br>     &#x2F;</em><br>    跳过本类直接查找父类<br>    其他规则一样<br>    *&#x2F;<br>    super.cal();<br><br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。（相当于跳过本类，从父类开始按规则找。父类找不到找爷爷类·····）</span><br><span class="line"></span><br><span class="line">### super和this的比较</span><br><span class="line"></span><br><span class="line">![image-20220320190806497](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190806497.png)</span><br><span class="line"></span><br><span class="line">![image-20220320190935663](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190935663.png)</span><br><span class="line"></span><br><span class="line">## 重写（overwrite）</span><br><span class="line"></span><br><span class="line">### 基本介绍</span><br><span class="line"></span><br><span class="line">简单地说：方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这方法覆盖了父类的方法。</span><br><span class="line"></span><br><span class="line">### 案例</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class Animal&#123;</span><br><span class="line">	public void cry()&#123;</span><br><span class="line">		System.out.println(&quot;叫&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">	1. 因为dog是Animal的子类</span><br><span class="line">    2. Dog的cry方法和Animal的cry方法定义形式一样(名称，返回类型，参数)</span><br><span class="line">    3. 这时我们就说Dog的cry方法，重写了Animal的cry方法</span><br><span class="line">  */      </span><br><span class="line">class dog extends Animal&#123;</span><br><span class="line">	public void cry()&#123;</span><br><span class="line">		System.out.println(&quot;汪汪汪&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="注意事项和使用细节"><a href="#注意事项和使用细节" class="headerlink" title="注意事项和使用细节"></a>注意事项和使用细节</h3><ol>
<li><p>子类的方法的形参列表，方法名称，要和父类的方法的参数，方法名称完全一样。</p>
</li>
<li><p>子类方法的返回类型和父类方法返回类型一样，或者父类返回类型的子类</p>
<p>比如 父类返回类型是Object，子类方法返回类型是String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInfo</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类方法不能缩小父类方法的访问权限public &gt; protected &gt; 默认(default ) &gt; private </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sayOk</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayOk</span><span class="params">()</span>&#123;&#125;<span class="comment">//这样是可以的，但不能缩小</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="重写与重载的区别"><a href="#重写与重载的区别" class="headerlink" title="重写与重载的区别"></a>重写与重载的区别</h3><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320211941817.png" alt="image-20220320211941817"></p>
<p>练习</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> seatWork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">override</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1. 编写一个Person类，包括属性/private（name,age），</span></span><br><span class="line"><span class="comment">    * 构造器，方法say（返回组我介绍的字符串）</span></span><br><span class="line"><span class="comment">    * 2. 编写一个student类，继承Person类，增加id，score属性/private，</span></span><br><span class="line"><span class="comment">    * 以及构造器，定义say方法（返回自我介绍信息）</span></span><br><span class="line"><span class="comment">    * 3. 在main方法中，分别创建Person和Student对象，调用say方法输出自我介绍*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">say1</span> <span class="operator">=</span> person.say();</span><br><span class="line">        System.out.println(say1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">12</span>,<span class="number">12345</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">say</span> <span class="operator">=</span> student.say();</span><br><span class="line">        System.out.println(say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是父类&quot;</span>);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;name&quot;+getName()+&quot;\t&quot;+&quot;age&quot;+getAge()+&quot;\t&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name&quot;</span>+getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;age&quot;</span>+getAge()+<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> id, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.say()+<span class="string">&quot;id&quot;</span>+getId()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;score&quot;</span>+getScore()+<span class="string">&quot;\t&quot;</span>;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;name&quot;+getName()+&quot;\t&quot;+&quot;age&quot;+getAge()+&quot;\t&quot;</span></span><br><span class="line"><span class="comment">//        +&quot;id&quot;+getId()+&quot;\t&quot;+&quot;score&quot;+getScore()+&quot;\t&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多态（重要）"><a href="#多态（重要）" class="headerlink" title="多态（重要）"></a><u><em>多态</em></u>（重要）</h2><p> 多态可以提高代码的复用性</p>
<h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>多态(多种)（状态）</p>
<ol>
<li>方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础之上的额</li>
</ol>
<h3 id="多态的具体体现"><a href="#多态的具体体现" class="headerlink" title="多态的具体体现"></a>多态的具体体现</h3><h4 id="方法上体现"><a href="#方法上体现" class="headerlink" title="方法上体现"></a>方法上体现</h4><ol>
<li><p>方法的多态</p>
<p>重写和重载就体现多态</p>
</li>
<li><p>案例说明</p>
</li>
<li><p>重载上体现</p>
<ol>
<li>对某一方法，传入不同的参数，调用不同的方法</li>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320215939959.png" alt="image-20220320215939959"></li>
</ol>
</li>
</ol>
<h3 id="对象的多态（核心，难点，重点）"><a href="#对象的多态（核心，难点，重点）" class="headerlink" title="对象的多态（核心，难点，重点）"></a>对象的多态（核心，难点，重点）</h3><p>要记住几点：</p>
<ol>
<li><p>一个对象的编译类型和运行类型可以不一致</p>
<ul>
<li>&#96;&#96;&#96;<br>例如：<br>Animal animal &#x3D; new Dog();【animal编译类型时Animal，运行类型是Dog】<br>animal  &#x3D; new Cat(); 	【animal的运行类型变成了Cat，编译类型仍然是Animal】<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 编译类型在定义对象时，就确定了，不能改变</span><br><span class="line"></span><br><span class="line">   * ```</span><br><span class="line">     Animal animal = new Dog()   编译类型在定以后就不能改变，所以可以直接用引用接收其他的运行类型</span><br><span class="line">     animal  = new Cat();</span><br><span class="line">     animal  = new PIG();`````</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>运行类型是可以变化的</p>
</li>
<li><p>编译类型看定义时 &#x3D; 号的左边，运行类型看 &#x3D; 号的右边</p>
<ul>
<li>&#96;&#96;&#96;<br>Animal animal &#x3D; new Dog()  animal就是变异类型，dog就是运行类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">//编译类型和运行类型的体现</span><br><span class="line">class Animal&#123;</span><br><span class="line">	public void say()&#123;</span><br><span class="line">		System.out.println(&quot;动物在叫&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">	public void say()&#123;</span><br><span class="line">		System.out.println(&quot;猫在叫&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">	public void say()&#123;</span><br><span class="line">		System.out.println(&quot;狗在叫&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class test&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		//animal编译类型就是Animal，运行类型Dog</span><br><span class="line">		Animal animal = new Dog();</span><br><span class="line">		animal.say();//因为运行类型是dog，animal的运行类型是dog，所以输出dog类的say方法。</span><br><span class="line">		</span><br><span class="line">        animal = new Cat();</span><br><span class="line">        animal.say();//此时animal的运行类型是cat，所以输出cat类的say方法；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><p>多态的前提是：两个对象(类)存在继承关系</p>
<h4 id="多态的向上转型"><a href="#多态的向上转型" class="headerlink" title="多态的向上转型"></a>多态的向上转型</h4><ol>
<li><p>本质：父类的引用指向了子类的对象</p>
</li>
<li><p>语法：父类类型    引用名 &#x3D; new    子类类型()；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">//此时可称为向上转型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特点：编译类型看左边，运行类型看右边</p>
<p><span style="color:red;">可以调用父类中的所有成员(需要遵循访问权限),</span></p>
<p><span style="color:red;">不能调用子类中特有成员</span></p>
<p>（<span style="color:red;">因为在编译阶段，不能调用那些成员，是由编译类型来决定的。</span>）</p>
<p>最终运行效果按子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法</p>
<p>然后调用，与前面的方法调用规则一致</p>
</li>
</ol>
<h4 id="多态的向下转型"><a href="#多态的向下转型" class="headerlink" title="多态的向下转型"></a>多态的向下转型</h4><p>语法：子类类型   引用名 &#x3D; (子类类型) 父类引用;</p>
<ol>
<li><p>只能强转父类的引用，不能强转父类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时的向上转型</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">adimal.a();</span><br><span class="line"><span class="comment">//等等方法，这些方法只能调用父类子类的共同拥有的方法，不能调用子类的特殊方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时这样写</span></span><br><span class="line"><span class="comment">//强转一下，上述父类的引用</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span>  (Cat)animal；</span><br><span class="line">    cat.catchMouse();</span><br></pre></td></tr></table></figure>


</li>
<li><p>要求父类的引用必须指向的是当前目标类型的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也就是说animal必须是指向对应的子类</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//必须有这句话</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span>  (Cat)animal；<span class="comment">//才能强转成cat类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>可以调用子类类型中所有的成员</p>
</li>
</ol>
<h4 id="属性没有重写之说"><a href="#属性没有重写之说" class="headerlink" title="属性没有重写之说"></a>属性没有重写之说</h4><p>属性的值看编译类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] atgs)</span>&#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">		<span class="keyword">public</span>.out.print(a.count);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//此时输入的值为1</span></span><br><span class="line">        <span class="comment">//因为属性的值是看编译类型</span></span><br><span class="line">            </span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="keyword">public</span>.out.print(a.count);</span><br><span class="line">        <span class="comment">//此时输出2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="instanceOf比较操作符，"><a href="#instanceOf比较操作符，" class="headerlink" title="instanceOf比较操作符，"></a>instanceOf比较操作符，</h4><p>用于判断对象的类型是否为xx类型或xx类型的子类型</p>
<p>判断对象的运行类型是否为xx类型，或这个xx类型的子类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	 count = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] atgs)</span>&#123;</span><br><span class="line">	<span class="type">BB</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BB</span>();</span><br><span class="line">	<span class="keyword">public</span>.out.print(bb <span class="keyword">instanceof</span> BB);<span class="comment">//true</span></span><br><span class="line">	<span class="keyword">public</span>.out.print(bb <span class="keyword">instanceof</span> AA);<span class="comment">//true</span></span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//编译类型AA ，运行类型BB</span></span><br><span class="line">     <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="keyword">public</span>.out.print(aa <span class="keyword">instanceof</span> AA);<span class="comment">//true</span></span><br><span class="line">       <span class="keyword">public</span>.out.print(aa <span class="keyword">instanceof</span> BB);<span class="comment">//true </span></span><br><span class="line">        	</span><br><span class="line">     <span class="type">Object</span> <span class="variable">obj</span>   <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">public</span>.out.print(obj <span class="keyword">instanceof</span> AA);<span class="comment">//false,因为obj不是AA类，也不是AA的子类</span></span><br><span class="line">        </span><br><span class="line">&#125;&#125;	</span><br></pre></td></tr></table></figure>

<h4 id="java动态绑定机制-重要"><a href="#java动态绑定机制-重要" class="headerlink" title="java动态绑定机制(重要)"></a>java动态绑定机制(重要)</h4><ol>
<li>当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</li>
<li>当调用对象属性时，没有动态绑定机制，哪里声明，那里使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">	<span class="comment">//2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//3  </span></span><br><span class="line">		<span class="keyword">return</span> geti()+<span class="number">10</span>;<span class="comment">//5</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">geti</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">geti</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">A</span> <span class="variable">a</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>()</span><br><span class="line">   <span class="comment">//1</span></span><br><span class="line">a.sum <span class="comment">//40</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"><span class="comment">//因为执行到sum方法，开始准备执行geti方法时，因为有java动态绑定的机制，会跳到b类的geti方法执行</span></span><br><span class="line">    <span class="comment">//再根据继承跳回去</span></span><br></pre></td></tr></table></figure>



<h4 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h4><p>1）多态数组</p>
<p>数组的定义类型为父类类型，里面保存的实际元素类型为子类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> seatWork;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">polySeatwork</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 要求创建一个person对象name ，age</span></span><br><span class="line"><span class="comment">        * 两个student 对象和2个teacher对象，统一放在数组中，</span></span><br><span class="line"><span class="comment">        * 并调用每个对象的say方法</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Person1[] person1s = <span class="keyword">new</span> <span class="title class_">Person1</span>[<span class="number">5</span>];</span><br><span class="line">        person1s[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Person1</span>(<span class="string">&quot;human&quot;</span>,<span class="number">00</span>);</span><br><span class="line">        person1s[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Student1</span>(<span class="string">&quot;tom1&quot;</span>,<span class="number">12</span>,<span class="number">150</span>);</span><br><span class="line">        person1s[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Student1</span>(<span class="string">&quot;tom2&quot;</span>,<span class="number">13</span>,<span class="number">143</span>);</span><br><span class="line">        person1s[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">teacher</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">30</span>,<span class="number">4000</span>);</span><br><span class="line">        person1s[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">teacher</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">28</span>,<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环遍历多态数组，调用say方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; person1s.length ; i++) &#123;</span><br><span class="line">            <span class="comment">//老韩提示， person1s[i]的编译类型是Person，</span></span><br><span class="line">            <span class="comment">// 运行类型是根据实际情况而变化</span></span><br><span class="line">            System.out.println(person1s[i].say());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person1</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name = &quot;</span>+name+<span class="string">&quot;age = &quot;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student1</span> <span class="keyword">extends</span> <span class="title class_">Person1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student1</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.say()+<span class="string">&quot;score = &quot;</span>+score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;学习······&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span> <span class="keyword">extends</span> <span class="title class_">Person1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">teacher</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.say()+<span class="string">&quot;salary = &quot;</span>+salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(getName()+<span class="string">&quot;教书·············&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例升级：如何调用子类的特有方法，比如Teacher 有一个teach，Student有一个study方法。如何调用?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环遍历多态数组，调用say方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; person1s.length ; i++) &#123;</span><br><span class="line">            <span class="comment">//老韩提示， person1s[i]的编译类型是Person，</span></span><br><span class="line">            <span class="comment">// 运行类型是根据实际情况而变化</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断person1s[i]的运行类型</span></span><br><span class="line">            <span class="keyword">if</span> ( person1s[i] <span class="keyword">instanceof</span> Student1)&#123;</span><br><span class="line">               <span class="type">Student1</span> <span class="variable">student1</span> <span class="operator">=</span>  (Student1)person1s[i];</span><br><span class="line">               student1.say();</span><br><span class="line">               <span class="comment">//也可以写成一条语句</span></span><br><span class="line">               ((Student1)person1s[i]).study();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (person1s[i] <span class="keyword">instanceof</span> teacher)&#123;</span><br><span class="line">                ((teacher)person1s[i]).teach();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;============类型有误==============&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(person1s[i].say());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><p>方法定义的形参类型为父类型，实参类型允许为子类类型</p>
<ul>
<li><p>polyParameter.java</p>
</li>
<li><p>&#96;&#96;&#96;java<br>package seatWork;</p>
<p>public class polyParameter {<br>&#x2F;*<br>* 定义员工类Employee，包含姓名和月工资[private]，以及计算年工资getAnnual的方法。<br>* 普通员工和经理继承了员工，经理类多了奖金bonus属性和管理manage方法，<br>* 普通员工类多了work方法，普通员工和经理类要求分别重写getAnnual方法<br>*<br>*<br>* 测试类中添加一个方法showEmployAnnual（Employee e ),<br>* 实现获取任何员工对象的年工资，<br>* 并在main方法中调用该方法[e.getAnnual()]<br>*<br>* 测试类中添加一个方法，testWork，如果是普通员工，<br>* 则调用work方法，如果是经理，则调用manage方法<br><em>&#x2F;<br>public static void main(String[] args) {<br>    GeneralStaff staff &#x3D; new GeneralStaff(“zhangsan”, 5000);<br>    Manager manager &#x3D; new Manager(“lisi”, 5000, 10000);<br>    polyParameter polyParameter &#x3D; new polyParameter();<br>    polyParameter.showEmployAnnual(staff);<br>    polyParameter.showEmployAnnual(manager);<br><br>    polyParameter.testWork(staff);<br>    polyParameter.testWork(manager);<br><br>}<br>public void showEmployAnnual(Emplyee e){<br><br>    System.out.println(e.getAnnual());<br>}<br>&#x2F;</em><br>* 添加一个方法，testwork<br>* 如果是普通员工，则调用work方法<br>* 如果是经理则调用manage方法<br>* <em>&#x2F;<br>public void testWork(Emplyee e){<br>    if (e instanceof GeneralStaff){<br>        ((GeneralStaff) e).work();&#x2F;&#x2F;向下转型<br>    }else if (e instanceof Manager){<br>        ((Manager) e).manage();&#x2F;&#x2F;向下转型<br>    }<br>}<br>}<br>class Emplyee {<br>private String name;<br>private double salary;<br><br>public Emplyee(String name, double salary) {<br>    this.name &#x3D; name;<br>    this.salary &#x3D; salary;<br>}<br><br>public String getName() {<br>    return name;<br>}<br><br>public void setName(String name) {<br>    this.name &#x3D; name;<br>}<br><br>public double getSalary() {<br>    return salary;<br>}<br><br>public void setSalary(double salary) {<br>    this.salary &#x3D; salary;<br>}<br><br>public double getAnnual(){<br>    double tmp &#x3D; 12</em>salary;<br><br>    return tmp;<br>}<br>}</p>
<p>class GeneralStaff extends Emplyee{</p>
<pre><code>public GeneralStaff(String name, double salary) &#123;
    super(name, salary);
&#125;

@Override
public double getAnnual() &#123;
    return super.getAnnual();
&#125;

public void work()&#123;
    System.out.println(&quot;work method&quot;);
&#125;
</code></pre>
<p>}<br>class Manager extends Emplyee{<br>private double bonus;<br><br>public Manager(String name, double salary,double bonus) {<br>    super(name, salary);<br>    this.bonus &#x3D; bonus;<br>}<br><br>public void manage(){<br>    System.out.println(“manage method”);<br>}<br><br>@Override<br>public double getAnnual() {<br>    return super.getAnnual()+bonus;<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## Obeject类详解</span><br><span class="line"></span><br><span class="line">类Object是类的层次结构的根类，每个类都使用Object作为超类，所有对象(包括数组)都实现了这个类的方法</span><br><span class="line"></span><br><span class="line">#### equals</span><br><span class="line"></span><br><span class="line">==和equals的对比</span><br><span class="line"></span><br><span class="line">==是一个比较运算符</span><br><span class="line"></span><br><span class="line">1. 既可以判断基本类型，又可以判断引用类型</span><br><span class="line">2. 如果判断基本类型，判断值是否相等。例如：int i = 10; double b = 10.0;</span><br><span class="line">3. 如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">equals：是Object类中的方法，只能判断引用类型，</span><br><span class="line"></span><br><span class="line">判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等</span><br><span class="line"></span><br><span class="line">案例：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package seatWork;</span><br><span class="line"></span><br><span class="line">public class equalsExercise &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person02 person02 = new Person02(&quot;zhangsan&quot;, 123, &#x27;男&#x27;);</span><br><span class="line">        Person02 person03 = new Person02(&quot;zhangsan&quot;, 123, &#x27;男&#x27;);</span><br><span class="line">        //在没有重写equals方法时是不相等，此时的方法时比对是否指向同一对象</span><br><span class="line">        System.out.println(person02.equals(person03));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person02&#123;</span><br><span class="line">//    判断两个Person是否相等</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private char gender;</span><br><span class="line"></span><br><span class="line">    public Person02(String name, int age, char gender) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public char getGender() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGender(char gender) &#123;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">//        1. 先判断两个是否指向同一对象</span><br><span class="line">        if (this == obj)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">//        2.进行类型判断</span><br><span class="line">        if (obj instanceof Person02) &#123;</span><br><span class="line">//            3.向下转型，得到所有的属性信息进行比对</span><br><span class="line">            Person02 person02 = (Person02) obj;</span><br><span class="line">            return this.name.equals(person02.name)&amp;&amp;this.age== person02.age&amp;&amp;this.gender==person02.gender;</span><br><span class="line">        &#125;</span><br><span class="line">//        如果不是Person类型，则直接返回false</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h4><p>介绍：</p>
<p>返回对象的哈希码值，支持此方法是为了提高哈希表的性能</p>
<p>实际上，由object类定义的hashCode方法确定会针对不同的对象返回不同的证书，(这一般是通过将该对象的内部地址转移换成一个整数来实现的，但是java编程语言不需要这种实现技巧)</p>
<p>老韩六小结：</p>
<ol>
<li><p>提高具有哈希结构容器的效率</p>
</li>
<li><p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</p>
</li>
<li><p>两个引用，如果指向的是不同的对象，则哈希值是不一样的（极大概率不一样）</p>
</li>
<li><p>哈希值主要根据地址号来的！，不能完全将哈希值等价于地址</p>
</li>
<li><p>案例演示obj.hashCode() [测试 A obj1 &#x3D; new A(); A obj2 &#x3D; new A(); A obj3 &#x3D; obj1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> seatWork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hashCodeExcise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a3</span> <span class="operator">=</span> a;</span><br><span class="line">        System.out.println(<span class="string">&quot;a.hashCode() = &quot;</span>+a.hashCode());       System.out.println(<span class="string">&quot;a1.hashCode() = &quot;</span>+a1.hashCode());       System.out.println(<span class="string">&quot;a3.hashCode() = &quot;</span>+a3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220323164744164.png" alt="image-20220323164744164"></p>
</li>
<li><p>后面在集合，中hashCode如果需要的话，也会重写</p>
</li>
</ol>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>介绍：</p>
<p>默认返回：全类名+@+哈希值的十六进制，[查看object的tostring方法]</p>
<p>子类往往会重写toString方法，用于<span style="color:red;background:yellow">返回对象的属性信息</span></p>
<p>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。</p>
<p>当直接输出一个对象时，toString方法会被默认的调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(xxx);</span><br><span class="line">等价于System.out.print(xxx.toString);</span><br></pre></td></tr></table></figure>



<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><p>介绍：</p>
<p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</p>
<ol>
<li>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作</li>
<li>什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制销毁该对象，在销毁该对象前，会先调用finalize方法</li>
<li>垃圾回收机制的调用，是由系统来决定的(即有自己的GC算法 )，也可以通过System.gc()主动触犯垃圾回收机制</li>
</ol>
<h2 id="断点调试（debug）"><a href="#断点调试（debug）" class="headerlink" title="断点调试（debug）"></a>断点调试（debug）</h2><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p>在断点调试的过程中，是运行状态，是以对象运行类型来执行的</p>
<h4 id="介绍：-1"><a href="#介绍：-1" class="headerlink" title="介绍："></a>介绍：</h4><p>​	断点调试是指程序在的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步一步往下调，调试过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug。</p>
<h4 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h4><ul>
<li>F7（跳入）<ul>
<li>跳入方法内</li>
</ul>
</li>
<li>F8（跳过）<ul>
<li>逐行执行代码</li>
</ul>
</li>
<li>shift+F8（跳出）<ul>
<li>跳出方法</li>
</ul>
</li>
<li>F9（resume，执行到下一个断点）</li>
</ul>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220324141333874.png" alt="image-20220324141333874"></p>
<h1 id="面向对象（高级）"><a href="#面向对象（高级）" class="headerlink" title="面向对象（高级）"></a>面向对象（高级）</h1><h2 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h2><h3 id="一、类变量"><a href="#一、类变量" class="headerlink" title="一、类变量"></a>一、类变量</h3><p>案例理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Child&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//定义一个变量count，是一个类变量（静态变量）static静态</span></span><br><span class="line">    <span class="comment">//该变量最大的特点就是会被Child类的所有的对象实例共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Child （String name）&#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;加入了游戏····&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="comment">//定义一个变量count，统计多少小孩加入了游戏</span></span><br><span class="line">    <span class="comment">//传统方法，定义一个count然后统计</span></span><br><span class="line">    <span class="comment">//int count  = 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">Child</span> <span class="variable">child0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;xiaoming&quot;</span>)；</span><br><span class="line">        child0.join();</span><br><span class="line">    	<span class="comment">//count++;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改进后</span></span><br><span class="line">    	child0.count++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Child</span> <span class="variable">child1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;xiaoming&quot;</span>)；</span><br><span class="line">        child1.join();</span><br><span class="line">    	child1.count++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Child</span> <span class="variable">child2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;xiaoming&quot;</span>)；</span><br><span class="line">        child2.join();</span><br><span class="line">    	child2.count++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类变量可以通过类名来访问</span></span><br><span class="line">    System.out.println(<span class="string">&quot;共有&quot;</span>+child.count+<span class="string">&quot;小孩加入了游戏&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static变量会开辟一个独立的空间，所以new的对象空间不会再单独创建一个static变量的空间。所以这个static变量空间对于这个类的所有实例是共享的</p>
<h4 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h4><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220402161426676.png" alt="image-20220402161426676"></p>
<ol>
<li>static变量是对象共享的</li>
<li>不管static变量在哪<ol>
<li>static变量是同一个类，所有对象共享</li>
<li>static类变量，在类加载的时候就生成了</li>
</ol>
</li>
</ol>
<h4 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h4><p>访问修饰符	static	数据类型	变量名；【推荐】</p>
<p>static	访问修饰符	数据类型	变量名；</p>
<h4 id="类变量访问"><a href="#类变量访问" class="headerlink" title="类变量访问"></a>类变量访问</h4><p>类名.类变量名【推荐】</p>
<p>或者	</p>
<p>对象名.类变量名 [静态变量的访问修饰符的访问权限和范围和普通属性是一样的]</p>
<p>推荐使用第一种</p>
<h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li>什么时候使用类变量？<ul>
<li>当我们需要让某个类的所有对象都共享一个变量时，就可以使用类变量（静态变量）：比如上述的统计人数的案例</li>
</ul>
</li>
<li>类变量与实际变量的区别<ul>
<li>变量是该类的所有对象共享的</li>
<li>实例变量是每个对象独享的</li>
</ul>
</li>
<li>加上static成为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量</li>
<li>类变量可以通过<span style="color:red">类名.类变量名</span>或者<span style="color:red">对象名.类变量名</span>来访问。推荐第一种方式访问（前提是得满足访问权限）</li>
<li>实例变量不能通过<span style="color:red">类名.类变量名</span>方式访问</li>
<li>类变量是在类加载时就初始化了，也就是说，及时没有创建对象，只要加载类了，就可使用类变量了</li>
<li>类变量的声明周期是随类的加载开始，随着类的消亡而销毁</li>
</ol>
<h3 id="二、类方法"><a href="#二、类方法" class="headerlink" title="二、类方法"></a>二、类方法</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>类方法也称静态方法</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符	<span class="keyword">static</span>	数据源返回类型	方法名()&#123;&#125;	【推荐】</span><br><span class="line"><span class="keyword">static</span>	访问修饰符	数据返回类型	方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类方法调用"><a href="#类方法调用" class="headerlink" title="类方法调用"></a>类方法调用</h4><p>使用方式：</p>
<p><span style="color:red">类名.类方法名</span></p>
<p>或</p>
<p><span style="color:red">对象名.类方法名</span></p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。</p>
<p>比如：工具类中的方法utils</p>
<p>Math类、Arrays类、Collections集合类</p>
<h4 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息储存在方法区：<ul>
<li>类方法中无this的参数</li>
<li>普通方法中隐含this参数</li>
</ul>
</li>
<li>类方法可以通过类名调用，也可以通过对象名调用</li>
<li>普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用</li>
<li>类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以</li>
<li>类方法(静态方法)中，只能访问 静态变量和静态方法</li>
<li>普通成员方法，既可以访问静态的成员，非静态的方法。可以访问静态成员和非静态成员</li>
</ol>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>静态方法，只能访问静态的成员，</p>
<p>非静态方法，可以访问静态的 成员和非静态的成员</p>
<p>（前提是必须遵守访问权限规则）</p>
<h2 id="理解main方法语法"><a href="#理解main方法语法" class="headerlink" title="理解main方法语法"></a>理解main方法语法</h2><h4 id="深入理解main方法"><a href="#深入理解main方法" class="headerlink" title="深入理解main方法"></a>深入理解main方法</h4><p>解释main方法的形式：public static void main(String[] args){}</p>
<p>main方法是java虚拟机调用的</p>
<ol>
<li><p>java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public</p>
</li>
<li><p>java虚拟机在执行main()方法是不必创建对象，所有该方法必须是static</p>
</li>
<li><p>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</p>
</li>
<li><p>java执行的程序 参数1 参数2  参数3</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220403184106869.png" alt="image-20220403184106869"></p>
</li>
</ol>
<h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol>
<li><p>在main（）方法中我们可以直接调用main方法所在类的静态方法或静态属性</p>
</li>
<li><p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，再能通过这个对象去访问类中的非静态成员</p>
</li>
<li><p>例：</p>
<ul>
<li>&#96;&#96;&#96;java<br>class A{<br>private int a;<br>private static int b;<br><br>private void a(){<br>    System.out.println(“非静态方法a”);<br>}<br>private static void b(){<br>    System.out.println(“静态方法a”);<br>}<br><br><br><br>public static void main(String[] args){<br>    System.out.println(“id &#x3D; “ +a);&#x2F;&#x2F;错误 a是非静态变量，得实例一个对象才能调用<br>    System.out.println(“id &#x3D; “ +new A().a);&#x2F;&#x2F;这样是正确的，创建了个匿名对象调用<br>    System.out.println(“id &#x3D; “ +b);&#x2F;&#x2F;正确， 因为b是静态变量，可以直接调用<br>    System.out.println(“id &#x3D; “ +a());&#x2F;&#x2F;错误，和上述a的非静态变量的原因相同<br>    System.out.println(“id &#x3D; “ +new A().a());&#x2F;&#x2F;改成这样就是正确的，因为a()是非静态的方法<br><br>    A a &#x3D; new A();<br>    System.out.println(“id &#x3D; “ +a.a());&#x2F;&#x2F;同理<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   * </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 代码块</span><br><span class="line"></span><br><span class="line">#### 介绍</span><br><span class="line"></span><br><span class="line">代码块又称初始化块，属于类中的成员【即 是类的一部分】。类似于方法，将罗技语句封装在方法体中，通过&#123;&#125;包围起来</span><br><span class="line"></span><br><span class="line">和方法不同，没有方法名，没有返回，没有参数，只有方法体。而且不用通过对象或类显式调用，而是在家类是，或创建对象时隐式调用。</span><br><span class="line"></span><br><span class="line">#### 基本语法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">[修饰符]&#123;</span><br><span class="line">	代码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol>
<li>修饰符 可选，要写的话，也只能写static</li>
<li>代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块</li>
<li>逻辑语句可以为任何罗技语句（输入，输出，方法调用，循环，判断等）</li>
<li>; 号可以写上，也可以省略。</li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作</li>
<li>如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</li>
</ol>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">	pricate String director;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用场景</span></span><br><span class="line"><span class="comment">    1. 下面三个构造器都有相同的语句</span></span><br><span class="line"><span class="comment">    2. 这样重写大量的代码</span></span><br><span class="line"><span class="comment">    3. 可以吧相同语句提取出来，放到一个代码块中</span></span><br><span class="line"><span class="comment">    4. 我们不管调用哪个构造器，创建对象，都会先执行代码块</span></span><br><span class="line"><span class="comment">    5. 代码块调用的顺序都是优先于构造器</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;电影屏幕打开···&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;广告···&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;开始播放电影···&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name)</span>&#123;</span><br><span class="line">       <span class="comment">/* </span></span><br><span class="line"><span class="comment">        System.out.println(&quot;电影屏幕打开···&quot;);</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;广告···&quot;);</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;开始播放电影···&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name,<span class="type">double</span> price)</span>&#123;</span><br><span class="line">       <span class="comment">/* </span></span><br><span class="line"><span class="comment">        System.out.println(&quot;电影屏幕打开···&quot;);</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;广告···&quot;);</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;开始播放电影···&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name,<span class="type">double</span> price,String director)</span>&#123;</span><br><span class="line">       <span class="comment">/* </span></span><br><span class="line"><span class="comment">        System.out.println(&quot;电影屏幕打开···&quot;);</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;广告···&quot;);</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;开始播放电影···&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.director = director;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用细节-2"><a href="#使用细节-2" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li><p>static代码块也叫静态代码块，作用就是对类进行初始化，</p>
<p>而且它随着类的加载而执行</p>
<p>并且只会执行一次。</p>
<p>如果是普通代码块，每创建一个对象，就执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	xxxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通代码块</span></span><br><span class="line">&#123;</span><br><span class="line">	xxxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类什么时候被加载？[重要]</p>
<ol>
<li>创建对象实例时（new xxx)</li>
<li>创建子类对象实例，父类也会被加载<ol>
<li>先在家父类的代码块，再执行子类的</li>
</ol>
</li>
<li>使用类的静态成员时（静态属性，静态方法）</li>
</ol>
<p>案例：A类 extends B类的静态块</p>
<p>​			先执行a的静态块，然后再执行b的</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220404151232983.png" alt="image-20220404151232983"></p>
</li>
<li><p>普通代码块，在创建对象实例时，会被隐式调用。</p>
<p>被创建一次，就会调用一次</p>
<p>如果只是使用类的静态成员时，普通代码块并不会执行</p>
</li>
<li><p>创建一个对象时，在一个类 调用顺序是（重点，难点）</p>
<ol>
<li><p>调用静态代码块和静态属性初始化</p>
<p>（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">案例理解</span><br><span class="line">    </span><br><span class="line">    因为<span class="keyword">static</span>的优先级一样，</span><br><span class="line">    所以哪个写在前面，哪个就先执行</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> getn1();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&#x27;s static codeBlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getn1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;use getn1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">============================================</span><br><span class="line">输出结果：</span><br><span class="line">============================================</span><br><span class="line">use getn1</span><br><span class="line">A<span class="string">&#x27;s static codeBlock</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">=========================分割线=========================</span></span><br><span class="line"><span class="string">//如果更换顺序</span></span><br><span class="line"><span class="string">class A&#123;</span></span><br><span class="line"><span class="string">    static &#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;A&#x27;</span>s <span class="keyword">static</span> codeBlock<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    private static  int n1 = getn1();</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public static int getn1()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>use getn1<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        return 100;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;   </span></span><br><span class="line"><span class="string">============================================</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">============================================</span></span><br><span class="line"><span class="string"> A&#x27;s static codeBlock</span></span><br><span class="line"><span class="string">use getn1</span></span><br><span class="line"><span class="string">   </span></span><br></pre></td></tr></table></figure>


</li>
<li><p>调用普通代码块和普通属性的初始化</p>
<p>（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义的顺序调用） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先执行静态的，和上述的一样，</span></span><br><span class="line"><span class="comment">//然后再执行非静态的，规则也是和上述一样，谁写前面先执行谁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> getn2();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&#x27;s static codeBlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> getn1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getn1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;use getn1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getn2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getn2 被调用&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">============================================</span><br><span class="line">输出结果：</span><br><span class="line">============================================</span><br><span class="line">A<span class="string">&#x27;s static codeBlock</span></span><br><span class="line"><span class="string">use getn1</span></span><br><span class="line"><span class="string">getn2 被调用</span></span><br><span class="line"><span class="string">普通代码块被执行</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">=========================分割线=========================</span></span><br><span class="line"><span class="string">class A&#123;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;普通代码块被执行&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    private int b = getn2();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    static &#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;A&#x27;</span>s <span class="keyword">static</span> codeBlock<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    private static  int n1 = getn1();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public static int getn1()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>use getn1<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        return 100;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    public int getn2()&#123;</span></span><br><span class="line"><span class="string">        System.out.println(&quot;</span>getn2 被调用<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        return 1;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;    </span></span><br><span class="line"><span class="string">============================================</span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">============================================</span></span><br><span class="line"><span class="string">A&#x27;s static codeBlock</span></span><br><span class="line"><span class="string">use getn1</span></span><br><span class="line"><span class="string">普通代码块被执行</span></span><br><span class="line"><span class="string">getn2 被调用</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>调用构造器</p>
<p>构造器优先级最低，上述的两个规则执行完成后<br>才会执行构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> getn2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&#x27;s static codeBlock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> getn1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getn1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;use getn1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getn2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;getn2 被调用&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">============================================</span><br><span class="line">输出结果：</span><br><span class="line">============================================</span><br><span class="line">A<span class="string">&#x27;s static codeBlock</span></span><br><span class="line"><span class="string">use getn1</span></span><br><span class="line"><span class="string">普通代码块被执行</span></span><br><span class="line"><span class="string">getn2 被调用</span></span><br><span class="line"><span class="string">构造器被执行</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>构造器 的最前面其实隐含了super() 和调用普通代码块</p>
<p>静态相关的代码块，属性初始化，在类加载时，就执行完毕。因此是优先于 构造器和普通代码块执行的</p>
<p>演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//这里存在隐藏的调用</span></span><br><span class="line">			<span class="comment">//(1) super();</span></span><br><span class="line">			<span class="comment">//(2) 调用普通代码块</span></span><br><span class="line">			</span><br><span class="line">		 System.out.println(<span class="string">&quot;xxxx&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AAA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AAA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这里存在隐藏的调用</span></span><br><span class="line">        <span class="comment">//(1) super();</span></span><br><span class="line">        <span class="comment">//(2) 调用普通代码块</span></span><br><span class="line">        <span class="comment">//因为Object的代码块没有输出</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.先输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AAA的构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BBB</span> <span class="keyword">extends</span> <span class="title class_">AAA</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        根据规则父类的输出完毕后，再调用方法区</span></span><br><span class="line"><span class="comment">//        2. 再执行普通代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;bbb的普通代码块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BBB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这里存在隐藏的调用</span></span><br><span class="line">        <span class="comment">//(1) super();</span></span><br><span class="line">        <span class="comment">//(2) 调用普通代码块</span></span><br><span class="line"><span class="comment">//        等上述执行完毕后，最后执行该语句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BBB的无参构造被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个子类对象时(继承关系),他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：</p>
<ol>
<li>父类的静态代码块和静态属性（优先级一样，按定义的顺序执行）</li>
<li>子类的静态代码块和静态属性（优先级一样，按定义的顺序执行）</li>
<li>父类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）</li>
<li>父类的构造器</li>
<li>子类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）</li>
<li>子类的构造器</li>
</ol>
</li>
<li><p>静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任何成员</p>
</li>
</ol>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><ol>
<li>所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且只提供一个取得对象实例的方法</li>
<li>单例模式有两种方式：1）饿汉式 2）懒汉式<ol>
<li>二者最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例,而懒汉式在使用时才创建</li>
<li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li>
<li>饿汉式存在浪费资源的可能。（因为如果程序员一个对象实例都没使用，那么饿汉式创建的对象就是浪费了，懒汉式是使用时才创建，就不存在这个问题</li>
<li>在javaSE标准类中，java.lang.Runtim就是经典的单例设计模式</li>
</ol>
</li>
</ol>
<p>演示：</p>
<ol>
<li><p>恶汉式</p>
<p>类加载的时候，对象就被创建实例对象，可能会出现创建了，但是没有使用</p>
<p>步骤：</p>
<ol>
<li><p>构造器私有化 &#x3D;&gt; 防止直接new</p>
</li>
<li><p>类的内部创建对象</p>
</li>
<li><p>向外露出一个静态的公共方法。</p>
</li>
<li><p>代码实现</p>
</li>
<li><p>&#96;&#96;&#96;java<br>public class singleDesign {<br>public static void main(String[] args) {<br>    System.out.println(GirlFriend.info());<br>}<br>}<br>&#x2F;&#x2F;有一个女朋友类<br>&#x2F;&#x2F;只能有一个女朋友<br>class GirlFriend{<br>private String name;<br>&#x2F;&#x2F;    2.创建一个对象<br>&#x2F;&#x2F;    3.为了能够接收静态方法，需要修饰为static<br>private static GirlFriend girl &#x3D; new GirlFriend(info());<br>&#x2F;&#x2F;    如何保证只能有一个对象实例<br>&#x2F;&#x2F;    public girlFriend(String name) {<br>&#x2F;&#x2F;        this.name &#x3D; name;<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;    1. 改成私有的构造器<br>private GirlFriend(String name) {<br>    this.name &#x3D; name;<br>}<br>&#x2F;&#x2F;    4.创建一个静态方法，用于接收实例对象<br>public static String info(){<br>    return “g”;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 懒汉式</span><br><span class="line"></span><br><span class="line">   使用时才创建实例</span><br><span class="line"></span><br><span class="line">   1. 构造器私有化=&gt; 防止直接new</span><br><span class="line"></span><br><span class="line">   2. 类的内部创建对象</span><br><span class="line"></span><br><span class="line">   3. 向外暴露一个静态的公共方法</span><br><span class="line"></span><br><span class="line">   4. ```java</span><br><span class="line">      public class SingleDesign01 &#123;</span><br><span class="line">          public static void main(String[] args) &#123;</span><br><span class="line">              System.out.println(Cat.i);</span><br><span class="line">      //        此时只是初始化了cat ，但没有创建对象，其他的静态参数可以直接调用</span><br><span class="line">              System.out.println(Cat.getCat());</span><br><span class="line">      //        当只有调用了这个方法时，才会创建对象(通过判断发现没有cat类，此时创建后返回)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //懒汉式</span><br><span class="line">      //希望在程序运行中，只创建一个cat</span><br><span class="line">      </span><br><span class="line">      class Cat&#123;</span><br><span class="line">          private String name;</span><br><span class="line">          public static int i =1;</span><br><span class="line">      //    2.定义一个静态属性static</span><br><span class="line">          private  static Cat cat;</span><br><span class="line">      </span><br><span class="line">      //    3.提供一个公共的static方法 可以返回一个Cat对象</span><br><span class="line">          public  static  Cat getCat()&#123;</span><br><span class="line">              if (cat == null)&#123; //如果还没创建对象</span><br><span class="line">                  cat = new Cat(&quot;little cute&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">              return cat;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">      //    1.创建私有构造器</span><br><span class="line">          private Cat(String name)&#123;</span><br><span class="line">              this.name = name;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>final &#x2F; 最后的，最终的</p>
<p>fianl 可以修饰类、属性、方法和局部变量</p>
<p>某些情况下，程序员可能有以下需求，就会使用到final：</p>
<ol>
<li>当不希望类被继承时，可以用final修饰</li>
<li>当不希望父类的某个方法可以被子类覆盖&#x2F;重写（override）时，可以用final关键字修饰</li>
<li>当不希望类的某个属性的值被修改，可以使用final修饰</li>
<li>当不希望某个局部变量被修改，可以使用final修饰</li>
</ol>
<h4 id="使用细节-3"><a href="#使用细节-3" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li><p>final修饰的属性又叫常量，一般用XX_XX_XX来命名</p>
</li>
<li><p>final修饰的属性在定义时，必须赋初始值，并且以后都不能修改，赋值可以在如下位置之一（选择一个位置赋初始值即可）</p>
<ol>
<li><p>定义时：例如  public final double TAX_PATE&#x3D;0.09;</p>
</li>
<li><p>在构造器中</p>
</li>
<li><p>在代码块中</p>
</li>
<li><p>&#96;&#96;&#96;java<br>class A{<br>&#x2F;&#x2F;定义时赋值<br>public final double ATX_A &#x3D; 0.9;<br>&#x2F;&#x2F;在构造器中赋值<br>public final double ATX_B；<br>public A{<br>    ATX_B&#x3D;0.8；<br>}<br>&#x2F;&#x2F;在代码块中赋值<br>public final double ATX_C；<br>{<br>    ATX_C&#x3D;0.2；<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 如果final修饰的属性是静态的，则初始化的位置只能是</span><br><span class="line"></span><br><span class="line">   1. 定义时</span><br><span class="line">   2. 在静态代码块 </span><br><span class="line">   3. 不能再构造器中赋值</span><br><span class="line"></span><br><span class="line">4. final类不能被继承，但是可以实例化对象</span><br><span class="line"></span><br><span class="line">5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</span><br><span class="line"></span><br><span class="line">6. 一般来说，如果一个类已经是final类，就没有必要再将方法修饰成final方法。</span><br><span class="line"></span><br><span class="line">7. final不能修饰构造方法（即构造器）</span><br><span class="line"></span><br><span class="line">8. final和static 往往搭配使用，效率更高，不会导致类的加载。底层编译器做了优化处理</span><br><span class="line"></span><br><span class="line">9. 包装类(integer,Double,Float,Boolean等等都是final),String 也是final类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 抽象类</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">编写一个父类</span><br><span class="line">//class Animal&#123;</span><br><span class="line">abstract Animal&#123;</span><br><span class="line">	String name;</span><br><span class="line">	public Animal(String name)&#123;</span><br><span class="line">	 this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	这里的eat方法 实现了，没有什么意义</span><br><span class="line">	即父类中的方法不确定性的问题</span><br><span class="line">	</span><br><span class="line">	1.考虑将该方法设计为抽象(abstract)方法</span><br><span class="line">	2.所谓抽象方法就是没有实现的方法</span><br><span class="line">	3.所谓的没有实现就是没有方法体</span><br><span class="line">	4.当一个类存在抽象方法时，就需要将该类声明为abstract类</span><br><span class="line">	</span><br><span class="line">	一般来说，抽象类会被继承，有其子类来实现抽象方法</span><br><span class="line">	*/</span><br><span class="line">    </span><br><span class="line">	//public void eat()&#123;</span><br><span class="line">	//	System.out.println(&quot;这个是一个吃方法，但不知道吃啥&quot;);</span><br><span class="line">	//&#125;</span><br><span class="line">    </span><br><span class="line">	public abstract void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h4><ol>
<li><p>用abstract 关键字修饰的类时，这个类就是抽象类</p>
<ol>
<li>&#96;&#96;&#96;java<br>访问修饰符 abstract 类名{<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 用abstract 关键字来修饰一个方法时，这个方法就是抽象方法</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()</p>
</li>
</ol>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ol>
<li>抽象类不能被实例化</li>
<li>抽象类不一定包含abstract方法。也就是说，抽象类可以没有abstract方法</li>
<li>一旦包含了abstract方法，则这个类必须声明为abstract </li>
<li>abstract 只能修饰类和方法，不能修饰属性和其他的</li>
<li>抽象类可以有任意成员【抽象类的本质还是类】，比如：非抽象方法、构造器、静态属性等等</li>
<li>抽象方法不能有主体，即不能实现。例如：abstract void method()；不能有{}</li>
<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract 类（所谓实现就是有那个{}就可，具体内容不管）</li>
<li>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</li>
</ol>
<h4 id="抽象类实践-模板设计模式"><a href="#抽象类实践-模板设计模式" class="headerlink" title="抽象类实践-模板设计模式"></a>抽象类实践-模板设计模式</h4><p>现有个需求</p>
<ol>
<li>有多个类，完成不同的任务job</li>
<li>要求能得到各自完成任务的时间</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> seatWork;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">son1</span> <span class="variable">son1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">son1</span>();</span><br><span class="line">        son1.getCurrentTime();</span><br><span class="line">        <span class="type">son2</span> <span class="variable">son2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">son2</span>();</span><br><span class="line">        son2.getCurrentTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"><span class="comment">//在抽象类中定义一个抽象方法，这个方法后期会填入不同子类的不同不同方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//创建一个子类中的公共部分，在其中添加 不同的部分抽象类(方法)，</span></span><br><span class="line"><span class="comment">// 由于动态绑定机制，当调用该方法时，根据实例不同的子类实现不同的输出结果</span></span><br><span class="line"><span class="comment">//    也就是说相当于创建了个模板，不同的类用填不同的内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCurrentTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        job();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;用时：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son1</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son2</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">60000</span>; i++) &#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="接口（重要）"><a href="#接口（重要）" class="headerlink" title="接口（重要）"></a>接口（重要）</h2><h4 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h4><p>接口就是给出一些没有实现的方法，封装到一起，起到某个类要使用的时候，在根据具体情况吧这些方法写出来</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface 类名 implements 接口&#123;</span><br><span class="line"> 自己的属性；</span><br><span class="line"> 自己的方法；</span><br><span class="line"> 必须实现的接口的抽象方法；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结:</p>
<ol>
<li>jdk7之前，接口中所有方法否是抽象方法</li>
<li>jdk8之后，接口中可以有实现方法，但需要使用default关键字修饰</li>
<li>jdk8之后可以有静态方法</li>
<li>abstract关键字可以省略</li>
</ol>
<h4 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p>接口不能被实例化</p>
</li>
<li><p>接口中所有的方法是public方法，接口中抽象方法，可以不用填写abstract，因为默认修饰的就是public abstract xxx。</p>
</li>
<li><p>一个普通类实现接口，就必须将该接口的所有方法都实现</p>
</li>
<li><p>抽象类实现接口，可以不用实现接口的方法</p>
</li>
<li><p>一个类同时可以实现多个接口</p>
</li>
<li><p>接口的属性，只能是final的，而且public static final 修饰符，比如：int a &#x3D;1; 实际上是public static final int a &#x3D;1；（必须）初始化</p>
</li>
<li><p>接口中属性的访问形式：接口名.属性名</p>
</li>
<li><p>一个接口不能继承其他的类，但是可以继承多个别的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> extend B,c,d...&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口的修饰符只能是public和默认，这点和类的修饰符是一样的。</p>
</li>
</ol>
<p>小结：</p>
<p>继承vs接口</p>
<ol>
<li>当子类继承了父类，就自动拥有了父类的功能</li>
<li>如果子类需要拓展功能，可以通过实现接口的方式扩展</li>
<li>可以理解，接口是对java单继承机制的一个补充</li>
</ol>
<p>继承的价值：解决代码的复用性和可维护性</p>
<p>接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。更加的灵活</p>
<h2 id="内部类（重点）"><a href="#内部类（重点）" class="headerlink" title="内部类（重点）"></a>内部类（重点）</h2><h4 id="介绍：-2"><a href="#介绍：-2" class="headerlink" title="介绍："></a>介绍：</h4><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类成为内部类（inner class)，嵌套其他类的类成为外部类(out class)。是我们类的第五大成员</p>
<p>类的五大成员：</p>
<ol>
<li>属性</li>
<li>方法</li>
<li>构造器</li>
<li>代码块</li>
<li>内部类</li>
</ol>
<h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;<span class="comment">//外部类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">inner</span>&#123;<span class="comment">//内部类</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">other</span>&#123;<span class="comment">//外部其他类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h4><p>定义在外部类局部位置上（比如方法内）</p>
<h5 id="1）局部内部类（有类名）"><a href="#1）局部内部类（有类名）" class="headerlink" title="1）局部内部类（有类名）"></a>1）局部内部类（有类名）</h5><p>​		说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outclass</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="comment">//局部内部类师是定义在外部类的局部位置，通常在方法内</span></span><br><span class="line"> <span class="comment">// 1.第一种在局部位置</span></span><br><span class="line"> 	<span class="keyword">class</span> <span class="title class_">innerClass</span>&#123;&#125;</span><br><span class="line">  <span class="comment">//2. 在方法内，（局部内部类）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mehtod</span><span class="params">()</span>&#123;<span class="comment">//局部内部类（本质仍然是一个类）</span></span><br><span class="line">    	<span class="keyword">class</span> <span class="title class_">innerClass</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;n=&quot;</span>+n);</span><br><span class="line">      &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>可以直接访问外部类的所有成员，包括私有的</p>
</li>
<li><p>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但可以使用final修饰，因为局部变量也可以使用final修饰符的</p>
</li>
<li><p>作用域：仅仅在定义它的方法或代码块中</p>
</li>
<li><p>局部内部类—访问—-&gt;外部类的成员【访问方式：直接访问】</p>
</li>
<li><p>外部类—-访问—-&gt;局部内部类的成员</p>
<p>访问方式：创建对象，再访问（注意：必须在作用域内）</p>
</li>
<li><p>外部其它类—-&gt;不能访问—-&gt;局部内部类（因为 局部内部类地位是一个局部变量）</p>
</li>
<li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</p>
</li>
<li><p>&#96;&#96;&#96;java<br>class Outer{<br>private int n1 &#x3D; 10;<br>private static String name &#x3D; “张三”;<br>public void say(){<br>    int n3 &#x3D; 30;<br>  &#x2F;&#x2F;局部内部类是定义在外部类的局部位置，通常在方法<br>    &#x2F;&#x2F;不能添加访问修饰符，可以使用final修饰<br>  class localInner{&#x2F;&#x2F;局部内部类（本质仍然是一个类）<br>int n1 &#x3D; 100;<br>   int n2 &#x3D; 40;<br>    &#x2F;&#x2F;可以直接访问外部类的所有成员，包括私有的<br>  public void show(){<br>  &#x2F;&#x2F;默认输入内部类的n1的值 100<br>    System.out.print(“n1&#x3D;”+n1);<br>  &#x2F;&#x2F;输入outer.this.n1 输出的才是外部类的n1<br>  System.out.print(“n1&#x3D;”+outer.this.n1);<br><br>  }<br>}<br>}<br>  &#x2F;&#x2F;外部类使用内部类<br>  localInner inner &#x3D; new localInner();<br>  inner.show();<br> }</p>
<p>&#x2F;&#x2F;外部其他类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">9. </span><br><span class="line"></span><br><span class="line">##### 2）匿名内部类（没有类名，重点！！！！）</span><br><span class="line"></span><br><span class="line">###### 介绍：</span><br><span class="line"></span><br><span class="line">1. 本质是类</span><br><span class="line">2. 是一个内部类</span><br><span class="line">3. 该类没有名字</span><br><span class="line">4. 同时还是一个对象</span><br><span class="line"></span><br><span class="line">匿名内部类是定义在外部类的局部位置</span><br><span class="line"></span><br><span class="line">比如在方法中，并且没有类名</span><br><span class="line"></span><br><span class="line">###### 基本语法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">new 类 或 接口（参数列表）&#123;</span><br><span class="line">	类体</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">anonymous</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapterObjectHeightLevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">outer</span>();</span><br><span class="line">        outer.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outer</span>&#123;<span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//现有一个需求，使用IA接口，并创建对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        传统方法：新建一个类tiger 实现IA接口，并new tiger调用</span></span><br><span class="line"><span class="comment">//        IA tiger = new Tiger();</span></span><br><span class="line"><span class="comment">//        tiger.cry();</span></span><br><span class="line"><span class="comment">//        当此时的需求是只需要这个Tiger类使用一次，并且以后再也不使用</span></span><br><span class="line"><span class="comment">//        如果再用传统方法的话，会造成资源浪费，而且没有必要再去新建一个类</span></span><br><span class="line"><span class="comment">//        此时就需要匿名内部类来简化开发，如下</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *此时底层是这样的</span></span><br><span class="line"><span class="comment">             * class xxx(该类名是系统自动创建的) implements IA&#123;</span></span><br><span class="line"><span class="comment">             *     <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">             *     public void cry() &#123;</span></span><br><span class="line"><span class="comment">             *         System.out.println(&quot;老虎叫`````&quot;);</span></span><br><span class="line"><span class="comment">             *     &#125;</span></span><br><span class="line"><span class="comment">             * &#125;</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 之后在让tiger指向xxx的地址</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎叫`````&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        tiger.cry();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示基于类的匿名内部类</span></span><br><span class="line"><span class="comment">//        1. father的编译类型 Father(不加&#123;&#125;号)</span></span><br><span class="line"><span class="comment">//        2. father的编译类型 xxx$2(加&#123;&#125;号）</span></span><br><span class="line"><span class="comment">//        2.1 底层会创建匿名内部类</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&quot;tiger&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;override test method&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 相当于创建了哥匿名内部类重写了test方法</span></span><br><span class="line"><span class="comment">            * class xxx implement test&#123;</span></span><br><span class="line"><span class="comment">             *      <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">             *      public void test() &#123;</span></span><br><span class="line"><span class="comment">             *          System.out.println(&quot;override test method&quot;);</span></span><br><span class="line"><span class="comment">             *       &#125;</span></span><br><span class="line"><span class="comment">             * &#125;</span></span><br><span class="line"><span class="comment">             * 然后再将father指向xxx的地址</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">        &#125;;</span><br><span class="line">        father.test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Tiger implements IA&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void cry() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;老虎叫`````&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h6><ol>
<li><p>匿名内部类既是一个类的定义，同事它也是一个对象，因此从语法上来看，它既有定义类的特征，也有创建对象的特征，对前面的代码分析可以看出这个特点，因此调用匿名内部类方法有两种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.第一种方式</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;.cry();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.第二种方式</span></span><br><span class="line">A a=<span class="keyword">new</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.cry();</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以访问外部类的所有成员，包括私有的</p>
</li>
<li><p>不能添加访问修饰符，因为它的地位就是一个局部变量</p>
</li>
<li><p>作用域：方法或代码块中</p>
</li>
<li><p>匿名内部类—&gt;范围跟—&gt;外部类成员</p>
</li>
<li><p>外部其他类—&gt;不能访问—&gt;匿名内部类（因为 匿名内部类地位是一个局部变量）</p>
</li>
<li><p>如果外部类和内部类的成员变量重名时，内部类访问的话，默认就是就近原则，如果想访问外部，可以使用（外部类名.this.成员）去访问</p>
</li>
</ol>
<p>定义在外部类的成员位置上</p>
<h5 id="1）成员内部类（没用static修饰）"><a href="#1）成员内部类（没用static修饰）" class="headerlink" title="1）成员内部类（没用static修饰）"></a>1）成员内部类（没用static修饰）</h5><p>介绍：</p>
<ol>
<li><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">outer</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">inner</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.print(<span class="string">&quot;outer n1 = &quot;</span>+n1+<span class="string">&quot;outer name = &quot;</span>+name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位是一个成员</p>
</li>
<li><p>作用域</p>
<p>和外部类的其他成员一样，为整个类体比如前面的案例，在外部类的成员方法中创建成员内部类对象，再调用方法</p>
</li>
<li><p>成员内部类–&gt;访问—&gt;外部类成员</p>
<p>(比如属性)【访问方式：直接访问】</p>
</li>
<li><p>外部类 —访问—内部类</p>
<p>访问方式：创建对象，再访问</p>
</li>
<li><p>外部其他类—–访问—–成员内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种方式:</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">outer.<span class="type">inner</span> <span class="variable">class</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">outer</span>.<span class="keyword">new</span> <span class="title class_">inner</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line"> <span class="number">1.</span>定义一个方法，用于创建内部类并返回内部类的实例</span><br><span class="line">   <span class="keyword">public</span> inner <span class="title function_">getInner</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">Inner</span> <span class="variable">inner</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">   <span class="keyword">return</span> inner;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="number">2.</span> 在需要的地方<span class="keyword">new</span>一个外部类.这个方法</span><br><span class="line">  Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.getInner();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3这个方法不建议使用</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409142725630.png" alt="image-20220409142725630"></p>
</li>
</ol>
<h5 id="2）静态内部类（使用static修饰）"><a href="#2）静态内部类（使用static修饰）" class="headerlink" title="2）静态内部类（使用static修饰）"></a>2）静态内部类（使用static修饰）</h5><h6 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h6><p>静态内部类定义在外部类的成员位置，并且有static修饰</p>
<ol>
<li>可以直接访问外部的所有静态成员，包含私有的，但不能直接访问非静态成员</li>
<li>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员</li>
<li>作用域：同其他的成员，为整个类体</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">outer</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> n1=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inner就是静态内部类</span></span><br><span class="line">  <span class="comment">//1. 放在外部类的成员位置</span></span><br><span class="line">  <span class="comment">//2. 使用static修饰</span></span><br><span class="line">  <span class="comment">//3. 不能直接访问非静态成员</span></span><br><span class="line">  <span class="comment">//4. 可以添加修饰符</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">      	System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>静态内部类—访问—-外部类</p>
<p>（比如：静态属性）[访问方式：直接访问所有静态成员]</p>
</li>
<li><p>外部类–访问—静态内部类 </p>
<p>访问方式：创建对象，再访问</p>
</li>
<li><p>外部其他类 –访问 –内部类</p>
<p>访问方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问方式1</span></span><br><span class="line"><span class="comment">//因为静态内部类，是可以通过类名直接访问（前提是满足访问权限）</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">inner.xxx();</span><br><span class="line"><span class="comment">//访问方式2</span></span><br><span class="line"><span class="comment">//写一个方法，返回静态内部类的实例</span></span><br><span class="line"><span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> Outer.getInner();</span><br><span class="line"></span><br><span class="line">inner.xxx();</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者将方法换成静态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Inner <span class="title function_">getInner</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果外部类和静态内部类的成员重名时，静态内部访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问</p>
</li>
</ol>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>1）枚举对应的英文（enumeration,简写enum）</p>
<p>2）枚举是一组常量的集合</p>
<p>3）可以理解：枚举属于一种特殊的类，里面只包含一组有限的特定对象（比如一年只有四个季节，建一个季节类的话只能有四个，而且有被添加其他季节的风险）</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="1）自定义枚举"><a href="#1）自定义枚举" class="headerlink" title="1）自定义枚举"></a>1）自定义枚举</h4><ol>
<li>不需要提供set方法，因为枚举对象通常为只读</li>
<li>对枚举对象&#x2F;属性使用final +static共同修饰，实现底层优化</li>
<li>枚举对象通常使用大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapterEnum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">understandForEnum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">season</span> <span class="variable">autumn</span> <span class="operator">=</span> season.AUTUMN;</span><br><span class="line">        System.out.println(autumn.getSeasonName()+autumn.getSeasonDescription());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个季节类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String seasonName;<span class="comment">//季节名称</span></span><br><span class="line">    <span class="keyword">private</span> String seasonDescription;<span class="comment">//季节描述</span></span><br><span class="line">  <span class="comment">//1.将构造器私有化</span></span><br><span class="line">  <span class="comment">//2.去掉setxx方法，防止属性被修改</span></span><br><span class="line">  <span class="comment">//3.在season内部，直接创建固定的对象</span></span><br><span class="line">  <span class="comment">//4.优化，添加final</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">season</span><span class="params">(String seasonName, String seasonDescription)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDescription = seasonDescription;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//定义了四个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：定义枚举类型有一下几个特点</p>
<ol>
<li>构造器私有化</li>
<li>本类内部创建一组对象</li>
<li>对外暴露对象（添加public final static 修饰）</li>
<li>可以提供get方法，但不需要提供set方法</li>
</ol>
<h4 id="2）使用enum关键字实现"><a href="#2）使用enum关键字实现" class="headerlink" title="2）使用enum关键字实现"></a>2）使用enum关键字实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapterEnum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">understandForEnum02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(season02.SPRING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">season02</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现步骤</span></span><br><span class="line"><span class="comment">     * 1.使用enum代替class</span></span><br><span class="line"><span class="comment">     * 2.直接使用 常量名(实参列表)</span></span><br><span class="line"><span class="comment">     *   SPRING(&quot;春天&quot;,&quot;温暖&quot;),</span></span><br><span class="line"><span class="comment">     *   如果有多个常量则用,号隔开</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * enum修饰必须将常量对象写在第一行</span></span><br><span class="line"><span class="comment">     *  必须写在定义的变量和方法前面</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3.编写常量，私有构造器和get方法</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;温暖&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;凉爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String seasonName;<span class="comment">//季节名称</span></span><br><span class="line">    <span class="keyword">private</span> String seasonDescription;<span class="comment">//季节描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">season02</span><span class="params">(String seasonName, String seasonDescription)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDescription = seasonDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;season02&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDescription=&#x27;&quot;</span> + seasonDescription + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义四个固定对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public final static season02 SPRING = new season02(&quot;春天&quot;,&quot;温暖&quot;);</span></span><br><span class="line"><span class="comment">    public final static season02 SUMMER = new season02(&quot;夏天&quot;,&quot;炎热&quot;);</span></span><br><span class="line"><span class="comment">    public final static season02 AUTUMN = new season02(&quot;秋天&quot;,&quot;凉爽&quot;);</span></span><br><span class="line"><span class="comment">    public final static season02 WINTER = new season02(&quot;冬天&quot;,&quot;寒冷&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>当我们使用enum关键字开发一个枚举类时，默认会继承Enum类</li>
<li>传统的public static final SPRING &#x3D; new season(“春天”,”温暖”);简化成SPRING(“春天”,”温暖”),这里必须知道，它调用的是哪个构造器</li>
<li>如果使用无参构造器 创建枚举对象，则实参列表和小括号都可以省略</li>
<li>当有多个枚举对象时，使用，号间隔，最后一个分号结尾</li>
<li>枚举对象必须放在枚举的行首</li>
</ol>
<h3 id="enum常用方法说明"><a href="#enum常用方法说明" class="headerlink" title="enum常用方法说明"></a>enum常用方法说明</h3><p>使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类的相关方法</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409204654918.png" alt="image-20220409204654918"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        使用season02 枚举类，演示各个方法</span></span><br><span class="line">        <span class="type">season02</span> <span class="variable">summer</span> <span class="operator">=</span> season02.SUMMER;</span><br><span class="line"><span class="comment">//        输出枚举对象的名字</span></span><br><span class="line"><span class="comment">//        summer.name();</span></span><br><span class="line">        System.out.println(summer.name());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ordinal()输出的是该枚举对象的次序/编号，按枚举的顺序从0开始编号</span></span><br><span class="line"><span class="comment">//        summer枚举对象时第二个，因此返回 1</span></span><br><span class="line">        System.out.println(summer.ordinal());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        从反编译可以看出values方法，返货season02[]</span></span><br><span class="line"><span class="comment">//        含有定义所有的枚举对象</span></span><br><span class="line">        season02[] values = season02.values();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;values.length ; i++) &#123;</span><br><span class="line">            System.out.println(values[i].name());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        增强for循环演示</span></span><br><span class="line"><span class="comment">//        每执行一次values就会扔一个对象给season、</span></span><br><span class="line"><span class="comment">//        简单来说就是依次取出数组赋给season</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========增强for=========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(season02 season:values)&#123;</span><br><span class="line">            System.out.println(season.name());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        valueOf:将字符串转换成枚举对象，要求字符串必须VT为己有的常量名，否则会报错</span></span><br><span class="line"><span class="comment">//        1.根据输入的&quot;xia&quot;到season02中的枚举对象去查找</span></span><br><span class="line"><span class="comment">//        2.如果找到了，就返回，如果没有找到就报错，如下这个例子</span></span><br><span class="line">        <span class="comment">/*season02 vaof = chapterEnum.season02.valueOf(&quot;xia&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;vaof = &quot;+ vaof);*/</span></span><br><span class="line"><span class="comment">//        3.只要valueOf()中的参数和枚举对象一致才能正常返回，如下</span></span><br><span class="line">        <span class="type">season02</span> <span class="variable">xia</span> <span class="operator">=</span> chapterEnum.season02.valueOf(<span class="string">&quot;SUMMER&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;xia = &quot;</span> +xia);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        compareTo:比较两个枚举常量，比较的是编号</span></span><br><span class="line"><span class="comment">//        就是把season02.SPRING和season02.SUMMER的编号进行比较</span></span><br><span class="line"><span class="comment">//        底层是第一个的编号减去第二的编号，</span></span><br><span class="line"><span class="comment">//        如果=0则是相等的，</span></span><br><span class="line"><span class="comment">//        如果大于1，则代表前面那个编号大于后面一个编号</span></span><br><span class="line"><span class="comment">//        如果小于1，则反之</span></span><br><span class="line">        System.out.println(season02.SPRING.compareTo(season02.SUMMER));<span class="comment">//= -1</span></span><br><span class="line">        System.out.println(season02.SPRING.compareTo(season02.WINTER));<span class="comment">//= -3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用细节-4"><a href="#使用细节-4" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li>enum修饰的类不能在继承其他父类，因为enum会隐式继承一个Enum类</li>
<li>enum实现的类，仍然是一个类，所以还是可以实现接口的</li>
</ol>
<h3 id="Switch中使用枚举"><a href="#Switch中使用枚举" class="headerlink" title="Switch中使用枚举"></a>Switch中使用枚举</h3><p>案例</p>
<ol>
<li><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410224921752.png" alt="image-20220410224921752"></p>
</li>
<li><pre><code class="java">package homeWork.Annotation;

public class AnnotationHomeWork08 &#123;
    public static void main(String[] args) &#123;
//        Color.BLACK.show();
//        Color.RED.show();
    Color red = Color.RED;
//    在小（）内放入枚举对象
//        在每个case后，直接写上枚举类，定义枚举对象即可
        switch (red)&#123;
            case RED:
                System.out.println(&quot;红色&quot;);
                break;
            case BLUE:
                System.out.println(&quot;蓝色&quot;);
                break;
            case BLACK:
                System.out.println(&quot;黑色&quot;);
                break;
            case YELLOW:
                System.out.println(&quot;黄色&quot;);
                break;
            case GREEN:
                System.out.println(&quot;绿色&quot;);
                break;
            default:
                System.out.println(&quot;没匹配到&quot;);

        &#125;
    &#125;
&#125;
interface Tint&#123;
    public void show();
&#125;
enum Color implements Tint&#123;
    RED(255,0,0),
    BLUE(0,0,255),
    BLACK(0,0,0),
    YELLOW(255,255,0),
    GREEN(0,255,0);

    private int redValue;
    private int greenValue;
    private int blueValue;

    Color(int redValue, int greenValue, int blueValue) &#123;
        this.redValue = redValue;
        this.greenValue = greenValue;
        this.blueValue = blueValue;
    &#125;

    @Override
    public void show() &#123;
        System.out.println(redValue+&quot;\t&quot;+greenValue+&quot;\t&quot;+blueValue);
    &#125;
&#125;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 注解</span><br><span class="line"></span><br><span class="line">#### 介绍</span><br><span class="line"></span><br><span class="line">1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息</span><br><span class="line">2. 和注解一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</span><br><span class="line">3. 在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等，在javase中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替javaee旧版中所遗留 的繁冗代码和xml配置等</span><br><span class="line"></span><br><span class="line">使用Annotation时，前面要加@符号，并把Annotation当成一个修饰符使用。用于修饰它支持的程序元素</span><br><span class="line"></span><br><span class="line">1. @Override：限定某个方法，是重写父类方法，该注解只能用于方法</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   class son extends father&#123;</span><br><span class="line">   //1.@Override注解方法fly方法上，表示子类fly方法重写了父类的fly</span><br><span class="line">   //2.如果这里没有写@Override ，还是重写了fly</span><br><span class="line">   //3.如果写了@Override注解，编译器就会去检查该方法是否真的重写了fly方法，</span><br><span class="line">   	如果的确重写了，则编译通过。如果没有构成重写，则编译错误</span><br><span class="line">   @Override</span><br><span class="line">   public void fly()&#123;</span><br><span class="line">    System.out.println(&quot;son fly...&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

@Override只能修饰方法，不能修饰其他类
</code></pre>
</li>
<li><p>@Deprecated：用于表示某个程序元素(类、方法等)已过时</p>
</li>
<li><p>@SuppressWarnings：抑制编译器警告</p>
<ol>
<li><p>当写一些方法时，会出现一些无关不影响运行的警告。</p>
<p>可以使用@SuppressWarnings来抑制警告信息</p>
</li>
<li><p>可以在@SuppressWarnings{“”}中写入希望抑制的警告信息</p>
</li>
<li><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410190809537.png" alt="image-20220410190809537"></p>
</li>
<li><p>位置在哪就屏蔽哪里</p>
</li>
</ol>
</li>
</ol>
<h3 id="元注解（了解）"><a href="#元注解（了解）" class="headerlink" title="元注解（了解）"></a>元注解（了解）</h3><p>@Target是修饰注解的注解，称为元注解  （了解）</p>
<p>元注解的种类（使用不多，要求看到直到是干啥的）</p>
<h4 id="1）Retention-x2F-x2F-指定注解的作用范围，三种SOURCE-CLASS-RUNTIME"><a href="#1）Retention-x2F-x2F-指定注解的作用范围，三种SOURCE-CLASS-RUNTIME" class="headerlink" title="1）Retention &#x2F;&#x2F;指定注解的作用范围，三种SOURCE,CLASS,RUNTIME"></a>1）Retention &#x2F;&#x2F;指定注解的作用范围，三种SOURCE,CLASS,RUNTIME</h4><p>说明：</p>
<p>只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，</p>
<p>@Rentention包含一个RententionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值</p>
<p>@Rentention的三种值：</p>
<p>RententionPolicy.SOURCE &#x2F;&#x2F;编译器使用后，直接丢弃这种策略的注释</p>
<p>RententionPolicy.CLASS &#x2F;&#x2F; 编译器将把注释记录在class文件中，当运行java程序时，JVM不会保留注释，这是默认值</p>
<p>RententionPolicy.RUNTIME  &#x2F;&#x2F;编译器将把注解记录在class文件中，当运行java程序时，JVM会保留注释，程序可以通过反射获取该注释</p>
<p>示意图：</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410203107921.png" alt="image-20220410203107921"></p>
<h4 id="2）Target-x2F-x2F-指定注解可以在哪些地方使用"><a href="#2）Target-x2F-x2F-指定注解可以在哪些地方使用" class="headerlink" title="2）Target     &#x2F;&#x2F;指定注解可以在哪些地方使用"></a>2）Target     &#x2F;&#x2F;指定注解可以在哪些地方使用</h4><p>用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素</p>
<p>简单来说就是在哪些元素上使用</p>
<p>@Target   也包含一个名为value的成员变量	</p>
<p>Target(value &#x3D; CONSTRUCTOR（构造器）, FIELD（field） , LOACL_VARIABLE（局部变量）, METHOD（方法）,PACKAGE（包）,PARAMETER ,TYPE )</p>
<h4 id="3）Documented-x2F-x2F-指定该注解是否会在javadoc中体现"><a href="#3）Documented-x2F-x2F-指定该注解是否会在javadoc中体现" class="headerlink" title="3）Documented    &#x2F;&#x2F;指定该注解是否会在javadoc中体现"></a>3）Documented    &#x2F;&#x2F;指定该注解是否会在javadoc中体现</h4><p>@Documented   用于指定该元注解修饰的Annotation类将被Javadoc 工具提取成文档，即在生成文档时，可以看到注解</p>
<p>定义Documented  注解必须设置Retention 值为RUNTIME</p>
<h4 id="4）Inherited-x2F-x2F-子类会继承父类注解"><a href="#4）Inherited-x2F-x2F-子类会继承父类注解" class="headerlink" title="4）Inherited    &#x2F;&#x2F;子类会继承父类注解"></a>4）Inherited    &#x2F;&#x2F;子类会继承父类注解</h4><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p>java语言中，将程序执行中发生的不正常情况成为“异常”。（开发过程中的语法错误和逻辑错误不属于异常）</p>
<p>执行过程中所发生的异常事件可分为两类</p>
<ol>
<li>Error（错误）：java虚拟机无法解决的严重问题。例如：JVM系统内部错误，资源耗尽等严重情况。例：StackOverflowError[栈溢出]和OOM（out of memory),Error是严重错误，程序会崩溃。</li>
<li>Exception：因为，其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对想的代码进行处理，例如空指针访问，视图读取不存在的文件，网络连接中断等等，Exception分为两大类，运行时异常[程序运行发生的异常]和编译时异常[编译时，编译器查出的异常]</li>
</ol>
<h2 id="异常体系图（重要）"><a href="#异常体系图（重要）" class="headerlink" title="异常体系图（重要）"></a>异常体系图（重要）</h2><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411214601035.png" alt="image-20220411214601035"></p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411215335526.png" alt="image-20220411215335526"></p>
<p>小结：</p>
<ol>
<li><p>异常分为两大类，运行时异常和编译时异常</p>
</li>
<li><p>运行时异常，编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该避免出现的异常。java.lang.RuntimeException类及它的子类都是运行程序</p>
</li>
<li><p>对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影像</p>
</li>
<li><p>编译时异常，是编译器要求必须处置的异常</p>
</li>
</ol>
<h2 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h2><h3 id="常见的运行异常"><a href="#常见的运行异常" class="headerlink" title="常见的运行异常"></a>常见的运行异常</h3><h4 id="1）NullPoniterException-空指针异常"><a href="#1）NullPoniterException-空指针异常" class="headerlink" title="1）NullPoniterException 空指针异常"></a>1）NullPoniterException 空指针异常</h4><ol>
<li>当程序试图在需要对象的地方使用 null时，抛出该异常</li>
</ol>
<h4 id="2-ArithmeticException数字运算异常"><a href="#2-ArithmeticException数字运算异常" class="headerlink" title="2 ) ArithmeticException	数字运算异常"></a>2 ) ArithmeticException	数字运算异常</h4><ol>
<li>当出现异常的运行条件时，抛出此异常</li>
<li>例如 一个整数”除以零”时，抛出此类的一个实例</li>
</ol>
<h4 id="3）ArrayIndexOutOfBoundsException数组下标异常"><a href="#3）ArrayIndexOutOfBoundsException数组下标异常" class="headerlink" title="3）ArrayIndexOutOfBoundsException	数组下标异常"></a>3）ArrayIndexOutOfBoundsException	数组下标异常</h4><ol>
<li>用非法索引访问数组时抛出的异常，如果索引为负或者大于等于数组大小，则该索引为非法索引</li>
</ol>
<h4 id="4）ClassCastException类型转换异常"><a href="#4）ClassCastException类型转换异常" class="headerlink" title="4）ClassCastException	类型转换异常"></a>4）ClassCastException	类型转换异常</h4><ol>
<li>当试图将对象强制转换为不是实例的子类时，抛出该异常</li>
</ol>
<h4 id="5）NumberFormatException数字格式不正确异常"><a href="#5）NumberFormatException数字格式不正确异常" class="headerlink" title="5）NumberFormatException	数字格式不正确异常[]"></a>5）NumberFormatException	数字格式不正确异常[]</h4><ol>
<li>当应用程序试图将字符串转换成一种数值类型，但该字符不能转换为适当格式时，抛出该异常</li>
<li>使用该异常我们可以确保输入的是满足条件的数字</li>
</ol>
<h3 id="常见的编译异常"><a href="#常见的编译异常" class="headerlink" title="常见的编译异常"></a>常见的编译异常</h3><h4 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h4><p>编译异常是指在编译期间。就必须处理的异常，否则代码不能通过编译</p>
<h4 id="常见的编译异常-1"><a href="#常见的编译异常-1" class="headerlink" title="常见的编译异常"></a>常见的编译异常</h4><ol>
<li>SQLException	&#x2F;&#x2F;操作数据库时，查询表可能发生的异常</li>
<li>IOException		&#x2F;&#x2F;操作文件时，发生的异常</li>
<li>FileNotFoundException	&#x2F;&#x2F;当操作一个不存在的文件时，发生异常</li>
<li>ClassNotFoundException	&#x2F;&#x2F;加载类，该类不存在时，异常</li>
<li>EOFException		&#x2F;&#x2F;操作文件，到文件末尾，发生异常</li>
<li>IIIegalArguementException	&#x2F;&#x2F;参数异常</li>
</ol>
<h2 id="异常处理概念"><a href="#异常处理概念" class="headerlink" title="异常处理概念"></a>异常处理概念</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>异常处理就是当异常发生时，对异常处理的方式</p>
<h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><h4 id="1）try-catch-finally"><a href="#1）try-catch-finally" class="headerlink" title="1）try-catch-finally"></a>1）try-catch-finally</h4><p>程序员在代码中捕获发生的异常，自行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	代码/可能有异常</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="comment">//捕获的异常，传给e</span></span><br><span class="line"><span class="comment">//1.当异常发生时</span></span><br><span class="line"><span class="comment">//2.系统将异常封装成Exception对象e，传递给catch</span></span><br><span class="line"><span class="comment">//3.得到异常对象后，程序员自己处理</span></span><br><span class="line"><span class="comment">//4.如果没有发生异常，则catch代码块不执行</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管try代码块是否有异常发生，始终都要执行finally</span></span><br><span class="line">    <span class="comment">//通常将释放资源的代码方法finally代码块中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2）throws"><a href="#2）throws" class="headerlink" title="2）throws"></a>2）throws</h4><p>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p>
<h5 id="处理机制图"><a href="#处理机制图" class="headerlink" title="处理机制图"></a>处理机制图</h5><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411224543192.png" alt="image-20220411224543192"></p>
<p>throws处理机制</p>
<ol>
<li>try-catch-finally和throws二选一</li>
<li>如果程序员，没有显示是处理异常，默认throws</li>
</ol>
<h2 id="异常处理分类"><a href="#异常处理分类" class="headerlink" title="异常处理分类"></a>异常处理分类</h2><h3 id="try-catch方式处理异常说明"><a href="#try-catch方式处理异常说明" class="headerlink" title="try-catch方式处理异常说明"></a>try-catch方式处理异常说明</h3><h4 id="1）java提供try和catch块来处理异常。"><a href="#1）java提供try和catch块来处理异常。" class="headerlink" title="1）java提供try和catch块来处理异常。"></a>1）java提供try和catch块来处理异常。</h4><p>try块用于包含可能出错的代码块。catch用于处理try块中发生的异常，可以根据需要在程序中有多个数量的try…catch块</p>
<h4 id="2）基本语法"><a href="#2）基本语法" class="headerlink" title="2）基本语法"></a>2）基本语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可疑代码</span></span><br><span class="line"><span class="comment">//将异常生成对应的异常对象，传递给catch块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常)&#123;</span><br><span class="line"><span class="comment">//对异常的处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有finally是可以通过的</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用案例</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;糖&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span>  <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">System.out.println(<span class="string">&quot;数字=&quot;</span>+a);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;异常信息=&quot;</span>+e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块</p>
</li>
<li><p>如果异常没有发生，则顺序执行try代码块，不会进入到catch块</p>
</li>
<li><p>如果希望不管是否能发生异常，都执行某段代码块（比如关闭链接，释放资源等）、</p>
</li>
<li><p>可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求是父类异异常在后，子类异常在前，比如（Exception 在后，NullPointerException 在前）如果发生异常，只会匹配一个catch</p>
<ol>
<li><p>&#96;&#96;&#96;java<br>例:<br>try{</p>
<p>}catch(NullPointerException e){</p>
<p>}catch(Exception e){</p>
<p>}finally{</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 可以记性try-finally配合使用，这种方法相当于没有捕获异常，因此程序会直接崩掉</span><br><span class="line"></span><br><span class="line">   1. 应用场景：就是执行一段代码，不论是否发生异常，都必须执行某个业务逻辑</span><br><span class="line"></span><br><span class="line">#### 小结</span><br><span class="line"></span><br><span class="line">1. 如果没有出现异常，则执行try块中所有语句，不执行catch块中的语句，如果有finally，最后还要执行finally语句</span><br><span class="line">2. 如果出现异常，则try块异常发生后，剩下的语句不在执行，将执行catch块中的语句，如果有finally，最后还要执行finally里面的语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### throws异常处理</span><br><span class="line"></span><br><span class="line">#### 介绍：</span><br><span class="line"></span><br><span class="line">1）如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理异常，则此方法应显示的声明抛出异常，表明该方法将不对这些异常进行处理，而且由该方法的调用者负责处理</span><br><span class="line"></span><br><span class="line">2）在方法声明throws语句可以声明排除异常的列表，throws后面的异常类型可以是方法产生的异常类型，也可以是它的父类</span><br><span class="line"></span><br><span class="line">#### 注意事项</span><br><span class="line"></span><br><span class="line">1. 对于编译异常，程 序必须处理，比如try-catch或者throws</span><br><span class="line">2. 对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</span><br><span class="line">3. 子类重写父类的方法是，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一直，要么为父类抛出的异常的类型和子类型</span><br><span class="line">4. 在throws过程中，如果有try-catch，就相当于处理异常，就可以不必throws</span><br><span class="line">5. ![image-20220412135104986](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412135104986.png)</span><br><span class="line">6. </span><br><span class="line"></span><br><span class="line">## 自定义异常  </span><br><span class="line"></span><br><span class="line">### 介绍：</span><br><span class="line"></span><br><span class="line">当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述错误信息。</span><br><span class="line"></span><br><span class="line">### 自定义异常的步骤</span><br><span class="line"></span><br><span class="line">1. 定义类：自定义异常类名（程序员自己写）继承Exceotion或RuntimeException</span><br><span class="line">2. 如果继承Ecxeption，属于编译异常</span><br><span class="line">3. 如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//当我们接受Person对象年龄时，要求范围在18-120之间，否则抛出一个自定义异常（要求继承RuntimeException），并提示</span><br><span class="line">public class CustomException &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age =30;</span><br><span class="line">//        结果取反</span><br><span class="line">        if (!(age&gt;=18&amp;&amp;age&lt;=120))&#123;</span><br><span class="line">//            通过构造器设置输出信息</span><br><span class="line">            throw new AgeException(&quot;年龄需要在18-120之间&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;你的年龄为&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//定义一个异常类继承RuntimeException</span><br><span class="line">//一般情况下，我们自定义异常都继承RuntimeException</span><br><span class="line">//也就是说大都是定义为运行时异常，好处是我们可以使用默认处理机制</span><br><span class="line">//即比较方便</span><br><span class="line">class AgeException extends RuntimeException&#123;</span><br><span class="line">//    定义一个构造器</span><br><span class="line">    public AgeException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="throw和throws的对比"><a href="#throw和throws的对比" class="headerlink" title="throw和throws的对比"></a>throw和throws的对比</h2><table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th align="center">后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td align="center">异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常对象的关键字</td>
<td>方法体中</td>
<td align="center">异常对象</td>
</tr>
</tbody></table>
<p>throws</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//throws通常放在定义方法的末尾</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>throw</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//throw后面跟的是异常对象</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在18-120之间&quot;</span>);</span><br></pre></td></tr></table></figure>



<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="包装类的分类-Wrapper"><a href="#包装类的分类-Wrapper" class="headerlink" title="包装类的分类   Wrapper"></a>包装类的分类   Wrapper</h3><p>1、针对八种基本数据类型相应类型的引用类型—包装类</p>
<p>2、有了类的特点，就可以调用类中的方法</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center"><code>Byte</code></td>
</tr>
<tr>
<td align="center">short</td>
<td align="center"><code>Short</code></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center"><code>Integer</code></td>
</tr>
<tr>
<td align="center">long</td>
<td align="center"><code>Long</code></td>
</tr>
<tr>
<td align="center">float</td>
<td align="center"><code>Float</code></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center"><code>Doble</code></td>
</tr>
</tbody></table>
<p>上述标出来的6个数据类型父类均为Number</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412164154544.png" alt="image-20220412164154544"></p>
<h3 id="包装类和基本数据的转换"><a href="#包装类和基本数据的转换" class="headerlink" title="包装类和基本数据的转换"></a>包装类和基本数据的转换</h3><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>演示包装类和基本数据类型的相互转换，以int和integer演示</p>
<p>1）jdk5前的手动装箱和拆箱方式，装箱：基本类型-&gt;包装类型,反之拆箱</p>
<p>2）jdk5以后（包括jdk5）的自动装箱和拆箱方式</p>
<p>3）自动装箱底层调用的是valueOf方法，比如integer.valueOf();</p>
<p>4）其他类型同理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本类型——————&gt;包装类型[手动装箱]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"><span class="type">integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.value(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//包装类型————————&gt;基本类型[手动拆箱]</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> j.intValue();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jdk5.0之后的方式</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">m2</span> <span class="operator">=</span>m;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> n;</span><br><span class="line">System.out.println(<span class="string">&quot;n+100&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;n*2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">10</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包装类型和String类型的相互转换"><a href="#包装类型和String类型的相互转换" class="headerlink" title="包装类型和String类型的相互转换"></a>包装类型和String类型的相互转换</h3><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><p>以integer和String转为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类型----&gt;String类型</span></span><br><span class="line"><span class="type">integer</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> i.toString();</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> i+<span class="string">&quot;&quot;</span>; </span><br><span class="line">System.out.println(s3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String ---&gt;包装类</span></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Integer</span>(s1);</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">j2</span> <span class="operator">=</span> Integer.valueOf(s2);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Integer.parseInt(s3);</span><br></pre></td></tr></table></figure>

<h3 id="Integer类和Character类常方法"><a href="#Integer类和Character类常方法" class="headerlink" title="Integer类和Character类常方法"></a>Integer类和Character类常方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Integer.MIN_VALUE <span class="comment">//返回最小值</span></span><br><span class="line">Integer.MAX_VALUE <span class="comment">//返回最大值</span></span><br><span class="line"></span><br><span class="line">Character.isDigit(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//判断是不是数字</span></span><br><span class="line">Character.isLetter(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//判断是不是字母</span></span><br><span class="line">Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//判断是不是大写</span></span><br><span class="line">Character.inLowerCase(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//判断是不是小写</span></span><br><span class="line"></span><br><span class="line">Character.isWhitespace(<span class="string">&#x27;a&#x27;</span>)；<span class="comment">//判断是不是空格</span></span><br><span class="line">Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//转成大写</span></span><br><span class="line">Character.toLowerCase(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//转成小写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Integer面试题"><a href="#Integer面试题" class="headerlink" title="Integer面试题"></a>Integer面试题</h3><p>1.看代码输出什么，为啥</p>
<ol>
<li><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164815801.png" alt="image-20220413164815801"></p>
</li>
<li><p>因为integer的原码定义好了从-128-127之间不返回一个对象</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164729185.png" alt="image-20220413164729185"></p>
<p>2.integer面试题总结</p>
<p>看下列代码输出什么结果</p>
<p><span style="color:red;background:yellow " >只要有基本数据类型会自动拆箱，比对的是数值。判断的是值是否相等</span></p>
<p>如下的示例六和七，比对的是</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413205739995.png" alt="image-20220413205739995"></p>
</li>
</ol>
<h2 id="String-重要"><a href="#String-重要" class="headerlink" title="String(重要)"></a>String(重要)</h2><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413213320195.png" alt="image-20220413213320195"></p>
<p>String实现了三个接口并继承了Object类</p>
<ul>
<li>Serializable接口：说明String可以串行化。（可以在网络传输）</li>
<li>Comparable接口：说明String对象可以相互比较</li>
<li>CharSequence接口：字符序列</li>
</ul>
<p><span style="color:blue;background:pink">String类是final类，String类不能被其他类继承</span></p>
<p><span style="color:blue;background:pink">String 有属性，private final char value[];用于存放字符串内容（字符串的本质就是char数组）</span></p>
<p><span style="color:red;background:pink">(注意：value是一个final类型，不可修改（即：value不能指向新的地址，但是单个字符内容时可以变化的）)</span></p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>1）String对象用于保存字符串，也就是一组字符序列</p>
<p>2）字符串常量对象时用双引号括起来的字符序列。例如：”你好”，”21.213”，”boy”等等</p>
<p>3）字符串的字符使用Unicode字符编码，一个字符（不区分字幕还是汉字）占两个字节</p>
<p>4）String类较常用的构造方法（其他手册）</p>
<ul>
<li>String s1 &#x3D; new String();</li>
<li>String s2 &#x3D; new String(String original);</li>
<li>String s3 &#x3D; new String(char[] a);</li>
<li>String s4 &#x3D; new String(char[] a,int startIndex, int count)</li>
</ul>
<h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><h4 id="1）方式一：直接赋值String-s-x3D-“xxx”"><a href="#1）方式一：直接赋值String-s-x3D-“xxx”" class="headerlink" title="1）方式一：直接赋值String s &#x3D; “xxx”;"></a>1）方式一：直接赋值String s &#x3D; “xxx”;</h4><p>创建流程：</p>
<p>先从常量池查看是否有”xxx”数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</p>
<h4 id="2）方式二：调用构造器-String-s-x3D-new-String-“xxx”-；"><a href="#2）方式二：调用构造器-String-s-x3D-new-String-“xxx”-；" class="headerlink" title="2）方式二：调用构造器 String s &#x3D; new String(“xxx”)；"></a>2）方式二：调用构造器 String s &#x3D; new String(“xxx”)；</h4><p>流程：现在堆中创建空间，里面维护了value属性，指向常量池的xxx空间。如果常量池没有”xxx”，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414101904944.png" alt="image-20220414101904944"></p>
<h3 id="String字符串的特性"><a href="#String字符串的特性" class="headerlink" title="String字符串的特性"></a>String字符串的特性</h3><p>1）String是一个final类，代表不可变的字符序列</p>
<p>2）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的 </p>
<h4 id="面试题、"><a href="#面试题、" class="headerlink" title="面试题、"></a>面试题、</h4><p>1）String a &#x3D; “hello”+”abc”;创建了几个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编译器会在后台会进行优化，判断创建的常量池对象，是否有引用指向</span><br><span class="line">优化等价于<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;helloabc&quot;</span>；</span><br><span class="line"></span><br><span class="line">所以答案是创建了一个对象</span><br><span class="line">不是创建了三个</span><br></pre></td></tr></table></figure>

<p>2）String a &#x3D; “hello”;</p>
<p>String b &#x3D; “abc”;</p>
<p>String c &#x3D; a+b;</p>
<p>总共创建了几个对象</p>
<p>所以只创建了一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行流程</span><br><span class="line"><span class="number">1.</span> 先创建了一个<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> StringBuilder();</span><br><span class="line"><span class="number">2.</span>执行sb.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="number">3.</span>sb.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="number">4.</span><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">最后其实是c指向了堆中的对象（String）value[],堆中的对象指向了池中的“helloabc”</span><br></pre></td></tr></table></figure>

<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414140922725.png" alt="image-20220414140922725"></p>
<p>小结:底层是StringBuilder sb &#x3D; new StringBuilder();sb.append(a);sb.append(b);sb是在堆中，并append是在原来的字符串的基础上追加的。</p>
<p>重要规则：String c1 &#x3D; “sb”+”cd”;常量相加，看的是池。String c1 &#x3D; a+b;变量相加，是在堆中</p>
<h3 id="String类的常见方法"><a href="#String类的常见方法" class="headerlink" title="String类的常见方法"></a>String类的常见方法</h3><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>​	String类是保存字符串常量的。每次更新都需要重新开辟空间，效率低，因此java设计者还提供StringBuilder和StringBuffer来增强String的功能，并提高效率。</p>
<h4 id="Strng常见的方法"><a href="#Strng常见的方法" class="headerlink" title="Strng常见的方法"></a>Strng常见的方法</h4><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414145929644.png" alt="image-20220414145929644"></p>
<ul>
<li><p>equals		&#x2F;&#x2F;区分大小写，判断是否相等</p>
</li>
<li><p>equalsIgnoreCase   &#x2F;&#x2F;忽略大小写，判断内容是否相等</p>
</li>
<li><p>length  &#x2F;&#x2F;获取字符的个数，字符窜长度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </p>
</li>
<li><p>indexOf  &#x2F;&#x2F;获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到返回-1</p>
</li>
<li><p>lastIndexOf   &#x2F;&#x2F;获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，返回-1</p>
</li>
<li><p>substring &#x2F;&#x2F;截取指定范围字符串</p>
</li>
<li><p>trim  &#x2F;&#x2F;去前后空格</p>
</li>
<li><p>charAt &#x2F;&#x2F;获取某索引处的字符，之一不能使用Str[index]这种方式</p>
</li>
<li><p>toUpperCase  &#x2F;&#x2F;字符串转换成大写</p>
</li>
<li><p>toLowerCase  &#x2F;&#x2F;字符串转换成小写</p>
</li>
<li><p>concat  &#x2F;&#x2F;拼接字符串</p>
</li>
<li><p>replace  替换字符串中字符</p>
</li>
<li><p>split 分割字符串，罪域某些分割字符，我们需要转义</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">poem</span> <span class="operator">=</span><span class="string">&quot;锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦&quot;</span>;</span><br><span class="line">String[] split = poem.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//以，号为标准，分割上述整个字符串</span></span><br><span class="line"><span class="comment">//上述字符串被分割为4个部分用数组接收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆字符串进行分割时，如f</span></span><br><span class="line">poem = <span class="string">&quot;E:\\aaa\\bbb&quot;</span>;</span><br><span class="line">split  = poem.split(<span class="string">&quot;\\\\&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>和 文件路径</p>
</li>
<li><p>compareTo &#x2F;&#x2F;比较两个字符串的大小，如果前者大则返回正数，如果后者大则返回负数，</p>
<p>如果相等（</p>
<p>1.如果长度相同，并且字符串也相同返回0。</p>
<p>2.如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回if(c1 !&#x3D; c2）{</p>
<p>​		return c1 - c2;</p>
<p>}</p>
<p>3.如果前面的部分都相同，就返回str1.len - str2.len）</p>
</li>
<li><p>toCharArray &#x2F;&#x2F;字符串转成字符数组</p>
</li>
<li><p>format&#x2F;&#x2F;格式化字符串，%s字符串，%c字符，%d 整型，%.2f 浮点型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  %s%d%.2f%c成为占位符</span></span><br><span class="line"><span class="comment">//  这些占位符由后面的变量来替换</span></span><br><span class="line"><span class="comment">//  %s表示后面由字符串替换</span></span><br><span class="line"><span class="comment">//  %d表示整数替换</span></span><br><span class="line"><span class="comment">//  %.2f表示使用小数来替换，替换后，只会保留小数两位，并且会进行四舍五入的处理</span></span><br><span class="line"><span class="comment">//  %c是char类型替换</span></span><br><span class="line">    </span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;jack&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">98.3</span> /<span class="number">3</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统方法拼接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;名字是&quot;</span>+name+<span class="string">&quot;年龄是&quot;</span>+age+<span class="string">&quot;成绩是&quot;</span>+score+<span class="string">&quot;性别：&quot;</span>+gender<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//使用format拼接</span></span><br><span class="line"><span class="string">String info2 =String.format(&quot;</span>姓名是%s年龄是%d成绩是%d性别时%c<span class="string">&quot;,name,age,score,gender);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//可以做成一个模板后面直接调用</span></span><br><span class="line"><span class="string">String formatstr = &quot;</span>姓名是%s年龄是%d成绩是%d性别时%c<span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">String info2 =String.format(formatstr,name,age,score,gender);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">System.out.println(&quot;</span>info2 =<span class="string">&quot;+info2);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="StringBuffer-重要"><a href="#StringBuffer-重要" class="headerlink" title="StringBuffer(重要)"></a>StringBuffer(重要)</h2><p><span style="color:red;background:pink">串行化（对象可以网络传输，可以保存到文件）</span></p>
<h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>java.lang.StringBuffer代表可变字符序列，可以对字符串内容进行增删</p>
<p>很多方法与String相同，但StringBuffer是可变长度的</p>
<p>StringBuffer是一个容器</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415090614911.png" alt="image-20220415090614911"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//1.StringBuffer 的直接父类是 AbstractStringBuilder</span></span><br><span class="line"><span class="comment">//2.StringBuffer 实现了Serializable，即StringBuffer的对象可以串行化</span></span><br><span class="line"><span class="comment">//3.在父类中，AbstractStringBuilder 有属性 char[] value ，不是final</span></span><br><span class="line">	该value 数组存放祖父穿内容，因数存放在堆中的</span><br><span class="line"><span class="comment">//4.StringBuffer是一个final类， 不能被继承</span></span><br></pre></td></tr></table></figure>

<h3 id="String-对比StringBuffer"><a href="#String-对比StringBuffer" class="headerlink" title="String 对比StringBuffer"></a>String 对比StringBuffer</h3><p>1）String保存的是字符串常量，里面的值不能更改，每次String类的更新实际是更改地址，效率较低&#x2F;&#x2F;private final char value[]；</p>
<p>2）StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用更新地址，效率较高&#x2F;&#x2F;char[] value &#x2F;&#x2F;这个放在堆</p>
<h3 id="StringBuffer构造器"><a href="#StringBuffer构造器" class="headerlink" title="StringBuffer构造器"></a>StringBuffer构造器</h3><p>StringBuffer()</p>
<ul>
<li><p>构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符</p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;创建一个大小为16的char[]，用于存放字符串内容<br>StringBuffer stringBuffer &#x3D; new StringBuffer();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">StringBuffer(CharSequence seq)</span><br><span class="line"></span><br><span class="line">* public java.lang.StringBuffer(CharSequence seq)构造一个字符串缓冲区，它包含与指定的CharSequence 相同的字符</span><br><span class="line"></span><br><span class="line">StringBuffer(int capacity)//capacity[容量]</span><br><span class="line"></span><br><span class="line">* 构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对char[]大小进行指定</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  //通过构造器指定 char[]大小</span><br><span class="line">  StringBuffer stringBuffer = new StringBuffer(100);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>StringBuffer(String str)</p>
<ul>
<li><p>构造一个字符串缓冲器，并将其内容初始化为指定的字符串内容</p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;通过给一个String 创建StringBuffer,char[] 大小就是str.length()+16<br>StringBuffer stringBuffer &#x3D; new StringBuffer(“hello”);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### String和StringBuffer</span><br><span class="line"></span><br><span class="line">#### String-&gt;StringBuffer</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//        String-&gt;StringBuffer</span><br><span class="line">//        方式一</span><br><span class="line">        String str =&quot;xxx&quot;;</span><br><span class="line">//        注意：返回的是StringBuffer对象，对str本身是没有影响的</span><br><span class="line">        StringBuffer stringBuffer = new StringBuffer(str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//        方式二，使用append方法</span><br><span class="line">        StringBuffer stringBuffer1 = new StringBuffer();</span><br><span class="line">        stringBuffer1 = stringBuffer1.append(str);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="StringBuffer-gt-String"><a href="#StringBuffer-gt-String" class="headerlink" title="StringBuffer-&gt;String"></a>StringBuffer-&gt;String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//        StringBuffer-&gt;String</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;xxxxxx&quot;</span>);</span><br><span class="line"><span class="comment">//        方式一,使用StringBuffer提供的 toString方法;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuffer2.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        方式二,使用构造器搞定</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringBuffer2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="StirngBuffer类常见方法"><a href="#StirngBuffer类常见方法" class="headerlink" title="StirngBuffer类常见方法"></a>StirngBuffer类常见方法</h3><ol>
<li>增 append</li>
<li>删 delete(start,end)</li>
<li>改 replace(start,end,string)&#x2F;&#x2F;将start—end间的内容替换掉，不含end</li>
<li>查 indexOf &#x2F;&#x2F;查询字符串第1次出现的索引，如果找不回返回-1</li>
<li>插 insert</li>
<li>获取长度 length</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">       <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stringBuffer.append(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;wangwu&quot;</span>).append(<span class="literal">true</span>).append(<span class="number">10.2</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        删除</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span></span><br><span class="line"><span class="comment">        * 解读：删除11~14的字符[11,14)</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        stringBuffer.delete(<span class="number">11</span>,<span class="number">14</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    改</span></span><br><span class="line"><span class="comment">//        修改本质就是替换</span></span><br><span class="line"><span class="comment">//        使用fff替换索引11-14的字符</span></span><br><span class="line">        stringBuffer.replace(<span class="number">11</span>,<span class="number">14</span>,<span class="string">&quot;fff&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        查</span></span><br><span class="line"><span class="comment">//        查找指定的子串在字符串出现的索引.如果找不到返回-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stringBuffer.indexOf(<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        插入</span></span><br><span class="line"><span class="comment">//        指定一个位置插入</span></span><br><span class="line"><span class="comment">//        在索引为9的位置插入&quot;老王&quot;，原来索引为9的内容自动后移</span></span><br><span class="line">        stringBuffer.insert(<span class="number">9</span>,<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取长度</span></span><br><span class="line">        System.out.println(stringBuffer.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输入商品名称和商品价格，要求打印效果示例，实用前面学习的方法完成</span></span><br><span class="line"><span class="comment">         * 商品名  商品价格</span></span><br><span class="line"><span class="comment">         * 手机123，456.56  //比如 价格价格1,456,786.5</span></span><br><span class="line"><span class="comment">         * 要求：价格的小数点前面每三位用,号隔开，再输出</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        String prices;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">price</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(price);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        先完成最简单的实现21,312,412.32</span></span><br><span class="line"><span class="comment">//        找到小数点的索引,然后再该位置的前三位插入,</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> stringBuffer.lastIndexOf(<span class="string">&quot;.&quot;</span>)-<span class="number">3</span>; j &gt;<span class="number">0</span> ; j-=<span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">            stringBuffer = stringBuffer.insert(j, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(stringBuffer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="StringBuilder-重要"><a href="#StringBuilder-重要" class="headerlink" title="StringBuilder(重要)"></a>StringBuilder(重要)</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>1）一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder 不是线程安全)。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快（单线程的情况下，优先使用StringBuilder）</p>
<p>2）在StringBuilder上主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据</p>
<h3 id="StringBuilder常用方法"><a href="#StringBuilder常用方法" class="headerlink" title="StringBuilder常用方法"></a>StringBuilder常用方法</h3><p>StringBuilder和StringBuffer均代表可变字符序列，方法是一样的，所以使用和StringBuffer一样。</p>
<ol>
<li>StringBuilder是final类，不能被继承</li>
<li>StringBuilder对象可以串行化</li>
<li>继承了AbstractStringBuilder属性 char[] value，内容存到value</li>
<li>实现了Serializable接口，序列化（所谓系列化既可以保存类型和数据本身）</li>
</ol>
<h2 id="String、StringBuffer、StringBuilder的比较☆"><a href="#String、StringBuffer、StringBuilder的比较☆" class="headerlink" title="String、StringBuffer、StringBuilder的比较☆"></a>String、StringBuffer、StringBuilder的比较☆</h2><p>1）StringBuilder和StringBuffer非常类似，均代表可变字符序列，而且方法也一样</p>
<p>2）String：不可变字符序列，效率低，但是复用率高。</p>
<p>3）StringBuffer：可变字符序列、效率较高（增删）、线程安全</p>
<p>4）StringBuilder：可变字符序列、效率最高、线程不安全</p>
<p>5）String使用注意事项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;a&quot;</span>; <span class="comment">//创建了一个字符串</span></span><br><span class="line">s+= <span class="string">&quot;b&quot;</span>;   <span class="comment">//实际上原来的&quot;a&quot;字符串对象已经丢弃了，现在又产生了一个转字符串s+&quot;b&quot;（也就是&quot;ab&quot;).如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=》</span></span><br><span class="line"><span class="comment">//结论：如果我们对Stirng做大量修改，不要使用String</span></span><br></pre></td></tr></table></figure>

<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>StringBuilder  &gt; StringBuffer &gt;String </p>
<h3 id="使用原则，结论"><a href="#使用原则，结论" class="headerlink" title="使用原则，结论"></a>使用原则，结论</h3><ol>
<li>如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder</li>
<li>如果字符串存在大量的修改操作，并且在单线程的情况下使用StringBuilder</li>
<li>如果字符串存在大量的修改操作，并且在多线程的情况下使用StringBuffer</li>
<li>如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等</li>
</ol>
<p>StringBuffer和StringBuilder的方法使用一样</p>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Math类包含用于执行基本数学运算方法，如初等指数，对数，平方根和三角函数</p>
<p>方法一览（均为静态方法）<img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415145338171.png" alt="image-20220415145338171"></p>
<h3 id="Match常用的方法"><a href="#Match常用的方法" class="headerlink" title="Match常用的方法"></a>Match常用的方法</h3><ol>
<li><p>abs  绝对值</p>
</li>
<li><p>pow  求幂</p>
</li>
<li><p>ceil   向上取整  (返回&gt;&#x3D;该参数的最小整数)</p>
</li>
<li><p>floor   向下取整  (返回&lt;&#x3D;该参数的最大整数)</p>
</li>
<li><p>round   四舍五入</p>
</li>
<li><p>sqrt  求开方</p>
</li>
<li><p>random  求随机数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        random随机数</span></span><br><span class="line"><span class="comment">        random默认返回 0&lt;= x &lt;1之间的一个随机小数</span></span><br><span class="line"><span class="comment">        请写出a-b之间的一个随机整数，a,b均为整数比如a=2,b=7</span></span><br><span class="line"><span class="comment">        即返回一个2 - 7 之间的随机数</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * random返回的是0&lt;=x &lt;1之间的一个随机小数</span></span><br><span class="line"><span class="comment">         * Math.random()*(b-a)返回的就是0&lt;= 数 &lt;=b-a</span></span><br><span class="line"><span class="comment">         * (1)(int)(a)&lt;= x &lt;(int)(a+Math.random() * (b-a +1))</span></span><br><span class="line"><span class="comment">        * (2)集体使用解析</span></span><br><span class="line"><span class="comment">         * (int)(a+Math.random() * (b-a +1))</span></span><br><span class="line"><span class="comment">         *  = (int)(2+Math.random() * 6)</span></span><br><span class="line"><span class="comment">         *  Math.random() * 6返回的就是0&lt;= x &lt;6小数</span></span><br><span class="line"><span class="comment">         *  2+Math.random() * 6返回的就是2&lt;= x &lt;8小数</span></span><br><span class="line"><span class="comment">         *  (int)(2+Math.random() * 6) = 2 &lt;=x &lt;=7</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      公式就是：(int)(a+Math.random() * (b-a +1))</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println((<span class="type">int</span>) (<span class="number">2</span> +Math.random()*(<span class="number">7</span>-<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>max   求两个数的最大值</p>
</li>
<li><p>min    求两个数的最小值</p>
</li>
</ol>
<h2 id="Date-Calender-LoaclDate"><a href="#Date-Calender-LoaclDate" class="headerlink" title="Date,Calender,LoaclDate."></a>Date,Calender,LoaclDate.</h2><h3 id="Date-知道怎么查，怎么用即可"><a href="#Date-知道怎么查，怎么用即可" class="headerlink" title="Date[知道怎么查，怎么用即可]"></a>Date[知道怎么查，怎么用即可]</h3><h4 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h4><p>Date：精确到毫秒，代表特定的瞬间</p>
<p>SimpleDateFormat：格式和解析日期的类SimpleDateFormat 格式化和解析日期的具体类。它允许进行格式（日期-&gt;文本、解析（文本-&gt;日期）和规范化</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420110144786.png" alt="image-20220420110144786"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line"><span class="comment">//默认输出的格式是国外的格式</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();、</span><br><span class="line"><span class="comment">//因此需要对格式进行转换</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="comment">//其他格式的字母意思，查看手册</span></span><br><span class="line"><span class="type">String</span> <span class="variable">foramt</span> <span class="operator">=</span> d1.format(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取某个时间对应的毫秒数</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">23123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以吧一个格式化的字符串转成对应的date</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2000年7月五日 20:12:20 星期一&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">pares</span> <span class="operator">=</span> simpleDateFormat.parse(s);</span><br><span class="line"><span class="comment">//接收的格式必须个定义的格式一样</span></span><br></pre></td></tr></table></figure>

<h3 id="Calendar-日历"><a href="#Calendar-日历" class="headerlink" title="Calendar(日历)"></a>Calendar(日历)</h3><h4 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h4><p>主要就是Calendar类（日历）</p>
<p>1）public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable&lt;Calendar</p>
<p>2)calendar类是一个抽象类，他为特定瞬间为一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等，日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建日历对象，</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span>Calendar.getInstance();</span><br><span class="line">System.out.print(<span class="string">&quot;年&quot;</span>+c.get(Calendar.YEAR))；</span><br><span class="line">System.out.print(<span class="string">&quot;月&quot;</span>+c.get(Calendar.MONTH)+<span class="number">1</span>)；</span><br><span class="line">System.out.print(<span class="string">&quot;日&quot;</span>+c.get(Calendar.DAY_OF_MONTH))；</span><br><span class="line">System.out.print(<span class="string">&quot;小时&quot;</span>+c.get(Calendar.HOUR))；</span><br><span class="line">System.out.print(<span class="string">&quot;分钟&quot;</span>+c.get(Calendar.MINUTE))；</span><br><span class="line">System.out.print(<span class="string">&quot;秒&quot;</span>+c.get(Calendar.SECOND))；</span><br><span class="line"><span class="comment">//Calendar没有专门的格式化方法，所以程序员自己组合</span></span><br><span class="line">System.out.print(c.get(Calendar.SECOND)+<span class="string">&quot;年&quot;</span>+(c.get(Calendar.MONTH)+<span class="number">1</span>)+<span class="string">&quot;月&quot;</span>+c.get(Calendar.DAY_OF_MONTH)+<span class="string">&quot;日&quot;</span>)；</span><br></pre></td></tr></table></figure>

<h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>前面两代的不足分析</p>
<p>（jdk1.0中包含了一个java.Util.Date类，但是他的大多数方法已经存在JDK1.1引入Calendar类之后被弃用。Calendar也存在着很多问题</p>
<ol>
<li>可变性：像日期和时间这样的类应该是不可变的。</li>
<li>偏移性：Date中年份是从1900开始的，而月份是从0开始的</li>
<li>格式化：格式化只对Date有用，Calendar则不行</li>
<li>此外，他们不是线程安全的，不能处理闰秒等（每隔两天多出1s）</li>
</ol>
<h4 id="第三代日期类-1"><a href="#第三代日期类-1" class="headerlink" title="第三代日期类"></a>第三代日期类</h4><p>1）LoaclDate（日期）、localTime（时间）、loacalDateTime（日期和时间内）</p>
<p>JDK8</p>
<p>LoaclDate：只包含日期，可以获取日期字段</p>
<p>localTime：包含时间，可以获取时间字段</p>
<p>loacalDateTime包含日期和时间，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">loacalDateTime</span> <span class="variable">ln</span> <span class="operator">=</span> loacalDateTime.now();</span><br><span class="line">ln.getYear();</span><br><span class="line">ln.getMonth();</span><br><span class="line">ln.getMonthValue();<span class="comment">//输出数字版的月份</span></span><br></pre></td></tr></table></figure>

<h5 id="2）DateTimeFormatter格式日期类"><a href="#2）DateTimeFormatter格式日期类" class="headerlink" title="2）DateTimeFormatter格式日期类"></a>2）DateTimeFormatter格式日期类</h5><p>类似于SimpleDateFormat</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(格式);<span class="comment">//(yyyyMMdd....)</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">srt</span> <span class="operator">=</span> dtf.format(日期对象);</span><br></pre></td></tr></table></figure>

<h4 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h4><p>类似于Date</p>
<p>提供了一系列和Date类转换的方式</p>
<p>Instant—-&gt;Date;</p>
<p>Date date &#x3D; Date.from(instant);</p>
<p>Date —&gt;Instant;</p>
<p>Instant instant &#x3D; date.toInstant();</p>
<p>案例演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.print(now);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(now);</span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant();</span><br></pre></td></tr></table></figure>













<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>1）exit 退出当前程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.exit(0);表示退出</span><br><span class="line">//0代表一个正常状态状态  。</span><br></pre></td></tr></table></figure>

<p>2）Arraycopy：复制数组元素，比较合适底层调用，一般使用Arrays.copyOf完成数组复制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] dest = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">System.arraycopy(src,<span class="number">0</span>,dest,<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line"> 	src:源数组</span><br><span class="line">    srcpos：从原数组的哪个索引位置开始开始拷贝</span><br><span class="line">    dest:目标数组，即吧原数组的数据拷贝到哪个数组</span><br><span class="line">    destpos：把原数组的数据拷贝到 目标数组的哪个索引</span><br><span class="line">    length:从原数组拷贝多少个数据到目标数组</span><br></pre></td></tr></table></figure>

<p>3）currentTimeMillens：返回当前时间距离1970-1-1(1970年1月1日到现在) 的毫秒数</p>
<p>4）gc：运行垃圾回收机制System.gc();</p>
<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><p>Arrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="1）-toString返回数组的字符串形式，将数组拼接成字符串返回"><a href="#1）-toString返回数组的字符串形式，将数组拼接成字符串返回" class="headerlink" title="1） toString返回数组的字符串形式，将数组拼接成字符串返回"></a>1） toString返回数组的字符串形式，将数组拼接成字符串返回</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.ToString(arr)</span><br></pre></td></tr></table></figure>

<h4 id="2-sort排序（自然排序和定制排序）"><a href="#2-sort排序（自然排序和定制排序）" class="headerlink" title="2)sort排序（自然排序和定制排序）"></a>2)sort排序（自然排序和定制排序）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Integer arr[] = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">89</span>&#125;;</span><br><span class="line"><span class="comment">//可以直接使用该方法进行排序。不用再动手去敲方法</span></span><br><span class="line"><span class="comment">//因为数组时引用类型，所以通过sort排序后，会影响到实参arr</span></span><br><span class="line">Arrays.sort(arr);<span class="comment">//正序排序</span></span><br><span class="line"><span class="comment">//sort重载的，也可以通过传入一个接口Comparator实现定制排序</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、调用定制排序时，传入两个参数</span><br><span class="line">    (<span class="number">1</span>)排序数组的参数</span><br><span class="line">    (<span class="number">2</span>)实现Comparator接口的匿名内部类。要求实现Compare方法</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//      这里体现了接口编程的方式</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        倒序排序</span></span><br><span class="line">        Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> (Integer) o1;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> (Integer) o2;</span><br><span class="line"><span class="comment">//                return大于0 就是正序排序，小于0就是倒序</span></span><br><span class="line">                <span class="keyword">return</span> i2 -i1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">       bubble(a,<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> (Integer) o1;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> (Integer) o2;</span><br><span class="line">                <span class="keyword">return</span> i1 -i2 ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;定制类&quot;</span>+Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    定制排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(Integer[] arr,Comparator c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;arr.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(arr[j],arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    temp =arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="3）binarySearch-二分搜索"><a href="#3）binarySearch-二分搜索" class="headerlink" title="3）binarySearch 二分搜索"></a>3）binarySearch 二分搜索</h4><p>binarySearch 通过二分搜索法进行查找，要求必须排好序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果这个数组是有序的，可以通过该方法查找知否有这个数</span></span><br><span class="line"> <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">65</span>,<span class="number">78</span>&#125;;</span><br><span class="line"><span class="comment">//如果不存在该元素就返回，return -(low +1)//意思就是返回负的他该出现的位置的下标+1</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr,<span class="number">3</span>);<span class="comment">//返回-2</span></span><br></pre></td></tr></table></figure>

<h4 id="4）copyOf数组元素的复制"><a href="#4）copyOf数组元素的复制" class="headerlink" title="4）copyOf数组元素的复制"></a>4）copyOf数组元素的复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示从arr数组中拷贝arr.length个长度的元素到新的arr数组中</span></span><br><span class="line">Integer[] newArr = Arrays.copyOf(arr,arr.length);</span><br><span class="line">Integer[] newArr = Arrays.copyOf(arr,arr.length-<span class="number">1</span>);就是拷贝原数组长度-<span class="number">1</span></span><br><span class="line">Integer[] newArr = Arrays.copyOf(arr,arr.length+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//如果长度超出原数组的长度，则多出来的部分元素为null   </span></span><br></pre></td></tr></table></figure>

<h4 id="5-fill数组元素的填充"><a href="#5-fill数组元素的填充" class="headerlink" title="5)fill数组元素的填充"></a>5)fill数组元素的填充</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer[] num = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//使用99去填充num数组</span></span><br><span class="line"><span class="comment">//可以理解成替换原来的元素</span></span><br><span class="line">Arrays.fill(num,<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">==========运行结果======</span><br><span class="line">    [<span class="number">99</span>,<span class="number">99</span>,<span class="number">99</span>]</span><br></pre></td></tr></table></figure>

<h4 id="6-equals-比较两个数组元素内容是否完全一致"><a href="#6-equals-比较两个数组元素内容是否完全一致" class="headerlink" title="6)equals 比较两个数组元素内容是否完全一致"></a>6)equals 比较两个数组元素内容是否完全一致</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">equals</span>  <span class="operator">=</span> Arrays.equals(arr,arr2);</span><br><span class="line"><span class="comment">//如果两个数组元素一样，则返回true。不一样返回false</span></span><br></pre></td></tr></table></figure>

<h4 id="7-asList-将一组值，转换成list"><a href="#7-asList-将一组值，转换成list" class="headerlink" title="7)asList 将一组值，转换成list"></a>7)asList 将一组值，转换成list</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; asList = Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;asList&quot;</span>+asList);</span><br></pre></td></tr></table></figure>





<h2 id="Integer和BigDecimal类"><a href="#Integer和BigDecimal类" class="headerlink" title="Integer和BigDecimal类"></a>Integer和BigDecimal类</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1）BigInteger适合保存比较大的整型(整数)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当编程中需要处理很大的整数。long不够用可以使用BigInteger类</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;2222222222222222222222222222222222222222&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算</span></span><br><span class="line"><span class="comment">//在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）</span></span><br><span class="line">    </span><br><span class="line">BigInteger bigInteger <span class="number">2</span>=bigInteger.add(<span class="number">10</span>)；<span class="comment">//加</span></span><br><span class="line">    <span class="comment">//也可再创建一个BigInteger相加</span></span><br></pre></td></tr></table></figure>



<p>2）BigDecimal适合保存精度高的浮点型(小数)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当我们需要保存一个精度很高的值时，double不够用</span></span><br><span class="line"><span class="comment">//可以使用BigDecimal</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;22.22222222222222222222222222&quot;</span>);</span><br><span class="line"><span class="comment">//运算</span></span><br><span class="line"><span class="comment">//在对BigDecimal进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）</span></span><br><span class="line"><span class="comment">//需要创建一个需要操作的BigDecimal，然后调用即可</span></span><br><span class="line"></span><br><span class="line">BigDecimal bigDecimal=bigDecimal.add(<span class="number">2.3</span>);</span><br><span class="line">    <span class="comment">//使用删除方法时，可能会出现除不尽的情况，会抛出异常</span></span><br><span class="line"><span class="comment">//解决办法：在调用divede(删除)方法是，指定精度即可</span></span><br><span class="line">bigDecimal.divide(<span class="number">1.11</span>,BigDecimal.ROUND_CEILING)</span><br><span class="line"><span class="comment">//如果有无限循环小数，就会保留到分子的精度</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h2><h3 id="集合体系图"><a href="#集合体系图" class="headerlink" title="集合体系图"></a>集合体系图</h3><p>背下来</p>
<p>1）单例集合（在集合里面放单个的对象）</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163040446.png" alt="image-20220420163040446"></p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163624872.png" alt="image-20220420163624872"></p>
<p>2）双列集合（存放键值对形式的）</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163100945.png" alt="image-20220420163100945"></p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163609594.png" alt="image-20220420163609594"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放单个数据的成为单例</span></span><br><span class="line"><span class="type">ArrayList</span>  <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放双列数据的成为双例集合</span></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hashMap.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"><span class="comment">//key,value</span></span><br><span class="line">hashMap.put(<span class="string">&quot;no2&quot;</span>,<span class="string">&quot;李四&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection接口</p>
<h4 id="Collection接口实现类的特点"><a href="#Collection接口实现类的特点" class="headerlink" title="Collection接口实现类的特点"></a>Collection接口实现类的特点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>Collection实现子类可以存放多个元素，每个元素可以是 Object</li>
<li>有些Collection的实现类，可以存放重复的元素，有些不可以</li>
<li>有些Collection的实现类，有些是有序的（List），有些不是有序（Set）</li>
<li>Collection接口没有直接实现子类，是通过它的子接口Set和List来实现的</li>
</ol>
<h4 id="Collection接口和常用方法"><a href="#Collection接口和常用方法" class="headerlink" title="Collection接口和常用方法"></a>Collection接口和常用方法</h4><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420165341922.png" alt="image-20220420165341922"></p>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)add :添加单个元素</span><br><span class="line"><span class="number">2</span>)remove:删除指定元素</span><br><span class="line"><span class="number">3</span>)contains:查找元素是否存在</span><br><span class="line"><span class="number">4</span>）size：获取元素个数</span><br><span class="line"><span class="number">5</span>）isEempty：判断是否为空</span><br><span class="line"><span class="number">6</span>）clear：清空</span><br><span class="line"><span class="number">7</span>）addAll：添加多个元素</span><br><span class="line"><span class="number">8</span>）containsAll：查找多个元素是否都存在</span><br><span class="line"><span class="number">9</span>）removeAll：删除多个元素</span><br><span class="line">说明：以ArrayList实现类演示</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//        1.添加单个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;hahah&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        list.add(<span class="number">123</span>);<span class="comment">//等价于list.add(new Integer(123);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组增加&quot;</span>+list);</span><br><span class="line"><span class="comment">//      remove：删除指定元素</span></span><br><span class="line">        list.remove(<span class="number">0</span>);<span class="comment">//删除第一个元素,下标从0开始</span></span><br><span class="line">        list.remove(<span class="string">&quot;123&quot;</span>);<span class="comment">//删除指定元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组删除&quot;</span>+list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//       contains 查找元素是否存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;zhangsan&quot;</span>));<span class="comment">//F</span></span><br><span class="line"><span class="comment">//        size,显示元素的个数</span></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line"><span class="comment">//      isEmpty判断是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());</span><br><span class="line"><span class="comment">//        clear清空</span></span><br><span class="line">        list.clear();<span class="comment">//清空集合</span></span><br><span class="line">        System.out.println(<span class="string">&quot;list清空=&quot;</span>+list);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//        addAll:添加多个元素</span></span><br><span class="line">        list1.add(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;xxxxxx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.addAll(list1);</span><br><span class="line">        System.out.println(<span class="string">&quot;addAll&quot;</span>+list);</span><br><span class="line"><span class="comment">//        containsAll:查找多个元素知否存在</span></span><br><span class="line">        System.out.println(list.containsAll(list1));</span><br><span class="line"><span class="comment">//        removeAll：删除多个元素</span></span><br><span class="line">        list.removeAll(list1);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Iterator（迭代器）"><a href="#使用Iterator（迭代器）" class="headerlink" title="使用Iterator（迭代器）"></a>使用Iterator（迭代器）</h4><p>Collection接口遍历元素的方式1-使用Iterator（迭代器）</p>
<h5 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>1）Iterator对象成为迭代器，主要用于遍历Collection集合中的元素</p>
<p>2）所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可返回一个迭代器</p>
<p>3）Iterator的结构<img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420231917444.png" alt="image-20220420231917444"></p>
<p>4）Iterator仅用于遍历集合，Iterator本身并不存放对象</p>
<h6 id="迭代器的运行原"><a href="#迭代器的运行原" class="headerlink" title="迭代器的运行原"></a>迭代器的运行原</h6><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220421160914060.png" alt="image-20220421160914060"></p>
<p>hasNext用于判断</p>
<p>next（）；下移，并返回指向的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Iteraor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">HomeWork</span>(<span class="string">&quot;zhansgan&quot;</span>,<span class="number">12313</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">HomeWork</span>(<span class="string">&quot;haha&quot;</span>,<span class="number">231</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        使用迭代器遍历</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="comment">//        while循环  快捷方式输入 itit</span></span><br><span class="line"><span class="comment">//        ctrl+j提示所有快捷键</span></span><br><span class="line">     <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"><span class="comment">//            返回下一个元素，是Object类型</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      当退出while循环后，这是iterator迭代器，指向最后一个元素</span></span><br><span class="line"><span class="comment">//        iterator.next()  ，此时再让往下移指针会报异常：NuSuchElementException</span></span><br><span class="line"><span class="comment">//        如果希望再次遍历，需要我们重置迭代器</span></span><br><span class="line">        iterator = list.iterator();<span class="comment">//相当于指向了第一个元素</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeWork</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer phoneNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomeWork</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomeWork</span><span class="params">(String name, Integer phoneNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.phoneNum = phoneNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HomeWork&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, phoneNum=&quot;</span> + phoneNum +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for循环增强"><a href="#for循环增强" class="headerlink" title="for循环增强"></a>for循环增强</h4><p>Collection接口遍历元素的方式2-</p>
<p>增强for循环，可以代替iterator迭代器</p>
<p>特点：增强for就是简化版的iterator，本质一样。只能用于<span style="color:red">遍历集合或数组</span></p>
<h6 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素名 : 集合名或数组)&#123;</span><br><span class="line">	访问元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (Object homeWork:list) &#123;</span><br><span class="line">            System.out.println(homeWork);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        增强也可以在数组中使用</span></span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: a)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>增强for底层是迭代器</li>
<li>可以理解成增强for是简化版的迭代器</li>
</ol>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>基本介绍：</p>
<p>List接口是Collection接口的子接口</p>
<p>1）list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</p>
<p>2）list集合中的每个元素都有其对应的顺序索引，即支持索引</p>
<p>3）list容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p>
<p>4）JDK API中的List接口实现类有：ArrayList、LinkedList和Vector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"><span class="comment">//        此时不会有冲突，相当于会认为有两个tom</span></span><br><span class="line">        list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"><span class="comment">//        此时输出的顺序就是存进去的顺序</span></span><br><span class="line">        System.out.println(<span class="string">&quot;list&quot;</span>+list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2）list集合中的每个元素都有其对应的顺序索引，即支持索引</span></span><br><span class="line"><span class="comment">//        索引从0开始</span></span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="List接口的常用方法"><a href="#List接口的常用方法" class="headerlink" title="List接口的常用方法"></a>List接口的常用方法</h5><ol>
<li>void add（int index,Object ele）在index位置插入ele元素</li>
<li>boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来</li>
<li>Object get (int index)获取固定index位置的元素</li>
<li>int indexOf(Object obj)  返回obj在几个中首次出现的位置</li>
<li>int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置</li>
<li>Object remove(int index) 移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换</li>
<li>List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;no1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;no2&quot;</span>);</span><br><span class="line"><span class="comment">//        1. void add（int index,Object ele）在index位置插入ele元素</span></span><br><span class="line"><span class="comment">//        在index=1的位置插入一个对象</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;add(index,ele)&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//        2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list2.add(<span class="string">&quot;lno2&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;lno3&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;lno3&quot;</span>);</span><br><span class="line"><span class="comment">//        在1的位置插入list2的集合</span></span><br><span class="line">        list.addAll(<span class="number">1</span>,list2);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//        3. Object get (int index)获取固定index位置的元素</span></span><br><span class="line"><span class="comment">//        4. int indexOf(Object obj)  返回obj在几个中首次出现的位置</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">&quot;no1&quot;</span>));</span><br><span class="line"><span class="comment">//        5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置</span></span><br><span class="line">        System.out.println(list.lastIndexOf(<span class="string">&quot;lno3&quot;</span>));</span><br><span class="line"><span class="comment">//        6. Object remove(int index) 移除指定index位置的元素，并返回此元素</span></span><br><span class="line">        list.remove(<span class="number">1</span>);</span><br><span class="line">        System.out.println( list);</span><br><span class="line"><span class="comment">//        7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换</span></span><br><span class="line"><span class="comment">//        将索引为1的改为尼诺</span></span><br><span class="line">        list.set(<span class="number">1</span>,<span class="string">&quot;尼诺&quot;</span>);</span><br><span class="line"><span class="comment">//        8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">result</span> <span class="operator">=</span> list.subList(<span class="number">0</span>, <span class="number">2</span>);<span class="comment">//相当于选择了下标为0的和下标为2-1之间的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>permits all elements,including null , ArrayList 可以加入null，并且多个</li>
<li>ArrayList 是由数组来实现数据存储的</li>
<li>ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）看源码，在多线程情况下，不建议使用ArrayList</li>
</ol>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><h5 id="ArrayList底层机制和源码分析（重点）"><a href="#ArrayList底层机制和源码分析（重点）" class="headerlink" title="ArrayList底层机制和源码分析（重点）"></a>ArrayList底层机制和源码分析（重点）</h5><p>1）ArrayList中维护了一个Object类型的数组elementData</p>
<p>​		transient Object[] elementData </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient 表示瞬间，短暂的，表示该属性不会被序列化</span><br></pre></td></tr></table></figure>



<p>2）当创建对象ArrayList时，如果使用的是无参构造器，则初始elementData容量为0</p>
<p>3）当添加元素时，先判断是否需要扩容，则调用grow方法，否则直接添加元素到合适位置</p>
<p>4）如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍</p>
<p>5）如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity</p>
<p>6）如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍</p>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><h5 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h5><p>Vevtor底层也是一个对象数组。protected Object[] elementData;</p>
<p>Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized</p>
<p>在开发过程中，需要线程同步安全时，考虑使用Vector</p>
<h5 id="Vector-和ArrayList比较"><a href="#Vector-和ArrayList比较" class="headerlink" title="Vector 和ArrayList比较"></a>Vector 和ArrayList比较</h5><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>版本</th>
<th>线程安全（同步）效率</th>
<th>扩容倍数</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>jdk1.2</td>
<td>不安全，效率高</td>
<td>如果有参构造1.5倍如果无参1.第一次是10，第二次按1.5扩</td>
</tr>
<tr>
<td>Vector</td>
<td>可变数组</td>
<td>jdk1.0</td>
<td>安全，效率不高</td>
<td>如果是无参默认10，满后，就按两倍扩容。如果指定大小（创建）有参，则每次直接按2倍扩容</td>
</tr>
</tbody></table>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>1）LinkedList实现了双向链表和双端队列特点</p>
<p>2）可以添加任意元素（元素可以重复），包括null</p>
<p>3）线程不安全，没有实现同步</p>
<h5 id="LinkedList底层机制"><a href="#LinkedList底层机制" class="headerlink" title="LinkedList底层机制"></a>LinkedList底层机制</h5><ol>
<li><p>LinkedList底层维护了一个双向链表</p>
</li>
<li><p>LinkedList中维护了两个属性first和last分别指向首节点和尾结点</p>
</li>
<li><p>每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表</p>
</li>
<li><p>所以LinkedList的元素的 添加和删除，不是通过该数组完成的，相对来说效率较高</p>
</li>
<li><p>模拟一个简单双向链表理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        模拟一个简单的双向链表</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">zhangshan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;zhangshan&quot;</span>);</span><br><span class="line"><span class="comment">//        链接是三个结点，形成双向链表</span></span><br><span class="line"><span class="comment">//        jack-&gt;tom -&gt;zhangsan</span></span><br><span class="line">        jack.next = tom;</span><br><span class="line">        tom.next =zhangshan;</span><br><span class="line"><span class="comment">//        zhangsan-&gt;tom-&gt;jack</span></span><br><span class="line">        zhangshan.pre = tom;</span><br><span class="line">        tom.pre = jack;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> jack;<span class="comment">//让first引用指向jack，就是双向链表的头结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span>zhangshan;<span class="comment">//让last引用指向zhangshan，就是双向链表的尾结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        演示从头到尾进行遍历</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            输出first信息</span></span><br><span class="line">            System.out.println(first);</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        从未到头遍历</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(last);</span><br><span class="line">            last = last.pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Node类，node对象 表示双向链表的一个结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object item;<span class="comment">//真正存放数据</span></span><br><span class="line">    <span class="keyword">public</span> Node next;<span class="comment">//指向下一个结点</span></span><br><span class="line">    <span class="keyword">public</span> Node pre;<span class="comment">//指向前一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;item=&quot;</span> + item +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429152321935.png" alt="image-20220429152321935"></p>
<h5 id="ArrayList-和LinkedList的比较"><a href="#ArrayList-和LinkedList的比较" class="headerlink" title="ArrayList 和LinkedList的比较"></a>ArrayList 和LinkedList的比较</h5><table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删的效率</th>
<th>改查的效率</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>较低；数组扩容</td>
<td>较高</td>
<td>不安全</td>
</tr>
<tr>
<td>LinkedList</td>
<td>双向链表</td>
<td>较高，通过链表追加</td>
<td>较低</td>
<td>不安全</td>
</tr>
</tbody></table>
<p>何如选择</p>
<p>1）如果我们改查的操作较多，选择ArrayList</p>
<p>2）如果我们增删的操作多，选择LinkedList</p>
<p>3）一般来说，在程序中80%-90%都是查询，因此大部分情况下会选择ArrayList</p>
<p>4）在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说根据业务来进行合理选择</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>介绍</p>
<p>1）无序（添加和取出的顺序不一致），没有索引</p>
<p>2）不允许重复元素，所以最多包含和一个null</p>
<p>3）JDK API中Set接口的实现类有<img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429173926895.png" alt="image-20220429173926895"></p>
<h5 id="Set接口和常用方法"><a href="#Set接口和常用方法" class="headerlink" title="Set接口和常用方法"></a>Set接口和常用方法</h5><p>和List接口一样，Set接口也是Collection的子接口，因此常用方法和Collection接口一样</p>
<h5 id="set接口遍历方式"><a href="#set接口遍历方式" class="headerlink" title="set接口遍历方式"></a>set接口遍历方式</h5><p>同Collection的遍历方式一样，因为Set接口是Collection接口的子接口</p>
<ul>
<li>使用迭代器</li>
<li>增强for</li>
<li>不能使用索引的方式获取</li>
</ul>
<h5 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        以set接口实现类HashSet来讲解Set接口的方法</span></span><br><span class="line"><span class="comment">//        set接口的实现类的对象（set接口对象）</span></span><br><span class="line"><span class="comment">//        重复添加的数据只会存进去一个，null值也是只能存放一个</span></span><br><span class="line">    <span class="comment">//输出结果是无序的（存放的数据是无序的，即（添加的顺序和取出的顺序不一致））</span></span><br><span class="line">    <span class="comment">//虽然取出的顺序和添加的顺序不一致，但取出的顺序是固定的，不会一直变化</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(<span class="string">&quot;zhansgan&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;wa&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;zhansgan&quot;</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历</span></span><br><span class="line"><span class="comment">//        迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        增强for</span></span><br><span class="line">        <span class="keyword">for</span> (Object o :set) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">----------------输出结果----------------------</span><br><span class="line">    [<span class="literal">null</span>, lisi, wa, zhansgan]</span><br></pre></td></tr></table></figure>

<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>1)HashSet实现了Set接口</p>
<p>2）HashSet实际上是HashMap，看源码</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430145947382.png" alt="image-20220430145947382"></p>
<p>3）可以存放null值，但是只能有一个null</p>
<p>4）HashSet不保证元素时有序的，取决于hash之后，在确定索引的结果（即：不保证存放元素的顺序和取出的一致  ）</p>
<p>5）不能有重复元素&#x2F;对象。在前面Set接口使用已经标明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.执行add方法后，会返回一个Boolean值</span></span><br><span class="line"><span class="comment">//2.如果添加成功,返回true，否则返回false</span></span><br><span class="line"><span class="comment">//3.可以通过remove指定删除哪个对象</span></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        set.add(<span class="string">&quot;zhansgan&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;wa&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;zhansgan&quot;</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);</span><br><span class="line">        set.add(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        set.remove(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">HHHH</span>(<span class="string">&quot;zzz&quot;</span>));<span class="comment">//添加成功</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">HHHH</span>(<span class="string">&quot;zzz&quot;</span>));<span class="comment">//添加成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HHHH</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HHHH</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashSet底层机制说明"><a href="#HashSet底层机制说明" class="headerlink" title="HashSet底层机制说明"></a>HashSet底层机制说明</h5><p>1）HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树）</p>
<ol>
<li>HashSet底层是HashMap</li>
<li>添加一个元素时，先得到hash值 -会转成-索引值</li>
<li>找到储存数据表table，看这个索引位置是否已经存放的有元素</li>
<li>如果没有，直接加入</li>
<li>如果有调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</li>
<li>在java8中，如果一条链表的元素个数到了TREEEIFY_THRESHOLD(默认是8)个，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树）</li>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430160350549.png" alt="image-20220430160350549"></li>
</ol>
<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">//定义了一个辅助变量</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//table就是HashMap的一个属性，类型是Node[]</span></span><br><span class="line">     <span class="comment">//if语句表示如果当前table是null，或者大小=0</span></span><br><span class="line">    <span class="comment">//就是第一次扩容，到16个空间</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">   <span class="comment">//（1）根据key，得到hash值去计算key应该存放到table表的哪个索引位置</span></span><br><span class="line">    <span class="comment">//并且把这个位置的对象赋给p</span></span><br><span class="line">    <span class="comment">//（2）判断p是否为null</span></span><br><span class="line">    <span class="comment">//（2.1）如果为null，表示还没有存放元素，就创建了一个Node</span></span><br><span class="line">    <span class="comment">//（2.1）就放在该位置 tab[i] = newNode(hash, key, value, null); </span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="comment">//如果当前索引位置对应的链表的第一个元素和准备谈价的key的hash值一样</span></span><br><span class="line">            <span class="comment">//并且满足下面条件之一</span></span><br><span class="line">            <span class="comment">//1.准备加入的key和p指向的Node结点和key是同一个对象 </span></span><br><span class="line">            <span class="comment">//2.p指向的Node结点的key的equals（）和准备加入的key比较后相同</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//如果上述条件不满足，再判断p是不是一个红黑树</span></span><br><span class="line">            <span class="comment">//如果是一颗红黑树，就调用putTreeVal，来进行添加判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//依次比较链表内的内容</span></span><br><span class="line">                <span class="comment">//如果table对应索引的额位置，已经是一个链表，就是用for循环比较</span></span><br><span class="line">                <span class="comment">//(1)依次和链表的每一个元素比较后都不相同，则加入到该链表的最后</span></span><br><span class="line">                  <span class="comment">//然后立即判断该链表是否已经达到8个结点，就调用   treeifyBin()对当前这个链表进行树化（转成红黑树）</span></span><br><span class="line">                <span class="comment">//注意，在转成红黑树时，要进行判断，判断条件&#123;if(tab == null ||(n = tab.length)&lt;MIN_TREEIEY_CAPACITY)</span></span><br><span class="line">                <span class="comment">//resize();   //table数组是否小于64，结点是否到达8个并不为空      &#125;</span></span><br><span class="line">                <span class="comment">//如果上面条件成立，先table扩容</span></span><br><span class="line">                <span class="comment">//如果上面条件不成立，才进行树化</span></span><br><span class="line">                <span class="comment">//(2)依次和该链表的每一个元素比较过程中，如果有相同的情况，就直接break；</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        </span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                </span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashSet的扩容和转成红黑树机制"><a href="#HashSet的扩容和转成红黑树机制" class="headerlink" title="HashSet的扩容和转成红黑树机制"></a>HashSet的扩容和转成红黑树机制</h5><ol>
<li>HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（localFactor）是0.75 &#x3D;12</li>
<li>如果table数组实用到了临界值12，就会扩容到16*2&#x3D;32，新的临界值就是32 * 0.75 &#x3D; 24,依次类推</li>
<li>在java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8),并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树），否则仍然采用数组扩容机制</li>
</ol>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p><strong>说明</strong></p>
<p>1）LinkedHashSet是HashSet的子类</p>
<p>2）LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表</p>
<p>3）LinkedHashSet根据元素的hashCode值来决定元素的储存位置，同时使用链表维护元素的次序（图），这使得元素看起来是以插入顺序保存的<img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220501174705977.png" alt="image-20220501174705977"></p>
<p>4）LinkedHashSet不允许添加重复元素 </p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220502111826275.png" alt="image-20220502111826275"></p>
<p>可以理解成不同索引的数，构成双向链表</p>
<ol>
<li><p>在LinkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）</p>
</li>
<li><p>每一个结点有pre和next属性，这样可以形成双向链表</p>
</li>
<li><p>在添加一个元素时，先求hash值，在求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加[原则和hashset一样])</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail.next = newElement <span class="comment">//简单指定</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Element</span>.pre = <span class="type">tail</span></span><br><span class="line"><span class="variable">tail</span> <span class="operator">=</span> newElement;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p>
</li>
</ol>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ol>
<li><p>当使用无参构造器创建treeset的时候仍然是无序的</p>
</li>
<li><p>需求：希望添加的元素按字符串大小来排序?</p>
<ol>
<li><p>使用TreeSet提供的一个构造器,可以传入一个比较器（匿名内部类）</p>
</li>
<li><p>&#96;&#96;&#96;java<br>public class TreeSetDemo {<br>public static void main(String[] args) {<br>&#x2F;&#x2F;        TreeSet treeSet &#x3D; new TreeSet();<br>    TreeSet treeSet &#x3D; new TreeSet(new Comparator() {<br>        @Override<br>        public int compare(Object o1, Object o2) {<br>&#x2F;&#x2F;                调用String的compareTo方法比较字符串大小<br>            return ((String)o1).compareTo((String) o2);<br>        }<br>    });<br>    treeSet.add(“d”);<br>    treeSet.add(“b”);<br>    treeSet.add(“a”);<br>    treeSet.add(“c”);<br><br>    System.out.println(treeSet);<br>}}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   3. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Map</span><br><span class="line"></span><br><span class="line">Map**结构**</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220503163901620.png&quot; alt=&quot;image-20220503163901620&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">Map接口的特点（JDK8之后的）</span><br><span class="line"></span><br><span class="line">1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）</span><br><span class="line"></span><br><span class="line">2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&amp;Node对象中</span><br><span class="line"></span><br><span class="line">3）Map中的key不允许重复，原因和HashSet一样，前面分析过</span><br><span class="line"></span><br><span class="line">4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）</span><br><span class="line"></span><br><span class="line">5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个</span><br><span class="line"></span><br><span class="line">6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）</span><br><span class="line"></span><br><span class="line">7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"> Map map = new HashMap();</span><br><span class="line">//        1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）</span><br><span class="line">//        2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&amp;Node对象中</span><br><span class="line">//        3）Map中的key不允许重复，原因和HashSet一样，前面分析过</span><br><span class="line">//        4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）</span><br><span class="line">        map.put(&quot;no1&quot;,&quot;zhangsan&quot;);</span><br><span class="line">        map.put(&quot;no2&quot;,&quot;lisi&quot;);</span><br><span class="line">        map.put(&quot;no1&quot;,&quot;lisi&quot;);</span><br><span class="line">//        5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个</span><br><span class="line">        map.put(null,null);</span><br><span class="line">        map.put(null,null);</span><br><span class="line">        map.put(&quot;no3&quot;,null);</span><br><span class="line">        map.put(&quot;no4&quot;,null);</span><br><span class="line">        //        6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）</span><br><span class="line">        map.put(new Object(),&quot;zhangsan&quot;);</span><br><span class="line">//        7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</span><br><span class="line">//        通过get方法传入key，会返回对应的value</span><br><span class="line">        System.out.println(map.get(&quot;no2&quot;));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">=============输出==================</span><br><span class="line">  lisi</span><br><span class="line">&#123;no2=lisi, null=null, no1=lisi, no4=null, no3=null, java.lang.Object@1540e19d=zhangsan&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>8）Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，有因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry（如图）</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220504165516988.png" alt="image-20220504165516988"></p>
<p>数据存放在HashMap中，将set和collection作为一组对象放在Entry里面（其中不存放数据只是存放HashMap的引用）</p>
<ol>
<li>将HashMap中的key和value数据 存放到一个entrySet集合（该集合不存放数据，存放的都是引用）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no2&quot;</span>,<span class="string">&quot;lisi&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;lisi&quot;</span>);<span class="comment">//k-v</span></span><br><span class="line"><span class="comment">//        1.k-v最后是HashMap$Node node = newNode(hash ,key,value,null);</span></span><br><span class="line"><span class="comment">//        2.k-v为了方便程序员遍历，还会创建EntrySet集合，该集合存放的元素类型（Entry），</span></span><br><span class="line"><span class="comment">//        而一个Entry对象就有k-v，EntrySet&lt;Entry&lt;k,v&gt;&gt;，即：transient Set&lt;Map.Entry&lt;k,v&gt;&gt; entrySet;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        3.在entrySet中，定义的类型是Map.Entry，但是实际上存放的是HashMap$Node类型</span></span><br><span class="line"><span class="comment">//        因为HashMap$Node implement Map.Entry 因为实现了Map.Entry接口，那么这个类的对象实例可以赋给这个接口类型</span></span><br><span class="line"><span class="comment">//        4.当吧HashMap$Node存放到entrySet后就方便我们的遍历，因为Map.Entry提供了两个重要的方法，getKey()和getValue方法</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        System.out.println(set.getClass());</span><br><span class="line"><span class="comment">//        输出：class java.util.HashMap$EntrySet</span></span><br><span class="line">        <span class="keyword">for</span> (Object o :set) &#123;</span><br><span class="line">            System.out.println(o.getClass());</span><br><span class="line"><span class="comment">//            输出：class java.util.HashMap$Node</span></span><br><span class="line"><span class="comment">//            从HashMap$Node取出k-v</span></span><br><span class="line"><span class="comment">//            先做一个向下转型</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) o;</span><br><span class="line">            System.out.println(entry.getKey() +<span class="string">&quot;&quot;</span>+ entry.getValue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h4 id="map接口和常用方法"><a href="#map接口和常用方法" class="headerlink" title="map接口和常用方法"></a>map接口和常用方法</h4><p>1）put：添加</p>
<p>2）remove：根据键删除映射关系</p>
<p>3）get：根据键获取值</p>
<p>4）size：获取元素个数</p>
<p>5）isEmpty：判断个数是否为0</p>
<p>6）clear；清楚</p>
<p>7）containsKey：查找键值否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no2&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no3&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no4&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        map.remove(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lisi</span> <span class="operator">=</span> map.get(<span class="string">&quot;no2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;lisi==&quot;</span>+lisi);</span><br><span class="line"></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line"></span><br><span class="line">        map.isEmpty();</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        map.clear();</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        System.out.println(map.containsKey(<span class="string">&quot;no3&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Map遍历方法"><a href="#Map遍历方法" class="headerlink" title="Map遍历方法"></a>Map遍历方法</h4><p>1）containsKey：查找键是否存在</p>
<p>2）KeySet：获取所有的键</p>
<p>3）entrySet：获取所有关系</p>
<p>4）values：获取所有的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;no1&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no2&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="literal">null</span>,<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no3&quot;</span>,<span class="string">&quot;lisdsdsi&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;no4&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        第一粗：先取出所有的key，通过key取出对应的value</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">//        增强for</span></span><br><span class="line">        <span class="keyword">for</span> (Object o :set) &#123;</span><br><span class="line">            System.out.println(map.get(o));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;迭代器&quot;</span>);</span><br><span class="line"><span class="comment">//        （2） 使用迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">            System.out.println(map.get(next));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========第二中=========&quot;</span>);</span><br><span class="line"><span class="comment">//      第二组：吧所有的values取出</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">//        这里可以使用所有的collections使用的遍历方法</span></span><br><span class="line">        <span class="keyword">for</span> (Object o :values) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;迭代器&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator1.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=========第三中=========&quot;</span>);</span><br><span class="line"><span class="comment">//        通过entryset获取</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set1</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Object entry :set1) &#123;</span><br><span class="line"><span class="comment">//            将entry转为map.entry</span></span><br><span class="line">            Map.Entry  entry1= (Map.Entry) entry;</span><br><span class="line">            System.out.println(entry1.getKey()+<span class="string">&quot; &quot;</span>+entry1.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;迭代器&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> set1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator2.next();</span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) next;</span><br><span class="line">            System.out.println(m.getKey()+<span class="string">&quot; itit &quot;</span>+ m.getValue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>Map接口的常用实现类：HashMap、Hashtable和Properties</li>
<li>HashMap是Map接口使用频率最高的实现类</li>
<li>HashMap是以key-value对的方式来存储数据（HashMap$Node类型）</li>
<li>key不能重复，但值可以，允许使用null键和null值</li>
<li>如果添加相同的 key，则会覆盖原来的k-v，等同于修改，（key不会替换，val会替换）</li>
<li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来储存的</li>
<li>HashMap没有实现同步，因此线程不安全 的</li>
</ol>
<h4 id="HashMap底层机制"><a href="#HashMap底层机制" class="headerlink" title="HashMap底层机制"></a>HashMap底层机制</h4><p>1）HashMap底层维护了Node类型的数组table，默认为null</p>
<p>2）当创建对象时，将加载银子（loadfactor）初始化为0.75</p>
<p>3）当添加key-value时，通过key的哈希值得到在table的索引，然后判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是连链表结构，做出相应处理。如果添加时发现容量不够则需扩容</p>
<p>4）第一次添加，则需扩容table容量为16，临界值(threshold)为12</p>
<p>5）以后再扩容，需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推</p>
<p>6）在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64)，就会进行树化。</p>
<h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p><strong>基本介绍</strong></p>
<p>1）存放的元素时键值对：key-value</p>
<p>2）hashTable的键和值都不能为null，否则会抛出空指针异常</p>
<p>3）hashTable使用方法基本上和HashMap一样</p>
<p>4）hashTable是线程安全的，HashMap是线程不安全的</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220506160740866.png" alt="image-20220506160740866"></p>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p><strong>基本介绍</strong></p>
<ol>
<li>properties类继承了Hashtable类并实现了Map接口，也是使用一种键值对(key-value)的形式来保存数据</li>
<li>它的使用特点和Hashtable类似</li>
<li>properties还可用于从xxx.properties文件中，加载数据到properties类对象，并进行读取和修改</li>
<li>说明：工作后 xxx.properties文件常用作配置文件，io流部分(详细讲解)[<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xudong-bupt/p/3758136.html]">www.cnblogs.com/xudong-bupt/p/3758136.html]</a></li>
</ol>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>1）Collections是一个操作Set、List和Map等集合的工具类</p>
<p>2）Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</p>
<h3 id="排序操作（均为static方法）"><a href="#排序操作（均为static方法）" class="headerlink" title="排序操作（均为static方法）"></a>排序操作（均为static方法）</h3><ol>
<li><p>reverse（List）：反转List中元素的顺序</p>
</li>
<li><p>shuffle（List）：对List集合元素进行随机排序</p>
</li>
<li><p>sort（List）：根据元素的自然顺序对指定List集合元素按升序排序</p>
</li>
<li><p>sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序</p>
</li>
<li><p>swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换</p>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Collectionsdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;zhansgan&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;wngwu&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;laoliu&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;dasima&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span>+list);</span><br><span class="line"><span class="comment">//        1. reverse（List）：反转List中元素的顺序</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;reverse=&quot;</span>+list);</span><br><span class="line"><span class="comment">//        2. shuffle（List）：对List集合元素进行随机排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Collections.shuffle(list);</span><br><span class="line">            System.out.println(<span class="string">&quot;随机&quot;</span>+list);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;sort&quot;</span>+list);</span><br><span class="line"><span class="comment">//        4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ((String)o1).length()-((String)o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度排序&quot;</span>+list);</span><br><span class="line"><span class="comment">//        5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换</span></span><br><span class="line"></span><br><span class="line">        Collections.swap(list,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;位置交换&quot;</span>+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><ol>
<li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p>
</li>
<li><p>Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素</p>
</li>
<li><p>Object min（Collection)</p>
</li>
<li><p>Object min (Collection，Comparator)</p>
</li>
<li><p>int frequency （Collection，Object）：染回指定集合中指定元素的出现次数</p>
</li>
<li><p>void copy（List dest，List src）：将src中的内容复制到dest中</p>
</li>
<li><p>boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值</p>
</li>
<li><p>&#96;&#96;&#96;java<br>public static void main(String[] args) {<br>    ArrayList list &#x3D; new ArrayList();<br>    list.add(“zhansgan”);<br>    list.add(“lisi”);<br>    list.add(“wngwu”);<br>    list.add(“laoliu”);<br>    list.add(“dasima”);<br>    System.out.println(“list&#x3D;”+list);<br>&#x2F;&#x2F;        1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>    System.out.println(“max num&#x3D;”+Collections.max(list));<br>&#x2F;&#x2F;        2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素<br>&#x2F;&#x2F;            获取最大长度的值<br>    &#x2F;&#x2F;        3. Object min（Collection)<br>&#x2F;&#x2F;        4. Object min (Collection，Comparator)同理<br>    Object max &#x3D; Collections.max(list, new Comparator() {<br><br>        @Override<br>        public int compare(Object o1, Object o2) {<br>            return ((String) o1).length() - ((String) o2).length();<br>        }<br>    });<br>    System.out.println(“字符串最大的值为&#x3D;”+max);<br>&#x2F;&#x2F;        5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数</p>
<pre><code>    System.out.println(&quot;lailiu=&quot;+ Collections.frequency(list,&quot;lailiu&quot;));
</code></pre>
<p>&#x2F;&#x2F;        6. void copy（List dest，List src）：将src中的内容复制到dest中<br>       ArrayList oldList &#x3D;  new ArrayList();<br>&#x2F;&#x2F;           为了完成一个拷贝，我们需要先给oldList赋值，大小和list一样,不然会报错<br>    for (int i &#x3D; 0; i &lt; list.size(); i++) {<br>        oldList.add(“”);<br>    }<br>&#x2F;&#x2F;        拷贝<br>    Collections.copy(oldList,list);<br>    System.out.println(“oldList&#x3D;”+oldList);<br>&#x2F;&#x2F;        7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值<br>    Collections.replaceAll(list,”laoliu”,”老六”);<br>    System.out.println(“替换后&#x3D;”+list);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 总结</span><br><span class="line"></span><br><span class="line">在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择分析如下</span><br><span class="line"></span><br><span class="line">1）先判断储存类型（一组对象或一组键值对）</span><br><span class="line"></span><br><span class="line">2）一组对象[单列]：Collection接口</span><br><span class="line"></span><br><span class="line">* 允许重复：List</span><br><span class="line">  * 增删多：LinkedList（底层维护了一个双向链表）</span><br><span class="line">  * 改查多：ArrayList（底层维护了Object类型的可变数组）</span><br><span class="line">* 不允许重复：Set</span><br><span class="line">  * 无序：HashSet（底层是HashMap，维护了一个哈希表 即（数组+链表+红黑树））</span><br><span class="line">  * 排序：TreeSet</span><br><span class="line">  * 插入和取出顺序一直：LinkedHashSet，维护数组+双向链表</span><br><span class="line"></span><br><span class="line">3）一组键值对[双列]：Map</span><br><span class="line"></span><br><span class="line">* 键无序：HashMap（底层是：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树）</span><br><span class="line">* 键排序：TreeSet</span><br><span class="line">* 键插入和取出顺序一致：LinkedHashMap</span><br><span class="line">* 读取文件：Properties</span><br><span class="line"></span><br><span class="line"># 泛型</span><br><span class="line"></span><br><span class="line">## 泛型语法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//        1.当我们ArrayList&lt;Dog&gt;表示放到ArrayList集合中的元素只能是Dog类型</span><br><span class="line">//        2.如果编译器发现添加的类型不满足，就会报错</span><br><span class="line">        ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();</span><br><span class="line">        dogs.add(new Dog(&quot;laogou&quot;,12));</span><br><span class="line">        dogs.add(new Dog(&quot;xiaogou&quot;,1));</span><br><span class="line">    &#125;</span><br><span class="line">//       方便遍历</span><br><span class="line">        for (Dog dog : dogs) &#123;</span><br><span class="line">            System.out.println(dog);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>好处：</p>
<ol>
<li>编译时，检查添加元素的类型，提高了安全性</li>
<li>减少了类型转换的次数，提高效率</li>
<li>不再提示编译警告</li>
</ol>
<h3 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h3><p>理解：泛（广泛）型（类型）&#x3D;&#x3D;&gt; integer，String</p>
<p>可以表示数据类型的数据类型<img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171057972.png" alt="image-20220509171057972"></p>
<p>1）泛型又称参数化类型，时jdk5.0出现的新特性，解决数据类型的安全性问题</p>
<p>2）在类声明或实例化时只要制定好需要的具体的类型即可</p>
<p>3）java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮</p>
<p>4）泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171249826.png" alt="image-20220509171249826"></p>
<p>（此时E称为泛型，那么Dog-&gt;E（此时E为 ））</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Cat&lt;String&gt; tianyuanmao = <span class="keyword">new</span> <span class="title class_">Cat</span>&lt;&gt;(<span class="string">&quot;tianyuanmao&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&lt;E&gt; &#123;</span><br><span class="line">    E e;<span class="comment">//E表示 e的数据类型，改数据类型在定义Cat对象时指定的，即在编译期间，就确定是什么类型了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(E e)</span> &#123;<span class="comment">//E也可在参数类型体现</span></span><br><span class="line">        <span class="built_in">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">method</span><span class="params">()</span>&#123;<span class="comment">//返回类型也可体现</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>泛型的声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface 接口&lt;T&gt; &#123;&#125;</span><br><span class="line">class类&lt;K,V,...&gt;&#123;&#125;(可以接收多个泛型等等)</span><br><span class="line">说明：</span><br><span class="line">    <span class="number">1.</span>其中K,V,T不代表值，而是表示类型</span><br><span class="line">    <span class="number">2.</span>任意字母都可以。常用T表示，是type的缩写</span><br></pre></td></tr></table></figure>

<p>泛型的实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要在类名后面指定类型参数的值（类型）。如</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">List &lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Iterator &lt;Customer&gt; iterator = coustomers.iterator();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用细节-5"><a href="#使用细节-5" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li><p>interface List<T>{},public class HashSet<E>{}….等等</p>
<ol>
<li>说明：T，E只能是引用类型</li>
<li>不能是基本数据类型（八大基本数据类型,int,double 等等）</li>
</ol>
</li>
<li><p>在指定泛型具体类型后，可以传入该类型或者其子类类型</p>
</li>
<li><p>泛型适用形式</p>
<ol>
<li><p>&#96;&#96;&#96;java<br>List<integer> list1 &#x3D;new ArrayList<Integer>{}</p>
<p>List<Integer> list2 &#x3D; new ArrayList&lt;&gt;();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 如果我们这样写List list3 = new ArrayList（）；默认给它的泛型是[&lt;E&gt; E就是Object 类型]</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 自定义泛型</span><br><span class="line"></span><br><span class="line">### 泛型类</span><br><span class="line"></span><br><span class="line">**基本语法**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class 类名&lt;T,R....&gt;&#123;</span><br><span class="line">成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>细节：</p>
<ol>
<li><p>普通成员可以使用泛型（属性，方法）</p>
</li>
<li><p>使用泛型的数组，不能初始化</p>
</li>
<li><p>静态方法中不能使用类的泛型‘</p>
<ol>
<li>因为静态是和类相关的，在类加载时，对象还没创建</li>
<li>所以，如果静态方法和静态属性使用泛型时 ，JVM就无法完成初始化</li>
</ol>
</li>
<li><p>泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）</p>
</li>
<li><p>如果在创建对象时，没有指定类型，默认为object</p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;1.demo后面有泛型，所以我们吧demo就称为自定义泛型类<br>&#x2F;&#x2F;2.T,R,M泛型的标识符，一般是单个大写字母<br>&#x2F;&#x2F;3.泛型标识符可以有多个<br>&#x2F;&#x2F;4.普通成员可以使用泛型 （属性，方法）<br>&#x2F;&#x2F;5.使用泛型的数组，不能初始化<br>&#x2F;&#x2F;（因为数组在new的<br>class demo&lt;T,R,M&gt;{<br>String name;<br>T t;<br>R r;<br>M m;<br>T[] t1;&#x2F;&#x2F;可以声明<br><br>public demo11(String name, T t, R r, M m) {&#x2F;&#x2F;构造器使用泛型<br>    this.name &#x3D; name;<br>    this.t &#x3D; t;<br>    this.r &#x3D; r;<br>    this.m &#x3D; m;<br>}<br>&#x2F;&#x2F;方法使用泛型<br> public String getName() {<br>    return name;<br>}<br><br>public void setName(String name) {<br>    this.name &#x3D; name;<br>}<br><br>public T getT() {<br>    return t;<br>}<br><br>public void setT(T t) {<br>    this.t &#x3D; t;<br>}<br><br>public R getR() {<br>    return r;<br>}<br><br>public void setR(R r) {<br>    this.r &#x3D; r;<br>}<br><br>public M getM() {<br>    return m;<br>}<br><br>public void setM(M m) {<br>    this.m &#x3D; m;<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 泛型接口</span><br><span class="line"></span><br><span class="line">**基本语法**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">interface  接口名 &lt;T,R...&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>细节：</p>
<ol>
<li><p>接口中，静态成员也不能使用泛型</p>
</li>
<li><p>泛型接口的类型，在继承接口或者实现接口时确定</p>
</li>
<li><p>没有指定类型，默认为Object</p>
</li>
</ol>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p><strong>基本语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符&lt;T,R...&gt;返回类型 方法名（番薯列表）&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意细节</strong>：</p>
<ol>
<li><p>反省方法，可以定义在普通类中，也可以定义在泛型类中</p>
</li>
<li><p>当泛型方法被调用时，类型会确定</p>
</li>
<li><p>public void eat（E e）{}，修饰符后没有&lt;T,R..&gt;eat方法不是泛型方法，而是使用了泛型</p>
</li>
<li><pre><code class="java">//泛型方法，可以定义在普通类中，也可以定义在泛型类中
class Car&#123;
    public void run()&#123;//普通方法

    &#125;
//    1.T,R就是泛型标识符
//    2.提供给fly方法使用的
    public &lt;T,R&gt; void  fly(T t, R r)&#123;//泛型方法

    &#125;

&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. ```java</span><br><span class="line">   class Car2&lt;T,R&gt;&#123;//泛型类</span><br><span class="line">       public &lt;U,M&gt; void  fly(U u, M m)&#123;//泛型方法</span><br><span class="line">       &#125;</span><br><span class="line">       public void  fly2(T t)&#123;</span><br><span class="line">   //        1.该方法不是泛型方法</span><br><span class="line">   //        2.是fly2方法使用了类声明的泛型</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>&#96;&#96;&#96;java<br>Car car &#x3D; new Car();<br>    car.fly(“baoma”,2000);<br>    &#x2F;&#x2F;在调用方法是，编译器会自动识别传入的参数的类型，就会确定型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. 泛型方法可以使用类声明的泛型，也可使用自己声明的泛型</span><br><span class="line"></span><br><span class="line">## 泛型继承和通配符</span><br><span class="line"></span><br><span class="line">**介绍**</span><br><span class="line"></span><br><span class="line">1)泛型不具备继承性</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">List&lt;Object&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">//是错误的，因为泛型中没有继承性</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2）&lt;?&gt;:支持任意泛型类型</p>
<p>3）&lt;? extend A&gt;:支持A类以及 A类的子类，规定了泛型的上限</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142709072.png" alt="image-20220511142709072"></p>
<p>4）&lt;? super A&gt;:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</p>
<p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142730306.png" alt="image-20220511142730306"></p>
<h1 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h1><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><ol>
<li>一个类有很多功能代码需要测试，为了测试，就需要写入main方法中</li>
<li>如果有很多个功能代码测试，就需要来回注销，切换很麻烦</li>
<li>如果可以直接运行一个方法，就会方便很多</li>
</ol>
<h3 id="介绍：-3"><a href="#介绍：-3" class="headerlink" title="介绍："></a>介绍：</h3><p>1. </p>
<h1 id="练习部分"><a href="#练习部分" class="headerlink" title="练习部分"></a>练习部分</h1><h2 id="快速入门部分"><a href="#快速入门部分" class="headerlink" title="快速入门部分"></a>快速入门部分</h2><ol>
<li><p>开发一个hello.java文件，输出：老王 is studying java！</p>
<ol>
<li>&#96;&#96;&#96;java<br>public class hello{<br>public static void main(String[] args) {<br>System.out.println(“lao wang is studying java”);<br><br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. 需注意的事项：记得吧类部分带上public class 带上，不要只写个方法</span><br><span class="line"></span><br><span class="line">## 制表符部分</span><br><span class="line"></span><br><span class="line">1. ![image-20220204140604059](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204140604059.png)</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      public class ChangeChar &#123;</span><br><span class="line">          public static void main(String[] args) &#123;</span><br><span class="line">              System.out.println(&quot;书名\t作者\t价格\t销量\n三国\t罗贯中\t120\t1000&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="进制部分"><a href="#进制部分" class="headerlink" title="进制部分"></a>进制部分</h2><ul>
<li><p>第一部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 0b110001100</span><br><span class="line">   =0*2^0 + 0*2^1 + 1*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 0*2^6 + 1*2^7 + 1*2^8</span><br><span class="line">   =0+0+4+8+0+0+0+128+256</span><br><span class="line">   =396</span><br><span class="line">02456</span><br><span class="line">=6*8^0 + 5*8^1 + 4*8^2 + 2*8^3</span><br><span class="line">=6+40+256+1024</span><br><span class="line">=1326</span><br><span class="line"></span><br><span class="line">0xA45</span><br><span class="line">=5*16^0 + 4*16^1 + 10*16^2</span><br><span class="line">=5 + 64 + 2560</span><br><span class="line">=2629</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="位运算练习"><a href="#位运算练习" class="headerlink" title="位运算练习"></a>位运算练习</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2|3</span><br><span class="line">1. 2的原码：00000000 00000000 00000000 00000010</span><br><span class="line">2. 2的补码：00000000 00000000 00000000 00000010</span><br><span class="line">3. 3的原码：00000000 00000000 00000000 00000011</span><br><span class="line">4. 3的补码：00000000 00000000 00000000 00000011</span><br><span class="line">5.2|3：00000000 00000000 00000000 00000010（都为1结果为1否则为0）</span><br><span class="line">6. 转为原码：00000000 00000000 00000000 00000010</span><br><span class="line">7.结果为：2</span><br><span class="line"></span><br><span class="line">2^3</span><br><span class="line">1. 2的原码：00000000 00000000 00000000 00000010</span><br><span class="line">2. 2的补码：00000000 00000000 00000000 00000010</span><br><span class="line">3. 3的原码：00000000 00000000 00000000 00000011</span><br><span class="line">4. 3的补码：00000000 00000000 00000000 00000011</span><br><span class="line">5.2^3:00000000 00000000 00000000 00000001(两位一个为0，一个为1，结果为1，否则为0)</span><br><span class="line">6.转为原码：00000000 00000000 00000000 00000001</span><br><span class="line">7.结果为1</span><br></pre></td></tr></table></figure>

<h2 id="switch练习"><a href="#switch练习" class="headerlink" title="switch练习"></a>switch练习</h2><ol>
<li><p><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162131420.png" alt="image-20220225162131420"></p>
<ul>
<li><img src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162214945.png" alt="image-20220225162214945"></li>
</ul>
</li>
<li><p>3,4,5为春季。6，7，8，为夏季，9,10,11位秋季。12,1,2为冬季</p>
<ul>
<li>&#96;&#96;&#96;java<br>Scanner scanner &#x3D; new Scanner(System.in);<br>    System.out.println(“请输入月份”);<br>    int month &#x3D; scanner.nextInt();<br>    if (month&gt;0 &amp;&amp; month&lt;&#x3D;12){<br>        switch (month){<br>            case 3:<br>            case 4:<br>            case 5:<br>                System.out.println(“春季”);<br>                break;<br>            case 6:<br>            case 7:<br>            case 8:<br>                System.out.println(“夏季”);<br>                break;<br>            case 9:<br>            case 10:<br>            case 11:<br>                System.out.println(“秋季”);<br>                break;<br>            case 12:<br>            case 1:<br>            case 2:<br>                System.out.println(“冬季”);<br>                break;<br>        }<br>    }else {<br>        System.out.println(“输入不合法”);<br>    }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 数组部分</span><br><span class="line"></span><br><span class="line">* 已知数组&#123;10,12,45,90&#125;。添加一个数使该数组依然是升序的</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//方法1：数组扩容➕冒泡排序</span><br><span class="line"></span><br><span class="line">package basics.chapterArray;</span><br><span class="line"></span><br><span class="line">import java.time.OffsetDateTime;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.concurrent.ForkJoinPool;</span><br><span class="line"></span><br><span class="line">public class exercisesArryHomeWork &#123;</span><br><span class="line">    /*</span><br><span class="line">    * 已知数组&#123;10,12,45,90&#125;</span><br><span class="line">    * 添加一个数使该数组依然是升序的</span><br><span class="line">    * */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;10,12,45,90&#125;;</span><br><span class="line">        char key;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        int inputnum;</span><br><span class="line">        int tmp;</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            int[] arr2 = new int[arr.length+1];</span><br><span class="line">            for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class="line">                arr2[i] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;请输入添加一个数&quot;);</span><br><span class="line">            inputnum = scanner.nextInt();</span><br><span class="line">            arr2[arr2.length-1] = inputnum;</span><br><span class="line">            arr = arr2;</span><br><span class="line">            for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class="line">                System.out.print(arr[i]+&quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;是否继续输入? y/n&quot;);</span><br><span class="line">            key = scanner.next().charAt(0);</span><br><span class="line">            if (key == &#x27;y&#x27;)&#123;</span><br><span class="line">                System.out.println(&quot;continue&quot;);</span><br><span class="line">            &#125;else if (key == &#x27;n&#x27;)&#123;</span><br><span class="line">                System.out.println(&quot;end&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                System.out.println(&quot;input error&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while (true);</span><br><span class="line">        System.out.println(&quot;============数组排序==============&quot;);</span><br><span class="line">        for (int i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;arr.length ; j++) &#123;</span><br><span class="line">                if (j&gt;=arr.length-1)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else if (arr[j]&lt;=arr[j+1])&#123;</span><br><span class="line">                    System.out.println(&quot;no change&quot;);</span><br><span class="line">                &#125;else if (arr[j]&gt;=arr[j+1])&#123;</span><br><span class="line">                    tmp = arr[j+1];</span><br><span class="line">                    arr[j+1] = arr[j];</span><br><span class="line">                    arr[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;=============输出==============&quot;);</span><br><span class="line">        for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+&quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>方法二：定位➕扩容</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//1. 先定义原数组 </span><br><span class="line">//2. 遍历数组，如果发现insertnum &lt; arr[i] ,说明i就是要插入的位置</span><br><span class="line">//3. 如果index 保留 index =i</span><br><span class="line">//4. 如果遍历完后，没有发现inserNum&lt;=arr[i] ，说明index = arr.length</span><br><span class="line">即：添加到arr的最后</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basics.chapterArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exercisesArrayHomeWorkmethod2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">90</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">insertNum</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//          数组定位</span></span><br><span class="line"><span class="comment">//        1.遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line"><span class="comment">//            2. 如果arr[i]的这个数大于insertNum则表示这个数的位置是要添加的数的位置</span></span><br><span class="line">            <span class="keyword">if</span> (insertNum&lt;=arr[i])&#123;</span><br><span class="line"><span class="comment">//                3. 用index接受这个位置信息</span></span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        4. 数组扩容添加</span></span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//        创建一个j，当插入前半部分时，j指向arr的数组的数不变。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j=<span class="number">0</span>; i &lt;arr2.length; i++) &#123;</span><br><span class="line"><span class="comment">//            如果i不等于上面得到的i的位置</span></span><br><span class="line">            <span class="keyword">if</span> ( i != index)&#123;</span><br><span class="line"><span class="comment">//                则将arr的数赋给对应的新数组</span></span><br><span class="line">                arr2[i] = arr[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                arr2[i] = insertNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr = arr2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="二维数组部分"><a href="#二维数组部分" class="headerlink" title="二维数组部分"></a>二维数组部分</h3><ol>
<li>&#96;&#96;&#96;java<br>&#x2F;&#x2F;            int[][] arr &#x3D;</li>
</ol>
</div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2022/10/27/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2022/10/27/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/";
            const title         = "「java基础笔记」";
            const excerpt       = `[TOC]
java基础这是快速复习java基础的笔记
重要编程思想化繁为简：现将复杂的功能转变成简单的需求。
先死后活：有限考虑固定的值，再考虑变量。
java概述知识点：
快速练习
使用黑窗口编译.java文件时，注意要把需要编译...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/java/" rel="tag">java</a>
                </div>
                <div class="pull-date">
                    <time datetime="2022-10-27T05:23:58.499Z" itemprop="dateModified">最后编辑：2022-10-27</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" Hello World" href="/2022/10/13/hello-world/">&lt; 上一篇</a>
            </div>
            
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/logo.webp" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">ninosBlog</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                4
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                4
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                2
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%9F%BA%E7%A1%80"><span class="toc-text">java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-text">重要编程思想</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E6%A6%82%E8%BF%B0"><span class="toc-text">java概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E7%BB%83%E4%B9%A0"><span class="toc-text">快速练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B6%E8%A1%A8%E7%AC%A6"><span class="toc-text">制表符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-2"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2.算数运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-text">3.关系运算符（比较运算符）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-x3D-%EF%BC%89%E3%80%81"><span class="toc-text">5.赋值运算符（&#x3D;）、</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">6.三元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">7.运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-text">进制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#amp-11011101"><span class="toc-text">  &amp;11011101</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-text">程序控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%EF%BC%88if-else-switch%EF%BC%89"><span class="toc-text">顺序控制（if,else,switch）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E6%8E%A7%E5%88%B6"><span class="toc-text">分支控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%8D%95%E5%88%86%E6%94%AF"><span class="toc-text">1）单分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E5%8F%8C%E5%88%86%E6%94%AF"><span class="toc-text">2）双分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%A4%9A%E5%88%86%E6%94%AF"><span class="toc-text">3）多分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%B5%8C%E5%A5%97%E5%88%86%E6%94%AF"><span class="toc-text">4）嵌套分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89switch%E5%88%86%E6%94%AF"><span class="toc-text">5）switch分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%EF%BC%88for-while-dowhile-%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF-%E9%87%8D%E7%82%B9-%EF%BC%89"><span class="toc-text">循环控制（for,while,dowhile,多重循环[重点]）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89for%E5%BE%AA%E7%8E%AF"><span class="toc-text">1）for循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-text">注意事项：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7"><span class="toc-text">编程技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89while%E5%BE%AA%E7%8E%AF"><span class="toc-text">2）while循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-1"><span class="toc-text">注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89do%E2%80%A6while%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="toc-text">3）do…while循环控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-2"><span class="toc-text">注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="toc-text">4）多重循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-text">练习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#continue-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">continue-跳转控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#return-%E8%B7%B3%E8%BD%AC%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">return-跳转控制语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-text">数组【重点】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">动态初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F1"><span class="toc-text">使用方式1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F2"><span class="toc-text">使用方式2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-text">注意事项和细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E6%9C%BA%E5%88%B6"><span class="toc-text">数组赋值机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D"><span class="toc-text">数组拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="toc-text">数组翻转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9"><span class="toc-text">数组扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-text">1）顺序查找：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-text">2）二分查找：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE%EF%BC%9A"><span class="toc-text">二维数组内存原理图：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">二维数组的使用方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BD%A2%E5%BC%8F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">对象在内存中存在的形式（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-text">类对象的内存分配机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-text">内存分析流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">成员方法的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">成员方法传参（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%9C%BA%E5%88%B6%EF%BC%88recursion%EF%BC%89"><span class="toc-text">递归机制（recursion）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E4%B9%98%EF%BC%88factorial%EF%BC%89"><span class="toc-text">阶乘（factorial）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">递归调用的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E7%BB%83%E4%B9%A0"><span class="toc-text">斐波拉契数练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88overload%EF%BC%89"><span class="toc-text">重载（overload）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-constructor"><span class="toc-text">构造器(constructor)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%E7%BA%A7%EF%BC%89"><span class="toc-text">面向对象（中级）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#idea"><span class="toc-text">idea</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85"><span class="toc-text">包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-text">包的命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85"><span class="toc-text">java常用的包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">封装（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89extends"><span class="toc-text">继承（重要）extends</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-text">继承作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-text">介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%88%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-text">继承的本质（分析）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE%EF%BC%9A"><span class="toc-text">内存原理图：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Super"><span class="toc-text">Super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">细节和注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-text">注意事项和使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">重写与重载的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">多态（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%93%E7%8E%B0"><span class="toc-text">多态的具体体现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8A%E4%BD%93%E7%8E%B0"><span class="toc-text">方法上体现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E6%80%81%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%8C%E9%9A%BE%E7%82%B9%EF%BC%8C%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">对象的多态（核心，难点，重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82-1"><span class="toc-text">注意事项和细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">多态的向上转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-text">多态的向下转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%B2%A1%E6%9C%89%E9%87%8D%E5%86%99%E4%B9%8B%E8%AF%B4"><span class="toc-text">属性没有重写之说</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceOf%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%8C"><span class="toc-text">instanceOf比较操作符，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6-%E9%87%8D%E8%A6%81"><span class="toc-text">java动态绑定机制(重要)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">多态的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-text">多态参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashCode"><span class="toc-text">hashCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-NaN"><span class="toc-text">toString</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finalize"><span class="toc-text">finalize()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%EF%BC%88debug%EF%BC%89"><span class="toc-text">断点调试（debug）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA%EF%BC%9A"><span class="toc-text">提示：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A-1"><span class="toc-text">介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE-1"><span class="toc-text">快捷键</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89"><span class="toc-text">面向对象（高级）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">类变量和类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-text">一、类变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-text">内存分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%B3%95"><span class="toc-text">定义语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE"><span class="toc-text">类变量访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">二、类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-text">格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">类方法调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-1"><span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95"><span class="toc-text">理解main方法语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3main%E6%96%B9%E6%B3%95"><span class="toc-text">深入理解main方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA"><span class="toc-text">提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-text">注意：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-text">案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-2"><span class="toc-text">使用细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-text">介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-3"><span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-6"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-text">细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AE%9E%E8%B7%B5-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">抽象类实践-模板设计模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">接口（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-7"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">内部类（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A-2"><span class="toc-text">介绍：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">内部类的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E6%9C%89%E7%B1%BB%E5%90%8D%EF%BC%89"><span class="toc-text">1）局部内部类（有类名）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA"><span class="toc-text">演示</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%BB%86%E8%8A%82"><span class="toc-text">注意细节</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E6%B2%A1%E7%94%A8static%E4%BF%AE%E9%A5%B0%EF%BC%89"><span class="toc-text">1）成员内部类（没用static修饰）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E4%BD%BF%E7%94%A8static%E4%BF%AE%E9%A5%B0%EF%BC%89"><span class="toc-text">2）静态内部类（使用static修饰）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-8"><span class="toc-text">介绍</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-text">枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%88enum%EF%BC%89"><span class="toc-text">枚举（enum）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-9"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE"><span class="toc-text">1）自定义枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%BD%BF%E7%94%A8enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">2）使用enum关键字实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="toc-text">enum常用方法说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-4"><span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Switch%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE"><span class="toc-text">Switch中使用枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">元注解（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89Retention-x2F-x2F-%E6%8C%87%E5%AE%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%8C%E4%B8%89%E7%A7%8DSOURCE-CLASS-RUNTIME"><span class="toc-text">1）Retention &#x2F;&#x2F;指定注解的作用范围，三种SOURCE,CLASS,RUNTIME</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89Target-x2F-x2F-%E6%8C%87%E5%AE%9A%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BD%BF%E7%94%A8"><span class="toc-text">2）Target     &#x2F;&#x2F;指定注解可以在哪些地方使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89Documented-x2F-x2F-%E6%8C%87%E5%AE%9A%E8%AF%A5%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%90%A6%E4%BC%9A%E5%9C%A8javadoc%E4%B8%AD%E4%BD%93%E7%8E%B0"><span class="toc-text">3）Documented    &#x2F;&#x2F;指定该注解是否会在javadoc中体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89Inherited-x2F-x2F-%E5%AD%90%E7%B1%BB%E4%BC%9A%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%B3%A8%E8%A7%A3"><span class="toc-text">4）Inherited    &#x2F;&#x2F;子类会继承父类注解</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">异常的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-10"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E5%9B%BE%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">异常体系图（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-text">常见的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E5%BC%82%E5%B8%B8"><span class="toc-text">常见的运行异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89NullPoniterException-%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8"><span class="toc-text">1）NullPoniterException 空指针异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ArithmeticException%E6%95%B0%E5%AD%97%E8%BF%90%E7%AE%97%E5%BC%82%E5%B8%B8"><span class="toc-text">2 ) ArithmeticException	数字运算异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89ArrayIndexOutOfBoundsException%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E5%BC%82%E5%B8%B8"><span class="toc-text">3）ArrayIndexOutOfBoundsException	数组下标异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89ClassCastException%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%BC%82%E5%B8%B8"><span class="toc-text">4）ClassCastException	类型转换异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%89NumberFormatException%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E4%B8%8D%E6%AD%A3%E7%A1%AE%E5%BC%82%E5%B8%B8"><span class="toc-text">5）NumberFormatException	数字格式不正确异常[]</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8"><span class="toc-text">常见的编译异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-11"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8-1"><span class="toc-text">常见的编译异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-text">异常处理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">异常处理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89try-catch-finally"><span class="toc-text">1）try-catch-finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89throws"><span class="toc-text">2）throws</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%9B%BE"><span class="toc-text">处理机制图</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%88%86%E7%B1%BB"><span class="toc-text">异常处理分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="toc-text">try-catch方式处理异常说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89java%E6%8F%90%E4%BE%9Btry%E5%92%8Ccatch%E5%9D%97%E6%9D%A5%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-text">1）java提供try和catch块来处理异常。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">2）基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-6"><span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">throw和throws的对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB-Wrapper"><span class="toc-text">包装类的分类   Wrapper</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">包装类和基本数据的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%92%8CString%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">包装类型和String类型的相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer%E7%B1%BB%E5%92%8CCharacter%E7%B1%BB%E5%B8%B8%E6%96%B9%E6%B3%95"><span class="toc-text">Integer类和Character类常方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">Integer面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E9%87%8D%E8%A6%81"><span class="toc-text">String(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3"><span class="toc-text">理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BCString-s-x3D-%E2%80%9Cxxx%E2%80%9D"><span class="toc-text">1）方式一：直接赋值String s &#x3D; “xxx”;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8-String-s-x3D-new-String-%E2%80%9Cxxx%E2%80%9D-%EF%BC%9B"><span class="toc-text">2）方式二：调用构造器 String s &#x3D; new String(“xxx”)；</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">String字符串的特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%81"><span class="toc-text">面试题、</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">String类的常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Strng%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">Strng常见的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer-%E9%87%8D%E8%A6%81"><span class="toc-text">StringBuffer(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%AF%B9%E6%AF%94StringBuffer"><span class="toc-text">String 对比StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">StringBuffer构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer-gt-String"><span class="toc-text">StringBuffer-&gt;String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StirngBuffer%E7%B1%BB%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">StirngBuffer类常见方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder-%E9%87%8D%E8%A6%81"><span class="toc-text">StringBuilder(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">StringBuilder常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E6%AF%94%E8%BE%83%E2%98%86"><span class="toc-text">String、StringBuffer、StringBuilder的比较☆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E7%8E%87"><span class="toc-text">效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%8C%E7%BB%93%E8%AE%BA"><span class="toc-text">使用原则，结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math"><span class="toc-text">Math</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Match%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">Match常用的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date-Calender-LoaclDate"><span class="toc-text">Date,Calender,LoaclDate.</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date-%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E6%9F%A5%EF%BC%8C%E6%80%8E%E4%B9%88%E7%94%A8%E5%8D%B3%E5%8F%AF"><span class="toc-text">Date[知道怎么查，怎么用即可]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">第一代日期类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar-%E6%97%A5%E5%8E%86"><span class="toc-text">Calendar(日历)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">第二代日期类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">第三代日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%A5%E6%9C%9F%E7%B1%BB-1"><span class="toc-text">第三代日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89DateTimeFormatter%E6%A0%BC%E5%BC%8F%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-text">2）DateTimeFormatter格式日期类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instant-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">Instant 时间戳</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System"><span class="toc-text">System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">常见方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-text">Arrays类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-12"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89-toString%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BD%A2%E5%BC%8F%EF%BC%8C%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%BC%E6%8E%A5%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%94%E5%9B%9E"><span class="toc-text">1） toString返回数组的字符串形式，将数组拼接成字符串返回</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-sort%E6%8E%92%E5%BA%8F%EF%BC%88%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-text">2)sort排序（自然排序和定制排序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89binarySearch-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-text">3）binarySearch 二分搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89copyOf%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">4）copyOf数组元素的复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-fill%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%A1%AB%E5%85%85"><span class="toc-text">5)fill数组元素的填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-equals-%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4"><span class="toc-text">6)equals 比较两个数组元素内容是否完全一致</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-asList-%E5%B0%86%E4%B8%80%E7%BB%84%E5%80%BC%EF%BC%8C%E8%BD%AC%E6%8D%A2%E6%88%90list"><span class="toc-text">7)asList 将一组值，转换成list</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer%E5%92%8CBigDecimal%E7%B1%BB"><span class="toc-text">Integer和BigDecimal类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-text">集合框架体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-text">集合体系图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection"><span class="toc-text">Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">Collection接口实现类的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Collection接口和常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Iterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89"><span class="toc-text">使用Iterator（迭代器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-6"><span class="toc-text">基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F"><span class="toc-text">迭代器的运行原</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E5%A2%9E%E5%BC%BA"><span class="toc-text">for循环增强</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="toc-text">基本语法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">List接口的常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-7"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">ArrayList底层机制和源码分析（重点）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-13"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector-%E5%92%8CArrayList%E6%AF%94%E8%BE%83"><span class="toc-text">Vector 和ArrayList比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList"><span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-text">说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-text">LinkedList底层机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList-%E5%92%8CLinkedList%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">ArrayList 和LinkedList的比较</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-text">set</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Set接口和常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set%E6%8E%A5%E5%8F%A3%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">set接口遍历方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-3"><span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet"><span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E"><span class="toc-text">HashSet底层机制说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet%E7%9A%84%E6%89%A9%E5%AE%B9%E5%92%8C%E8%BD%AC%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9C%BA%E5%88%B6"><span class="toc-text">HashSet的扩容和转成红黑树机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashSet"><span class="toc-text">LinkedHashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-text">TreeSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">map接口和常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-text">Map遍历方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-text">HashMap底层机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable"><span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties"><span class="toc-text">Properties</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections"><span class="toc-text">Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">Collections工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9D%87%E4%B8%BAstatic%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">排序操作（均为static方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2"><span class="toc-text">查找、替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-14"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-5"><span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">泛型方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85"><span class="toc-text">知识点补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JUnit"><span class="toc-text">JUnit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A-3"><span class="toc-text">介绍：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%83%A8%E5%88%86"><span class="toc-text">练习部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E9%83%A8%E5%88%86"><span class="toc-text">快速入门部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E9%83%A8%E5%88%86"><span class="toc-text">进制部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%BB%83%E4%B9%A0"><span class="toc-text">位运算练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E7%BB%83%E4%B9%A0"><span class="toc-text">switch练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%83%A8%E5%88%86"><span class="toc-text">二维数组部分</span></a></li></ol></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/">java</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/">安装文档</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/">博客相关</a><span class="category-list-count">1</span></li></ul></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/java/" style="font-size: 0.6em;">java</a> <a href="/tags/%E5%AE%89%E8%A3%85/" style="font-size: 0.8em;">安装</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/10/27/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"><i class="fa  fa-book"></i> java基础笔记</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/10/13/hello-world/"><i class="fa  fa-book"></i> Hello World</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/09/24/Node.js%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%88%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%EF%BC%89/"><i class="fa  fa-book"></i> Node.js安装与配置（详细步骤）</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/09/24/hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"><i class="fa  fa-book"></i> hexo+github搭建博客</a>
            
          
        
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/CandyUnion"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        <li><a target="_blank" rel="me" href="https://nya.one/@Candinya"><i class="fa fa fa-share-alt-square"></i></a></li>
                        <li><a target="_blank" rel="nofollow" href="https://github.com/Candinya"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 nino'sBlog 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by John Doe.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>




    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/vendors/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>