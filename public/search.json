[{"title":"java基础笔记","date":"2022-10-27T04:40:00.000Z","url":"/2022/10/27/java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","tags":[["java","/tags/java/"]],"categories":[["学习笔记","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["java","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/"]],"content":"[TOC] java基础这是快速复习java基础的笔记 重要编程思想化繁为简：现将复杂的功能转变成简单的需求。 先死后活：有限考虑固定的值，再考虑变量。 java概述知识点： 快速练习 使用黑窗口编译.java文件时，注意要把需要编译的java文件编码设置与cmd黑窗口编码相同 java执行流程分析 制表符 2. ```java @author 标明开发该类模块的作者 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @param 对方法中某参数的说明 @return 对方法返回值的说明 @exception 对方法可能抛出的异常进行说明 @author 作者名 @version 版本号 其中，@author 可以多次使用，以指明多个作者，生成的文档中每个作者之间使用逗号 (,) 隔开。@version 也可以使用多次，只有第一次有效 使用 @param、@return 和 @exception 说明方法 这三个标记都是只用于方法的。@param 描述方法的参数，@return 描述方法的返回值，@exception 描述方法可能抛出的异常。它们的句法如下： @param 参数名 参数说明 @return 返回值说明 @exception 异常类名 说明 注意事项： 变量表示内存中的一个储存区域，[不同的变量，类型不同，占用的空间大小不同，比如：int 4个字节，double 8个字节] 该区域有自己的名称[变量名]和类型[数据类型] 变量必须先声明，后使用，有着自身的顺序 该区域的数据可以在同一类型范围内不断变化 变量在同一个作用域内不能重名 变量&#x3D;变量名+值+数据类型，变量三要素 运算符 +号的使用 当左右两边为数值类型的时候，做加法运算 当左右两边有一方为字符串类型时，做拼接运算 数据类型java数据类型 基本数据类型 数值型 整数类型，存放整数（byte[1],short[2],int[4],long[8]) 浮点（小数）类型（float[4]，double[8]) 字符型（char[2]），存放单个字符’a’ 布尔型（Boolean[1]），存放true，false 引用数据类型（面向对象部分讲解） 类（class） 接口（interface） 数组（[]） 八大基本数据类型 【byte，short，int，long，float，double】，char，Boolean 浮点数据类型 默认情况下输入的字符默认是double类型的 如果想改成float类型需要在数值后面加上f或F &#96;&#96;&#96;javafloat a &#x3D; 1.1 &#x2F;&#x2F;错误float a &#x3D; 1.1F &#x2F;&#x2F;正确double b &#x3D; 1.1 &#x2F;&#x2F;正确double b &#x3D; 1.1F &#x2F;&#x2F;正确 &#96;&#96;&#96;java&#x2F;&#x2F;类似问题的解决方法double a &#x3D; 2.7 ;double b &#x3D; 8.1&#x2F;3 ;&#x2F;&#x2F;理论上数学得数是2.7System.out.println(a);&#x2F;&#x2F;2.7System.out.println(b); if(a &#x3D;&#x3D; b){&#x2F;&#x2F;这样的写法会出问题System.out.println(“相等”);} &#x2F;&#x2F;可以使用计算其差值if(Math.abs(a-b)&lt;0.001){System.out.println(“差值非常小，到我规定的精度内，认为相等”); &#x2F;&#x2F; Math方法调用java API } 注意事项 多重类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的哪种数据类型，然后再进行计算 （ byte , short ) 和 char之间不会相互转换，当把一个具体的数赋给byte时。 先判断该数是否在byte范围内，如果是就可以 byte，short，char 三者可以进行计算，在计算时都会先转换成int类型 &#96;&#96;&#96;javabyte b1 &#x3D; 1;byte a1 &#x3D; 1;short b2 &#x3D; 1;short s2 &#x3D; b1 + b2&#x2F;&#x2F;错误&#x2F;&#x2F;因为计算时会转换成int类型，int不能再赋给比它小的类型shortint s2 &#x3D; b1 + b2 &#x2F;&#x2F;正确byte s3 &#x3D; a1 + b1&#x2F;&#x2F;错误&#x2F;&#x2F;byte，short，char,只要涉及计算都会转换为int类型，所以错误 3、基本数据类型和String类型的转换 介绍 在程序开发中，我们经常需要吧基本数据类型转换成String类型，或String转基本数据类型 方式 基本转String 基本数据类型的值+” “ &#96;&#96;&#96;java&#x2F;&#x2F;例int n1 &#x3D; 123;float f &#x3D; 2.3f;double b &#x3D; 4.5;String str1 &#x3D; n1 +” “;String str2 &#x3D; f +””;String str3 &#x3D; b +””; 注意事项 string转换基本类型时，要确保string类型能够转成有效数据，可以吧’123’转换成一个整数，但不能吧”hello”转换成一个整数 运算符运算符1.简介 是一种特殊符号，表示数据的运算、赋值和比较等 种类 算数运算符 赋值运算符 关系运算符(比较运算符) 逻辑运算符 位运算符 [ 需要二进制基础 ] 三元运算符 2.算数运算符 对数值类型的变量进行运算的 预览： 注意事项 取模 再%的本质，看一个公式 a % b &#x3D; a-a &#x2F; b * b 面试题 答案为 1 运行步骤为 (1)先把 i 的值赋给一个临时变量tmp (2)再进行计算i++，结果为i&#x3D;2 (3)tmp的值重新赋给i，此时i &#x3D;1 答案为2 运行步骤为 (1)再进行计算i++，结果为i&#x3D;2 (2)再将2移到临时变量tmp (3)tmp赋给 i 3.关系运算符（比较运算符） 介绍 关系运算符的结果都是boolean型， 通常用在if条件语句结构条件中 关系运算符组成的表达式成为关系表达式 预览图 4.逻辑运算符预览： &#96;&#96;&#96;&amp;&amp;（短路与） 只有两个条件都为true ，才为true &#x2F;&#x2F;如果第一个条件为false，则后面的条件不执行，直接输出flase，效率高 &amp; （逻辑与） 只有两个条件都为true ，才为true &#x2F;&#x2F;两个条件都执行，效率低 5.赋值运算符（&#x3D;）、分类： 基本赋值运算符 &#x3D; int a &#x3D; 10； 复合赋值运算符 复合运算符会进行类型转换 6.三元运算符 语法：条件表达式？ 表达式1: 表达式2； 运算规则： 如果条件表达式为true，运算后的结果是表达式1； 如果条件表达式为false，运算后的结果是表达式2； 口诀：【一灯大师：一真大师（如果为真，返回1）】 例： 本质就是if，else语句 7.运算符优先级 小结：优先级排名 () ，{}等优先级最高 单目运算&#x3D;&#x3D;a ，–a等； 算术运算符+- 位移运算符 比较运算符 逻辑运算符 三元运算符 赋值运算符 标识符标识符的规则和规范 java中对各种变量、方法和类的命名使用的字符成为标识符。 &#96;&#96;&#96;javaint num &#x3D;1;&#x2F;&#x2F; num就是标识符 进制介绍对于整数，有四种表达方式 二进制（Bin&#x2F;B）：0,1，满2进1，以0b或0B开头 八进制（OCT&#x2F;O）：0-7，满8进1。以数字0开头表示 十进制（DEC&#x2F;D）：0-9，满10进1 十六进制（HEX&#x2F;H）：0-9及A(10)-F(15)，满16进1.以0x或0X开头表示。此处的A-F不区分大小写 &#96;&#96;&#96;javaint n1 &#x3D; 0b1010;int n2 &#x3D; 01010;int n3 &#x3D; 1010;int n4 &#x3D; 0x10101; 八进制转十进制 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和。 &#96;&#96;&#96;例：0234转成十进制0 234&#x3D;48^0 + 38^1 + 2*8^2&#x3D;4+24+128&#x3D;156 第一部分练习 第二组 十进制转二进制 规则：将该数不断除2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制 &#96;&#96;&#96;将34转换成二进制34%2 余017%2 余18%2 余04%2 余02%2 余01%2 余1反着读结果：0b100010 &#x2F;&#x2F;前缀0b的意思为二进制正确答案为：0b00100010因为一个字节二进制的是八位，34的出的结果是六位所以前面需要多加两个0 十进制转十六进制 规则：将该数不断除16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的十六进制 &#96;&#96;&#96;例：237答案为 ED 二进制转十六进制 从低位开始，将二进制数的每四位一组，转成对应的十六进制即可 &#96;&#96;&#96;11010101&#x3D;0xD51110010110&#x3D;0x396 每四个转成十进制再拼起来 十六进制转二进制 规则：将八进制数每一位，转成对应的4位的二进制数 &#96;&#96;&#96;23B&#x3D;2(0010)3(0011)B(1011)&#x3D;001000111011AB29&#x3D;A(1010)B(1011)2(0010)9(1001)&#x3D;1010101100101001 |：按位或 规则：两位有一个为1，结果为1，否则为0 &#96;&#96;&#96;10011010 &amp;11011101 &#x3D;11011111&#x2F;&#x2F; 两个有一个1结果才为1 ~：按位取反 规则：0为1,1为0 练习部分 运算符&gt;&gt;，&lt;&lt;和&gt;&gt;&gt;运算规则 算数右移&gt;&gt;；低位溢出，符号位不变，并用符号位补溢出的高位 &#96;&#96;&#96;int a &#x3D; 1&gt;&gt;2;1:00000000 00000000 00000000 000000011 &gt;&gt;2 &#x2F;&#x2F;相当于把最后边的01去掉用符号位补上结果：00000000 00000000 00000000 00000000最后结果为0 简便的方法1&gt;&gt;2 &#x3D; 1&#x2F;2&#x2F;2&#x3D; 015&gt;&gt;2 &#x3D; 15&#x2F;2&#x2F;2&#x3D;3 &#x2F;&#x2F;取整 3.&gt;&gt;&gt;逻辑右移，也叫无符号右移，运算规则是：低位溢出，高位补0 程序控制结构顺序控制（if,else,switch）介绍程序从上到下逐行执行，中间没有任何判断和跳转 分支控制1）单分支基本语法： 说明：当条件表达式为true时，则执行{}内的代码。false就不执行。如果只有一条执行语句，可以省略{}。但不建议省略 2）双分支基本语法： 3）多分支基本语法： 流程图： else只能有一个执行入口 特别说明： 多分支可以没有else，如果所有条件都不成立，则一个执行入口都没有 如果有else，如果所有的条件表达式都不成立，则默认执行else代码块。 练习： 4）嵌套分支介绍： 一个分支完整的嵌套了另一个分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支。 规范：不建议超过三层（可读性不好） 基本语法： 5）switch分支基本语法： switch 关键字,表示swtich分支 表达式 对应一个值 case常量1：当表达式的值等于常量1，就执行语句块1 break：表示退出switch 如果case 常量1 匹配，就执行语句块1，如果没有则继续case 常量2； 如果一个都没有匹配上，就执行default Switch流程图： 注意： 穿透 如果case1 没有break 则case不进行判断直接执行case2 的语句块 注意事项和细节 表达式数据类型，应和case后的常量类型一致，或者是可以自动转换成可以相互比较的类型，比如输入的是字符，而常量是int Switch(表达式)中表达式的返回值必须是：（byte，short，int，char，enum，String） case子句中的值必须是常量，不能是变量 default子句是可选的，当没有匹配的case时，执行default。default语句是可选的，当没有匹配的任何常量，则没有任何输出。 break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有则会出现穿透现象，使程序执行后面所有的case语句块，除非遇到break； 练习 switch 和if的比较 如果判断的具体数值不多，而且符合byte，short，int，char，enum，string类型虽然这两个语句都可以用，建议用switch 其他情况，对区间判断，对结果为boolean配型判断，使用if，if的使用范围更广 循环控制（for,while,dowhile,多重循环[重点]）1）for循环 基本语法 说明 for关键字，表示循环控制 for有四要素，1）循环变量初始化，2）循环条件，3）循环操作，4）循环变量迭代 循环操作，这里可以有很多条语句，也就是我们要执行的代码块 如果 循环操作(语句)只有一条语句，可以省略{}，建议不要省略 例子： for循环流程图 注意事项： 循环条件返回一个布尔值(Boolean) for（；循环条件；）中的初始化和变量迭代可以写到其他地方，但两边的分号不能省略 00 12 24 编程技巧 化繁为简：将复杂的需求拆解成简单的需求 先死后活：先考虑固定的值，然后转成可以灵活变化的值 练习 打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活] &#96;&#96;&#96; 2）while循环基础语法： 说明： while循环也有四要素 只是四要素放的位置，和for不一样 流程图 注意事项： 循环条件是返回布尔值 while循环是先判断再执行语句 3）do…while循环控制基础语法： 说明: do while 是关键字 也有循环四要素，只是位置不一样 先执行，在判断，也就是说，一定会执行一次 最后有一个分号 while和do… while区别 while是先判断再执行 do .. while是先执行再判断 流程图： 注意事项： 循环条件是返回一个布尔值的表达式 do…while 循环是先执行后判断，因此它至少执行一次 4）多重循环介绍 讲一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do …while均可以作为外层循环和内层循环 。【建议一般使用两层，最多不超过三层，否则代码可读性很差】 实质上，嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环 例：设外层循环次数为m次，内层为n次。则内层循环体实际上需要执行m*n次 练习 统计3个班成绩情况，每个班有5名同学，求出各个班的平均成绩和所有班级的平均分【学生的成绩从键盘输入】 &#96;&#96;&#96;javaScanner scanner &#x3D; new Scanner(System.in);&#x2F;&#x2F; int clss &#x3D; 1; int stu &#x3D;0; double sum &#x3D; 0; for (int i &#x3D; 1; i &lt;&#x3D;3 ; i++) { for ( int j &#x3D; 1;j&lt;&#x3D;5;j++){ System.out.println(“请输入”+i+”班”+j+”成绩”); int s &#x3D; scanner.nextInt(); sum &#x3D; sum + s; } System.out.println(i+”班的平均分为：”+(sum &#x2F; 5)); sum &#x3D;0; } 打印空心金字塔 &#96;&#96;&#96;java&#x2F;&#x2F;可手动修改的 改为菱形 以while循环为例流程图： 注意事项 break语句出现在多层嵌套语句块时，可以通过标签指明要终止的是哪一层语句块 标签的基本使用 break语句可以指定退出哪层 label1是标签，由程序员决定 break后指定到哪个label就退出到哪里 在实际开发中，尽量不要使用标签 如果没有指定break，默认退出最近的循环体 continue-跳转控制语句介绍： continue语句用于结束本次循环，继续执行下次循环。 continue语句多出现在多层嵌套的循环语句中时，可以用过标签指明要跳过的是哪一环，这个和前面的标签使用一样 基本语法 流程图： return-跳转控制语句介绍： return使用在方法，表示跳出所在的方法 注意： 如果吧return放在main方法中会退出程序 数组【重点】数组介绍 数组可以存放 多个同一类型 的数据。数组也是一种数据类型，是引用数据类型。 即：数（数据）组（一组）就是一组数据 案例（快速入门）： 动态初始化使用方式1先new出一个数组，再动态的给它赋值。 数组的定义： 数据类型 数组名[] &#x3D; new 数据类型[大小] 数据类型[] 数组名 &#x3D; new 数据类型[大小] 以上两种写法的效果都是等价的 例： 内存图： 例： 使用方式2 先声明数组 语法： 数据类型 数组名[]; 或 数据类型[] 数组名; int a[] &#x2F; int[] a; 创建数组 语法： 数组名 &#x3D; new 数据类型 [ 大小 ]; a &#x3D; new int[5]; 解释：1.先声明，在内存中相当于创建了一个空的变量，这时没有任何左右 2.再创建，才使得这个数组有意义。不写的话会报空指针异常 静态初始化语法： 数据类型 数组名[] &#x3D; {元素值，元素值，元素值，……} 案例跳转 注意事项和细节 数组是多核相同的数据类型的组合，实现对这些数据的统一管理 数组中的元素可以使任何数据类型，包括基本数据类型和引用数据类型，但不能混用 数组创建后，如果没有赋值，会有默认值：int 0 , short 0 , byte 0 ,long 0, float 0 ,double 0.0 , char \\u0000, boolean false , String null; 使用数组的步骤： 声明数组并开辟空间 给数组各个元素赋值 使用数组 数组的下表是从0开始的 数组下表必须在指定范围内使用，否则报：下标越界异常，比如: int[] arr &#x3D; new int [5] ; 则有效下标为0-4 数组属于引用数据类型，数组行数据是对象（object） boolean 类型没有赋值的情况下默认false 数组赋值机制 基本数据类型赋值，这个值就是具体的数据，而且相互不影响 数组再默认情况下是引用传递，赋的值是地址。赋值方式为引用传递 数组拷贝案例： jvm内存图分析: 数组翻转案例： 要求：需要把数组的元素内容反转。 arr { 1 , 2 , 3 , 4 , 5 }–&gt;{5 , 4 , 3 , 2 , 1} 方式1： 方式2 数组扩容数组缩减同理 数组添加 要求：实现动态的给数组添加元素效果，实现对数组扩容 1）原始数组使用静态分配int[] arr &#x3D; {1,2,3} 2）增加的元素4，直接放在数组的最后 arr &#x3D; {1,2,3,4} 3）用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y&#x2F;n 排序介绍 排序的分类： 内部排序： 指将需要处理的所有数据都加载到内部存储中进行排序。包括（交换式排序法，选择时排序法和插入式排序法） 外部排序法： 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。 冒泡排序基本思想：通过对待排序序列从后向前（从下标较大的元素开始），一次比较相邻元素的值若发现逆序则交换，使值较大的元素从前移向后部。像水下的气泡一样逐渐向上冒。 特点： 一共有五个元素 一共进行了四轮排序，可以看成外层循环 每1轮排序可以确定一个数的位置，比如第一轮排序确最大数，第二轮确定第二大的数 的位置，依次类推 当进行比较时，如果前面的数大于后面的数，就交换 案例说明: 将五个无序：24,69,80,57,13使用冒泡排序，从小到大排序 查找1）顺序查找： 2）二分查找：算法部分讲解补充 二维数组介绍：一个数组内，还有数组 要理解的点： 看到定义形式就可知道是不是二维数组 二维数组的每一个元素都是一维数组 二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历 案例： 二维数组内存原理图： 二维数组的使用方式方式1：动态初始化 方式2：动态初始化 方式3：动态初始化 列数不确定 java不强制每个数组的长度都一样 例： 杨辉三角形 提示： 第一行有一个元素，第n行有n个元素 第一行的第一个元素和最后一个元素都是1 从第三行开始，对于非第一个元素和最后一个元素的元素的值，arr[i],[j] &#96;&#96;&#96;java中间的数为：arr[i][j] &#x3D; arr[i-1][j]+ arr[i-1][j-1] 面向对象类与对象1）类是抽象的，概念的。代表一类事物，比如人类，猫类，狗类。。。。，即它是实例 2） 对象是具体的，实际的，代表一个具体事务，即是实例 3） 类是对象的模板，对象是类的一个个体，对应一个实例 属性可以使基本数据类型，也可以是引用数据类型(对象，数组) 对象在内存中存在的形式（重要）java内存的结构分析： 栈：一般存放基本数据类型（局部变量） 堆：存放对象（Cat cat ，数组等） 方法区：常量池（常量，比如字符串），类加载信息 示意图：[Cat(name,age,price)] 对象和数组都是引用类型 如果存放的数据，类型是基本数据类型则存放在堆中，引用的数据类型则存放在方法区 注意事项1） 属性的定义语法同变量，示例：访问修饰符 属性类型 属性名; 2） 属性的定义类型可以为任意类型，包含基本类型或引用类型 3） 属性如果不赋值，有默认值，规则和数组一致 创建对象 先声明在创建 直接创建 访问属性 类对象的内存分配机制 成员方法介绍： 用于描述对象的行为，成为方法 案例： 内存分析流程图 方法的优点： 提高了代码的复用性 可将实现的细节封装起来，然后提供其他用户来调用 成员方法的定义 参数列表：表示成员方法输入cal(int n) 数据类型(返回类型)：表示成员方法输出，void表示没有返回值 方法主体:表示为了实现某一功能代码块 return语句不是必须的 注意事项 访问修饰符 &#96;&#96;&#96; java访问修饰符 返回数据类型\\void（表示没有返回值） 方法名(形参列表…){&#x2F;&#x2F;方法体语句;return；&#x2F;&#x2F;返回值} 访问修饰符（作用是控制 方法的适用范围） 如果不写默认访问，[有四种：public protected 默认] 一个方法最多有一个返回值 返回多个结果，返回数组 返回类型可以为任意类型，包含基本类型和引用类型(数组，对象) 如果方法要求有返回数据类型，则方法体中最后执行的语句必须为return值；而且要求返回值类型必须和return的值的类型一致或兼容 如果方法是void，则方法体照片那个可以没有return语句，或者 只写 return； 方法命名；使用驼峰命名法，最好见名知意 方法体 ​ 里面写完成功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义 调用细节 同一类中的方法调用：直接调用即可 直接输入：方法名（参数）即可 跨类中的方法A类调用B类方法：需要通过对象名调用。比如：对象名.方法名(参数) 成员方法传参（重要）基本数据类型 基本数据类型，传递的值（拷贝），形参的任何改变不影响实参！ 引用数据类型 引用类型传递的是地址（传递也是值，但值是地址），可以通过形参影响实参。 递归机制（recursion）递归调用的本质，是方法的调用 栈是先进后出，先出后进（所以图中的test栈2先输出，然后是3，4） 每次这个栈内的方法执行完成后，外边的方法（图中test方法）都会执行一边 哪里调用就返回给哪里 阶乘（factorial） 递归调用的规则 执行一个方法时，就创建一个新的受保护的独立空间（栈空间） 方法的局部变量是独立的，不会相互影响，比如n变量 如果方法中使用的是引用类型变量（比如数组，或者对象），就会共享该引用类型的数据。 递归必须像退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:) 当一个方法执行完毕，或者遇到return，就会执行完毕或者返回时，该方法也就执行 斐波拉契数练习 解析图 重载（overload）介绍：java允许同一个类中，多个同名方法的存在，但要求形参列表不一致！！！ 好处： 减轻了起名的麻烦 减轻了记名的麻烦 注意细节： 方法名：必须相同 形参参列表：必须不同（参数类型或个数或顺序，至少有一样不同） 返回类型：无要求 可变参数介绍： java允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法。 基本语法： 案例 注意事项： 可变参数的实参可以为0或任意多个 可变参数的实参可以为数组 可变参数的本质就是数组 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后 一个形参列表中只能出现一个可变参数 作用域 在java中，主要的变量就是属性（成员变量）和局部变量 我们说的局部变量一般是指在成员方法中定义的变量 作用域的分类 全局变量：也就是属性，作用域为整个整体 局部变量：也就是除了属性以外的其他变量，作用域为定义它的代码块中 全局变量可以不赋值，直接使用，因为有默认值（也可指定值），局部变量必须赋值后，才能使用，因为没有默认值。 、 注意事项和细节 属性和局部变量可以重名，访问时遵循就近原则 在一个作用域中，比如在同一个成员方法中，两个局部变量，不能重 属性生命周期较长，伴随对象的创建而创建，伴随对象的死亡而死亡。局部变量，生命周期较短，伴随它的代码块的执行而创建，伴随代码块的结束而死亡 作用域范围不同： 全集变量&#x2F;属性：可以被本类使用，或其他类使用（通过对象调用） 局部变量：智能在本类中对应的方法中使用 修饰符不同 全局变量&#x2F;属性可以加修饰符 局部变量不可以加修饰符 构造器(constructor)基本介绍：构造方法又称构造器(constructor)，是类的一种特殊方法，它的主要作用是完成对新的对象初始化。 特点： 方法和类名相同 没有返回值 在创建对象时，系统会自动调用该类的构造器完成对对象的初始化 需求案例： 案例1:创建一个人类的对象，显示把一个对象创建好后，再给他的年龄姓名等属性赋值，如果现在我要求，在创建人类对象的时候，就直接指定这个对象的年龄和姓名。 此时可以使用构造器 基本语法： 构造器的修饰符可以默认，也可是public，protected，private 构造器没有返回值,也不能写void 方法名和类名必须一样 参数列表和成员方法一样的规则 构造器的调用系统完成 细节： 一个类可以定义多个不同的构造器，即构造器的重载 比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄 构造器是完成对象的初始化，并不是创建对象 如果程序员没有定义构造器，系统会自动生成一个默认的无参构造器(也叫默认构造方法),比如Person(){ } 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的午餐构造器，除非显示的定义一下，即自己再手写一边Person(){ } 对象创建流程 加载Person.class，只会加载一次。 在堆中分配空间(地址) 完成对象初始化 3.1 默认初始化 age&#x3D;0 name &#x3D; null 3.2 显示初始化 age&#x3D;90,name&#x3D;null, 3.3 构造器的初始化 age&#x3D;20，name&#x3D;zhangsan 在对象堆中的地址，返回给p(也可理解成对象的引用) this案例： 介绍： java虚拟机会给每个对象分配this，代表当前对象。 分析图： 每一个对象都有一个隐藏的属性this 这个this它指向自己 简单说，哪个对象调用this就指向哪个对象 注意事项： this关键字可以用来访问本类的属性，方法，构造器 this用于区分当前类的属性和局部变量 访问成员方法的语法：this.方法名(参数列表)； 访问构造器语法：this(参数列表);&#x2F;&#x2F;注意，只能在构造器中访问另外一个构造器(当有访问构造器的语法this时，必须放在构造器语句里的第一行 ) &#96;&#96;&#96;javaclass T{String name;int age;&#x2F;&#x2F;无参构造器public T(){ &#x2F;&#x2F;当执行无参构造器时，我们想去访问有参构造器 this(“zhangsan”,12);&#x2F;&#x2F;这样访问有参构造器 &#x2F;&#x2F;当有访问构造器的语法this时，必须放在构造器语句里的第一行 System.out.println(“T() 构造器”);}&#x2F;&#x2F;有参构造器public T(String name,int age){ System.out.println(“T(String name,int age) 构造器”);}} 面向对象（中级）idea快捷键 模板 设置路径 file -&gt; settings -&gt; editor -&gt; live templates-&gt; 可以自己自定义，也可查看预设的模板 包三大作用： 区分相同名字的类 当类不同的时候，可以很好的管理 控制访问范围 基本语法： package com.xxx; package 关键字，表示打包 com.xxx:表示包名 包的本质 就是创建不同的文件&#x2F;目录保存文件 包的命名规则： 智能包含数字，字母，下划线，小圆点，但不能用数字开头，不能是关键字或保留字 规范 一般是小写字母+小圆点 com.公司名.项目名.业务模块名 例：com.alibaba.taobao.login java常用的包 包的引入 建议需要什么类就引入什么类，不建议(java.util.* )全部引入 访问修饰符介绍 java提供了四种访问控制修饰符号控制方法和属性(成员变量)的访问权限(范围) 公开级别：public 修饰，对外公开 受保护级别：用protected修饰，对子类和统一包中的类公开 默认级别：没有修饰符号，向同一包的内公开 私有级别：用private修饰，只有类本身可以访问，不对外公开 注意事项： 修饰符可以用修饰类中的属性，成员方法以及类 只有默认的和public才能修饰类，并且遵循上述访问权限的特点 成员方法访问规则和属性完全一样 封装（重要）封装（encapsulation）就是把抽象出来的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作。 封装的好处 隐藏实现细节 方法(连接数据库)&lt;—-调用(传入参数) 可对数据进行验证，保证安全合理 封装的实现步骤 ( 三 步 ) 将属性进行私有化，private 提供一个公共的set方法，对属性进行判断并赋值 提供一个公共的get方法，用于获取属性的值 继承（重要）extends继承作用：解决代码复用性 介绍：相当多个类存在相同的属性（变量） 和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些属性和方法，只需通过extend来声明继承父类即可 基本语法 示意图 注意事项 子类继承了所有的属性和方法，但是私有属性不能再子类直接访问，需要通过公共方法访问 子类必须调用父类的构造器，完成父类的初始化 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中调用super去指定使用父类的那个构造器完成对父类的初始化工作，否则编译不通过 如果希望指定去调用父类的某个构造器，则显式的调用一下{super ( 参数 ) } super在使用时，需要放在第一行。super只能在构造器中使用 super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器 java所有类都是Object的子类，是所有类的基类 Ctrl+H可以看到类的继承关系 父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类) 子类对多只能继承一个父类(指直接传承)，即java中是单继承机制。 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系 person is a music person music music extends person 继承的本质（分析）当子类创建号对象以后，建立查找关系 内存原理图： Super基本介绍super代表父类的构造器，用于访问父类的属性，方法，构造器 基本语法 访问父类的属性，但不能访问父类的private属性[案例] super.属性名； 访问父类的方法名，不能访问父类的private方法 super.方法名(参数列表); 访问父类的构造器(这点前面用过); super(参数列表); 只能放在构造器的第一句并只能出现一句 细节和注意事项 调用父类的构造器的好处（分工明确，弗雷属性由父类初始化，子类的属性由子类初始化） 当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果 &#96;&#96;&#96;java案例class A{public void cal(){ System.out.println(“a类的cal方法”);}}class B{public void sum(){ System.out.println(“b类的sum方法”);&#x2F;* 此时有三种方法调用cal 1. 找cal方法时，顺序是：先找本类，如果有，开始调用。 2. 如果没有。则找父类（如果有则调用） 3. 如果父类没有则继续找父类的父类。以此类推。直到Object类‘ 提示：如果查找的过程中找到了，但不能访问，则报错 如果查找的过程中没找到。则提示没找到&#x2F; cal(); this.cal();&#x2F;&#x2F;等价cal（）； &#x2F; 跳过本类直接查找父类 其他规则一样 *&#x2F; super.cal();}} 注意事项和使用细节 子类的方法的形参列表，方法名称，要和父类的方法的参数，方法名称完全一样。 子类方法的返回类型和父类方法返回类型一样，或者父类返回类型的子类 比如 父类返回类型是Object，子类方法返回类型是String 子类方法不能缩小父类方法的访问权限public &gt; protected &gt; 默认(default ) &gt; private 重写与重载的区别 练习 多态（重要） 多态可以提高代码的复用性 基本介绍多态(多种)（状态） 方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础之上的额 多态的具体体现方法上体现 方法的多态 重写和重载就体现多态 案例说明 重载上体现 对某一方法，传入不同的参数，调用不同的方法 对象的多态（核心，难点，重点）要记住几点： 一个对象的编译类型和运行类型可以不一致 &#96;&#96;&#96;例如：Animal animal &#x3D; new Dog();【animal编译类型时Animal，运行类型是Dog】animal &#x3D; new Cat(); 【animal的运行类型变成了Cat，编译类型仍然是Animal】 运行类型是可以变化的 编译类型看定义时 &#x3D; 号的左边，运行类型看 &#x3D; 号的右边 &#96;&#96;&#96;Animal animal &#x3D; new Dog() animal就是变异类型，dog就是运行类型 注意事项和细节多态的前提是：两个对象(类)存在继承关系 多态的向上转型 本质：父类的引用指向了子类的对象 语法：父类类型 引用名 &#x3D; new 子类类型()； 特点：编译类型看左边，运行类型看右边 可以调用父类中的所有成员(需要遵循访问权限), 不能调用子类中特有成员 （因为在编译阶段，不能调用那些成员，是由编译类型来决定的。） 最终运行效果按子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法 然后调用，与前面的方法调用规则一致 多态的向下转型语法：子类类型 引用名 &#x3D; (子类类型) 父类引用; 只能强转父类的引用，不能强转父类的对象 要求父类的引用必须指向的是当前目标类型的对象 可以调用子类类型中所有的成员 属性没有重写之说属性的值看编译类型 instanceOf比较操作符，用于判断对象的类型是否为xx类型或xx类型的子类型 判断对象的运行类型是否为xx类型，或这个xx类型的子类型 java动态绑定机制(重要) 当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定 当调用对象属性时，没有动态绑定机制，哪里声明，那里使用 多态的应用1）多态数组 数组的定义类型为父类类型，里面保存的实际元素类型为子类型 案例升级：如何调用子类的特有方法，比如Teacher 有一个teach，Student有一个study方法。如何调用? 多态参数方法定义的形参类型为父类型，实参类型允许为子类类型 polyParameter.java &#96;&#96;&#96;javapackage seatWork; public class polyParameter {&#x2F;** 定义员工类Employee，包含姓名和月工资[private]，以及计算年工资getAnnual的方法。* 普通员工和经理继承了员工，经理类多了奖金bonus属性和管理manage方法，* 普通员工类多了work方法，普通员工和经理类要求分别重写getAnnual方法*** 测试类中添加一个方法showEmployAnnual（Employee e ),* 实现获取任何员工对象的年工资，* 并在main方法中调用该方法[e.getAnnual()]** 测试类中添加一个方法，testWork，如果是普通员工，* 则调用work方法，如果是经理，则调用manage方法&#x2F;public static void main(String[] args) { GeneralStaff staff &#x3D; new GeneralStaff(“zhangsan”, 5000); Manager manager &#x3D; new Manager(“lisi”, 5000, 10000); polyParameter polyParameter &#x3D; new polyParameter(); polyParameter.showEmployAnnual(staff); polyParameter.showEmployAnnual(manager); polyParameter.testWork(staff); polyParameter.testWork(manager);}public void showEmployAnnual(Emplyee e){ System.out.println(e.getAnnual());}&#x2F;* 添加一个方法，testwork* 如果是普通员工，则调用work方法* 如果是经理则调用manage方法* &#x2F;public void testWork(Emplyee e){ if (e instanceof GeneralStaff){ ((GeneralStaff) e).work();&#x2F;&#x2F;向下转型 }else if (e instanceof Manager){ ((Manager) e).manage();&#x2F;&#x2F;向下转型 }}}class Emplyee {private String name;private double salary;public Emplyee(String name, double salary) { this.name &#x3D; name; this.salary &#x3D; salary;}public String getName() { return name;}public void setName(String name) { this.name &#x3D; name;}public double getSalary() { return salary;}public void setSalary(double salary) { this.salary &#x3D; salary;}public double getAnnual(){ double tmp &#x3D; 12salary; return tmp;}} class GeneralStaff extends Emplyee{ }class Manager extends Emplyee{private double bonus;public Manager(String name, double salary,double bonus) { super(name, salary); this.bonus &#x3D; bonus;}public void manage(){ System.out.println(“manage method”);}@Overridepublic double getAnnual() { return super.getAnnual()+bonus;}} hashCode介绍： 返回对象的哈希码值，支持此方法是为了提高哈希表的性能 实际上，由object类定义的hashCode方法确定会针对不同的对象返回不同的证书，(这一般是通过将该对象的内部地址转移换成一个整数来实现的，但是java编程语言不需要这种实现技巧) 老韩六小结： 提高具有哈希结构容器的效率 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的 两个引用，如果指向的是不同的对象，则哈希值是不一样的（极大概率不一样） 哈希值主要根据地址号来的！，不能完全将哈希值等价于地址 案例演示obj.hashCode() [测试 A obj1 &#x3D; new A(); A obj2 &#x3D; new A(); A obj3 &#x3D; obj1] 后面在集合，中hashCode如果需要的话，也会重写 toString介绍： 默认返回：全类名+@+哈希值的十六进制，[查看object的tostring方法] 子类往往会重写toString方法，用于返回对象的属性信息 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。 当直接输出一个对象时，toString方法会被默认的调用 finalize()介绍： 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制销毁该对象，在销毁该对象前，会先调用finalize方法 垃圾回收机制的调用，是由系统来决定的(即有自己的GC算法 )，也可以通过System.gc()主动触犯垃圾回收机制 断点调试（debug）提示：在断点调试的过程中，是运行状态，是以对象运行类型来执行的 介绍：​ 断点调试是指程序在的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步一步往下调，调试过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug。 快捷键 F7（跳入） 跳入方法内 F8（跳过） 逐行执行代码 shift+F8（跳出） 跳出方法 F9（resume，执行到下一个断点） 面向对象（高级）类变量和类方法一、类变量案例理解： static变量会开辟一个独立的空间，所以new的对象空间不会再单独创建一个static变量的空间。所以这个static变量空间对于这个类的所有实例是共享的 内存分析 static变量是对象共享的 不管static变量在哪 static变量是同一个类，所有对象共享 static类变量，在类加载的时候就生成了 定义语法访问修饰符 static 数据类型 变量名；【推荐】 static 访问修饰符 数据类型 变量名； 类变量访问类名.类变量名【推荐】 或者 对象名.类变量名 [静态变量的访问修饰符的访问权限和范围和普通属性是一样的] 推荐使用第一种 使用细节 什么时候使用类变量？ 当我们需要让某个类的所有对象都共享一个变量时，就可以使用类变量（静态变量）：比如上述的统计人数的案例 类变量与实际变量的区别 变量是该类的所有对象共享的 实例变量是每个对象独享的 加上static成为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量 类变量可以通过类名.类变量名或者对象名.类变量名来访问。推荐第一种方式访问（前提是得满足访问权限） 实例变量不能通过类名.类变量名方式访问 类变量是在类加载时就初始化了，也就是说，及时没有创建对象，只要加载类了，就可使用类变量了 类变量的声明周期是随类的加载开始，随着类的消亡而销毁 二、类方法介绍类方法也称静态方法 格式 类方法调用使用方式： 类名.类方法名 或 对象名.类方法名 使用场景当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。 比如：工具类中的方法utils Math类、Arrays类、Collections集合类 使用细节 类方法和普通方法都是随着类的加载而加载，将结构信息储存在方法区： 类方法中无this的参数 普通方法中隐含this参数 类方法可以通过类名调用，也可以通过对象名调用 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以 类方法(静态方法)中，只能访问 静态变量和静态方法 普通成员方法，既可以访问静态的成员，非静态的方法。可以访问静态成员和非静态成员 总结：静态方法，只能访问静态的成员， 非静态方法，可以访问静态的 成员和非静态的成员 （前提是必须遵守访问权限规则） 理解main方法语法深入理解main方法解释main方法的形式：public static void main(String[] args){} main方法是java虚拟机调用的 java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public java虚拟机在执行main()方法是不必创建对象，所有该方法必须是static 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数 java执行的程序 参数1 参数2 参数3 提示 在main（）方法中我们可以直接调用main方法所在类的静态方法或静态属性 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，再能通过这个对象去访问类中的非静态成员 例： &#96;&#96;&#96;javaclass A{private int a;private static int b;private void a(){ System.out.println(“非静态方法a”);}private static void b(){ System.out.println(“静态方法a”);}public static void main(String[] args){ System.out.println(“id &#x3D; “ +a);&#x2F;&#x2F;错误 a是非静态变量，得实例一个对象才能调用 System.out.println(“id &#x3D; “ +new A().a);&#x2F;&#x2F;这样是正确的，创建了个匿名对象调用 System.out.println(“id &#x3D; “ +b);&#x2F;&#x2F;正确， 因为b是静态变量，可以直接调用 System.out.println(“id &#x3D; “ +a());&#x2F;&#x2F;错误，和上述a的非静态变量的原因相同 System.out.println(“id &#x3D; “ +new A().a());&#x2F;&#x2F;改成这样就是正确的，因为a()是非静态的方法 A a &#x3D; new A(); System.out.println(“id &#x3D; “ +a.a());&#x2F;&#x2F;同理}} 注意： 修饰符 可选，要写的话，也只能写static 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块 逻辑语句可以为任何罗技语句（输入，输出，方法调用，循环，判断等） ; 号可以写上，也可以省略。 优点 相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性 案例 使用细节 static代码块也叫静态代码块，作用就是对类进行初始化， 而且它随着类的加载而执行 并且只会执行一次。 如果是普通代码块，每创建一个对象，就执行 类什么时候被加载？[重要] 创建对象实例时（new xxx) 创建子类对象实例，父类也会被加载 先在家父类的代码块，再执行子类的 使用类的静态成员时（静态属性，静态方法） 案例：A类 extends B类的静态块 ​ 先执行a的静态块，然后再执行b的 普通代码块，在创建对象实例时，会被隐式调用。 被创建一次，就会调用一次 如果只是使用类的静态成员时，普通代码块并不会执行 创建一个对象时，在一个类 调用顺序是（重点，难点） 调用静态代码块和静态属性初始化 （注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用 调用普通代码块和普通属性的初始化 （注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义的顺序调用） 调用构造器 构造器优先级最低，上述的两个规则执行完成后才会执行构造器 构造器 的最前面其实隐含了super() 和调用普通代码块 静态相关的代码块，属性初始化，在类加载时，就执行完毕。因此是优先于 构造器和普通代码块执行的 演示： 创建一个子类对象时(继承关系),他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下： 父类的静态代码块和静态属性（优先级一样，按定义的顺序执行） 子类的静态代码块和静态属性（优先级一样，按定义的顺序执行） 父类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行） 父类的构造器 子类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行） 子类的构造器 静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任何成员 单例设计模式介绍 所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且只提供一个取得对象实例的方法 单例模式有两种方式：1）饿汉式 2）懒汉式 二者最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例,而懒汉式在使用时才创建 饿汉式不存在线程安全问题，懒汉式存在线程安全问题 饿汉式存在浪费资源的可能。（因为如果程序员一个对象实例都没使用，那么饿汉式创建的对象就是浪费了，懒汉式是使用时才创建，就不存在这个问题 在javaSE标准类中，java.lang.Runtim就是经典的单例设计模式 演示： 恶汉式 类加载的时候，对象就被创建实例对象，可能会出现创建了，但是没有使用 步骤： 构造器私有化 &#x3D;&gt; 防止直接new 类的内部创建对象 向外露出一个静态的公共方法。 代码实现 &#96;&#96;&#96;javapublic class singleDesign {public static void main(String[] args) { System.out.println(GirlFriend.info());}}&#x2F;&#x2F;有一个女朋友类&#x2F;&#x2F;只能有一个女朋友class GirlFriend{private String name;&#x2F;&#x2F; 2.创建一个对象&#x2F;&#x2F; 3.为了能够接收静态方法，需要修饰为staticprivate static GirlFriend girl &#x3D; new GirlFriend(info());&#x2F;&#x2F; 如何保证只能有一个对象实例&#x2F;&#x2F; public girlFriend(String name) {&#x2F;&#x2F; this.name &#x3D; name;&#x2F;&#x2F; }&#x2F;&#x2F; 1. 改成私有的构造器private GirlFriend(String name) { this.name &#x3D; name;}&#x2F;&#x2F; 4.创建一个静态方法，用于接收实例对象public static String info(){ return “g”;} final关键字介绍final &#x2F; 最后的，最终的 fianl 可以修饰类、属性、方法和局部变量 某些情况下，程序员可能有以下需求，就会使用到final： 当不希望类被继承时，可以用final修饰 当不希望父类的某个方法可以被子类覆盖&#x2F;重写（override）时，可以用final关键字修饰 当不希望类的某个属性的值被修改，可以使用final修饰 当不希望某个局部变量被修改，可以使用final修饰 使用细节 final修饰的属性又叫常量，一般用XX_XX_XX来命名 final修饰的属性在定义时，必须赋初始值，并且以后都不能修改，赋值可以在如下位置之一（选择一个位置赋初始值即可） 定义时：例如 public final double TAX_PATE&#x3D;0.09; 在构造器中 在代码块中 &#96;&#96;&#96;javaclass A{&#x2F;&#x2F;定义时赋值public final double ATX_A &#x3D; 0.9;&#x2F;&#x2F;在构造器中赋值public final double ATX_B；public A{ ATX_B&#x3D;0.8；}&#x2F;&#x2F;在代码块中赋值public final double ATX_C；{ ATX_C&#x3D;0.2；}} 介绍 用abstract 关键字修饰的类时，这个类就是抽象类 &#96;&#96;&#96;java访问修饰符 abstract 类名{} 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类() 细节 抽象类不能被实例化 抽象类不一定包含abstract方法。也就是说，抽象类可以没有abstract方法 一旦包含了abstract方法，则这个类必须声明为abstract abstract 只能修饰类和方法，不能修饰属性和其他的 抽象类可以有任意成员【抽象类的本质还是类】，比如：非抽象方法、构造器、静态属性等等 抽象方法不能有主体，即不能实现。例如：abstract void method()；不能有{} 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract 类（所谓实现就是有那个{}就可，具体内容不管） 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的 抽象类实践-模板设计模式现有个需求 有多个类，完成不同的任务job 要求能得到各自完成任务的时间 接口（重要）介绍接口就是给出一些没有实现的方法，封装到一起，起到某个类要使用的时候，在根据具体情况吧这些方法写出来 语法 小结: jdk7之前，接口中所有方法否是抽象方法 jdk8之后，接口中可以有实现方法，但需要使用default关键字修饰 jdk8之后可以有静态方法 abstract关键字可以省略 注意事项 接口不能被实例化 接口中所有的方法是public方法，接口中抽象方法，可以不用填写abstract，因为默认修饰的就是public abstract xxx。 一个普通类实现接口，就必须将该接口的所有方法都实现 抽象类实现接口，可以不用实现接口的方法 一个类同时可以实现多个接口 接口的属性，只能是final的，而且public static final 修饰符，比如：int a &#x3D;1; 实际上是public static final int a &#x3D;1；（必须）初始化 接口中属性的访问形式：接口名.属性名 一个接口不能继承其他的类，但是可以继承多个别的接口 接口的修饰符只能是public和默认，这点和类的修饰符是一样的。 小结： 继承vs接口 当子类继承了父类，就自动拥有了父类的功能 如果子类需要拓展功能，可以通过实现接口的方式扩展 可以理解，接口是对java单继承机制的一个补充 继承的价值：解决代码的复用性和可维护性 接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。更加的灵活 内部类（重点）介绍：一个类的内部又完整的嵌套了另一个类结构。被嵌套的类成为内部类（inner class)，嵌套其他类的类成为外部类(out class)。是我们类的第五大成员 类的五大成员： 属性 方法 构造器 代码块 内部类 基本语法 内部类的分类定义在外部类局部位置上（比如方法内） 1）局部内部类（有类名）​ 说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名 可以直接访问外部类的所有成员，包括私有的 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但可以使用final修饰，因为局部变量也可以使用final修饰符的 作用域：仅仅在定义它的方法或代码块中 局部内部类—访问—-&gt;外部类的成员【访问方式：直接访问】 外部类—-访问—-&gt;局部内部类的成员 访问方式：创建对象，再访问（注意：必须在作用域内） 外部其它类—-&gt;不能访问—-&gt;局部内部类（因为 局部内部类地位是一个局部变量） 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问 &#96;&#96;&#96;javaclass Outer{private int n1 &#x3D; 10;private static String name &#x3D; “张三”;public void say(){ int n3 &#x3D; 30; &#x2F;&#x2F;局部内部类是定义在外部类的局部位置，通常在方法 &#x2F;&#x2F;不能添加访问修饰符，可以使用final修饰 class localInner{&#x2F;&#x2F;局部内部类（本质仍然是一个类）int n1 &#x3D; 100; int n2 &#x3D; 40; &#x2F;&#x2F;可以直接访问外部类的所有成员，包括私有的 public void show(){ &#x2F;&#x2F;默认输入内部类的n1的值 100 System.out.print(“n1&#x3D;”+n1); &#x2F;&#x2F;输入outer.this.n1 输出的才是外部类的n1 System.out.print(“n1&#x3D;”+outer.this.n1); }}} &#x2F;&#x2F;外部类使用内部类 localInner inner &#x3D; new localInner(); inner.show(); } &#x2F;&#x2F;外部其他类 演示 注意细节 匿名内部类既是一个类的定义，同事它也是一个对象，因此从语法上来看，它既有定义类的特征，也有创建对象的特征，对前面的代码分析可以看出这个特点，因此调用匿名内部类方法有两种 可以访问外部类的所有成员，包括私有的 不能添加访问修饰符，因为它的地位就是一个局部变量 作用域：方法或代码块中 匿名内部类—&gt;范围跟—&gt;外部类成员 外部其他类—&gt;不能访问—&gt;匿名内部类（因为 匿名内部类地位是一个局部变量） 如果外部类和内部类的成员变量重名时，内部类访问的话，默认就是就近原则，如果想访问外部，可以使用（外部类名.this.成员）去访问 定义在外部类的成员位置上 1）成员内部类（没用static修饰）介绍： 成员内部类是定义在外部类的成员位置，并且没有static修饰 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位是一个成员 作用域 和外部类的其他成员一样，为整个类体比如前面的案例，在外部类的成员方法中创建成员内部类对象，再调用方法 成员内部类–&gt;访问—&gt;外部类成员 (比如属性)【访问方式：直接访问】 外部类 —访问—内部类 访问方式：创建对象，再访问 外部其他类—–访问—–成员内部类 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问 2）静态内部类（使用static修饰）介绍静态内部类定义在外部类的成员位置，并且有static修饰 可以直接访问外部的所有静态成员，包含私有的，但不能直接访问非静态成员 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员 作用域：同其他的成员，为整个类体 静态内部类—访问—-外部类 （比如：静态属性）[访问方式：直接访问所有静态成员] 外部类–访问—静态内部类 访问方式：创建对象，再访问 外部其他类 –访问 –内部类 访问方式： 如果外部类和静态内部类的成员重名时，静态内部访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问 枚举和注解枚举（enum）介绍1）枚举对应的英文（enumeration,简写enum） 2）枚举是一组常量的集合 3）可以理解：枚举属于一种特殊的类，里面只包含一组有限的特定对象（比如一年只有四个季节，建一个季节类的话只能有四个，而且有被添加其他季节的风险） 实现方式1）自定义枚举 不需要提供set方法，因为枚举对象通常为只读 对枚举对象&#x2F;属性使用final +static共同修饰，实现底层优化 枚举对象通常使用大写，常量的命名规范 枚举对象根据需要，也可以有多个属性 总结：定义枚举类型有一下几个特点 构造器私有化 本类内部创建一组对象 对外暴露对象（添加public final static 修饰） 可以提供get方法，但不需要提供set方法 2）使用enum关键字实现 注意事项 当我们使用enum关键字开发一个枚举类时，默认会继承Enum类 传统的public static final SPRING &#x3D; new season(“春天”,”温暖”);简化成SPRING(“春天”,”温暖”),这里必须知道，它调用的是哪个构造器 如果使用无参构造器 创建枚举对象，则实参列表和小括号都可以省略 当有多个枚举对象时，使用，号间隔，最后一个分号结尾 枚举对象必须放在枚举的行首 enum常用方法说明使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类的相关方法 使用细节 enum修饰的类不能在继承其他父类，因为enum会隐式继承一个Enum类 enum实现的类，仍然是一个类，所以还是可以实现接口的 Switch中使用枚举案例 @Override只能修饰方法，不能修饰其他类 @Deprecated：用于表示某个程序元素(类、方法等)已过时 @SuppressWarnings：抑制编译器警告 当写一些方法时，会出现一些无关不影响运行的警告。 可以使用@SuppressWarnings来抑制警告信息 可以在@SuppressWarnings{“”}中写入希望抑制的警告信息 位置在哪就屏蔽哪里 元注解（了解）@Target是修饰注解的注解，称为元注解 （了解） 元注解的种类（使用不多，要求看到直到是干啥的） 1）Retention &#x2F;&#x2F;指定注解的作用范围，三种SOURCE,CLASS,RUNTIME说明： 只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间， @Rentention包含一个RententionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值 @Rentention的三种值： RententionPolicy.SOURCE &#x2F;&#x2F;编译器使用后，直接丢弃这种策略的注释 RententionPolicy.CLASS &#x2F;&#x2F; 编译器将把注释记录在class文件中，当运行java程序时，JVM不会保留注释，这是默认值 RententionPolicy.RUNTIME &#x2F;&#x2F;编译器将把注解记录在class文件中，当运行java程序时，JVM会保留注释，程序可以通过反射获取该注释 示意图： 2）Target &#x2F;&#x2F;指定注解可以在哪些地方使用用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素 简单来说就是在哪些元素上使用 @Target 也包含一个名为value的成员变量 Target(value &#x3D; CONSTRUCTOR（构造器）, FIELD（field） , LOACL_VARIABLE（局部变量）, METHOD（方法）,PACKAGE（包）,PARAMETER ,TYPE ) 3）Documented &#x2F;&#x2F;指定该注解是否会在javadoc中体现@Documented 用于指定该元注解修饰的Annotation类将被Javadoc 工具提取成文档，即在生成文档时，可以看到注解 定义Documented 注解必须设置Retention 值为RUNTIME 4）Inherited &#x2F;&#x2F;子类会继承父类注解异常异常的概念介绍java语言中，将程序执行中发生的不正常情况成为“异常”。（开发过程中的语法错误和逻辑错误不属于异常） 执行过程中所发生的异常事件可分为两类 Error（错误）：java虚拟机无法解决的严重问题。例如：JVM系统内部错误，资源耗尽等严重情况。例：StackOverflowError[栈溢出]和OOM（out of memory),Error是严重错误，程序会崩溃。 Exception：因为，其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对想的代码进行处理，例如空指针访问，视图读取不存在的文件，网络连接中断等等，Exception分为两大类，运行时异常[程序运行发生的异常]和编译时异常[编译时，编译器查出的异常] 异常体系图（重要） 小结： 异常分为两大类，运行时异常和编译时异常 运行时异常，编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该避免出现的异常。java.lang.RuntimeException类及它的子类都是运行程序 对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影像 编译时异常，是编译器要求必须处置的异常 常见的异常常见的运行异常1）NullPoniterException 空指针异常 当程序试图在需要对象的地方使用 null时，抛出该异常 2 ) ArithmeticException 数字运算异常 当出现异常的运行条件时，抛出此异常 例如 一个整数”除以零”时，抛出此类的一个实例 3）ArrayIndexOutOfBoundsException 数组下标异常 用非法索引访问数组时抛出的异常，如果索引为负或者大于等于数组大小，则该索引为非法索引 4）ClassCastException 类型转换异常 当试图将对象强制转换为不是实例的子类时，抛出该异常 5）NumberFormatException 数字格式不正确异常[] 当应用程序试图将字符串转换成一种数值类型，但该字符不能转换为适当格式时，抛出该异常 使用该异常我们可以确保输入的是满足条件的数字 常见的编译异常介绍编译异常是指在编译期间。就必须处理的异常，否则代码不能通过编译 常见的编译异常 SQLException &#x2F;&#x2F;操作数据库时，查询表可能发生的异常 IOException &#x2F;&#x2F;操作文件时，发生的异常 FileNotFoundException &#x2F;&#x2F;当操作一个不存在的文件时，发生异常 ClassNotFoundException &#x2F;&#x2F;加载类，该类不存在时，异常 EOFException &#x2F;&#x2F;操作文件，到文件末尾，发生异常 IIIegalArguementException &#x2F;&#x2F;参数异常 异常处理概念基本介绍异常处理就是当异常发生时，对异常处理的方式 异常处理方式1）try-catch-finally程序员在代码中捕获发生的异常，自行处理 2）throws将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM 处理机制图 throws处理机制 try-catch-finally和throws二选一 如果程序员，没有显示是处理异常，默认throws 异常处理分类try-catch方式处理异常说明1）java提供try和catch块来处理异常。try块用于包含可能出错的代码块。catch用于处理try块中发生的异常，可以根据需要在程序中有多个数量的try…catch块 2）基本语法 注意事项 如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块 如果异常没有发生，则顺序执行try代码块，不会进入到catch块 如果希望不管是否能发生异常，都执行某段代码块（比如关闭链接，释放资源等）、 可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求是父类异异常在后，子类异常在前，比如（Exception 在后，NullPointerException 在前）如果发生异常，只会匹配一个catch &#96;&#96;&#96;java例:try{ }catch(NullPointerException e){ }catch(Exception e){ }finally{ } throw和throws的对比 意义 位置 后面跟的东西 throws 异常处理的一种方式 方法声明处 异常类型 throw 手动生成异常对象的关键字 方法体中 异常对象 throws throw 常用类包装类包装类的分类 Wrapper1、针对八种基本数据类型相应类型的引用类型—包装类 2、有了类的特点，就可以调用类中的方法 基本数据类型 包装类 boolean Boolean char Character byte Byte short Short int Integer long Long float Float double Doble 上述标出来的6个数据类型父类均为Number 包装类和基本数据的转换案例演示包装类和基本数据类型的相互转换，以int和integer演示 1）jdk5前的手动装箱和拆箱方式，装箱：基本类型-&gt;包装类型,反之拆箱 2）jdk5以后（包括jdk5）的自动装箱和拆箱方式 3）自动装箱底层调用的是valueOf方法，比如integer.valueOf(); 4）其他类型同理 包装类型和String类型的相互转换案例以integer和String转为例 Integer类和Character类常方法 Integer面试题1.看代码输出什么，为啥 因为integer的原码定义好了从-128-127之间不返回一个对象 2.integer面试题总结 看下列代码输出什么结果 只要有基本数据类型会自动拆箱，比对的是数值。判断的是值是否相等 如下的示例六和七，比对的是 String(重要) String实现了三个接口并继承了Object类 Serializable接口：说明String可以串行化。（可以在网络传输） Comparable接口：说明String对象可以相互比较 CharSequence接口：字符序列 String类是final类，String类不能被其他类继承 String 有属性，private final char value[];用于存放字符串内容（字符串的本质就是char数组） (注意：value是一个final类型，不可修改（即：value不能指向新的地址，但是单个字符内容时可以变化的）) 理解1）String对象用于保存字符串，也就是一组字符序列 2）字符串常量对象时用双引号括起来的字符序列。例如：”你好”，”21.213”，”boy”等等 3）字符串的字符使用Unicode字符编码，一个字符（不区分字幕还是汉字）占两个字节 4）String类较常用的构造方法（其他手册） String s1 &#x3D; new String(); String s2 &#x3D; new String(String original); String s3 &#x3D; new String(char[] a); String s4 &#x3D; new String(char[] a,int startIndex, int count) 创建方式1）方式一：直接赋值String s &#x3D; “xxx”;创建流程： 先从常量池查看是否有”xxx”数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址 2）方式二：调用构造器 String s &#x3D; new String(“xxx”)；流程：现在堆中创建空间，里面维护了value属性，指向常量池的xxx空间。如果常量池没有”xxx”，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址 String字符串的特性1）String是一个final类，代表不可变的字符序列 2）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的 面试题、1）String a &#x3D; “hello”+”abc”;创建了几个对象 2）String a &#x3D; “hello”; String b &#x3D; “abc”; String c &#x3D; a+b; 总共创建了几个对象 所以只创建了一个 小结:底层是StringBuilder sb &#x3D; new StringBuilder();sb.append(a);sb.append(b);sb是在堆中，并append是在原来的字符串的基础上追加的。 重要规则：String c1 &#x3D; “sb”+”cd”;常量相加，看的是池。String c1 &#x3D; a+b;变量相加，是在堆中 String类的常见方法说明：​ String类是保存字符串常量的。每次更新都需要重新开辟空间，效率低，因此java设计者还提供StringBuilder和StringBuffer来增强String的功能，并提高效率。 Strng常见的方法 equals &#x2F;&#x2F;区分大小写，判断是否相等 equalsIgnoreCase &#x2F;&#x2F;忽略大小写，判断内容是否相等 length &#x2F;&#x2F;获取字符的个数，字符窜长度 indexOf &#x2F;&#x2F;获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到返回-1 lastIndexOf &#x2F;&#x2F;获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，返回-1 substring &#x2F;&#x2F;截取指定范围字符串 trim &#x2F;&#x2F;去前后空格 charAt &#x2F;&#x2F;获取某索引处的字符，之一不能使用Str[index]这种方式 toUpperCase &#x2F;&#x2F;字符串转换成大写 toLowerCase &#x2F;&#x2F;字符串转换成小写 concat &#x2F;&#x2F;拼接字符串 replace 替换字符串中字符 split 分割字符串，罪域某些分割字符，我们需要转义 案例： 和 文件路径 compareTo &#x2F;&#x2F;比较两个字符串的大小，如果前者大则返回正数，如果后者大则返回负数， 如果相等（ 1.如果长度相同，并且字符串也相同返回0。 2.如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回if(c1 !&#x3D; c2）{ ​ return c1 - c2; } 3.如果前面的部分都相同，就返回str1.len - str2.len） toCharArray &#x2F;&#x2F;字符串转成字符数组 format&#x2F;&#x2F;格式化字符串，%s字符串，%c字符，%d 整型，%.2f 浮点型 StringBuffer(重要)串行化（对象可以网络传输，可以保存到文件） 基本介绍java.lang.StringBuffer代表可变字符序列，可以对字符串内容进行增删 很多方法与String相同，但StringBuffer是可变长度的 StringBuffer是一个容器 String 对比StringBuffer1）String保存的是字符串常量，里面的值不能更改，每次String类的更新实际是更改地址，效率较低&#x2F;&#x2F;private final char value[]； 2）StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用更新地址，效率较高&#x2F;&#x2F;char[] value &#x2F;&#x2F;这个放在堆 StringBuffer构造器StringBuffer() 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符 &#96;&#96;&#96;java&#x2F;&#x2F;创建一个大小为16的char[]，用于存放字符串内容StringBuffer stringBuffer &#x3D; new StringBuffer(); StringBuffer(String str) 构造一个字符串缓冲器，并将其内容初始化为指定的字符串内容 &#96;&#96;&#96;java&#x2F;&#x2F;通过给一个String 创建StringBuffer,char[] 大小就是str.length()+16StringBuffer stringBuffer &#x3D; new StringBuffer(“hello”); StringBuffer-&gt;String StirngBuffer类常见方法 增 append 删 delete(start,end) 改 replace(start,end,string)&#x2F;&#x2F;将start—end间的内容替换掉，不含end 查 indexOf &#x2F;&#x2F;查询字符串第1次出现的索引，如果找不回返回-1 插 insert 获取长度 length StringBuilder(重要)基本介绍1）一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder 不是线程安全)。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快（单线程的情况下，优先使用StringBuilder） 2）在StringBuilder上主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据 StringBuilder常用方法StringBuilder和StringBuffer均代表可变字符序列，方法是一样的，所以使用和StringBuffer一样。 StringBuilder是final类，不能被继承 StringBuilder对象可以串行化 继承了AbstractStringBuilder属性 char[] value，内容存到value 实现了Serializable接口，序列化（所谓系列化既可以保存类型和数据本身） String、StringBuffer、StringBuilder的比较☆1）StringBuilder和StringBuffer非常类似，均代表可变字符序列，而且方法也一样 2）String：不可变字符序列，效率低，但是复用率高。 3）StringBuffer：可变字符序列、效率较高（增删）、线程安全 4）StringBuilder：可变字符序列、效率最高、线程不安全 5）String使用注意事项： 效率StringBuilder &gt; StringBuffer &gt;String 使用原则，结论 如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder 如果字符串存在大量的修改操作，并且在单线程的情况下使用StringBuilder 如果字符串存在大量的修改操作，并且在多线程的情况下使用StringBuffer 如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等 StringBuffer和StringBuilder的方法使用一样 Math基本介绍Math类包含用于执行基本数学运算方法，如初等指数，对数，平方根和三角函数 方法一览（均为静态方法） Match常用的方法 abs 绝对值 pow 求幂 ceil 向上取整 (返回&gt;&#x3D;该参数的最小整数) floor 向下取整 (返回&lt;&#x3D;该参数的最大整数) round 四舍五入 sqrt 求开方 random 求随机数 max 求两个数的最大值 min 求两个数的最小值 Date,Calender,LoaclDate.Date[知道怎么查，怎么用即可]第一代日期类Date：精确到毫秒，代表特定的瞬间 SimpleDateFormat：格式和解析日期的类SimpleDateFormat 格式化和解析日期的具体类。它允许进行格式（日期-&gt;文本、解析（文本-&gt;日期）和规范化 Calendar(日历)第二代日期类主要就是Calendar类（日历） 1）public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable&lt;Calendar 2)calendar类是一个抽象类，他为特定瞬间为一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等，日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 第三代日期类前面两代的不足分析 （jdk1.0中包含了一个java.Util.Date类，但是他的大多数方法已经存在JDK1.1引入Calendar类之后被弃用。Calendar也存在着很多问题 可变性：像日期和时间这样的类应该是不可变的。 偏移性：Date中年份是从1900开始的，而月份是从0开始的 格式化：格式化只对Date有用，Calendar则不行 此外，他们不是线程安全的，不能处理闰秒等（每隔两天多出1s） 第三代日期类1）LoaclDate（日期）、localTime（时间）、loacalDateTime（日期和时间内） JDK8 LoaclDate：只包含日期，可以获取日期字段 localTime：包含时间，可以获取时间字段 loacalDateTime包含日期和时间， 2）DateTimeFormatter格式日期类类似于SimpleDateFormat Instant 时间戳类似于Date 提供了一系列和Date类转换的方式 Instant—-&gt;Date; Date date &#x3D; Date.from(instant); Date —&gt;Instant; Instant instant &#x3D; date.toInstant(); 案例演示 System常见方法1）exit 退出当前程序 2）Arraycopy：复制数组元素，比较合适底层调用，一般使用Arrays.copyOf完成数组复制。 3）currentTimeMillens：返回当前时间距离1970-1-1(1970年1月1日到现在) 的毫秒数 4）gc：运行垃圾回收机制System.gc(); Arrays类介绍Arrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索） 方法1） toString返回数组的字符串形式，将数组拼接成字符串返回 2)sort排序（自然排序和定制排序） 3）binarySearch 二分搜索binarySearch 通过二分搜索法进行查找，要求必须排好序 4）copyOf数组元素的复制 5)fill数组元素的填充 6)equals 比较两个数组元素内容是否完全一致 7)asList 将一组值，转换成list Integer和BigDecimal类应用场景1）BigInteger适合保存比较大的整型(整数) 2）BigDecimal适合保存精度高的浮点型(小数) 集合集合框架体系集合体系图背下来 1）单例集合（在集合里面放单个的对象） 2）双列集合（存放键值对形式的） CollectionCollection接口 Collection接口实现类的特点 Collection实现子类可以存放多个元素，每个元素可以是 Object 有些Collection的实现类，可以存放重复的元素，有些不可以 有些Collection的实现类，有些是有序的（List），有些不是有序（Set） Collection接口没有直接实现子类，是通过它的子接口Set和List来实现的 Collection接口和常用方法 常用方法 使用Iterator（迭代器）Collection接口遍历元素的方式1-使用Iterator（迭代器） 基本介绍1）Iterator对象成为迭代器，主要用于遍历Collection集合中的元素 2）所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可返回一个迭代器 3）Iterator的结构 4）Iterator仅用于遍历集合，Iterator本身并不存放对象 迭代器的运行原 hasNext用于判断 next（）；下移，并返回指向的元素 for循环增强Collection接口遍历元素的方式2- 增强for循环，可以代替iterator迭代器 特点：增强for就是简化版的iterator，本质一样。只能用于遍历集合或数组 基本语法 案例 增强for底层是迭代器 可以理解成增强for是简化版的迭代器 List基本介绍： List接口是Collection接口的子接口 1）list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复 2）list集合中的每个元素都有其对应的顺序索引，即支持索引 3）list容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素 4）JDK API中的List接口实现类有：ArrayList、LinkedList和Vector List接口的常用方法 void add（int index,Object ele）在index位置插入ele元素 boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来 Object get (int index)获取固定index位置的元素 int indexOf(Object obj) 返回obj在几个中首次出现的位置 int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置 Object remove(int index) 移除指定index位置的元素，并返回此元素 Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换 List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合 注意事项 permits all elements,including null , ArrayList 可以加入null，并且多个 ArrayList 是由数组来实现数据存储的 ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）看源码，在多线程情况下，不建议使用ArrayList ArrayListArrayList底层机制和源码分析（重点）1）ArrayList中维护了一个Object类型的数组elementData ​ transient Object[] elementData 2）当创建对象ArrayList时，如果使用的是无参构造器，则初始elementData容量为0 3）当添加元素时，先判断是否需要扩容，则调用grow方法，否则直接添加元素到合适位置 4）如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍 5）如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity 6）如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍 Vector介绍Vevtor底层也是一个对象数组。protected Object[] elementData; Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized 在开发过程中，需要线程同步安全时，考虑使用Vector Vector 和ArrayList比较 底层结构 版本 线程安全（同步）效率 扩容倍数 ArrayList 可变数组 jdk1.2 不安全，效率高 如果有参构造1.5倍如果无参1.第一次是10，第二次按1.5扩 Vector 可变数组 jdk1.0 安全，效率不高 如果是无参默认10，满后，就按两倍扩容。如果指定大小（创建）有参，则每次直接按2倍扩容 LinkedList说明1）LinkedList实现了双向链表和双端队列特点 2）可以添加任意元素（元素可以重复），包括null 3）线程不安全，没有实现同步 LinkedList底层机制 LinkedList底层维护了一个双向链表 LinkedList中维护了两个属性first和last分别指向首节点和尾结点 每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表 所以LinkedList的元素的 添加和删除，不是通过该数组完成的，相对来说效率较高 模拟一个简单双向链表理解 ArrayList 和LinkedList的比较 底层结构 增删的效率 改查的效率 线程 ArrayList 可变数组 较低；数组扩容 较高 不安全 LinkedList 双向链表 较高，通过链表追加 较低 不安全 何如选择 1）如果我们改查的操作较多，选择ArrayList 2）如果我们增删的操作多，选择LinkedList 3）一般来说，在程序中80%-90%都是查询，因此大部分情况下会选择ArrayList 4）在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说根据业务来进行合理选择 set介绍 1）无序（添加和取出的顺序不一致），没有索引 2）不允许重复元素，所以最多包含和一个null 3）JDK API中Set接口的实现类有 Set接口和常用方法和List接口一样，Set接口也是Collection的子接口，因此常用方法和Collection接口一样 set接口遍历方式同Collection的遍历方式一样，因为Set接口是Collection接口的子接口 使用迭代器 增强for 不能使用索引的方式获取 案例 HashSet1)HashSet实现了Set接口 2）HashSet实际上是HashMap，看源码 3）可以存放null值，但是只能有一个null 4）HashSet不保证元素时有序的，取决于hash之后，在确定索引的结果（即：不保证存放元素的顺序和取出的一致 ） 5）不能有重复元素&#x2F;对象。在前面Set接口使用已经标明 HashSet底层机制说明1）HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树） HashSet底层是HashMap 添加一个元素时，先得到hash值 -会转成-索引值 找到储存数据表table，看这个索引位置是否已经存放的有元素 如果没有，直接加入 如果有调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后 在java8中，如果一条链表的元素个数到了TREEEIFY_THRESHOLD(默认是8)个，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树） 源码分析 HashSet的扩容和转成红黑树机制 HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（localFactor）是0.75 &#x3D;12 如果table数组实用到了临界值12，就会扩容到16*2&#x3D;32，新的临界值就是32 * 0.75 &#x3D; 24,依次类推 在java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8),并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树），否则仍然采用数组扩容机制 LinkedHashSet说明 1）LinkedHashSet是HashSet的子类 2）LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表 3）LinkedHashSet根据元素的hashCode值来决定元素的储存位置，同时使用链表维护元素的次序（图），这使得元素看起来是以插入顺序保存的 4）LinkedHashSet不允许添加重复元素 可以理解成不同索引的数，构成双向链表 在LinkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail） 每一个结点有pre和next属性，这样可以形成双向链表 在添加一个元素时，先求hash值，在求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加[原则和hashset一样]) 这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致 TreeSet 当使用无参构造器创建treeset的时候仍然是无序的 需求：希望添加的元素按字符串大小来排序? 使用TreeSet提供的一个构造器,可以传入一个比较器（匿名内部类） &#96;&#96;&#96;javapublic class TreeSetDemo {public static void main(String[] args) {&#x2F;&#x2F; TreeSet treeSet &#x3D; new TreeSet(); TreeSet treeSet &#x3D; new TreeSet(new Comparator() { @Override public int compare(Object o1, Object o2) {&#x2F;&#x2F; 调用String的compareTo方法比较字符串大小 return ((String)o1).compareTo((String) o2); } }); treeSet.add(“d”); treeSet.add(“b”); treeSet.add(“a”); treeSet.add(“c”); System.out.println(treeSet);}} 8）Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，有因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry（如图） 数据存放在HashMap中，将set和collection作为一组对象放在Entry里面（其中不存放数据只是存放HashMap的引用） 将HashMap中的key和value数据 存放到一个entrySet集合（该集合不存放数据，存放的都是引用） map接口和常用方法1）put：添加 2）remove：根据键删除映射关系 3）get：根据键获取值 4）size：获取元素个数 5）isEmpty：判断个数是否为0 6）clear；清楚 7）containsKey：查找键值否存在 Map遍历方法1）containsKey：查找键是否存在 2）KeySet：获取所有的键 3）entrySet：获取所有关系 4）values：获取所有的值 小结 Map接口的常用实现类：HashMap、Hashtable和Properties HashMap是Map接口使用频率最高的实现类 HashMap是以key-value对的方式来存储数据（HashMap$Node类型） key不能重复，但值可以，允许使用null键和null值 如果添加相同的 key，则会覆盖原来的k-v，等同于修改，（key不会替换，val会替换） 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来储存的 HashMap没有实现同步，因此线程不安全 的 HashMap底层机制1）HashMap底层维护了Node类型的数组table，默认为null 2）当创建对象时，将加载银子（loadfactor）初始化为0.75 3）当添加key-value时，通过key的哈希值得到在table的索引，然后判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是连链表结构，做出相应处理。如果添加时发现容量不够则需扩容 4）第一次添加，则需扩容table容量为16，临界值(threshold)为12 5）以后再扩容，需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推 6）在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64)，就会进行树化。 HashTable基本介绍 1）存放的元素时键值对：key-value 2）hashTable的键和值都不能为null，否则会抛出空指针异常 3）hashTable使用方法基本上和HashMap一样 4）hashTable是线程安全的，HashMap是线程不安全的 Properties基本介绍 properties类继承了Hashtable类并实现了Map接口，也是使用一种键值对(key-value)的形式来保存数据 它的使用特点和Hashtable类似 properties还可用于从xxx.properties文件中，加载数据到properties类对象，并进行读取和修改 说明：工作后 xxx.properties文件常用作配置文件，io流部分(详细讲解)[www.cnblogs.com/xudong-bupt/p/3758136.html] CollectionsCollections工具类1）Collections是一个操作Set、List和Map等集合的工具类 2）Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作 排序操作（均为static方法） reverse（List）：反转List中元素的顺序 shuffle（List）：对List集合元素进行随机排序 sort（List）：根据元素的自然顺序对指定List集合元素按升序排序 sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序 swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换 案例： 查找、替换 Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素 Object min（Collection) Object min (Collection，Comparator) int frequency （Collection，Object）：染回指定集合中指定元素的出现次数 void copy（List dest，List src）：将src中的内容复制到dest中 boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值 &#96;&#96;&#96;javapublic static void main(String[] args) { ArrayList list &#x3D; new ArrayList(); list.add(“zhansgan”); list.add(“lisi”); list.add(“wngwu”); list.add(“laoliu”); list.add(“dasima”); System.out.println(“list&#x3D;”+list);&#x2F;&#x2F; 1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 System.out.println(“max num&#x3D;”+Collections.max(list));&#x2F;&#x2F; 2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素&#x2F;&#x2F; 获取最大长度的值 &#x2F;&#x2F; 3. Object min（Collection)&#x2F;&#x2F; 4. Object min (Collection，Comparator)同理 Object max &#x3D; Collections.max(list, new Comparator() { @Override public int compare(Object o1, Object o2) { return ((String) o1).length() - ((String) o2).length(); } }); System.out.println(“字符串最大的值为&#x3D;”+max);&#x2F;&#x2F; 5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数 &#x2F;&#x2F; 6. void copy（List dest，List src）：将src中的内容复制到dest中 ArrayList oldList &#x3D; new ArrayList();&#x2F;&#x2F; 为了完成一个拷贝，我们需要先给oldList赋值，大小和list一样,不然会报错 for (int i &#x3D; 0; i &lt; list.size(); i++) { oldList.add(“”); }&#x2F;&#x2F; 拷贝 Collections.copy(oldList,list); System.out.println(“oldList&#x3D;”+oldList);&#x2F;&#x2F; 7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值 Collections.replaceAll(list,”laoliu”,”老六”); System.out.println(“替换后&#x3D;”+list);} 好处： 编译时，检查添加元素的类型，提高了安全性 减少了类型转换的次数，提高效率 不再提示编译警告 介绍理解：泛（广泛）型（类型）&#x3D;&#x3D;&gt; integer，String 可以表示数据类型的数据类型 1）泛型又称参数化类型，时jdk5.0出现的新特性，解决数据类型的安全性问题 2）在类声明或实例化时只要制定好需要的具体的类型即可 3）java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮 4）泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型 （此时E称为泛型，那么Dog-&gt;E（此时E为 ）） 语法泛型的声明 泛型的实例化 使用细节 interface List{},public class HashSet{}….等等 说明：T，E只能是引用类型 不能是基本数据类型（八大基本数据类型,int,double 等等） 在指定泛型具体类型后，可以传入该类型或者其子类类型 泛型适用形式 &#96;&#96;&#96;javaList list1 &#x3D;new ArrayList{} List list2 &#x3D; new ArrayList&lt;&gt;(); 细节： 普通成员可以使用泛型（属性，方法） 使用泛型的数组，不能初始化 静态方法中不能使用类的泛型‘ 因为静态是和类相关的，在类加载时，对象还没创建 所以，如果静态方法和静态属性使用泛型时 ，JVM就无法完成初始化 泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型） 如果在创建对象时，没有指定类型，默认为object &#96;&#96;&#96;java&#x2F;&#x2F;1.demo后面有泛型，所以我们吧demo就称为自定义泛型类&#x2F;&#x2F;2.T,R,M泛型的标识符，一般是单个大写字母&#x2F;&#x2F;3.泛型标识符可以有多个&#x2F;&#x2F;4.普通成员可以使用泛型 （属性，方法）&#x2F;&#x2F;5.使用泛型的数组，不能初始化&#x2F;&#x2F;（因为数组在new的class demo&lt;T,R,M&gt;{String name;T t;R r;M m;T[] t1;&#x2F;&#x2F;可以声明public demo11(String name, T t, R r, M m) {&#x2F;&#x2F;构造器使用泛型 this.name &#x3D; name; this.t &#x3D; t; this.r &#x3D; r; this.m &#x3D; m;}&#x2F;&#x2F;方法使用泛型 public String getName() { return name;}public void setName(String name) { this.name &#x3D; name;}public T getT() { return t;}public void setT(T t) { this.t &#x3D; t;}public R getR() { return r;}public void setR(R r) { this.r &#x3D; r;}public M getM() { return m;}public void setM(M m) { this.m &#x3D; m;}} 细节： 接口中，静态成员也不能使用泛型 泛型接口的类型，在继承接口或者实现接口时确定 没有指定类型，默认为Object 泛型方法基本语法 注意细节： 反省方法，可以定义在普通类中，也可以定义在泛型类中 当泛型方法被调用时，类型会确定 public void eat（E e）{}，修饰符后没有&lt;T,R..&gt;eat方法不是泛型方法，而是使用了泛型 &#96;&#96;&#96;javaCar car &#x3D; new Car(); car.fly(“baoma”,2000); &#x2F;&#x2F;在调用方法是，编译器会自动识别传入的参数的类型，就会确定型 2）&lt;?&gt;:支持任意泛型类型 3）&lt;? extend A&gt;:支持A类以及 A类的子类，规定了泛型的上限 4）&lt;? super A&gt;:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限 知识点补充JUnit 一个类有很多功能代码需要测试，为了测试，就需要写入main方法中 如果有很多个功能代码测试，就需要来回注销，切换很麻烦 如果可以直接运行一个方法，就会方便很多 介绍：1. 练习部分快速入门部分 开发一个hello.java文件，输出：老王 is studying java！ &#96;&#96;&#96;javapublic class hello{public static void main(String[] args) {System.out.println(“lao wang is studying java”);}} 进制部分 第一部分 位运算练习 switch练习 3,4,5为春季。6，7，8，为夏季，9,10,11位秋季。12,1,2为冬季 &#96;&#96;&#96;javaScanner scanner &#x3D; new Scanner(System.in); System.out.println(“请输入月份”); int month &#x3D; scanner.nextInt(); if (month&gt;0 &amp;&amp; month&lt;&#x3D;12){ switch (month){ case 3: case 4: case 5: System.out.println(“春季”); break; case 6: case 7: case 8: System.out.println(“夏季”); break; case 9: case 10: case 11: System.out.println(“秋季”); break; case 12: case 1: case 2: System.out.println(“冬季”); break; } }else { System.out.println(“输入不合法”); } 方法二：定位➕扩容 二维数组部分 &#96;&#96;&#96;java&#x2F;&#x2F; int[][] arr &#x3D; "},{"title":"Hello World","date":"2022-10-13T03:15:14.282Z","url":"/2022/10/13/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"},{"title":"Node.js安装与配置（详细步骤）","date":"2022-09-24T13:52:45.000Z","url":"/2022/09/24/Node.js%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%88%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%EF%BC%89/","tags":[["安装","/tags/%E5%AE%89%E8%A3%85/"]],"categories":[["安装文档","/categories/%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/"]],"content":"[TOC] 一、安装Node.js1.下载Node.js官网下载根据自身系统下载对应的安装包（我这里为Windows11 64位，故选择下载第一个安装包） 2.安装双击安装包，点击Next，勾选使用许可协议，点击Next，选择安装位置（可根据个人情况更换路径，我这里选择安装在E:\\devTools\\nodejs） 继续点击Next，点击Next，点击Install，点击Finish完成安装。 3.添加环境变量3.1 进入环境变量，编辑【系统变量】下的变量【Path】 3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\） 二、验证是否安装成功进入cmd命令行窗口，输入node -v查看nodejs版本 输入npm -v查看npm版本 如下图所示，即为安装成功： 三、修改模块下载位置此步骤修改以后npm全局下载模块的保存位置，可根据自身情况选择是否更改。 1.查看npm默认存放位置使用npm get prefix查看npm全局模块的存放路径 使用npm get cache查看npm缓存默认存放路径 如上图所示，npm 全局模块存放位置以及cache的存放位置，默认是在 C 盘 “C:\\Users\\用户\\AppData” 下。 2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹 3.修改默认文件夹设置全局模块的安装路径到 “node_global” 文件夹， 设置缓存到 “node_cache” 文件夹 如下图所示： 注意：由于 node 全局模块大多数都是可以通过命令行访问的，还要把【node_global】的路径“E:\\devTools\\nodejs\\node_global”加入到【系统变量 】下的【PATH】 变量中，方便直接使用命令行运行，如下图所示： 4.测试默认位置是否更改成功经过上面的步骤，nodejs下载的模块就会自动下载到我们自定义的目录，接下来我们测试一下是否更改成功。输入下面的命令： 或者 注意：“-g”等同于“–global”，“-g” 是全局安装，不加“-g”就是默认下载到当前目录。“-g” 表示安装到之前设置的【node_global】目录下，同时nodejs会自动地在node_global文件夹下创建【node_modules】子文件夹， 即自动下载到“E:\\devTools\\nodejs\\node_global\\node_modules” 路径下。 如上图所示，下载express模块成功，然后在文件管理器中查看是否保存到上面自定义的路径下。 可以看到，express模块已经成功地下载到【E:\\devTools\\nodejs\\node_global\\node_modules】下。 注意：若执行命令npm install express -g出现如下报错： 是由于对文件夹操作的权限不够，右击Nodejs文件夹-&gt;属性-&gt;安全，点击编辑，将所有权限都✔即可。 ※执行npm install express -g仍然出错的话继续将nodejs下【node_cache】、【node_global】、【node_modules】这三个文件夹的所有权限勾选，再次执行： 四、设置淘宝镜像1.将npm默认的registry修改为淘宝registry说明：npm 默认的 registry ,也就是下载 npm 包时会从国外的服务器下载，国内下载会很慢，一般更换为淘宝镜像：。 1.1 查看当前使用的镜像路径 1.2 更换npm为淘宝镜像 1.3 检查镜像是否配置成功再次执行npm config get registry，检查当前的镜像路径： 如上图所示，npm默认的registry已修改为淘宝registry。 2.全局安装基于淘宝源的cnpm说明：由于npm的服务器在海外，所以访问速度比较慢，访问不稳定 ，cnpm的服务器是由淘宝团队提供，服务器在国内，cnpm是npm镜像，一般会同步更新，相差在10分钟，所以cnpm在安装一些软件时候会比较有优势。但是cnpm一般只用于模块安装，在项目创建与卸载等相关操作时仍使用npm。 2.1 全局安装基于淘宝源的cnpm 2.2 本地查看cnpm模块 2.3 执行命令查看cnpm是否安装成功 如下图所示，即代表cnpm配置成功。 "},{"title":"hexo+github搭建博客","date":"2022-09-24T13:52:45.000Z","url":"/2022/09/24/hexo+github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","tags":[["安装","/tags/%E5%AE%89%E8%A3%85/"]],"categories":[["安装文档","/categories/%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/"],["博客相关","/categories/%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"]],"content":"[TOC] 环境准备1、安装nodejs直接到官网上下载安装即可 Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) Node自带npm 详细安装配置 nodejs配置 2、安装gitWindows：下载并安装 git.Mac：使用 Homebrew, MacPorts 或者下载 安装程序。Linux (Ubuntu, Debian)：sudo apt-get install git-coreLinux (Fedora, Red Hat, CentOS)：sudo yum install git-core npm下载慢的话也可以下载淘宝下载源cnpm 开始安装Hexo1.安装hexo 安装完成可输入hexo -v查看版本 2、初始化hexo，新建存储博客的文件夹 3、进入文件夹，安装一下npm 可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了 4、启动服务站点 访问 至此hero就搭建好了。可以在本地访问了 将hexo博客站点上传到github上1、新建guthub仓库仓库名称限制了为你的：用户名+.github.io 2、安装hexo上传插件这里需要安装一个hexo的上传插件deploy-git 3、修改hexo配置文件指定仓库路径可在文件夹中直接打开文件，也可通过vim直接编辑 4、推送站点到github 注意事项推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现下图：鉴权失败（用户名密码错误） hexo文件夹详解： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 "}]