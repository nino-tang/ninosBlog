---
title: 数据库
comments: true
toc: true
date: 2022-11-23 22:45:59
categories:
  - 学习笔记
  - 编程
tags: 编程
pic:
---

#   数据库

所谓数据库，就是在数据安装一个数据库管理系统（DBMS），这个管理程序可以管理多个数据库，DBMS（datebse manage system)

一个数据库可以创建多个表，以保存数据

数据库管理系统（DBMS）、数据库和表关系如图： 

![image-20220709165315972](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220709165315972.png)



## 创建

![image-20220709182114626](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220709182114626.png)

1、CHARACTER SET:指定数据库采用的额字符集，如果不指定默认utf8

2、COLLATE:指定数据库字符集的校对规则（常用的utf8_bin（区分大小写）,utf8_general_ci（不区分大小写），注意默认是utf8_general_ci）

```mysql
create database if not exists dbname;

//创建一个hsp_db01的数据库
create database if not exists hsp_db01;
//创建一个hsp_db02的数据库,该数据库使用utf-8校验
create database hsp_db02 character set utf-8 
//创建一个hsp_db03的数据库，该数据库使用utf-8校验并带校对规则的数据库
create database hsp_db03 character set utf-8 collate  utf8_bin

```





## 查看、删除数据库

在创建数据库或者表的时候，为了规避关键字可以使用反引号解决 ``

```sql
//查看数据库
show databases;
//显示数据库创建语句
show create database db_name;
//数据库删除语句
drop database [if exists] db_name

//查看数据库结构
desc 数据库名;
```



## 备份恢复数据库

备份数据库

```sql
命令行备份：（注意：需要在dos界面执行命令行）
mysqldump -u用户名 -p -B 数据库1 数据库2 数据库3...>（路径）文件名.sql

恢复数据库(注意：在mysql命令行界面 或使用数据如操作软件再执行比如Navicat，sqlyog)
source 文件名.sql
```

备份数据表

```sql
mysqldump -u用户名 -p密码 数据库 表1 表2 表3 表n > （路径）文件名.sql

恢复
进入数据库执行source 文件名.sql
use 数据库;
source 文件名.sql;
```





# 表

## 创建

创建表的基本语法

```sql
crate table table_name(
	field1 datatype,
	field2 datatype,
	field3 datatype,
)character 字符集 collate 校对规则 engine引擎

field:指定列名 datatype：指定列类型(字段类型)
character set：如果不指定则为所在数据库字符集
collate：如不指定则为所在数据库校对规则
engine：引擎

例:
create table user (`id` int(10),`name` varchar(255),`password` varchar(255),`birthday` date)character set utf8 collate utf8_bin engine innodb;
```

注意：创建表示，要根据需保存的数据创建相应的列，并根据数据的类型定义相应的列类型。例：user表

## 删除

## 修改☆

使用alter table语句追加，修改，或删除列的语法

```sql
添加列
alter table tablename
add		(cloum datatype [default expt]
		[,cloum datatype]...);
		
添加多条，无条件
alter table emp add (列1 int(2),列2 int(2));
		
多条添加并附加默认值等条件
alter table emp add 列1 int(2) not null DEFAULT 2 after image,add 列2 char(4) not null DEFAULT 1111 after a;

		
例：
将image字段（不为空，默认为空的字符的值），该字段安排在salary字段后面
alter table emp add image varchar(32) not null DEFAULT '' after salary;
```

```sql
修改列
alter table tablename
modify	(cloum datatype [default expr]
		[,cloum datatype]...);
		
		修改列
alter table emplyee
MODIFY c char(22),
MODIFY d int(33);

修改字段名称
alter table emplyee change `原列名` 
`新列名` varchar(32) not null default '默认值';
修改的就列名前提后面的条件也是非空的并且有默认值的，如果不是的话就删掉重新添加
```

```sql
删除列
alter table tablename
drop (cloum);
删除多个列
alter table emp drop colum1,drop colum2;

查看表结构:   desc tablename;
```

```sql
修改表名：rename table 表名 to 新表名
修改表字符集：alter table 表名 character set字符集;
```



# mysql数据类型

mysql的数据类型指的就是字段类型或列类型

![image-20220808145730870](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220808145730870-16599419220611.png)



## 数值类型存储需求

| 列类型                      | 存储需求                                      |
| --------------------------- | --------------------------------------------- |
| tinyint                     | 1个字节                                       |
| smallint                    | 2个字节                                       |
| mediumint                   | 3个字节                                       |
| int,integer                 | 4个字节                                       |
| bigint                      | 8个字节                                       |
| float(p)                    | 如果0<=p<=24为4个字节，如果25<=p<=53为8个字节 |
| float                       | 4个字节                                       |
| double[precision],item real | 8个字节                                       |
| decimal(M,D),numeric(M,D)   | 变长；参考线下面                              |
| bit(m)                      | 大约(m+7)/8个字节                             |

decimal（和numeric）存储需求与具体版本有关；

使用二进制格式将9个十进制（基于10）数压缩为4个字节来表示decimal列值。每个值的整数和分数部分的储存分别确定。每个9位数需要四个字节，并且"剩余的"位需要四个字节的一部分。下表给出了超位数的存储需求。、

### decimal[M,D] [unsigned]

* 可以支持更加精确的小数位，M是小数的位数(精度)的总数，D是小数点(标度)后面的位数

  ```
  例如；5,2
  xxx.xx
  111.11
  长度为五位，其中两位为小数点
  ```

* 如果D是0，则值没有小数点，或分数部分。M最大为65，D最大为30。如果D被省略，则默认是0.如果M被省略，默认是10

* 建议：如果希望小数的精度高，推荐使用decimal

| 剩余的 | 字节 |
| ------ | ---- |
| 位数   | 目数 |
| 0      | 0    |
| 1      | 1    |
| 2      | 1    |
| 3      | 2    |
| 4      | 2    |
| 5      | 3    |
| 6      | 3    |
| 7      | 4    |
| 8      | 4    |
| 9      | 4    |

## 日期和时间类型

### 存储需求

| 列类型    | 存储需求 |
| --------- | -------- |
| date      | 3个字节  |
| datatime  | 8个字节  |
| timestamp | 4个字节  |
| time      | 3个字节  |
| year      | 1个字节  |

### 日期类型的基本使用

```sql
create table `time`(
	brithday date, --生日  年月日
	job_time datetime,--记录 年月日 时分秒
	login_time timestamp
							not null default CURRENT_TIMESTAMP
							on UPDATE CURRENT_TIMESTAMP  --登录时间，根据修改时间自动填充
);
```





## 字符串类型

### 存储需求

| 列类型                        | 存储需求                                              |
| ----------------------------- | ----------------------------------------------------- |
| char(m)                       | m个字节，0<=m<=255                                    |
| varchar(m)                    | L+1个字节，其中L<=m且0<=m<=65535(参考下方注释)        |
| binary(m)                     | m个字节，0<=m<=255                                    |
| varbinary(m)                  | L+1个字节，其中L<=m且0<=m<=255                        |
| tinyblob,tinytext             | L+1个字节，其中L<2^8                                  |
| blob,text                     | L+2个字节，其中L<2^16                                 |
| mediumblob,mediumtext         | L+3个字节，其中L<2^24                                 |
| longblob,longtext             | L+4个字节，其中L<2^32                                 |
| enum('value','value2',.....)  | 1或2个字节，取决于枚举值的个数（最多65335个值）       |
| set('value1','value2',......) | 1,2,3,4或8个字节，取决于set成员的数目（最多64个成员） |

char(size) --最大255个字符

varchar(size) --0~65535字节（直接写65535会报错的）因为会留3个字节来记录该char的长度

​					   --可变长度字符串   最大65535个字节

​						--utf8编码下最大21844字符  1-3个字节用于记录大小

​						--如果是utf8编码   varchar(size)  size = (65535-3)/3 = 21844（因为utf8编码三个字节代表一个字符，所以除以3）

​						--如果是GBK编码   varchar(size)  size = (65535-3)/2 = 32766（因为GBK编码三个字节代表一个字符，所以除以2）



### 字符串使用细节

细节1

* char(4)  --这个4表示字符数（最大255），不是字节数，不管是中文还是字母都是放4个，按字符计算。

* varchar(4) --这个4是表示字符数，不管是字母还是中文都以定好的表的编码来存放数据（所以具体占用的字节数是根据编码计算的）
* 不管是中文还是英文字母，都是最多存放4个，是按照字符来存放的

细节2

* char(4) --是定长，也就是说，即使插入'aa'，也会占用四个字符的空间。
* varchar(4) --是变长，也就是说，插入'aa'，实际空间大小并是不4个字符，而是按照实际占用空间来分配（<span style = "color:red;background:yellow">varchar本身还需要占用1-3个字节来记录存放内容的长度</span>）

细节3

* 什么时候使用char，什么时候用varchar
  1. 如果数据定长，推荐使用char，比如md5的密码， 邮编，手机号码，身份证号码
  2. 如果一个字段长度不确定，就是用varchar，比如留言，文章等等
* 查询速度：char>varchar

细节4

* 在存放文本是，也可以使用text数据类型，可以将text列视为varchar列，注意text不能有默认值，大小0~2^16字节，如果希望存放更多字符，可以选择MEDIUMTEXT 0~2^24 或者 LONGTEXT 0~2^32



 



# CRUD

## insert

```sql
insert into table_name (colum1,colum2,colum3,...)values (values1,values2,values3...); 
```

使用细节：

1. 插入的数据应与字段的数据类型相同
2. 数据的长度应在列的规定范围内
3. 在values中列出的数据位置必须与被加入的列的排列位置相对应
4. 字符和日期类型数据应包括在单引号内
5. 列可以插入空值[前提是该字段允许为空]，Insert into table value(null)
6. insert into tab_name(列名) values (),(),()形式添加多条记录
7. 如果是给表中的所有字段添加数据，可以不写前面的列名
8. 默认值的使用，当不给某个字段值时，如果有默认值就会添加 ，否则报错

## update

```sql
update table_name set col_name = expr1,col_name2...where where_definition

没有带where的语句慎用

例：
#修改所有员工的工资为5000
update emplyee set salary = 5000;
-- 修改小妖怪的工资为3000
update emplyee set salary = 3000 WHERE `name`='小妖怪';
-- 修改老妖怪的工资在原有即基础上增加1000
update emplyee set salary = salary+1000 WHERE `name`='老妖怪';


```

注意：

1. update语句可以用新值更新原有的表行中的格列
2. set子句只是要修改哪些列和要给与哪些值
3. where 子句指定应更新哪些行。如果没有where子句，则更新所有的行
4. 如果需要修改多个字段，可以通过set字段1=值1，字段2=值2...

## delete

```mysql
delete from table_name
			[where where_definition]
			没有带where条件的话会删除表内的所有记录
#例子
delete from emplyee where `name` = '老妖怪'
```

注意：

1. 如果不使用where语句，将删除表中的所有数据。
2. delete 语句不能删除某一列的值，（可以使用update设置为null或''
3. 使用delete语句仅删除记录，不删除表本身，如果要删除表使用drop table语句。

## select

### 运算符

| 比较运算符                              |                                       |
| --------------------------------------- | ------------------------------------- |
| > < <= >= =  （不等于的两种写法)<> 或!= | 大于、小于、大于（小于）等于、不等于  |
| between ... and ...                     | 显示在某一区间的值                    |
| in（set）                               | 显示在in列表中的值，例如：in(100,200) |
| like 'zhang' \| not like 'san%'         | 模糊查询 记得要加百分号               |
| is null                                 | 判断是否为空                          |

| 逻辑运算符 |                                    |
| ---------- | ---------------------------------- |
| and        | 多个条件同时成立                   |
| or         | 多个条件任一成立                   |
| not        | 不成立 例：where not(saraly >100); |



### 单表

distinct :取消重复

```sql
select [distinct] */colum1,colum2,...
		from tablename;
```

使用表达式对查询的列进行运算

```sql
select */colum1|expression,colum2|expression,..
from table_name
```

```sql
#在select语句中可以使用as语句
select columnname as 别名 from 表名;
```

```sql
-- 	查询练习
select * from student;
select distinct chinese from student ;

-- 查询总分
select `name`,(chinese + english + math) from student;

-- 起别名
select `name` as '名字',(chinese + english + math+10) as totle from student
```

注意事项：

1. select指定向查询哪些列的数据
2. column指定列名
3. *号表示查询所有列
4. from 指定查询那张表
5. distinct 可选，指显示结果去重

**使用order by子句排序查询**

```sql
select folum1,colum2,colum3..
		from table;
		order by colum asc|desc,...
```

注意：

1. order by指定排序的列，排序的列可以是表中的列名，也可以是select语句后指定的列名
2. asc升序[默认]，desc降序
3. order by 子句应位于select语句的结尾。

### 查询增强

```sql
create table dept (deptno int,dname varchar(32),loc VARCHAR(50));
INSERT into dept VALUES(10,'accounting','new_york');
INSERT into dept VALUES(20,'research','dallas');
INSERT into dept VALUES(30,'sales','chicago');
INSERT into dept VALUES(40,'operations','boston');

SELECT * from emp where hiredate<'1992-1-1';
#如何使用like操作符（模糊查询）
%表示从0到多个字符
_ :表示单个字符
?如何显示首字符为s的员工姓名和工资
?如何显示第三个字符为大写o的所有员工的姓名和工资

SELECT ename,sal from emp where LEFT(ename,1) like 'n%'
SELECT ename,sal from emp where left(ename,4) like '%o%'
SELECT ename,sal from emp where left(ename,4) like '___o%' 
#判断某一列数据是否为null时应该用is 不是=
select * from emp where mgr is null;

#order by子句加强
?按照工资的从低到高的顺序[升序]，显示雇员信息
select * from emp ORDER BY sal
?按照部门号升序而雇员的工资降序排列，显示雇员信息
select * from emp ORDER BY deptno ASC,sal DESC
```

### 分页查询

基本语法：

```sql
select ... limit start ,rows
表示从start+1行开始取，取出rows行，start从0开始计算


公式，需要在java中计算然后填入sql，只写在sql会报错
select * from emp ORDER BY empno limit 每页显示的记录数*（第几页-1），每页显示的记录数 
```

```sql
根据雇员的id分页查询每页显示3个人
第一页
select * from emp ORDER BY empno limit 0,3 
第二页
select * from emp ORDER BY empno limit 3,3 
第三页
select * from emp ORDER BY empno limit 6,3 
第四页
select * from emp ORDER BY empno limit 9,3 

```



### 分组增强

```sql
#1.显示每种岗位的雇员总数、平均工资
select count(*),avg(sal),job from emp GROUP BY job;
#2. 显示雇员总数，以及获得补助的雇员数
SELECT count(empno),count(comm) from emp
	统计没有获得补助的雇员数
select count(*) , count(if(comm is null,12,null)) from emp
	(如果comm为null，true的话范围一个值（可以使任何数只要不是null就会被记录）,null（false的话返回null，不会记录该条数据）)
#3. 显示管理者的总人数
select count(DISTINCT mgr) from emp
#4. 显示雇员工资的最大差额
select max(sal)-min(sal) as '差额' from emp
```

### 多表(重点)

```sql
select * from emp,dept;在默认情况下，当两个表查询时，规则：
```

1. 从第一张表中，取出一行和第二张表的每一行进行组合，返回结果[含有两张表的所有列]
2. 一共返回的记录数，第一张表的行数*第二张表的行数
3. 这样的多表查询默认处理返回的结果，成为笛卡尔集
4. 解决多表的关键就是写出正确的过滤条件where

```sql
select * from emp,dept where emp.deptno = dept.deptno;
显示雇员名，工资，所在部门名字，部门编号
select ename,sal,dname,emp.deptno from emp,dept where emp.deptno = dept.deptno;
```

注意：多表查询的条件不能少于<span style ="color:red;background:yellow">表的个数-1</span>，否则会出现笛卡尔集

练习.案例

```sql
select * from emp,dept;
在默认情况下，当两个表查询时，规则：
1. 从第一张表中，取出一行和第二张表的每一行进行组合，返回结果[含有两张表的所有列]
2. 一共返回的记录数，第一张表的行数*第二张表的行数

select * from emp,dept where emp.deptno = dept.deptno;
显示雇员名，工资，所在部门名字，部门编号
select ename,sal,dname,emp.deptno from emp,dept where emp.deptno = dept.deptno;

显示部门号为10的部门明员工名和工资
SELECT ename,dname,sal from emp,dept where emp.deptno = dept.deptno
and emp.deptno = 10 

select * from emp,salgrade;

select * from emp,salgrade where losal<sal<hisal;

select ename,sal,dname from emp,dept where emp.deptno = dept.deptno ORDER BY emp.deptno desc
```



#### 自连接

自连接是指在同一张表的连接查询（也就是说将一张表看做两张表进行查询）

特点：

1. 把同一张表当做两张表使用
2. 需要给表取别名，表名，表别名
3. 列名不明确，可以指定列名的别名，列名 as 列的别名

```sql
#显示公司员工名字和他的上级，（因为员工和上级的信息都是存在这张表中的，通过mgr字段对员工的empno字段绑定来确定上下级关系的，所以使用单链表查询）
select  yuangong.ename as '员工',shangji.ename as '上级'  from emp  yuangong ,emp shangji where yuangong.empno = shangji.mgr;
```



#### 子查询

子查询是指在其他sql语句中的select语句，也叫嵌套查询

#### 单行子查询

单行子查询是指只返回一行数据的子查询语句

```sql
查询张三同一部门的所有员工
1. select deptno from emp where ename = 'zhangsan'(子查询的结果只有一行数据)
2. select * from emp where 
deptno = (select deptno from emp where ename = 'zhangsan');
```



#### 多行子查询

多行子查询指返回多行数据的子查询  使用关键字in

```sql
查询和部门10的工作相同的雇员
名字，岗位，工资，部门号，但是不包含10号部门的雇员信息
1. SELECT DISTINCT job from emp where deptno = 10;

select ename,job,sal,deptno from emp where job in (
SELECT DISTINCT job from emp where deptno = 10) and deptno != 10;
```

#### 子查询当做临时表使用

![image-20220822150351153](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220822150351153.png)



#### 子查询中使用all操作符和 any操作符

```sql
显示工资比部门10的所有员工的工资高的员工的姓名，工资，部门号
select ename ,sal,deptno from emp where sal>all(select sal from emp where deptno = 10)


显示工资比部门10的其中一个员工的工资高的员工的姓名，工资，部门号
select ename ,sal,deptno from emp where sal>any(select sal from emp where deptno = 10)

显示工资比部门10的其中一个员工的最少的工资高的员工的姓名，工资，部门号
select ename ,sal,deptno from emp where sal> (select min(sal) from emp where deptno = 10)
```

#### 多列子查询

(字段1，字段2 ... )=(select 字段1，字段2 from xxx)

```sql
多列子查询
查询与zhangsan的部门和岗位完全相同的所有雇员（并且不包含本人）
select deptno,job from emp where ename = 'zhangsan'

select ename,deptno,job from emp where (deptno,job)=(select deptno,job from emp where ename = 'zhangsan') and ename != 'zhangsan'
```



### 合并查询

有时在实际应用中，为了合并多个select语句的结果，可以使用集合操作符号union，union all 

1. union all

   该操作符用于取得两个结果集的并集。当使用该操作符时，不会取消重复行

   ```sql
   两个查询语句
   select ename,sal,job from emp where sal > 2500
   select ename,sal,job from emp where job= 'dev';
   #union all 就是将两个查询结果合并
   select ename,sal,job from emp where sal > 2500
   union all
   select ename,sal,job from emp where job= 'dev';xxxxxxxxxx 两个查询语句select ename,sal,job from emp where sal > 2500select ename,sal,job from emp where job= 'dev';#union all 就是将两个查询结果合并select ename,sal,job from emp where sal > 2500union allselect ename,sal,job from emp where job= 'dev';select ename,sal,job from emp where sal>2500 unionselect ename,sal,job,from emp where job= 'dev';
   ```

   

### 总结

#### 数据分组总结

* 如果select语句同时包含有group by，having，limit order by那么它们的顺序是group by，having，order by

  ```sql
  select colum1,colum2,... from tablename
  						group by xxx
  						having xxx
  						order by xxx asc/desc
  						limit xxx,xxx
  ```

  

* 案例：

  ```sql
  统计各个部门的平均工资，并且是大于1000的并且按照平均工资从高到低排序，取出前两行记录
  select avg(sal) as 'pg' from emp
  								GROUP BY deptno
  								HAVING pg>1000
  								order by pg
  								limit 0,2
  ```

  

# 表复制

## 自我复制数据（蠕虫复制）

有时，为了某个sql语句进行效率测试，我们需要海量数据时，可以使用此方法为表创建

```sql
演示自我复制
1.先把emp表复制到my_tab表
insert into my_tab
  (id,`name`,sal,job,deptno)
	select empno,ename,sal,job,deptno from emp
	
#有数据后自己复制插入自己，就是不停的乘以2，使数据不停增大
insert into my_tab
		select * from my_tab
	
select count(*) from my_tab;
select * from my_tab;

```







# 函数

## 统计函数

### 统计函数 - count

count - 返回查询行的总数

```sql
select count(*) | count(列名) from tablename
							[where where_definition]
							
#例如:
#统计函数
#统计一共有多少条记录
SELECT count(*) from student;
#统计成绩大于40学生的人数
select count(*) from student where chinese > 40;
```

count(*) 和 count(列) 的区别

1. count(*) 返回满足条件的记录的行数

2. count(列)：统计满足条件的某列有多少个，但是会排除为null的情况

3. 简答来说就是如果里面有空的行，cout(*)记录也会加上这条，count(列)是不会记录为null的值

4. ```sql
   #案例
   create table tmp (id int);
   insert into tmp VALUE(1);
   insert into tmp VALUE(12);
   insert into tmp VALUE(13);
   insert into tmp VALUE(14);
   insert into tmp VALUE(null);
   
   SELECT count(*) from tmp; # 返回5
   SELECT count(id) from tmp; # 返回4
   ```

### 合计函数 - sum

sum函数返回满足where条件的行的和

```sql
select sum(列名) {,sum(列名2)} from tablename
					[where where_definition]
```

注意：

1. sum仅对数值起作用，否则会报错。
2. 对多列求和，“，”号不能少

```sql
#案例
#求各科成绩的总和
select sum(chinese),sum(english),sum(math) from student;
#求所有成绩的总和
select sum(chinese+english+math) from student;
#求语文成绩的平均分
SELECT sum(math) / count(*) from student;
#平均分函数
select avg(math) from student;
```

### max/min函数

max/min函数返回满足where条件的一列的最大/最小值

```sql
select max(列名) from tablename
				[where where_definition]
				
#案例
#max函数
select max(chinese) from student;
#min函数
select min(chinese) from student;

也可写在一起
select max(chinese), min(chinese)  from student;

select max(chinese) as '最高分', min(chinese) as '最低分'  from student;
```

## 分组统计

* 使用group by 子句对列进行分组

  ```sql
  select column1,column2,column3..from table group by column
  ```

  

* 使用having子句对分组后的结果进行过滤

  ```sql
  select column1,column2,column3...
  	from table
  		group by column having...
  ```

  ```sql
  
  #如何显示每个部门的平均工资和最高工资
  select avg(sal),max(sal),deptno from emp group by deptno;
  
  #显示每个部门的每个岗位的平均工资和最低工资
  select avg(sal),min(sal),deptno,job from emp group by deptno,job;
  
  #显示平均工资地域2000的部门号和它的平均工资
  select avg(sal) as pingjun,deptno from emp GROUP BY deptno HAVING pingjun<2000;
  ```

  

## 时间日期

|                                              |                                        |
| -------------------------------------------- | -------------------------------------- |
| current_date()                               | 当前日期                               |
| current_time()                               | 当前时间                               |
| current_timestamp()                          | 当前时间戳                             |
| date(datetime)                               | 返回datetime的日期部分                 |
| date_add(date2,interval d_value d_type)      | 在date2中加上日期或时间                |
| date_sub(date2,interval d_value d_type)      | 在date2上减去一个时间                  |
| datediff(date1,data2)                        | 两个日期差（结果是天）                 |
| timediff(date1,date2)                        | 两个时间差（差多少小时多少分钟多少秒） |
| now()                                        | 当前时间                               |
| year\|month\|date(datetime)  from_unixtime() | 年月日                                 |

```sql
--创建测试表
create table mes(id int,contant varchar(30),sendtime datetime);
SELECT * from mes;

INSERT into mes VALUES(1,'haha',CURRENT_TIMESTAMP);
INSERT into mes VALUES(2,'shanghai',NOW());
INSERT into mes VALUES(3,'xian',CURRENT_DATE);

--日期时间相关函数
| current_date()      | 当前日期   |
select CURRENT_DATE from dual

| current_time()      | 当前时间   |
select CURRENT_TIME from dual

| current_timestamp() | 当前时间戳 |
SELECT CURRENT_TIMESTAMP from dual


| date(datetime)                          | 返回datetime的日期部分  |
| date_add(date2,interval d_value d_type) | 在date2中加上日期或时间 |
| date_sub(date2,interval d_value d_type) | 在date2上减去一个时间   |
| datediff(date1,data2)                   | 两个日期差（结果是天）  |

#应用实例
--显示所有新闻信息，发布日期在十分钟以内的时间，日期只显示日期不显示时间
select id,contant,DATE(sendtime) from mes where DATE_ADD(sendtime,INTERVAL 10 MINUTE)>=NOW();
select id,contant,DATE(sendtime) from mes where DATE_SUB(NOW(),INTERVAL 10 MINUTE)<=sendtime;

--请用mysql的sql语句中求出2011-11-11和1990-1-1相差多少天
select DATEDIFF('2011-11-11','1990-1-1') from dual
--请用mysql的sql语句中求出你活了多少天
select DATEDIFF('2022-08-16','2000-01-31') from dual
--如果你能活到80岁，求出你还能或多少天
select DATEDIFF('2080-01-31','2022-08-16') from dual

| timediff(date1,date2)                        | 两个时间差（差多少小时多少分钟多少秒） |
select TIMEDIFF('10:11:11','05:20:10') from dual
| now()                                        | 当前时间                               |
| year\|month\|date(datetime)  from_unixtime() | 年月日                                 |
SELECT YEAR(NOW()) from dual;
SELECT MONTH(NOW()) from dual;
SELECT DAY(NOW()) from dual;

#UNIX_TIMESTAMP返回的是1970-1-1到现在的秒数
select UNIX_TIMESTAMP()from dual
#FROM_UNIXTIME可以版一个UNIX_TIMESTAMP秒数，转成指定格式的日期
select FROM_UNIXTIME(UNIX_TIMESTAMP()) from dual
select FROM_UNIXTIME(160633307,'%Y-%m-%d %H:%i:%s') from dual


```



## 字符串函数

常见字符串函数（加粗的是常用）

| **charset(str)**                        | 返回字串字符集                                               |
| --------------------------------------- | ------------------------------------------------------------ |
| **concat(string2[,...])**               | 连接字串，将多个列拼接成一列                                 |
| instr(string,substring)                 | 返回substring在string中出现的位置，没有返回0                 |
| **ucase(string2)**                      | 转换成大写                                                   |
| **lcase(string2)**                      | 转换成小写                                                   |
| left(string2,length)                    | 从string2中的左边起取length个字符串                          |
| **length(string)**                      | string长度[按照字节]                                         |
| **replace(str,search_str,replace_str)** | 在str中使用replace_str替换search_str                         |
| strcmp(string1,string2)                 | 逐字符比较两个字串大小（大于返回1，等于返回0，小于返回-1     |
| **substring(str,position [,length])**   | 从str的position开始[从1开始计算]，取length个字符。如果length不写则取完后面所有 |
| ltrim (string) rtrim (string2) trim     | 取出前端空格或后端空格                                       |

```sql
#查询字符串
select charset(ename) from emp
#字符串拼接
select CONCAT(ename,'的工作是',job) from emp 
#dual是系统的一个哑铃表，没有表可用的时候选择
#查询hanshunping中ping出现的位置
SELECT instr('hanshunping','ping') from dual 
转换大小写
select ucase(ename) from emp
select LCASE(ename) from emp
从左边取2两个字符长度
select LEFT(ename,2) from emp
从右边取2两个字符长度
select RIGHT(ename,2) from emp
返回字节长度
select LENGTH(ename) from emp

替换(如果job列里的dev替换成开发者
select replace(job,'dev','开发者') from emp

比较字符串的字节大小,如果字符集设置的是不区分大小写大小写比较则相等
SELECT STRCMP('zhang','ZHANG1') from dual;
截取字符串,从第一个位置开始截取两个字节
select SUBSTRING(ename,1,2) from emp;
#去除左右边空格
select LTRIM('  ename') from dual #去除左边空格
SELECT RTRIM('enamel  ') from dual #去除右边空格
select  TRIM(' ename ') from dual #去除两边空格


以首字母大写的方式显示
select REPLACE(ename,left(ename,1),UCASE(left(ename,1))) from emp;
```



## **数学函数**

| 常见函数                              |                                |
| ------------------------------------- | ------------------------------ |
| ABS(num)                              | 绝对值                         |
| BIN（decimal_number)                  | 十进制转二进制                 |
| ceiling(number2)                      | 向上取整，得到比num2大的最小数 |
| conv（number2，from_base,tobase)      | 进制转换                       |
| floor(number2)                        | 向下取整，得到比num2小的最大数 |
| format(number,decimal,decimal_places) | 保留小数位数                   |
| hex(decimalNumber)                    | 转16进制                       |
| least(number,number2[,....])          | 求最小值                       |
| mod(numerator,denominator )           | 求余                           |
| rand([seed])                          | rand([seed])其范围为0<=v<=1.0  |

如果使用rand()每次返回不同的随机数

如果使用rand(seed)返回随机数，范围0<=v<=1.0，如果seed不变，该随机数不变

```sql
绝对值
select ABS(-10) from dual
转二进制
select bin(100) from dual;
向上取整
SELECT CEILING(10.2) from dual
向下取整
SELECT FLOOR(10.2) from dual
进制转换  十进制的8转成2进制输出
select CONV(8,10,2) from dual

保留最小数位数
select 3.1415926 from dual
select FORMAT(3.1415926,2) from dual#保留两位小数输出
转16进制
select HEX(8) FROM dual

求最小值
SELECT LEAST(1,2,3,4,5) from dual

求余
select mod(10,3) from dual
返回一个随机数

SELECT rand()  from dual
```

## 加密函数

| user（）                                   | 查询用户                                                     |
| ------------------------------------------ | ------------------------------------------------------------ |
| database（）                               | 数据库名称                                                   |
| MD5（str)                                  | 为字符串算出一个MD5 32的字符串，（用户密码）加密             |
| password（str) select * from mysql.user \G | 从原文密码str计算并返回密码字符串，通常用于对mysql数据库的用户密码加密 |

```sql
--加密函数
--user() 查询用户   用户@ip地址
select USER() from dual
--database 查询当前使用的数据库名称
SELECT DATABASE() from dual;

--MD5 
SELECT LENGTH(MD5('hsp')) from dual;


create table users(
	id int,
	name varchar(32) not null DEFAULT '',
	password varchar(32) not null DEFAULT'')
	
	
INSERT into users VALUES(100,'张三',MD5('zhangsan'));
INSERT into users VALUES(100,'李四',MD5('lisi'));

SELECT * from `users` 
where `name` = '张三' and `password` = MD5('zhangsan')

--PASSWORD(str) 加密函数,mysql数据库用户密码就是该方法加密的
select PASSWORD('zhangsan') from dual

mysql.user 表示 数据库.表
```



## **流程函数**



| if(expr1,expr2,expr3)                                        | 如果expr1为true，则返回expr2否则返回expr3                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ifnull(exor1,expr2)                                          | 如果expr1不为空null，则返回expr1，否则返回expr2              |
| select case when expr1 then expr2 when expr3 then expr4 else expr5 end;[类似多重分支] | 如果expr1为true，则返回expr2，如果expr2为true，返回expr4，否则返回expr5 |
|                                                              |                                                              |

```sql
| if(expr1,expr2,expr3)                                        | 如果expr1为true，则返回expr2否则返回expr3                    |
select IF(true,'beijing','shanghai') from dual

------------------------------------------------------------ |
| ifnull(exor1,expr2)                                          | 如果expr1不为空null，则返回expr1，否则返回expr2
select IFNULL('null1',null)from dual
# select case when expr1 then expr2 when expr3 then expr4 else expr5 end;[类似多重分支] 
#如果expr1为true，则返回expr2，如果expr2为true，返回expr4，否则返回expr5 |
select CASE 
	WHEN true THEN
		'jack'
	WHEN FALSE THEN
	  'tom'
	ELSE
		'cxk'
END ;

SELECT ename,
(SELECT CASE 
when job = 'salesman' then '销售'
WHEN job = 'dev' THEN '开发者' 
WHEN job = 'prman' then '剪辑' 
else '其他' end) from emp;


```



# **内连接**

# **外连接**

外连接

1. 左外连接（如果左侧的表完全显示我们就说是左外连接）

   1. ```mysql
      
      select `name`,stu.id,grade from stu left join exam on stu.id = exam.id;
      -- (就是把stu当成左表，左外连接就是把stu表的全部显示)
      
      ```

   2. 运行结果![image-20220825151010713](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220825151010713.png)

2. 右外连接（如果右侧的表完全显示我们就说是右外连接）

   1. ```mysql
      -- 右外连接
      -- 显示所有人的成绩，如果没有名字匹配，显示为null
      select `name`,stu.id,grade from stu RIGHT join exam on stu.id = exam.id;
      
      ```

   2. 运行结果![image-20220825151140663](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220825151140663.png)

3. ```mysql
   -- 演示左右连接
   -- 创建一个stu表
   create table stu(
   id int,
   `name` varchar(32));
   -- 插入数据
   insert into stu VALUES
   (1,'jack'),(2,'tom'),(3,'kitty'),(4,'nono')
   
   SELECT * from stu
   -- 创建exam表
   create table exam(
   id int,
   grade int)
   -- 插入信息
   insert into exam values
   (1,46),(2,76),(3,22),(11,100)
   
   -- 左外连接
   -- (显示所有人的成绩，如果没有成绩，也要现实该人的姓名和id，成绩显示为null）
   
   select `name`,stu.id,grade from stu left join exam on stu.id = exam.id;
   -- (就是把stu当成左表，左外连接就是把stu表的全部显示)
   
   -- 右外连接
   -- 显示所有人的成绩，如果没有名字匹配，显示为null
   select `name`,stu.id,grade from stu RIGHT join exam on stu.id = exam.id;
   
   
   ```

小结：在实际开发中，绝大多数情况下使用的是之前学的类连接方法，外连接使用不多，面试会问





# **约束**

## **not null**（非空）

如果在列上定义了not  null ，那么当插入数据时，必须为该列提供数据

```sql
字段名 字段类型 not null
```



## **primary key**

```sql
字段名 字段类型 primary key 	
```

用于唯一的标识标识行的数据，当定义主键约束后，<span style="color:red;background:yellow">该列的值不能重复</span>

```mysql
create table pt17(
id int PRIMARY KEY, -- 表示id是主键
`name` varchar(32),
email varchar(32));
-- 主键列的值时不可以重复的
insert into pt17 values(1,'jack','tangnino@qq.com'),
												(2,'tom','tang@gmail.com')
-- 执行这句时就会报错，因为id为主键并已经存在一个了										
insert into pt17 values(1,'mm','hahah@qq.com')
```

**细节说明**

1. primary key不能重复并且不能为null

2. 一张表最多只能有一个主键，但可以是复合主键

   ```sql
   --  演示复合主键（id 和 name 做成复合主键）
   create table t18 (
    id int,
   `name` varchar(32),
   email varchar(32),
   PRIMARY key (id,`name`)   
   );
   
   insert into t18 values(1,'name1','aa@qq.com');
   insert into t18 values(2,'name1','aa@qq.com'); -- 也可以
   insert into t18 values(2,'name2','aa@qq.com');
   
   insert into t18 values(1,'name1','google.gmail.com');-- 不可以添加，只有两个完全相同的才不能被添加进去
   
   ```

   * 复合主键是将多个字段看成一个主键，而不是有多个主键

3. 主键的指定方式有两种

   * 直接在字段名后指定：字段名 primary key
   * 在表定义最后写primary key(列名);

4. 使用desc 表名，可以看到primary key的情况

老韩提醒：在实际开发中，每个表往往都会有设计一个主键



## **unique**(唯一)

当定义了唯一约束后，该列值时不能重复的

```sql
字段名 字段类型 unique
```

使用细节：

1. 如果没有指定not null ，则unique字段可以有多个null

2. 一张表可以有多个unique字段

3. ```sql
   -- 1. 如果没有指定not null ，则unique字段可以有多个null
   -- 以下都可以存进去
   -- 如果一个字段是 unique not null 使用的效果基本等于 not null
   insert into t19 values(null,'name2','bb@qq.com');
   insert into t19 values(null,'name2','bb@qq.com');
   insert into t19 values(null,'name2','bb@qq.com');
   
   -- 2. 一张表可以有多个unique字段
   
   create table t20 (
    id int unique,  -- 表示id不可以重复
   `name` varchar(32) unique,-- 表示name不可以重复
   email varchar(32)  
   );
   ```

## **foreign key**(外键)

用于定义主表和从表之间的关系，外键约束要定义在从表上，主表则必须具有主键约束或unique约束。

当定义外键约束后，要求外键列数据必须在主表的主键列存在或是为null

```sql
foreign key （本表字段名）references
主键表（主键名或unique字段名）
```

演示：

```sql
学生表（从表）
id name class_id
班级表（主表）
id		class_name
-- 主表(被引用的表)
create table my_class(
id int primary key, -- 引用的id必须是主键或者unique修饰的
`name` varchar(32) not null default '');

-- 从表
create table my_stu(
id int primary key,
`name` varchar(32) not null default'',
class_id int,
foreign key (class_id) references my_class(id)); -- 指定class_id引用主表的id为外键

```

示意图

![image-20220827165329831](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220827165329831.png)

**细节说明**

1. 外键指向的表的字段要求是primary key 或者是unique
2. 表的类型是innodb，这样的表才支持外键
3. 外键字段的类型要和主键字段类型要一致（长度可以不同）
4. 外键字段的值，必须在主键字段中出现过，或为null【前提是外键字段允许为null】
5. 一旦建立主外键关系，数据不能在随意删除了











## **check**

强制行数据必须满足条件，假定在sal列上定义了check约束，并要求sal列值在1000~2000之间如果不再1000~2000之间就会提示错误

提示：oracle和sqlserver均支持check mysql5.7目前不支持check，只做语法校验，但不会生效

```sql
基本语法：列名 类型 check （check 条件）
user表
id ,name,sex(man,woman),sal(大于100小于90)
```

```sql
create table user(
id int primary key,
`name` varchar(32),
sex varchar(6) check(sex in('man','woman')),
sal double check (sal>1000 and sal <10000));
```



## **自增长**

```sql
字段名 整型 primary key auto_increment
```

添加自增长字段的方式

```sql
insert into xxx (字段1，字段2，...)values (null,'值',...);
insert into xxx(字段2，...)values ('值1','值',...);
insert into xxx values (null,'值',....)
```

```sql
-- 自增演示
create table t1(
id int primary key auto_increment,
`name` varchar(32) not null default'',
email varchar(32) not null default'');
desc t1

select * from t1
insert into t1 (id,`name`,`email`) values (null,'lisi','tang@qq.com');
insert into t1 values (null,'zhangsan','tang@qq.com');
insert into t1 (`name`,`email`) values ('lisi','tang@qq.com');

```

**使用细节**

1. 一般来说自增长是和primary key 配合使用的

2. 自增长也可以单独使用[但是需要配合一个unique]

3. 自增长修饰的字段为整数类型的（虽然小数也可以但是非常非常少这样使用）

4. 自增长默认从1开始，也可以通过如下命令修改

   ```sql
   alter tablename auto_increment = xxx;
   ```

5. 如果添加数据时，给自增长字段（列）指定的有值，则以指定的值为准增长（前提指定的值是最大的），如果指定了自增长，一般来说就按照自增长的规则添加数据



# **索引**

可以提高数据库的性能，查询速度可以提高千百倍。

创建索引后，只对创建索引的列有效

索引会占用很多磁盘空间，而且要对多列创建索引，通常一个不够用

**索引的原理**

* 没有索引为什么会慢？
  * 因为会全盘扫描
* 使用索引为什么会快？
  * 形成一个索引的数据结构，比如二叉树等等

**索引的代价**

1. 磁盘占用

2. 如果对表进行dml操作（修改，删除，添加），会对索引进行维护，对速度有影响


```sql
create table t1(
id int primary key, -- 主键，同时也是索引，成为主键索引
name varchar(32));

create table t2(
id int unique, -- id是唯一的，同时也是索引，成为unique索引
name varchar(32));
```

**主键索引**

主键自动的为主索引（类型primary key）

**唯一索引（UNIQUE）**

**普通索引（INDEX）**

**全文索引**（FULLTEXT）

【适用于mylSAM】

一般开发中mysql自带的全文索引（fulltext）不好用， 

开发中考虑使用全文索引，全文搜索Solr和ElasticSearch（ES）

## 索引的使用

```sql
-- 演示索引的使用
create table t1(
id int,
`name` varchar(32))

-- 查询表是否有索引
-- 方式1、
show INDEXES from t1
-- 方式2、
show index from t1
-- 方式3、
show keys from t1
-- 方式4、
desc t1

-- 添加索引
-- 添加唯一索引(某列是唯一不是重复时优先使用)
create unique index id_index on t1(id);

-- 添加普通索引(某列的值不是唯一时使用)
create  index id_index on t1(id);
-- 添加普通索引方式2
alter table t1 add index id_index(id);


-- 添加主键索引
-- 一般用primary key修饰的就默认为主键索引
-- 没有设置主键表的添加方法如下
 alter table t1 add primary key(id);
 
--  删除索引
drop index id_index on t1
-- 删除主键索引
alter table t1 drop primary key
```

**小结：**

1. 较频繁的作为查询条件字段应该创建索引

   ```sql
   -- 例如：
   select * from emp where empno =1
   ```

2. 唯一性太差的字段不适合单独创建索引，及时频繁作为查询条件\

   ```sql
   -- 例如：
   select * from emp where sex='男'
   ```

3. 更新非常频繁的字段不适合创建索引

   ```sql
   -- 例如：
   select * from emp where logincount=1
   ```

   

4. 不会出现在where子句中字段不该创建索引



# **事务**

**介绍**

​	事务用于保证数据的一致性，它<span style="color:red;background:yellow">由一组相关的dml（insert,delete,update）语句组成</span>，该组dml语句要么全部成功，要么全部失败。

如：转账就要用事务来完成，用以保证数据的一致性

## 事务管理

**事务和锁**

***当执行事务操作时（dml语句），mysql会在表上加锁，防止其他用户改表的数据。这对用户来讲是非常重要的***

mysql**数据库控制台事务的几个重要操作**

1. start transaction -- 开始一个事务
2. savepoint 保存点名 -- 设置保存点
3. rollback to 保存点名 -- 回退事务
4. rollback -- 回退全部事务
5. commit -- 提交事务，所有操作生效，不能回退

细节：

1. 没有设置保存点
2. 多个保存点
3. 存储引擎
4. 开始事务方式

```sql
create table t2 (
id int,
name varchar(32));
-- 开启事务
start transaction
-- 创建一个时间点a
savepoint a
-- 对数据进行操作
insert into t2 VALUES (1,'tang'),(2,'hao')

-- 创建时间点b
SAVEPOINT b
-- 数据操作
delete from t2 where id =2

-- 此时的数据为一条，如果后悔了可以回退到时间点b
rollback to b
-- 也可以直接回到时间点a
rollback to a
-- 回到最初的时间点（事务开始时）
rollback

-- 执行提交事务，执行此操作则所有时间也就无了，无法进行回滚处理
commit
select * from t2
```

* 回退事务（rollback）
  * 在介绍回退事务前，先介绍一下保存点（savepoint）保存点是事务中的点，用于取消部分事务，当前结束事务（commit），会自动删除该事物定义的所有保存点。当执行回退事务时，通过指定保存点可以回退到指定的点
* 提交事务（commit）
  * 使用commit语句可以提交事务，当执行了commit语句子句后，会确认事务的变化、结束事务、删除保存点、释放锁，数据生效。当前使用commit语句结束事务后，其他会话将可以查看到事务变化后的新数据

* 事务细节
  1. 如果不开始事务，默认情况下，dml操作时自动提交的，不能回滚
  2. 如果开始一个事务，没有创建保存点。你可以执行rollback，默认就是回退到事务开始的状态。
  3. 可以在事务中（还没提交时），创建多个保存点，比如：savepoint aaa; 执行dml   savepoint bbb;
  4. 可以在事务没有提交前，选择回退到哪个保存点
  5. mysql的事务机制需要innodb的存储引擎还可以使用，myisam不好使
  6. 开始一个事务start transaction ，set autocommit = off

## 隔离级别

多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性。

如果不考虑隔离性，可能会引发以下几个问题

* <span style="color:yellow">脏读（dirty read）</span>：当一个事务读取另一个事务尚未提交的改变 时，产生脏读
* <span style="color:yellow">不可重复读（nonrepeatable read）</span>：同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，由此发生不可重复读
* <span style="color:yellow">幻读（phantom read）</span>：同一查询在同一事务多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻读

**隔离级别**

概念：Mysql隔离级别定义了事务与事务之间的隔离程度

| Mysql隔离级别（四种）                    | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ---------------------------------------- | ---- | ---------- | ---- | ------ |
| 读未提交（read uncommitted）             | √    | √          | √    | 不加锁 |
| 读已提交（read committed）               | ×    | √          | √    | 不加锁 |
| 可重复读（repeatable read）              | ×    | ×          | ×    | 不加锁 |
| 可串行化（Serializable）[演示重开客户端] | ×    | ×          | ×    | 加锁   |

* √可能出现，×不会出现
* 加锁：当有一个事务在操作a表，另一个事务操作a表时会卡主知道第一个事务操作完。类似于线程锁

**执行语句**

1. 查看当前绘画隔离级别

   ```sql
   select @@tx_isolation
   ```

2. 查看系统当前隔离级别

   ```sql
   select @@global.tx_isolation;
   ```

3. 设置当前会话隔离级别

   ```sql
   set session transaction isolation level [repeatable read];-- 后面的隔离级别自己选着写
   ```

4. 设置系统当前隔离级别

   ```sql
   set global transaction isolation level repeatable read;
   ```

5. mysql默认的事务隔离级别是repeatable read ，一般情况下，没有特殊要求，没有必要修改（因为该级别可以满足大部分项目需求）

6. 全局隔离级别去mysql配置文件[mysql.ini]文件里面修改配置

   ```ini
   [mysqld]
   transaction-isolation  = prpeatable-read 
   ```

   

## ACID

**事物的acid特性**

1. 原子性（atomicity）

   原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生改变，要么都不发生。

2. 一致性（Consistency）

   事务必须使数据库从一个一致性状态变换到另外一个一致性状态

3. 隔离性（isolation）

   事物的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要互相隔离

4. 持久性（Durability）

   持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影像

# mysql表类型和存储引擎

基本介绍

1. mysql表类型由存储引擎（Storage Engines）决定，主要包括myISAM、innoDB、Memory等。
2. mysql数据表主要支持六种类型，分别是：CSV、Memory、ARCHIVE、MRG_MYISAM、MYISAM、InnoBDB。
3. 这六种又分为两类，一类是 ” 事务安全型 “ （transaction-safe），比如：InnoDB；其余都属于第二类，成为 ” 非事务安全型 " （non-transaction-safe）[mysiam和memory]

显示当前数据库支持的引擎

```sql
show engines;
```

**主要的存储引擎/表类型的特点**



![image-20220831110848519](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220831110848519.png)

**细节说明**

1. MYISAM不支持事务，也不支持外键，但访问速度快，对事务完整性没有要求
2. InnoDB储存引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但比起MYISAM储存引擎，InnoDB写的处理效率差一些硬气会占用更多的磁盘空间以保留数据和索引
3. Memory储存引擎使用存在内存中的内容来创建表，每个Memory表只实际对应一个磁盘文件。Memory类型的表访问非常快，因为它的数据是存放在内存中的，并且默认使用HASH索引。但是一旦服务关闭，表中的数据就会丢失掉，表的结构还在。

**选择引擎**

1. 如果你的应用不需要事务，处理的只是基本的CRUD操作，那么MYISAM是不二的选择，速度快。
2. 如果需要支持事务，选择InnoDB。
3. Memory 存储引擎就是将数据存储在内存中，由于没有磁盘I/O的等待，速度极快。但由于是内存存储引擎，所做的任何修改在服务器重启后都将消失。经典用法（用户的在线状态）

**修改存储引擎**

```sql
alter table `表名` engine  = 存储引擎;
```



# 视图

## 视图的原理

**基本概念**

视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含列，其数据来自对应的真实表（基表）

**基表和视图的关系图**

 ![image-20220831133623085](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220831133623085.png)

**总结：**

1. 视图是根据基表（可以使多个基表）创建的，视图是虚拟的表
2. 视图也有列，数据来自基表
3. 通过视图可以修改基表的数据
4. 基表的改变，也会影像到视图的数据

## 视图的基本使用

```sql
create view 视图名 as select语句
alter view 视图名 as select语句
show create view 视图名
drop view 视图名1，视图名2
```



## 细节

1. 创建视图后，到数据库文件夹看，对应视图只有一个视图结构的文件（形式：视图名.frm）
2. 视图的数据变化会影响到基表，基表的数据变化也会影响到视图（insert，update，delete）
3. 视图中可以再使用视图

## 视图的最佳实践

1. <span style="color:red">安全</span>。一些数据表有着重要的信息。有些字段是保密的，不能让用户直接看到。这时就可以创建一个视图，在这张视图中只保留一部分字段。这样，用户就可以查询到自己需要的字段，不能查看保密的字段
2. <span style="color:red">性能</span>。关系数据库的数据常常会分表存储，使用外键建立这些表的之间关系。这是数据库查询会用到连接（join）。这样做不但麻烦，效率相对也比较低。如果建立一个视图，将相关的表和字段组合在一起，就可以避免使用join查询数据
3. <span style="color:red">灵活</span>。如果系统中有一张旧的表，这张表由于设计的问题，即将被废弃。然而，很多应用都是基于这张表，不易修改。这是就可以建立一张视图，视图中的数据直接映射到新建的表。这样，就可以少做很多改动，也达到了升级数据表的目的。

# mysql管理

## mysql用户

mysql中的用户，都储存在系统数据库mysql中的user表内

![image-20220831142617430](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220831142617430.png)

其中user**表的重要字段说明**：

1. host：   允许登录的“位置”，loaclhost表示该用户只允许本机登录，也可以指定ip地址，比如192.168.0.100
2. user： 用户名；
3. authentication_string：密码，是通过mysql的password() 函数加密之后的密码

* drop user '用户' @ '允许登录的位置'

## 用户管理

* 创建用户

  ```sql
  create user '用户名' @'允许登录的位置（ip）' identified by '密码'
  说明： 创建用户，同时指定密码
  
  create user 'nino'@'localhost' identified by 'nino'
  ```

* 删除用户

  ```sql
  drop user '用户' @ '允许登录的位置'
  ```

* 用户修改密码

  ```sql
  修改自己的密码
  set password = password('密码');
  修改他人密码(需要修改密码的权限)
  set password for '用户名'@'登录位置' = password('密码');
  ```

 

**给用户授权**

基本语法

```sql
grant 权限列表 on 库.对象名 to '用户名'@'登录地址' 【identified by '密码'】

```

说明：

1. 权限列表，多个权限用逗号隔开

   ```sql
   grant select on...
   grant select,delete,create on 数据库名.表名/数据库.* to "用户名"@ip /'用户名'@'%';
   grant all 【privileges】 on ...//表示赋予该用户在该对象上的所有权限
   ```

2. 特别说明

   ```sql
   *.* ：代表本系统中的所有数据库的所有对象（表，视图，存储过程）
   库.*：表示某个数据库中的所有数据对象（表，视图，存储过程等）
   ```

3. identity by 可以省略，也可以写出

   1. 如果用户存在，就是修改该用户的密码
   2. 如果该用户不存在，就是创建该用户！

**回收用户权限**

基本语法：

```sql
revoke 权限列表 on 库.对象名 from '用户名'@'登录位置';
```

**权限生效指令**

```sql
如果权限没有生效则执行该指令
flush privileges;
```

**细节说明**

1. 在创建用户的时候，如果不指定host，则为%，%表示所有ip都有连接权限

2. 也可以这样指定

   ```sql
   create user'xxx'@'192.168.1.%'表示在192.168.1.*的ip可以登录mysql
   ```

3. 在删除用户的时候，如果host不是%，需要明确指定'用户'@’host值‘



# JDBC和连接池

## **介绍：**

1. jdbc是为访问不同的数据库提供了同一的接口，为使用者屏蔽了细节问题。
2. java程序员使用jdbc，可以连接任何提供了jdbc驱 动程序的数据库系统，从而完成对数据库的各种操作

**jdbc原理图**

![image-20220902161945307](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220902161945307.png)

**快速入门**

```java
package chapterJDBC;

import com.mysql.jdbc.Driver;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class JDBCdemo01 {
    public static void main(String[] args) throws SQLException {
//        前置工作，创建一个文件夹libs，将依赖jar文件放入然后点 add  to project
//        注册驱动
        Driver driver = new Driver();//a创建driver对象
//        得到连接
        String url  = "jdbc:mysql://localhost:3306/hsp_db03";
//        创建一个properties，将用户名密码存入
        Properties properties = new Properties();
//        说明：前面的user和password是规定好的不能改
        properties.setProperty("user","root");
        properties.setProperty("password","root");
        Connection connect = driver.connect(url, properties);


//        执行sql
        String sql ="insert into actor values (null,'张三','男','1970-11-11',110);";
        Statement statement = connect.createStatement();
        int i = statement.executeUpdate(sql);
        System.out.println( i>0?  "yes ":"no");

//        关闭链接资源

        statement.close();
        connect.close();
    }
}

```

## 连接数据库的五种方式

方式一：

```java
//创建Driver对象
Driver driver = new Driver();
        
        String url="jdbc:mysql://localhost:3306/hsp_db03";
        Properties properties = new Properties();
        properties.setProperty("user","root");
        properties.setProperty("password","root");
        Connection connect = driver.connect(url, properties);
        Statement statement = connect.createStatement();
        String sql="insert into actor values(null,'lisi','女','1980-11-11','123123')";
        int i = statement.executeUpdate(sql);
        if (i>0){
            System.out.println("success");
        }else {
            System.out.println("fall");
        }
```

方式二：

```java
 //使用反射加载driver类，动态加载，更加灵活，减少依赖性
Class<?> aClass = Class.forName("com.mysql.jdbc.Driver");
    Driver o = (Driver) aClass.newInstance();

    String url="jdbc:mysql://localhost:3306/hsp_db03";
    Properties properties = new Properties();
    properties.setProperty("user","root");
    properties.setProperty("password","root");
    Connection connect = o.connect(url, properties);
    Statement statement = connect.createStatement();
    String sql="insert into actor values(null,'lisi','女','1980-11-11','123123')";
    int i = statement.executeUpdate(sql);
    if (i>0){
        System.out.println("success");
    }else {
        System.out.println("fall");
    }
}
```

方式三:使用DriverManager代替driver统一管理

```java
s
Class<?> aClass = Class.forName("com.mysql.jdbc.Driver");
    Driver driver = (Driver) aClass.newInstance();

    String url="jdbc:mysql://localhost:3306/hsp_db03";
    String user = "root";
    String password ="root";

//    注册driver驱动
    DriverManager.registerDriver(driver);
    Connection connection = DriverManager.getConnection(url, user, password);

    String sql="insert into actor values(null,'laoliu','女','1980-11-11','123123')";

    Statement statement = connection.createStatement();
    int i = statement.executeUpdate(sql);
    if (i>0){
        System.out.println("success");
    }else {
        System.out.println("fall");
    }

```

方式四：

```java
//    使用Class.forName 会自动完成注册驱动，简化代码
// 相对于方式三只是少了 DriverManager.registerDriver(driver);注册驱动语句
        Class<?> aClass = Class.forName("com.mysql.jdbc.Driver");

    Driver o = (Driver) aClass.newInstance();

    String url="jdbc:mysql://localhost:3306/hsp_db03";
    String user = "root";
    String password ="root";
    String sql="insert into actor values(null,'laoliu','女','1980-11-11','123123')";
    
    Connection connection = DriverManager.getConnection(url, user, password);
    Statement statement = connection.createStatement();
    statement.executeUpdate(sql);
```

方式四。1：

```java
//相较于方式四可以省略 Class<?> aClass = Class.forName("com.mysql.jdbc.Driver");语句

```

提示：

1. mysql驱动5.1.6可以无需输入Class.forName("com.mysql.jdbc.Driver");
2. 从jdk1.5以后使用jdbc4，不再需要显示调用Class.forName("com.mysql.jdbc.Driver");注册驱动 而是自动调用驱动。jar包下META-INF\services\java.sql.Driver文本中类名去注册
3. 建议写上Class.forName("com.mysql.jdbc.Driver");，更加明确

方式五

```java
public void fangshi05() throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException {
//        在方式4的基础上改进，增加配置文件让其更加灵活
//    1.读取配置文件
    Properties properties = new Properties();
    properties.load(new FileInputStream("src/main/resources/jdbcdemo.properties"));
    String user = properties.getProperty("user");
    String passwrod = properties.getProperty("password");
    String url = properties.getProperty("url");
    String driver = properties.getProperty("driver");

    System.out.println(url+user+passwrod);
    System.out.println(driver);

   Class.forName(driver);

    Connection connection = DriverManager.getConnection(url, user, passwrod);
    Statement statement = connection.createStatement();

    String sql ="insert into actor values(null,'laoliu','女','1980-11-11','123123')";
    int i = statement.executeUpdate(sql);
    if (i>0){
        System.out.println("success");
    }else {
        System.out.println("faslse");
    }


}
```

## ResultSet [结果集]

**介绍**  

1. 表示数据库结果集的数据表，通常通过执行查询数据库的语句生成
2. ResultSet对象保持一个光标指向其当前的数据行。最初，光标位于第一行之前
3. next方法将光标移动到下一行，并且由于在ResultSet 对象中没有更多行时返回false，因此可以在while循环中使用循环来遍历结果集

```java
package chapterJDBC;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.*;
import java.util.Properties;

public class resultsetDemo {
    public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException {
//       创建properti集合读取配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream("src/main/resources/jdbcdemo.properties"));
//将配置文件内容映射出来
        String url  = properties.getProperty("url");
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String driver = properties.getProperty("driver");
//      注册驱动
        Class.forName(driver);
//      建立连接
        Connection connection = DriverManager.getConnection(url, user, password);
//        得到statement
        Statement statement = connection.createStatement();
//      编写sql语句
        String sql = "select name,sex,borndate,phone from actor";
//       调用executeQuery方法执行sql语句，返回结果集由resultset接收
        ResultSet resultSet = statement.executeQuery(sql);
//        遍历结果集
        while (resultSet.next()){
//            从结果的第一列开始取，取完开始取第二行。
//            getxx方法后填的是列号
            String name = resultSet.getString(1);
            String sex = resultSet.getString(2);
            Date date = resultSet.getDate(3);
            int phone = resultSet.getInt(4);
            System.out.println("| "+name+"\t"+sex+"\t"+date+"\t"+phone+" |");
        }
//      关闭资源
        resultSet.close();
        statement.close();
        connection.close();



    }
}

```

## statement 



**基本介绍**

1. statement独享用于执行静态sql语句并返回其生成的结果的对象
2. 在连接建立后，需要对数据库进行访问，执行命令或是sql语句，可以通过
   * statement [存在sql注入问题]
   * preparedStatement[预处理]
   * CallableStatement 【储存过程】
3. statement对象执行sql语句，存在sql注入风险
4. sql注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据注入非法的得sql语句段或命令，恶意攻击数据库
   * **sql注入介绍**
   * ![image-20220907171222421](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220907171222421-16625419878771.png)
5. 要防范sql注入，只要用preparedStatement（从statement扩展而来）取代statement 就可以

## preparedStatement(预处理)

```java
//编写sql
String sql = "select count(*) form admin where username = ? and password=?";
```

1. preparedStatement执行的sql语句中的参数用问号(?)来表示，调用preparedStatement对象执行setXxx()方法老设置这些参数.setXxx()方法有两个参数，第一个参数是要设置sql语句中的参数的索引（从1开始），第二个是设置sql语句中的参数的值
2. 调用executeQuery()，返回ResultSet对象
3. 调用executeUpdate()：执行更新，包括增、删、修改

```java
案例
package chapterJDBC;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.*;
import java.util.Properties;
import java.util.Scanner;

public class preparedStatementDemo {
    public static void main(String[] args) throws IOException, ClassNotFoundException, SQLException {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入用户名");
        String username = scanner.nextLine();
        System.out.println("请输入密码");
        String pwd = scanner.nextLine();


        Properties properties = new Properties();
        properties.load(new FileInputStream("src/main/resources/jdbcdemo.properties"));
        String driver = properties.getProperty("driver");
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String url = properties.getProperty("url");

        Class.forName(driver);

        Connection connection = DriverManager.getConnection(url, user, password);
//        编写sql语句
        String sql  = "select name,phone from actor where name=? and phone =?";
//        调用preparedStatement方法将sql语句填入，并通过setString方法网sql语句内的占位符填入相应的内容
        PreparedStatement preparedStatement = connection.prepareStatement(sql);
        preparedStatement.setString(1,username);
        preparedStatement.setString(2,pwd);
//      执行语句，获得返回的信息，并处理
        ResultSet resultSet = preparedStatement.executeQuery();
        if (resultSet.next()){
            System.out.println("success");
        }else {
            System.out.println("error password");
        }

    }
}

```



**优点**

1. 不使用+拼接sql语句，减少语法错误
2. 有线的解决了sql注入问题
3. 大大减小了编译次数，效率较高

## 预处理的dml（增删改）

```java
public void dml() throws IOException, ClassNotFoundException, SQLException {


        Properties properties = new Properties();
        properties.load(new FileInputStream("src/main/resources/jdbcdemo.properties"));
        String driver = properties.getProperty("driver");
        String user = properties.getProperty("user");
        String password = properties.getProperty("password");
        String url = properties.getProperty("url");

        Class.forName(driver);

        Connection connection = DriverManager.getConnection(url, user, password);
//        增加
        String add = "insert into actor values(null,?,?,?,?);";
        Scanner scanner = new Scanner(System.in);
        PreparedStatement preparedStatement = connection.prepareStatement(add);
        System.out.println("please input name");
        String inputName = scanner.next();
        preparedStatement.setString(1,inputName);
        System.out.println("please input sex? 男/女");
        String sex = scanner.next();
        preparedStatement.setString(2,sex);
        System.out.println("please input borndate");
        String date = scanner.next();
        preparedStatement.setString(3,date);
        System.out.println("please input phone");
        String num = scanner.next();
        preparedStatement.setString(4,num);

        int i = preparedStatement.executeUpdate();
        System.out.println(i>0? "success":"error");


        preparedStatement.close();
        connection.close();

    }

```

##  封装一个jdbc工具类

 ```sql
 package chapterJDBC;
 
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.sql.*;
 import java.util.Properties;
 
 public class JDBCUtil {
     private static String username;
     private static String password;
     private static String url;
     private static String driver;
 
     static {
         Properties properties = new Properties();
         try {
             properties.load(new FileInputStream("src/main/resources/jdbcdemo.properties"));
             username = properties.getProperty("user");
             password = properties.getProperty("password");
             url  = properties.getProperty("url");
             driver = properties.getProperty("driver");
         } catch (IOException e) {
 //            在实际开发中，推荐这样处理
 //            1、将编译异常转成运行异常，然后throw掉
 //            2、这时调用者可以捕获该异常
             throw new RuntimeException(e);
         }
     }
 
     public static Connection getConnection(){
         try {
             return DriverManager.getConnection(url,username,password);
         } catch (SQLException throwables) {
             throw new RuntimeException(throwables);
         }
     }
 
 //    关闭相关资源
     public static void close(ResultSet resultSet, Statement statement,Connection connection){
 //        判断是否为null
         try {
             if (resultSet!= null){
                 resultSet.close();
             }else if (statement!=null){
                 statement.close();
             }else if (connection!=null){
                 connection.close();
             }
         }catch (SQLException e){
 //            将编译异常转成运行异常抛出
             throw new RuntimeException(e);
         }
 
     }
 }
 
 ```

测试

```java
package chapterJDBC;

import org.junit.jupiter.api.Test;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class utilTest {
    @Test
    public void utilDML(){
        Connection connection = null;
        PreparedStatement preparedStatement=null;
        String sqlUpdate ="update actor set name=? where name=?";

        try {
            connection = JDBCUtil.getConnection();
             preparedStatement = connection.prepareStatement(sqlUpdate);
            preparedStatement.setString(1,"zhangsan");
            preparedStatement.setString(2,"tanghao");
            int i = preparedStatement.executeUpdate();
            System.out.println(i>0? "success":"false");
        } catch (SQLException throwables) {
            throw new RuntimeException(throwables);
        }finally{
             JDBCUtil.close(null,preparedStatement,connection);
        }
       
    }
    @Test
    public void utilSelect(){
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        String sql="select * from actor";
        ResultSet resultSet =null;

        try {
            connection = JDBCUtil.getConnection();
            preparedStatement = connection.prepareStatement(sql);

             resultSet = preparedStatement.executeQuery();
            while (resultSet.next()){
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                String sex = resultSet.getString("sex");
                Date brondate = resultSet.getDate("borndate");
                int phone = resultSet.getInt("phone");
                System.out.println("\t"+id+"\t"+name+"\t"+sex+"\t"+brondate+"\t"+phone);
            }



        }catch (Exception e){
            throw new RuntimeException(e);
        }finally {
            JDBCUtil.close(resultSet,preparedStatement,connection);
        }



    }
}

```

## jdbc中的事务

**介绍**

1. JDBC程序中当一个connection对象创建时，默认那个框下是自动提交事务：每次执行一个sql语句时，如果执行成功，就会向数据库自动提交，而不能回滚

2. JDBC程序为了让多个sql语句作为一个整体执行，需要<span style="color:yellow">使用事务</span>

3. 调用connection的setAutoCommit（false）可以需要自动提交事务

4. 在所有sql语句都成功执行后，调用commit()；方法提交事务

5. 在其中某个操作失败或出现异常时，调用rollback;方法回滚事务

   ```java
   package chapterJDBC;
   
   import org.junit.jupiter.api.Test;
   
   import java.sql.Connection;
   import java.sql.PreparedStatement;
   import java.sql.SQLException;
   
   public class chapterTransaction {
       @Test
       public void usetransaction(){
           Connection connection = null;
           PreparedStatement preparedStatement = null;
           String sql1="update actor set phone = phone-100 where name=?";
           String sql2="update actor set phone = phone+100 where name=?";
   
   
           try {
               connection =  JDBCUtil.getConnection();
               connection.setAutoCommit(false);
               preparedStatement = connection.prepareStatement(sql1);
               preparedStatement.setString(1,"zhangsan");
               preparedStatement.executeUpdate();
               preparedStatement = connection.prepareStatement(sql2);
               preparedStatement.setString(1,"lisi");
               preparedStatement.executeUpdate();
   //            在执行上述语句时如果报错，则会直接进入回滚
   
   
   //            提交
               connection.commit();
   
           } catch (SQLException throwables) {
               try {
                   connection.rollback();//默认回滚到事物开始时
                   System.out.println("sql异常回滚");
               } catch (SQLException e) {
                   e.printStackTrace();
               }
   
           }finally {
               JDBCUtil.close(null,preparedStatement,connection);
           }
   
       }
   }
   
   ```

   

## 批处理

**基本介绍**

1. 当需要成批插入或更新记录时，可以采用java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交更有效率

2. JDBC的批量处理语句包括下面方法：

   addBatch():添加需要批量处理的sql语句或参数

   executeBatch():执行批量处理语句

   clearBatch()：清空批处理包的语句

3. <span style="color:red">JDBC连接mysql时，如果需要使用批处理功能，请再url中加参数?rewriteBatchedStatements=true</span>

4. 批处理往往和preparedStatement一起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高

5. ```java
   public void useBatch(){
           Connection connection = null;
           PreparedStatement preparedStatement = null;
           String sql = "insert into admin values(null,?,?)";
   
           try {
               connection = JDBCUtil.getConnection();
               preparedStatement = connection.prepareStatement(sql);
   //          循环五千次添加，并且每当到1000次时进行一次批量提交
               for (int i = 0; i < 5000; i++) {
                   preparedStatement.setString(1,"username"+i);
                   preparedStatement.setString(2,"password"+i);
   //                添加到批处理
                   preparedStatement.addBatch();
                   if ((i+1)%1000==0){//如果i除1000余0，则运行一次批处理
                       preparedStatement.executeBatch();
                       //执行完清空
                       preparedStatement.clearBatch();
   
                   }
   
               }
   
   
   
           } catch (SQLException throwables) {
               throwables.printStackTrace();
           }finally {
               JDBCUtil.close(null,preparedStatement,connection);
           }
       }
   ```

6. 

## 连接池

### **传统获取connection连接问题**

1. 传统的JDBC数据库连接使用DriverManager来获取，每次向数据库建立连接的时候都要将connection加载到内存中，再验证ip地址，用户名和密码(0.05s~1s时间)。需要数据库连接的的时候，就像数据库要求一个，频繁的进行数据库连接操作将占用很多系统资源，容易造成服务器崩溃。
2. 每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据<span style="color:red">库内存泄露</span>,最终将导致重启数据库。
3. 传统获取连接的方式，不能控制创建的连接数量，如果连接过多，也可能导致内存泄露，MYSQL崩溃
4. 解决传统开发中的数据库连接问题，可以采用数据库连接池技术(connection pool)

### **数据库连接池的基本介绍**

1. 预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需要从"缓存池"中取出一个，使用完毕后再放回去
2. 数据库连接池负责分配、管理和释放数据库连接，他允许应用程序<span style="color:yellow">重复使用</span>一个现有的数据库连接，而不是重新建立一个
3. 当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中
4. ![image-20220916160612084](https://ninos-img.oss-cn-shanghai.aliyuncs.com/img/image-20220916160612084.png)

### 数据库连接池的种类

1. JDBC的数据库连接池使用java.sql.DataSource来表示，DataSource只是一个接口，该接口通常由第三方提供实现
2. <span style ="color:yellow">C3P0</span>数据库连接池，速度相对较慢，稳定性不错(hibernate,spring)
3. DBCP数据库连接池，速度相对C3P0较快，但不稳定
4. Proxool数据库连接池，有监控连接池状态的功能，稳定性较C3P0差一点
5. BoneCP数据库连接池，速度快
6. <span style="color:yellow">Druid</span>(德鲁伊)是阿里提供的数据库连接池，集DBCP，C3P0，Proxool优点于一身的数据库连接池

**使用方式**

1. ```java
    public void method01() throws IOException, PropertyVetoException, SQLException {
   //        创建一个数据源对象
           ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();
   //        读取配置文件参数
           Properties properties = new Properties();
           properties.load(new FileInputStream("src/main/resources/jdbcdemo.properties"));
           String url = properties.getProperty("url");
           String username = properties.getProperty("user");
           String password = properties.getProperty("password");
           String driver = properties.getProperty("driver");
   //      设置数据源参数
           comboPooledDataSource.setDriverClass(driver);
           comboPooledDataSource.setJdbcUrl(url);
           comboPooledDataSource.setUser(username);
           comboPooledDataSource.setPassword(password);
   
   //        设置初始化参数
           comboPooledDataSource.setInitialPoolSize(10);
   //      设置最大连接数
           comboPooledDataSource.setMaxPoolSize(50);
   
   
   //        测试5000次连接操作
           for (int i = 0; i < 5000; i++) {
               //        这个方法是从DataSource接口实现的
               Connection connection = comboPooledDataSource.getConnection();
               System.out.println("ok");
               connection.close();
           }
   
       }
   ```

2. 方式二

   * 使用配置文件 <span style="color:blue">c3p0-config.xml</span>

     ```xml
     <?xml version="1.0" encoding="UTF-8"?>
     <c3p0-config>
         <!-- This is default config! -->
         <default-config>
             <property name="initialPoolSize">10</property>
             <property name="maxIdleTime">30</property>
             <property name="maxPoolSize">100</property>
             <property name="minPoolSize">10</property>
             <property name="maxStatements">200</property>
         </default-config>
     
         <!-- This is my config for mysql-->
         <named-config name="demo">
             <property name="driverClass">com.mysql.jdbc.Driver</property>
             <property name="jdbcUrl">jdbc:mysql://localhost:3306/hsp_db03?serverTimezone=GMT</property>
             <!--MySQL账户密码-->
             <property name="user">root</property>
             <property name="password">root</property>
             <!-- 初始化连接池中的连接数，取值应在minPoolSize与maxPoolSize之间，默认为3-->
             <property name="initialPoolSize">10</property>
             <!--最大空闲时间，60秒内未使用则连接被丢弃。若为0则永不丢弃。默认值: 0 -->
             <property name="maxIdleTime">30</property>
             <!--连接池中保留的最大连接数。默认值: 15 -->
             <property name="maxPoolSize">100</property>
             <!-- 连接池中保留的最小连接数，默认为：3-->
             <property name="minPoolSize">10</property>
             <!--c3p0全局的PreparedStatements缓存的大小。如果maxStatements与maxStatementsPerConnection均为0，则缓存不生效，只要有一个不为0，则语句的缓存就能生效。如果默认值: 0-->
             <property name="maxStatements">200</property>
             <!-- 当连接池连接耗尽时，客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException，如设为0则无限期等待。单位毫秒。默认: 0 -->
     
             <!--这种写法也可以
             <property name="checkoutTimeout" value="3000"/>
             -->
             <property name="checkoutTimeout">3000</property>
             <!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。默认值: 3 -->
             <!--
             <property name="acquireIncrement" value="2"/>
             -->
             <property name="acquireIncrement">2</property>
             <!--定义在从数据库获取新连接失败后重复尝试的次数。默认值: 30 ；小于等于0表示无限次-->
             <!--
             <property name="acquireRetryAttempts" value="0"/>
             -->
             <property name="acquireRetryAttempts">0</property>
             <!--重新尝试的时间间隔，默认为：1000毫秒-->
             <!--
             <property name="acquireRetryDelay" value="1000" />
             -->
             <property name="acquireRetryDelay">1000</property>
             <!--关闭连接时，是否提交未提交的事务，默认为false，即关闭连接，回滚未提交的事务 -->
             <property name="autoCommitOnClose">false</property>
             <!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。默认值: null -->
             <property name="automaticTestTable">Test</property>
             <!--如果为false，则获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常，但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。默认: false-->
             <property name="breakAfterAcquireFailure">false</property>
             <!--每60秒检查所有连接池中的空闲连接。默认值: 0，不检查 -->
             <property name="idleConnectionTestPeriod">60</property>
             <!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。默认值: 0 -->
             <property name="maxStatementsPerConnection">200</property>
         </named-config>
     
     
         <!-- This is my config for oracle
         <named-config name="oracle">
             <property name="driverClass">oracle.jdbc.driver.OracleDriver</property>
             <property name="jdbcUrl">jdbc:oracle:thin:@localhost:1521:orcl</property>
             <property name="user">scott</property>
             <property name="password">liang</property>
             <property name="initialPoolSize">10</property>
             <property name="maxIdleTime">30</property>
             <property name="maxPoolSize">100</property>
             <property name="minPoolSize">10</property>
             <property name="maxStatements">200</property>
         </named-config>
         -->
     </c3p0-config>
     
     
     ```

     

   * 将配置文件放在src目录下

### 遇到的问题

1. **通过配置文件链接c3p0时，运行会报错找不到驱动**

**原因**：是编译后，配置文件没有加载到classes文件夹下。手动复制进去即可。

**解决方法：**是在pom文件（前提是maven项目）下添加以下配置(目前添加后没有什么用，不知道是否生效)

```xml
 <build>
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.xml</include>
                    <include>**/*.properties</include>
                    <include>**/*.yml</include>
                    <include>**/*.p12</include>
                </includes>
                <filtering>false</filtering>
            </resource>

            <resource>
                <directory>src/main/resources</directory>

                <includes>
                    <include>**/*.xml</include>
                    <include>**/*.properties</include>
                    <include>**/*.yml</include>
                    <include>**/*.p12</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
    </build>
```



##  德鲁伊连接池

**德鲁伊的使用**

1. 引入druid的依赖jar包

2. 创建配置文件druid.properties

3. 创建properties对象，读取配置文件

4. ```java
    public void druiddemo01() throws Exception {
           Properties properties1 = new Properties();
           properties1.load(new FileInputStream("src/main/resources/druid.properties"));
           DataSource dataSource = DruidDataSourceFactory.createDataSource(properties1);
      
           long start = System.currentTimeMillis();
           for (int i = 0; i < 5000; i++) {
               Connection connection = dataSource.getConnection();
               connection.close();
           }
           long end = System.currentTimeMillis();
           System.out.println(end-start);
      
       }
      
   ```

### 基于德鲁伊的数据库工具类

```java
public class JDBCUtil {
    private static String username;
    private static String password;
    private static String url;
    private static String driver;

    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream("src/main/resources/jdbcdemo.properties"));
            username = properties.getProperty("user");
            password = properties.getProperty("password");
            url  = properties.getProperty("url");
            driver = properties.getProperty("driver");
        } catch (IOException e) {
//            在实际开发中，推荐这样处理
//            1、将编译异常转成运行异常，然后throw掉
//            2、这时调用者可以捕获该异常
            throw new RuntimeException(e);
        }
    }

    public static Connection getConnection(){
        try {
            return DriverManager.getConnection(url,username,password);
        } catch (SQLException throwables) {
            throw new RuntimeException(throwables);
        }
    }

//    关闭相关资源
    public static void close(ResultSet resultSet, Statement statement,Connection connection){
//        判断是否为null
        try {
            if (resultSet!= null){
                resultSet.close();
            }else if (statement!=null){
                statement.close();
            }else if (connection!=null){
                connection.close();
            }
        }catch (SQLException e){
//            将编译异常转成运行异常抛出
            throw new RuntimeException(e);
        }

    }
}
```

**测试**

```java
 public void UseDruidUtilsDemo(){
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet =null;
        String sql ="select id,username,password from admin order by ? limit 0,100";


        try {
            connection = JDBCDruidUtil.getConnection();
            preparedStatement = connection.prepareStatement(sql);
//            preparedStatement.setString(1,"admin");
            preparedStatement.setString(1,"id");
            resultSet = preparedStatement.executeQuery();

            while (resultSet.next()){
                String id = resultSet.getString(1);
                String username = resultSet.getString(2);
                String password = resultSet.getString(3);
                System.out.println("\t"+id+"\t"+username+"\t"+password+"\t");

            }
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            JDBCDruidUtil.close(resultSet,preparedStatement,connection);
        }
    }
```

**注意：**使用setString方法时，拼接后会给拼接的字段添加''（单引号），如果填的是表名的话，就会报错

## Apache--DBUtils

**理解**：

传统方法的连接池工具类中，接收的resultset不能用作数据处理，关闭链接就失效等缺点。解决方法：就是利用创建一个实体类并根据ArrayList接收成一个集合，才能在关闭链接的情况下保留数据。

虽然已经有DBUtils方法比较强大，但是先手写一个demo便于理解

```java
//    封装到一个ArrayList集合中
    @Test
public void UseDruidUtilsDemo2(){
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet =null;
    String sql ="select id,username,password from admin order by ? limit ?,?";
   // 定义一个相对应的实体类泛型的集合
    ArrayList<admin> admins = new ArrayList<>();


    try {
        connection = JDBCDruidUtil.getConnection();
        preparedStatement = connection.prepareStatement(sql);
//            preparedStatement.setString(1,"admin");
        preparedStatement.setString(1,"id");
        preparedStatement.setInt(2,0);
        preparedStatement.setInt(3,2);
        resultSet = preparedStatement.executeQuery();

        while (resultSet.next()){
            int id = resultSet.getInt(1);
            String username = resultSet.getString(2);
            String password = resultSet.getString(3);
		//接收并添加到集合中
            System.out.println(id+username+password);
            admins.add(new admin(id,username,password));

        }
    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        JDBCDruidUtil.close(resultSet,preparedStatement,connection);
    }
    //关闭链接后依然可以保留数据
    
    //遍历显示数据
//      迭代器遍历
//        Iterator<admin> iterator = admins.iterator();
//        while (iterator.hasNext()) {
//            admin next =  iterator.next();
//            System.out.println(next.toString());
//
//        }
//    增强for
        for (admin admin : admins) {
            System.out.println(admin.toString());

        }
    }
```

**基本介绍**

1. common-dbutils是Apache组织的一个开源JDBC工具类库，它是对JDBC的封装使用dbutils能极大简化jdbc的编码的工作量

   * DbUtils类

2. QueryRunner类：该类封装了SQL的执行，是线程安全带的。可以实现增、删、改、查、批处理

3. 使用QueryRunner类实现查询

4. ResultSetHandler接口：该接口用于处理java.sql.ResultSet，将数据按要求转换为另一种形式，

   ```
   ArrayHandler:把结果集中的第一行数据转成对象数组
   ArrayListHandler:把结果集中的每一行数据都转成一个数组，再存放在list中
   BeanHandler:将结果集中的第一行数据封装到一个对应的javaBean实例中
   BeanListHandler:将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到list里
   ColumnListHandler:将结果集中的每一列的数据存放到List中
   KeyedHandler(name):将结果集中的每行数据都封装到Map里，再把这些的map存放到一个map里，其key为指定的key。
   MapHandler:将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值
   MapListHandler:将结果集中的每一行数据都封装到一个Map里，然后再存放到List
   ```

   

相对于上述的手写工具类节省了大量的代码

demo使用DBUtils+Druid（德鲁伊连接池），完成对admin表的crud

```java

@Test
//    使用DBUtils+Druid（德鲁伊连接池），完成对admin表的crud
    public void testQuerymant(){
//        1.得到链接
        Connection connection = JDBCDruidUtil.getConnection();
//      2.使用DButils类和接口，先引入先关的jar,加入到本项目
//      3.  创建一个QueryRunner
        QueryRunner queryRunner = new QueryRunner();

        String sql ="select * from admin order by ? limit ?,?";
//       4. 可以执行相关的方法
        List<admin> admins = null;
        try {
            //            之所以泛型那里填写的admin.class是因为这里使用到了反射，此时是不知道admin类的路径的，所以用反射去获取
            //注意：使用反射的话，实体类要有一个无参构造器
            //5.new BeanListHandler<>(admin.class)：将在resultset ->admin对象 ——> 封装到 ArrayList 
            //底层使用反射机制，去获取admin类的属性，然后进行封装
            //语句后面的"id", 0, 10是可变参数Object...params(就是接收sql语句中的?参数填入sql的)，==原来的preparedStatement.setString()等方法传入的参数
             admins = queryRunner.query(connection, sql, new BeanListHandler<>(admin.class), "id", 0, 10);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            
//            6.在该工具类的底层result和preparedStatement自己给关掉了，所以直接传个null即可
                JDBCDruidUtil.close(null,null,connection);
        }
        for (admin admin : admins) {
            System.out.println(admin.toString());
        }

    }
```

**增删改演示**

```java
//    使用DBUtils+Druid（德鲁伊连接池）返回单个对象
    @Test
public void testQuerySingle(){
//        1.得到链接
    Connection connection = JDBCDruidUtil.getConnection();
//      2.使用DButils类和接口，先引入先关的jar,加入到本项目
//      3.  创建一个QueryRunner
    QueryRunner queryRunner = new QueryRunner();

    String sql ="select * from admin where id = ?";
//      执行相关的方法，返回单个的对象
    try {
//        此时使用的方法是BeanHandler，返回单个对象
        admin querySingle = queryRunner.query(connection, sql, new BeanHandler<>(admin.class), 2);
        System.out.println(querySingle);
    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        JDBCDruidUtil.close(null,null,connection);
    }

}

@Test
//      //    使用DBUtils+Druid（德鲁伊连接池）返回单个对象的单个数据，例如需要返回id=2 的名字
public void testQuerySingleColumn(){
//        1.得到链接
    Connection connection = JDBCDruidUtil.getConnection();
//      2.使用DButils类和接口，先引入先关的jar,加入到本项目
//      3.  创建一个QueryRunner
    QueryRunner queryRunner = new QueryRunner();

    String sql ="select username  from admin where id = ?";
//      执行相关的方法，返回单个的对象
    try {
//        此时使用的方法是BeanHandler，返回单个对象
        Object query = queryRunner.query(connection, sql, new ScalarHandler(), 2);
//        因为返回一个对象，使用的 Handler就是ScalarHandler。如果不存在就返回一个null
        System.out.println(query);

    } catch (SQLException e) {
        e.printStackTrace();
    }finally {
        JDBCDruidUtil.close(null,null,connection);
    }

}
@Test
    public void testQuerydml(){
//        1.得到链接
        Connection connection = JDBCDruidUtil.getConnection();
//      2.使用DButils类和接口，先引入先关的jar,加入到本项目
//      3.  创建一个QueryRunner
        QueryRunner queryRunner = new QueryRunner();

        String add ="insert into admin values (?,?,?)";
        String delete = "delete from admin where id=?";
        String update =" update admin set username=? where username=? ";

        String select="select * from admin where username=?";
        String select2="select * from admin where id=?";

        try {
//            执行dml操作使用方法update
//            返回值的意思是受影响的行数（affected:受影响的）.等于0基本上就是代表失败
            int update1 = queryRunner.update(connection, update, "zhangsan", "username0");
            System.out.println(update1>0? "执行成功":"执行失败");

            admin zhangsan = queryRunner.query(connection, select, new BeanHandler<>(admin.class), "zhangsan");
            System.out.println(zhangsan.toString());


            int update2 = queryRunner.update(connection, add,  null,"lisi233", "lisi");
            System.out.println(update2>0? "执行成功":"执行失败");
            if (update2>0){
                admin lisi = queryRunner.query(connection, select, new BeanHandler<>(admin.class), "lisi233");
                System.out.println(lisi);
            }

            int update3 = queryRunner.update(connection, delete, 3);
            System.out.println(update3>0? "执行成功":"执行失败");

            admin de = queryRunner.query(connection, select2, new BeanHandler<>(admin.class), 3);
            System.out.println(de);


        } catch (SQLException e) {
            e.printStackTrace();
        }
//        此时使用的方法是BeanHandler，返回单个对象

            JDBCDruidUtil.close(null,null,connection);


    }
```

## BasicDao--dao和增删改查通用方法

**理解：**

apache-dbutils+druid简化了JDBC开发，但还有不足

1. sql语句时固定的，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查

2. 对于select操作，如果有返回值，返回类型不能固定，需要使用泛型

3. 将来的表很多，业务需求复杂，不可能只靠一个java类完成

   









# **练习使用的sql代码**

## **分组统计**

```sql
create table emp(
empno MEDIUMINT UNSIGNED not null DEFAULT 0 , --编号
ename varchar(20) not null default "",--名字
job varchar(9) not null default "",--工作
mgr MEDIUMINT unsigned ,--上级编号
hiredate date not null,--入职时间
sal decimal(7,2) not null ,--薪水
comm decimal(7,2) ,--红利 奖金
deptno MEDIUMINT UNSIGNED not null DEFAULT 0 -- 部门编号
);

insert into emp VALUES
(7001,'niko','salesman',7698,'1991-10-01',1000.00,30000.00,30),
(7002,'ware','salesman',77369,'1991-03-21',2000.00,3000.00,30),
(7003,'haha','salesman',7698,'1991-10-01',2000.00,3300.00,30),
(7004,'nio','salesman',7698,'1991-10-01',1000.00,1000.00,30),
(7005,'zhangsan','salesman',7839,'1991-10-01',1000.00,12000.00,30),
(7006,'wangwu','salesman',7839,'1991-10-01',3000.00,3010.00,30),
(7007,'niko1','salesman',7698,'1991-10-01',4400.00,30000.00,10),
(7008,'niko3','salesman',7839,'1991-10-01',2200.00,13330.00,10),
(7009,'niko4','salesman',7698,'1991-10-01',3400.00,13300.00,10),
(7010,'niko2','salesman',7566,'1991-10-01',2400.00,30000.00,10),
(7011,'niko5','salesman',7698,'1991-10-01',1400.00,30000.00,20),
(7012,'niko6','salesman',7566,'1991-10-01',1200.00,30000.00,20),
(7013,'niko7','salesman',7698,'1991-10-01',1000.00,30000.00,20),
(7014,'niko8','salesman',7566,'1991-10-01',1000.00,230.00,30),
(7015,'niko9','salesman',7698,'1991-10-01',6000.00,30000.00,30),
(7016,'niko0','salesman',7566,'1991-10-01',1000.00,30000.00,30),
(7017,'niko53','salesman',7698,'1991-10-01',1000.00,20000.00,30),
(7018,'niko12','salesman',7698,'1991-10-01',1000.00,30000.00,30),
(7019,'niko13','salesman',7566,'1991-10-01',1000.00,20000.00,30),
(7020,'niko15','salesman',7698,'1991-10-01',1000.00,10000.00,30);

#工资级别表
create table salgrade
(
grade MEDIUMINT UNSIGNED not null default 0,
losal decimal(17,2) not null,
hisal decimal(17,2) not null);

insert into salgrade VALUES (1,700,1200);
insert into salgrade VALUES (2,1201,1400);
insert into salgrade VALUES (3,1401,2000);
insert into salgrade VALUES (4,2001,3000);
insert into salgrade VALUES (5,3001,9999);

演示group by +having
having 子句用于限制分组显示结果
```



左后练习作业

```sql
create table class (
    classid int primary key,
    `subject` varchar(32) not null default'',
    deptname varchar(32) not null default'',
    enrolltime date,
    num int);
drop table  student;

create table student (
    studentid int primary key ,
    name varchar(32) not null default '',
    age int,
    classid int
);

create table department(
    departmentid int primary key ,
    deptname varchar(32) not null default ''
)


```

## goods表

```sql
create table Goods (
    id int(11) primary key ,
    goods_name varchar(10),
    price double);

insert into goods values
(10,'华为手机',2000),
(20,'苹果手机',3000),
(30,'小米手机',2000),
(40,'vivo',null),
(50,'sansung',2300),
(60,'hari',1800),
(70,'ibm',5000),
(80,'格力手机',null),
(90,'格力手机',null)
  ;
```











