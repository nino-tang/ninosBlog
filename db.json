{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-color-dark.min.css","path":"css/kr-color-dark.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kratosr.min.css","path":"css/kratosr.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/prismjs.min.css","path":"css/prismjs.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/404.webp","path":"images/404.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/about.webp","path":"images/about.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/alipay.JPG","path":"images/alipay.JPG","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/alipay.webp","path":"images/alipay.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/avatar.webp","path":"images/avatar.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/banner.webp","path":"images/banner.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/banner_dark.webp","path":"images/banner_dark.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/bg.webp","path":"images/bg.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/bg_dark.webp","path":"images/bg_dark.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/comment.webp","path":"images/comment.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/comment_dark.webp","path":"images/comment_dark.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/failure.ico","path":"images/failure.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/psr.webp","path":"images/psr.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wechat.JPG","path":"images/wechat.JPG","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wechat.webp","path":"images/wechat.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wxjb.webp","path":"images/wxjb.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/candy.min.js","path":"js/candy.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-dark.min.js","path":"js/kr-dark.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kratosr.min.js","path":"js/kratosr.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/local-search.min.js","path":"js/local-search.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/pjax.min.js","path":"js/pjax.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/snow.min.js","path":"js/snow.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/light.min.css","path":"css/highlight/light.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-blue.min.css","path":"css/highlight/night-blue.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-bright.min.css","path":"css/highlight/night-bright.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-eighties.min.css","path":"css/highlight/night-eighties.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night.min.css","path":"css/highlight/night.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/logo/logo.webp","path":"images/logo/logo.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_1.webp","path":"images/thumb/thumb_1.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_10.webp","path":"images/thumb/thumb_10.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_11.webp","path":"images/thumb/thumb_11.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_12.webp","path":"images/thumb/thumb_12.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_13.webp","path":"images/thumb/thumb_13.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_14.webp","path":"images/thumb/thumb_14.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_15.webp","path":"images/thumb/thumb_15.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_16.webp","path":"images/thumb/thumb_16.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_17.webp","path":"images/thumb/thumb_17.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_18.webp","path":"images/thumb/thumb_18.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_19.webp","path":"images/thumb/thumb_19.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_2.webp","path":"images/thumb/thumb_2.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_20.webp","path":"images/thumb/thumb_20.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_3.webp","path":"images/thumb/thumb_3.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_4.webp","path":"images/thumb/thumb_4.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_5.webp","path":"images/thumb/thumb_5.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_6.webp","path":"images/thumb/thumb_6.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_7.webp","path":"images/thumb/thumb_7.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_8.webp","path":"images/thumb/thumb_8.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_9.webp","path":"images/thumb/thumb_9.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/HELP-US-OUT.txt","path":"vendors/font-awesome@4.7.0/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/README.md","path":"vendors/font-awesome@4.7.0/README.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/package.json","path":"vendors/font-awesome@4.7.0/package.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/History.md","path":"vendors/nprogress@0.2.0/History.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/License.md","path":"vendors/nprogress@0.2.0/License.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Notes.md","path":"vendors/nprogress@0.2.0/Notes.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Readme.md","path":"vendors/nprogress@0.2.0/Readme.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/bower.json","path":"vendors/nprogress@0.2.0/bower.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/component.json","path":"vendors/nprogress@0.2.0/component.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.css","path":"vendors/nprogress@0.2.0/nprogress.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.js","path":"vendors/nprogress@0.2.0/nprogress.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/package.json","path":"vendors/nprogress@0.2.0/package.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/LICENSE","path":"vendors/qrcode_js@1.0.0/LICENSE","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/README.md","path":"vendors/qrcode_js@1.0.0/README.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/bower.json","path":"vendors/qrcode_js@1.0.0/bower.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index-svg.html","path":"vendors/qrcode_js@1.0.0/index-svg.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index.html","path":"vendors/qrcode_js@1.0.0/index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index.svg","path":"vendors/qrcode_js@1.0.0/index.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/jquery.min.js","path":"vendors/qrcode_js@1.0.0/jquery.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/package.json","path":"vendors/qrcode_js@1.0.0/package.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/qrcode.js","path":"vendors/qrcode_js@1.0.0/qrcode.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/qrcode.min.js","path":"vendors/qrcode_js@1.0.0/qrcode.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.css","path":"vendors/aplayer@1.10.1/dist/APlayer.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.css.map","path":"vendors/aplayer@1.10.1/dist/APlayer.min.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.js","path":"vendors/aplayer@1.10.1/dist/APlayer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.js.map","path":"vendors/aplayer@1.10.1/dist/APlayer.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/clipboard@2.0.6/dist/clipboard.js","path":"vendors/clipboard@2.0.6/dist/clipboard.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/clipboard@2.0.6/dist/clipboard.min.js","path":"vendors/clipboard@2.0.6/dist/clipboard.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/disqusjs@1.3.0/dist/disqus.js","path":"vendors/disqusjs@1.3.0/dist/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/disqusjs@1.3.0/dist/disqusjs.css","path":"vendors/disqusjs@1.3.0/dist/disqusjs.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css.map","path":"vendors/font-awesome@4.7.0/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css","path":"vendors/font-awesome@4.7.0/css/font-awesome.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.min.css","path":"vendors/font-awesome@4.7.0/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","path":"vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/animated.less","path":"vendors/font-awesome@4.7.0/less/animated.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/bordered-pulled.less","path":"vendors/font-awesome@4.7.0/less/bordered-pulled.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/core.less","path":"vendors/font-awesome@4.7.0/less/core.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/fixed-width.less","path":"vendors/font-awesome@4.7.0/less/fixed-width.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/font-awesome.less","path":"vendors/font-awesome@4.7.0/less/font-awesome.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/icons.less","path":"vendors/font-awesome@4.7.0/less/icons.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/larger.less","path":"vendors/font-awesome@4.7.0/less/larger.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/list.less","path":"vendors/font-awesome@4.7.0/less/list.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/mixins.less","path":"vendors/font-awesome@4.7.0/less/mixins.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/path.less","path":"vendors/font-awesome@4.7.0/less/path.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/rotated-flipped.less","path":"vendors/font-awesome@4.7.0/less/rotated-flipped.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/screen-reader.less","path":"vendors/font-awesome@4.7.0/less/screen-reader.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/stacked.less","path":"vendors/font-awesome@4.7.0/less/stacked.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/variables.less","path":"vendors/font-awesome@4.7.0/less/variables.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/font-awesome.scss","path":"vendors/font-awesome@4.7.0/scss/font-awesome.scss","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk-component.js","path":"vendors/gitalk@1.7.2/dist/gitalk-component.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk-component.js.map","path":"vendors/gitalk@1.7.2/dist/gitalk-component.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.css","path":"vendors/gitalk@1.7.2/dist/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.css.map","path":"vendors/gitalk@1.7.2/dist/gitalk.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.js","path":"vendors/gitalk@1.7.2/dist/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.js.map","path":"vendors/gitalk@1.7.2/dist/gitalk.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.min.js","path":"vendors/gitalk@1.7.2/dist/gitalk.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.min.js.map","path":"vendors/gitalk@1.7.2/dist/gitalk.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/constants.js","path":"vendors/gitment@0.0.3/dist/constants.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/constants.js.map","path":"vendors/gitment@0.0.3/dist/constants.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.browser.js","path":"vendors/gitment@0.0.3/dist/gitment.browser.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.browser.js.map","path":"vendors/gitment@0.0.3/dist/gitment.browser.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.js","path":"vendors/gitment@0.0.3/dist/gitment.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.js.map","path":"vendors/gitment@0.0.3/dist/gitment.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/icons.js","path":"vendors/gitment@0.0.3/dist/icons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/icons.js.map","path":"vendors/gitment@0.0.3/dist/icons.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/utils.js","path":"vendors/gitment@0.0.3/dist/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/utils.js.map","path":"vendors/gitment@0.0.3/dist/utils.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.js","path":"vendors/jquery@3.6.0/dist/jquery.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.min.js","path":"vendors/jquery@3.6.0/dist/jquery.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.min.map","path":"vendors/jquery@3.6.0/dist/jquery.min.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.js","path":"vendors/jquery@3.6.0/dist/jquery.slim.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.min.js","path":"vendors/jquery@3.6.0/dist/jquery.slim.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.min.map","path":"vendors/jquery@3.6.0/dist/jquery.slim.min.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/layui.all.js","path":"vendors/layui-src@2.5.5/dist/layui.all.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/layui.js","path":"vendors/layui-src@2.5.5/dist/layui.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.core.js","path":"vendors/mermaid@9.1.1/dist/mermaid.core.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.core.js.map","path":"vendors/mermaid@9.1.1/dist/mermaid.core.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs","path":"vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.LICENSE.txt","path":"vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.LICENSE.txt","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.map","path":"vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.js","path":"vendors/mermaid@9.1.1/dist/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.js.map","path":"vendors/mermaid@9.1.1/dist/mermaid.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js","path":"vendors/mermaid@9.1.1/dist/mermaid.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js.LICENSE.txt","path":"vendors/mermaid@9.1.1/dist/mermaid.min.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js.map","path":"vendors/mermaid@9.1.1/dist/mermaid.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/meting@2.0.1/dist/Meting.min.js","path":"vendors/meting@2.0.1/dist/Meting.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/component.html","path":"vendors/nprogress@0.2.0/test/component.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/test.js","path":"vendors/nprogress@0.2.0/test/test.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.all.min.js","path":"vendors/twikoo@1.5.11/dist/twikoo.all.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.all.min.js.LICENSE.txt","path":"vendors/twikoo@1.5.11/dist/twikoo.all.min.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.min.js","path":"vendors/twikoo@1.5.11/dist/twikoo.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.min.js.LICENSE.txt","path":"vendors/twikoo@1.5.11/dist/twikoo.min.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.Pure.min.js","path":"vendors/valine@1.4.18/dist/Valine.Pure.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.Pure.min.js.map","path":"vendors/valine@1.4.18/dist/Valine.Pure.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.js","path":"vendors/valine@1.4.18/dist/Valine.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.js.map","path":"vendors/valine@1.4.18/dist/Valine.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.umd.js","path":"vendors/valine@1.4.18/dist/Valine.min.umd.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.umd.js.map","path":"vendors/valine@1.4.18/dist/Valine.min.umd.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/detect.min.js","path":"vendors/valine@1.4.18/dist/detect.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/escape.min.js","path":"vendors/valine@1.4.18/dist/escape.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.css","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.js","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.d.ts","path":"vendors/@waline/client@1.6.0/dist/Waline.min.d.ts","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.js","path":"vendors/@waline/client@1.6.0/dist/Waline.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.js.map","path":"vendors/@waline/client@1.6.0/dist/Waline.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.d.ts","path":"vendors/@waline/client@1.6.0/dist/Waline.noStyle.d.ts","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.js","path":"vendors/@waline/client@1.6.0/dist/Waline.noStyle.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.js.map","path":"vendors/@waline/client@1.6.0/dist/Waline.noStyle.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/index.html","path":"vendors/@waline/client@1.6.0/dist/index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css.map","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.min.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.css.map","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.min.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.eot","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.svg","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.ttf","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff2","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/bootstrap.js","path":"vendors/bootstrap@3.3.4/dist/js/bootstrap.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js","path":"vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/npm.js","path":"vendors/bootstrap@3.3.4/dist/js/npm.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/theme/default.js","path":"vendors/gitment@0.0.3/dist/theme/default.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/theme/default.js.map","path":"vendors/gitment@0.0.3/dist/theme/default.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/layui.css","path":"vendors/layui-src@2.5.5/dist/css/layui.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/layui.mobile.css","path":"vendors/layui-src@2.5.5/dist/css/layui.mobile.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.eot","path":"vendors/layui-src@2.5.5/dist/font/iconfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.svg","path":"vendors/layui-src@2.5.5/dist/font/iconfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.ttf","path":"vendors/layui-src@2.5.5/dist/font/iconfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.woff","path":"vendors/layui-src@2.5.5/dist/font/iconfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.woff2","path":"vendors/layui-src@2.5.5/dist/font/iconfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/code.css","path":"vendors/layui-src@2.5.5/dist/css/modules/code.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/1.gif","path":"vendors/layui-src@2.5.5/dist/images/face/1.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/0.gif","path":"vendors/layui-src@2.5.5/dist/images/face/0.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/10.gif","path":"vendors/layui-src@2.5.5/dist/images/face/10.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/11.gif","path":"vendors/layui-src@2.5.5/dist/images/face/11.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/12.gif","path":"vendors/layui-src@2.5.5/dist/images/face/12.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/13.gif","path":"vendors/layui-src@2.5.5/dist/images/face/13.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/14.gif","path":"vendors/layui-src@2.5.5/dist/images/face/14.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/15.gif","path":"vendors/layui-src@2.5.5/dist/images/face/15.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/16.gif","path":"vendors/layui-src@2.5.5/dist/images/face/16.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/17.gif","path":"vendors/layui-src@2.5.5/dist/images/face/17.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/18.gif","path":"vendors/layui-src@2.5.5/dist/images/face/18.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/19.gif","path":"vendors/layui-src@2.5.5/dist/images/face/19.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/2.gif","path":"vendors/layui-src@2.5.5/dist/images/face/2.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/21.gif","path":"vendors/layui-src@2.5.5/dist/images/face/21.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/20.gif","path":"vendors/layui-src@2.5.5/dist/images/face/20.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/23.gif","path":"vendors/layui-src@2.5.5/dist/images/face/23.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/22.gif","path":"vendors/layui-src@2.5.5/dist/images/face/22.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/24.gif","path":"vendors/layui-src@2.5.5/dist/images/face/24.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/25.gif","path":"vendors/layui-src@2.5.5/dist/images/face/25.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/26.gif","path":"vendors/layui-src@2.5.5/dist/images/face/26.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/27.gif","path":"vendors/layui-src@2.5.5/dist/images/face/27.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/3.gif","path":"vendors/layui-src@2.5.5/dist/images/face/3.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/28.gif","path":"vendors/layui-src@2.5.5/dist/images/face/28.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/29.gif","path":"vendors/layui-src@2.5.5/dist/images/face/29.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/31.gif","path":"vendors/layui-src@2.5.5/dist/images/face/31.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/30.gif","path":"vendors/layui-src@2.5.5/dist/images/face/30.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/32.gif","path":"vendors/layui-src@2.5.5/dist/images/face/32.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/33.gif","path":"vendors/layui-src@2.5.5/dist/images/face/33.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/34.gif","path":"vendors/layui-src@2.5.5/dist/images/face/34.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/35.gif","path":"vendors/layui-src@2.5.5/dist/images/face/35.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/36.gif","path":"vendors/layui-src@2.5.5/dist/images/face/36.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/37.gif","path":"vendors/layui-src@2.5.5/dist/images/face/37.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/38.gif","path":"vendors/layui-src@2.5.5/dist/images/face/38.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/39.gif","path":"vendors/layui-src@2.5.5/dist/images/face/39.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/4.gif","path":"vendors/layui-src@2.5.5/dist/images/face/4.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/40.gif","path":"vendors/layui-src@2.5.5/dist/images/face/40.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/41.gif","path":"vendors/layui-src@2.5.5/dist/images/face/41.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/42.gif","path":"vendors/layui-src@2.5.5/dist/images/face/42.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/43.gif","path":"vendors/layui-src@2.5.5/dist/images/face/43.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/44.gif","path":"vendors/layui-src@2.5.5/dist/images/face/44.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/45.gif","path":"vendors/layui-src@2.5.5/dist/images/face/45.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/46.gif","path":"vendors/layui-src@2.5.5/dist/images/face/46.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/47.gif","path":"vendors/layui-src@2.5.5/dist/images/face/47.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/48.gif","path":"vendors/layui-src@2.5.5/dist/images/face/48.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/49.gif","path":"vendors/layui-src@2.5.5/dist/images/face/49.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/5.gif","path":"vendors/layui-src@2.5.5/dist/images/face/5.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/50.gif","path":"vendors/layui-src@2.5.5/dist/images/face/50.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/51.gif","path":"vendors/layui-src@2.5.5/dist/images/face/51.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/52.gif","path":"vendors/layui-src@2.5.5/dist/images/face/52.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/53.gif","path":"vendors/layui-src@2.5.5/dist/images/face/53.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/54.gif","path":"vendors/layui-src@2.5.5/dist/images/face/54.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/55.gif","path":"vendors/layui-src@2.5.5/dist/images/face/55.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/56.gif","path":"vendors/layui-src@2.5.5/dist/images/face/56.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/57.gif","path":"vendors/layui-src@2.5.5/dist/images/face/57.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/58.gif","path":"vendors/layui-src@2.5.5/dist/images/face/58.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/59.gif","path":"vendors/layui-src@2.5.5/dist/images/face/59.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/6.gif","path":"vendors/layui-src@2.5.5/dist/images/face/6.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/60.gif","path":"vendors/layui-src@2.5.5/dist/images/face/60.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/61.gif","path":"vendors/layui-src@2.5.5/dist/images/face/61.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/62.gif","path":"vendors/layui-src@2.5.5/dist/images/face/62.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/63.gif","path":"vendors/layui-src@2.5.5/dist/images/face/63.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/64.gif","path":"vendors/layui-src@2.5.5/dist/images/face/64.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/65.gif","path":"vendors/layui-src@2.5.5/dist/images/face/65.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/66.gif","path":"vendors/layui-src@2.5.5/dist/images/face/66.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/67.gif","path":"vendors/layui-src@2.5.5/dist/images/face/67.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/68.gif","path":"vendors/layui-src@2.5.5/dist/images/face/68.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/69.gif","path":"vendors/layui-src@2.5.5/dist/images/face/69.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/7.gif","path":"vendors/layui-src@2.5.5/dist/images/face/7.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/70.gif","path":"vendors/layui-src@2.5.5/dist/images/face/70.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/71.gif","path":"vendors/layui-src@2.5.5/dist/images/face/71.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/8.gif","path":"vendors/layui-src@2.5.5/dist/images/face/8.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/9.gif","path":"vendors/layui-src@2.5.5/dist/images/face/9.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/carousel.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/carousel.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/code.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/code.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/colorpicker.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/colorpicker.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/element.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/element.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/flow.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/flow.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/form.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/form.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/jquery.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/jquery.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laydate.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/laydate.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layedit.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/layedit.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layer.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/layer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layim.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/layim.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laypage.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/laypage.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laytpl.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/laytpl.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/mobile.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/mobile.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/rate.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/rate.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/slider.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/slider.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/table.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/table.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/transfer.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/transfer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/tree.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/tree.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/upload.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/upload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/util.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/util.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/plugins/emojis/index.js","path":"vendors/valine@1.4.18/dist/plugins/emojis/index.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/plugins/emojis/light.json","path":"vendors/valine@1.4.18/dist/plugins/emojis/light.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/layim.css","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/layim.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/chatlog.html","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/chatlog.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/find.html","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/find.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/mobile/layim.css","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/mobile/layim.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/getmsg.json","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/getmsg.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/msgbox.html","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/msgbox.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/1.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/1.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/2.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/2.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/3.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/3.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/4.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/4.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/5.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/5.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/logo.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/logo.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/voice/default.mp3","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/voice/default.mp3","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/laydate/default/laydate.css","path":"vendors/layui-src@2.5.5/dist/css/modules/laydate/default/laydate.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon-ext.png","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon-ext.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon.png","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-0.gif","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-0.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/layer.css","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/layer.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-1.gif","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-1.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-2.gif","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-2.gif","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"594570bf9c908588a489c21d1846ea055a7a8fa2","modified":1666845864488},{"_id":"source/_posts/Node.js安装与配置（详细步骤）.md","hash":"545d46850d1aa0cce8aa58c89ac806995626c0f6","modified":1665630914282},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1665630914283},{"_id":"source/_posts/hexo+github搭建博客.md","hash":"7f111144526824d809f63c0b26dcd91596467bf5","modified":1665630914283},{"_id":"source/_posts/java基础笔记.md","hash":"d12d706ba4c012dbe5f83408d3fba410d5b77b46","modified":1666846462434},{"_id":"node_modules/hexo-theme-kratos-rebirth/Kratos-Rebirth-Manual.md","hash":"1f2fe32940600601f88bf55b1e3f0d669ee78aa9","modified":1665630912896},{"_id":"node_modules/hexo-theme-kratos-rebirth/LICENSE","hash":"31a3d460bb3c7d98845187c716a30db81c44b615","modified":1665630912896},{"_id":"node_modules/hexo-theme-kratos-rebirth/_config.yml","hash":"2bce0e11456d45290667ba8670e7b11350e75b7a","modified":1665630912896},{"_id":"node_modules/hexo-theme-kratos-rebirth/ReadMe.md","hash":"b07f349495c3351002141650bbb8db33c3e20563","modified":1665630912896},{"_id":"node_modules/hexo-theme-kratos-rebirth/gulpfile.js","hash":"7d48d25a9520467cb26a34bac9222484f466f70d","modified":1665630912897},{"_id":"node_modules/hexo-theme-kratos-rebirth/package.json","hash":"d037e569fd7f674f589c1e9c7317dfc8516bd52d","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/.demo/_config.kratos-rebirth.yml","hash":"ca33ed423a7123c50c75dd61d24392caa3c16615","modified":1665630912894},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/FUNDING.yml","hash":"034eaa235c5cc18532e09e24106120d711af0320","modified":1665630912894},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/dependabot.yml","hash":"89c16d0b45677ff20b86b655e3bfc7f1e675b2d4","modified":1665630912895},{"_id":"node_modules/hexo-theme-kratos-rebirth/languages/zh-CN.yml","hash":"f253d94bc5171ef6e00d0511c3f4db26d3441781","modified":1665630912897},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/archive.ejs","hash":"6dec1243c2d76a415d2fa5766ab184652c90c18c","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/category.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/index.ejs","hash":"caf093b695c940527aebbf3532cc8cd016ed0e94","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/layout.ejs","hash":"ea86e5b8f64957145ff52f5e2660e62ff92e0b05","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/page.ejs","hash":"4593e0a73b36b34dce40e3fbfe4c8056a7c9eb8f","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/post.ejs","hash":"80744537a72bd31bee1162d8b69e938d989734d8","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/tag.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/additional-pages.js","hash":"b99cdd8fa23d0519403abefc595f031ebaace59a","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/cdn-optimize-helpers.js","hash":"b0865dc553d3b757757b5a0471d5bcef6fd5be41","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/check-update.js","hash":"fcadb1499a85d427d5b80fc6c64eab61ca999925","modified":1665630912903},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/friends.js","hash":"4c7dfca9d47c508934d7d27a56f8037a761da7ff","modified":1665630912903},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/genconfig.js","hash":"41e8da155a1cc418e05f3f9312568f0b3b9bd128","modified":1665630912903},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/search.js","hash":"fb892991e53a272db74ec5f3d3ab26e728c8ee06","modified":1665630912904},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/tag-widgets.js","hash":"78d14c05c6205762f73ad3df420d9c6e78b9cd4e","modified":1665630912904},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/ISSUE_TEMPLATE/bug_report.md","hash":"410f2b7b788f86585451c7f351245e4d51a87f91","modified":1665630912894},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/ISSUE_TEMPLATE/feature_request.md","hash":"40e561f1af41b0b88d146ec1ea62d7eabda3e890","modified":1665630912894},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/auto-release.yml","hash":"bb8f12db86ed191d831ef4036afeb047a41dce85","modified":1665630912895},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/build-demo.yml","hash":"a9db5770d0840e4d3072c1de70505be07339b7f5","modified":1665630912895},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/build-test.yml","hash":"47e843a2c76a84720e059665cce259a8d40453f0","modified":1665630912895},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/disqus.ejs","hash":"38a80a494e861be233b145675696ad9699aeeba0","modified":1665630912897},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/disqusjs.ejs","hash":"703b125ce33489c9be62a2c6ccfc913af9d0ca05","modified":1665630912897},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/gitalk.ejs","hash":"1d3e0fc575a5378aa878823a0ef31aeff0b72713","modified":1665630912897},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/gitment.ejs","hash":"7366111beed060f528e6ab6a1e907444d61519f5","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/livere.ejs","hash":"21dc5bc91d73b54b06ac36669eefd5258b07e83e","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/twikoo.ejs","hash":"7d0ac9d25737c75ab1236dd54c22d0a8c61f288e","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/valine.ejs","hash":"209c463bc047bac75b9ebe45e8cf87f6255a6368","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/waline.ejs","hash":"36ad550abddce2ab14e3948c2fe4f1846efa11ee","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/404.ejs","hash":"b29697cfdbbf641c8efdff7d0273a4883e678f42","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/categories.ejs","hash":"39a1c79de03dbc8295c9da59cebec15ae30dd632","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/search-page.ejs","hash":"3dc81379363c8ad0bedf8489a3e6200841ff2c79","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/tags.ejs","hash":"70b9ce41a0e149e60788ac6d16864fea5b3311e3","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/after-footer.ejs","hash":"f397b914b34e086342e5d00effbaea9d98caf107","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/footer.ejs","hash":"e60e2434911c05dab7aa683ddcc84aa554c51bcd","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/head.ejs","hash":"c9c3137a870398dc7df860095b9ace4285e4d6f9","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/header.ejs","hash":"5a0c9e8d4e20bc0cc3cd397843ab4315ed9845c5","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/sidebar.ejs","hash":"c34bd43af8b719d8444ccea4dd9bd173b01a024e","modified":1665630912900},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_plugins/mermaid.ejs","hash":"e749d76fe982771637e66e505c9265c218a4b580","modified":1665630912900},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_tools/player.ejs","hash":"af36d7c6cb593af243f5342028bb337364e9afaf","modified":1665630912900},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_tools/share.ejs","hash":"3f7369fc6344965f12315e5214aa9eee3fe8b5f1","modified":1665630912900},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/about.ejs","hash":"25cde6dff270c41ff9bb37242e3e6aa6b85761a4","modified":1665630912900},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/category.ejs","hash":"1f24ccfd175fabc83c7ea81f3412e78e65b8f3ab","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/posts.ejs","hash":"43461f2e3cb32b9092dcd9a977098ff8be6a3f68","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/tagcloud.ejs","hash":"223730bfe007f26d5279cb66f1da9222c7d64c62","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/toc.ejs","hash":"09bbd53a479953600de7f1f2e68e3c72c43410c5","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/lib/cdn.js","hash":"4d408c31df9605ac9d45a3cea53fcd1ab70178df","modified":1665630912903},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-color-dark.min.css","hash":"92a814c3fd3a954f77f0943f936dcf3b095f706f","modified":1665630912906},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kratosr.min.css","hash":"e1e9a22a19f9f95ec64d2449d242eb3eb26abd46","modified":1665630912906},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/prismjs.min.css","hash":"94df0fe6c26d18a094c54c30283d65c3659ccf7a","modified":1665630912906},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/404.webp","hash":"d2e2bd5cc2627a2b04d5e449a67949a2605ae13e","modified":1665630912907},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/about.webp","hash":"ca0fb739ab4426e7895742c1d8d52df1e14468e8","modified":1665630912907},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/alipay.webp","hash":"01fa6151d2122f0470ee6f38ac8e4ced6c81912e","modified":1665630912909},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/avatar.webp","hash":"3ed6e4e1e08e9c2700aa149d1f9e068fb02947cd","modified":1665630912909},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/banner.webp","hash":"7c5093243bfd581a633ba8a905e2d379cfa78c00","modified":1665630912910},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/banner_dark.webp","hash":"5589986444825e2b75c369d419ff736d3a396bac","modified":1665630912910},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/bg.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1665630912910},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/bg_dark.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1665630912911},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/comment.webp","hash":"7756b5a69f2a85a2d1c4251e3055bfa0218aa385","modified":1665630912911},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/comment_dark.webp","hash":"7756b5a69f2a85a2d1c4251e3055bfa0218aa385","modified":1665630912911},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1665630912912},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/psr.webp","hash":"bf457bf84bca767bac1bd2b960d91c53ba3fbdee","modified":1665630912912},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wechat.webp","hash":"06f3997bf554768c04cb588198c7b3d68c21b8e9","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wxjb.webp","hash":"722bad151afc24ee638f9cb07749666f81384b52","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/candy.min.js","hash":"68557657a90856086aaeaeeeeed768aa1e27d73e","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-dark.min.js","hash":"dc01e4d5e7863537fcf5c6ee240895253e238f37","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kratosr.min.js","hash":"19bfade8d8e04d42b48966f15e1ef70b8393eb56","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/local-search.min.js","hash":"9e60a349fe6bc9b0046f99f31aac125d0d66c1c3","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/pjax.min.js","hash":"49b491877a535d444875fcabe242654f47fc9082","modified":1665630912919},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/snow.min.js","hash":"0512232ec3bc342ff998abbebe5604cd73ef8b04","modified":1665630912919},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/light.min.css","hash":"c42fa620f43eaafa550bc68a7e69e6e34ada0032","modified":1665630912904},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-blue.min.css","hash":"3a02ca54dd6a7ca6a8deb10012b5604653e398c6","modified":1665630912905},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-bright.min.css","hash":"9a3a66fa13f93d5196b67e8cac24b2aac4165a2c","modified":1665630912905},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-eighties.min.css","hash":"c3731f78911a97ed001500796a6e8d4ee9a78ab5","modified":1665630912905},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night.min.css","hash":"6413d0664d104edd739554011c75b5a02b9f5fde","modified":1665630912905},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/logo/logo.webp","hash":"e2a66bc21bceaf23db81afdeb86cb1dbf62bc891","modified":1665630912912},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_1.webp","hash":"a818f050112ceb75e3a60dc1673a10783b254595","modified":1665630912913},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_10.webp","hash":"4983eeca7886bbe7c09b0c79f4774302fdfa1315","modified":1665630912913},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_11.webp","hash":"08d8d91e2b01768842abb47cd48a0f07d22d070c","modified":1665630912913},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_12.webp","hash":"b6b8e1281f9146925e45e937cb4d5b28bcabe957","modified":1665630912913},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_13.webp","hash":"c4c9050637f4ffa3cb7d782f59dadc993ac3a6de","modified":1665630912914},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_14.webp","hash":"f9300e2b45c1f061ec8cc21527142dafc558a9e6","modified":1665630912914},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_15.webp","hash":"8629f2a7d3b0192549f809e6b7479159af0222da","modified":1665630912914},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_16.webp","hash":"61714ccffd55d6fa74cf94bcdd5a464da04ce891","modified":1665630912914},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_17.webp","hash":"b5a036ec234a23c820a89d1c640b1f2e8dd3dfa4","modified":1665630912914},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_18.webp","hash":"5bc78b9d6cb0a0cf6daa3a35b93e575777a49ddd","modified":1665630912915},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_19.webp","hash":"15e0cd0cbe5c7166915a4b68680681beccc2afef","modified":1665630912915},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_2.webp","hash":"1bcf7461c2b9408b8a893013fa425eb46701faf6","modified":1665630912915},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_20.webp","hash":"4ab961d94a0d3abbefc7f6d9188a889ec2225e7a","modified":1665630912915},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_3.webp","hash":"3faffd2575e0751526249c5c56a2a5045a21363b","modified":1665630912915},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_4.webp","hash":"1d0f136590632e7ba31f5510d24891ba443f1f33","modified":1665630912916},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_5.webp","hash":"ba384ada1c2a17b67036addd68ffa1f604ab5a41","modified":1665630912916},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_6.webp","hash":"c2d8b68971dacd111566526f64d94932f5c6f076","modified":1665630912916},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_7.webp","hash":"4be8fe8ea1b3563b78924062e3aa013cd5c4e82b","modified":1665630912916},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_8.webp","hash":"9e6d74786d8459440d68c409eb654364dd279f8a","modified":1665630912916},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_9.webp","hash":"bca69e7d56982b43c52e9ffa17c8d5bb268834d8","modified":1665630912917},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1665630912952},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/README.md","hash":"3880a58a50ef7514317c4f47b5707d4fd0106c9c","modified":1665630912952},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/package.json","hash":"1f2b1a268fb702727f33f348e043ffd7d0b86ec5","modified":1665630912963},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/History.md","hash":"38f837f30c75bed4b8990b36fdf540fe3c63ccd3","modified":1665630913177},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/License.md","hash":"bc3e61d337e51c177534c644c20f190148d7905e","modified":1665630913177},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Notes.md","hash":"e7b5de6240b6918cbdccc708a06e4b20555966c1","modified":1665630913178},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Readme.md","hash":"63959b38ef0747eadd6f731b48d7aded7edc227b","modified":1665630913178},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/bower.json","hash":"55980d38b6f24ec91f44579bcd38c667986368c5","modified":1665630913178},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/component.json","hash":"ecbc4792d8583f73050dd4d918fea8073a7ded60","modified":1665630913178},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.css","hash":"17ca817a091da9dcf5fe0f2f1e1f2eea60a33149","modified":1665630913179},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.js","hash":"a7e1146d2021c42e68b599dc8bcc69d44fc31df3","modified":1665630913179},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/package.json","hash":"574122118ffc8d4705e58806a13612553bc41588","modified":1665630913179},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/LICENSE","hash":"7041717dd3a7d35354f94321b666e11977c7610e","modified":1665630913180},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/README.md","hash":"1a8e6fb255a22f8233dff9815ab8790bada84b3d","modified":1665630913180},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/bower.json","hash":"99449e46555b0ba514eca8246f1621048db97aa5","modified":1665630913180},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index-svg.html","hash":"3c856315a2467efcd00b278c570fbc7897021d98","modified":1665630913180},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index.html","hash":"7314a123d8a9acbd51321d4f538ba4b36b0673b5","modified":1665630913181},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index.svg","hash":"15730a03273bba608180e8b182453ae393b3c3e0","modified":1665630913181},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/package.json","hash":"b77af52b956e89bd76c6bf75cc33f0eca47c0bf4","modified":1665630913182},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/qrcode.js","hash":"8fa3048613aab15c7f7edc3ac74a84e90375126d","modified":1665630913183},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/qrcode.min.js","hash":"2d06c1f823f34c19981c6ae0b0eb0f5861c5e14b","modified":1665630913183},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1665630912936},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1665630912937},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1665630912937},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/clipboard@2.0.6/dist/clipboard.js","hash":"8d661d3b6e11cb117361a6ff54cf54054b5d8668","modified":1665630912950},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/clipboard@2.0.6/dist/clipboard.min.js","hash":"6371ec0a8e242395c7d4d008d2b98e472c9dcc52","modified":1665630912950},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/disqusjs@1.3.0/dist/disqus.js","hash":"b79249dfb619836cfd1251cb3c3d5c603bc55e61","modified":1665630912951},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/disqusjs@1.3.0/dist/disqusjs.css","hash":"0d8ae5946142b17f9a75683c7649cf73d6fdbe17","modified":1665630912951},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1665630912953},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1665630912952},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1665630912953},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/animated.less","hash":"421f2c4e10191f148c13b8a34e5ff3f484d4c393","modified":1665630912959},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/bordered-pulled.less","hash":"a2c292137b17406183ad0fdbf4880fd648b9a5ca","modified":1665630912960},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/core.less","hash":"1a37352286619b789d151a06eb4b7551e4c1aaa2","modified":1665630912960},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/fixed-width.less","hash":"ec0c24b97184dab86177660f486b8d08cd636c42","modified":1665630912960},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/font-awesome.less","hash":"9ffe7422dc235450a21f019f410ed359ed151f4b","modified":1665630912960},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/icons.less","hash":"0285a999eb1adad868366678c2d9365b77186a45","modified":1665630912961},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/larger.less","hash":"e7119e82dc50540dbc3472bba7d74282815a7ecc","modified":1665630912961},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/list.less","hash":"f53bc20884a1410d950b4a36a330c5181a8b55ab","modified":1665630912962},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/mixins.less","hash":"3c5b36b0069372b525ed8bbbcf6b3d4d2bed4e78","modified":1665630912962},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/path.less","hash":"1afb4a849059631f76ed2a519d7fb1bd0af14802","modified":1665630912962},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/rotated-flipped.less","hash":"95de5de9009714692430b04f9cd4388be8fba8f3","modified":1665630912962},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/screen-reader.less","hash":"71139132f170ebe7712836210f4d2c4905151899","modified":1665630912962},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/stacked.less","hash":"f044077bc8be1a989c245254e81eb084d52d29a7","modified":1665630912963},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/variables.less","hash":"8a5c800747705df16117cc598c1b9f512e873bfe","modified":1665630912963},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_animated.scss","hash":"8daf189b2f8a404495b8424b6fd1ba630dd1c2dc","modified":1665630912964},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_bordered-pulled.scss","hash":"164b6a0a2b307cd293f4a914ab0fcdf643950374","modified":1665630912964},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_core.scss","hash":"55a14a34267edc401b82e5ee41d8bd84fbb5da3f","modified":1665630912964},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_fixed-width.scss","hash":"224417ca266c657849afb2bbcb6dc455894ff387","modified":1665630912964},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_icons.scss","hash":"830e0183337d16c07b1c63838f7593a33ee87b15","modified":1665630912965},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_larger.scss","hash":"940e1c5ebc690283bfaee92560cf15fabedbf6a9","modified":1665630912965},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_list.scss","hash":"4b53ee01513df8b9ce76442b2d8f1851613a435c","modified":1665630912965},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_mixins.scss","hash":"4f3881034a4c11cae8cc915f288477b498a357a2","modified":1665630912965},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_path.scss","hash":"080158aeb1bf6df59ec98b2bbed44da61d9c9ca3","modified":1665630912966},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_rotated-flipped.scss","hash":"ca08a0af3da63c2f2a7d3c27a8747637744cc785","modified":1665630912966},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_screen-reader.scss","hash":"2d8563c488f68e75a28d540dd89301ee4ee08c97","modified":1665630912966},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_stacked.scss","hash":"cf6752ee609af36eb293a7197c88d31ecacbbc74","modified":1665630912966},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_variables.scss","hash":"0d6d70535104b42e60d7f44ae6ccf9de023a7b8b","modified":1665630912966},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/font-awesome.scss","hash":"dd83648ea5bc832f87c3c1bf956c54dec065a9bd","modified":1665630912967},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.css","hash":"61d71cb30f5f34cbb1f2b5bc469784d6cb908c22","modified":1665630912989},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.css.map","hash":"9dda04c29af8da6ac13a507beefea6fce4d7032e","modified":1665630912989},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/constants.js","hash":"08f6c79bf52239cbdd457bc0a94df395f578ee07","modified":1665630913031},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/constants.js.map","hash":"6b7b473ef4bba09ea572b3baaac73c122372439e","modified":1665630913032},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.js","hash":"df37d9fe8c1a0a1fb2883e5bcb93f880bb2bbf2e","modified":1665630913034},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.js.map","hash":"2cb4d20d09b110268e0ea8c199f72501aa2d66e8","modified":1665630913034},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/icons.js","hash":"d303f91799600aa8c7f5f5bb18c652fafac4359d","modified":1665630913034},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/icons.js.map","hash":"5604e4382d787a9a1976359d92bb9827f11c2c2b","modified":1665630913034},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/utils.js","hash":"df76ada59b1cf94a7ea1d44c56a6624d248b4228","modified":1665630913035},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/utils.js.map","hash":"6f99a8c2269c938d4422f3a244a8086f89800890","modified":1665630913035},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/layui.js","hash":"be7bcdcb4eb932f3e700e63584661f19b4139739","modified":1665630913072},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.LICENSE.txt","hash":"38165332beeccd3551309f85addb2354f2d18676","modified":1665630913102},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js.LICENSE.txt","hash":"38165332beeccd3551309f85addb2354f2d18676","modified":1665630913170},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/meting@2.0.1/dist/Meting.min.js","hash":"f2b3d20b8bd64ccd031c64628f2b1323078ae324","modified":1665630913177},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/component.html","hash":"5965cc7f9bb812ada1ffcd6abec39124c20a4ef8","modified":1665630913179},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/test.js","hash":"5c795debb89ec7d35ba1ec1e8ccbab0a7a353d78","modified":1665630913180},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.all.min.js.LICENSE.txt","hash":"c00fe261d987618ec25243062c089a6982d4480c","modified":1665630913187},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.min.js.LICENSE.txt","hash":"c00fe261d987618ec25243062c089a6982d4480c","modified":1665630913188},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/detect.min.js","hash":"596d6dcbe379f78a2ec655188d7bfa7182848e03","modified":1665630913200},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/escape.min.js","hash":"4f91bb0e3a71ce6421b303c6c32bb3fb3e751192","modified":1665630913200},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1665630912919},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1665630912921},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.d.ts","hash":"e8ff14efdfb197dec848f18bbdc337c18cf00956","modified":1665630912922},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.d.ts","hash":"e8ff14efdfb197dec848f18bbdc337c18cf00956","modified":1665630912929},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/index.html","hash":"c720f2027fb93454bbc7eb14ae4eb274a47e8642","modified":1665630912936},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css","hash":"a22e254bf086bf442a09344afe0e6cf188f5a1d5","modified":1665630912939},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css.map","hash":"ccb7ff3435bb5cff1fe9643fc0ac8cdde2dcd177","modified":1665630912940},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.min.css","hash":"fc6b4268fbd57ad95d2b41a1d4d6866f222fbdb2","modified":1665630912941},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1665630912946},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1665630912948},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1665630912947},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1665630912948},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js","hash":"27947c0c0fa837da9bdfdfc36f649c25f54bd1c0","modified":1665630912949},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/npm.js","hash":"e2b7590d6ec1fdac66b01fdf66ae0879f53b1262","modified":1665630912950},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/theme/default.js","hash":"449e59ac4b6b9c66384ee123e1523b5392d684a5","modified":1665630913035},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/theme/default.js.map","hash":"0b7317800be0ea17fa142c7bb26f7e8158b54447","modified":1665630913035},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/layui.mobile.css","hash":"f15da6c149002dd57ea25b8346534c8161c86e3c","modified":1665630913043},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.eot","hash":"de1bec30d0ef87af6ab83ab6a269c3c59bc83124","modified":1665630913049},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.ttf","hash":"5d2b8777c623bb6e96577cee675489d0299ffa1f","modified":1665630913051},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.woff","hash":"6133b92b4e5c3866675b2656ceae14606fa01eb0","modified":1665630913051},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.woff2","hash":"c9b04ae5b10f88f8bc7c48840164f468ee7b10b0","modified":1665630913051},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/code.css","hash":"d7adeb3ada7c3c069aa6d098f953e0a87cfb49ef","modified":1665630913044},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/1.gif","hash":"e6da9a45ecb8c766a8f7c2362ccf2976d20d17a9","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/0.gif","hash":"87db440c06299666a8a1f407a6008c5bf6d70817","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/10.gif","hash":"04fe5b26b7e2c980d12ad7157a4ce908c2a74f14","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/11.gif","hash":"170c2e16dd383e26d9d68406eb217dbf191ea14e","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/12.gif","hash":"f5da3f33448e67537e3df8ff63b010247b06841c","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/13.gif","hash":"0afcb6c47cb53fa4a8467d7d7bf00ec464df2f8e","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/14.gif","hash":"1af45520e97328498b1a281b6955df5029fc9679","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/15.gif","hash":"a0f216d0aaaeec369109e4b581eacd4e83e5ccb6","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/16.gif","hash":"54db2506b93b76c58174177245dcc6ef3fd0591f","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/17.gif","hash":"0b88c01b477d4ca98eb99a665c0ab8738551aeec","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/18.gif","hash":"eeee84a351d6e84d291b0c27e5d70014a3a2748d","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/19.gif","hash":"620b2afa4c36cbfdd09c57807d8a662a5267ea51","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/2.gif","hash":"43b3ca892341431f697e1326aa693c1f252922be","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/21.gif","hash":"86d3d5273ffd13841d246698eb648d85e178c4dc","modified":1665630913054},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/20.gif","hash":"7f1cefe1db5c5ee6a9b0eea4d9618cba4b1ac790","modified":1665630913054},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/23.gif","hash":"43295056d287f3da526dfb77915edc3de7551e3e","modified":1665630913054},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/22.gif","hash":"dcad257d86505e921618f7d85b60bf6ac2ce319d","modified":1665630913054},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/24.gif","hash":"02a263028625496740eea9a50141a4ad98d826a1","modified":1665630913054},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/25.gif","hash":"05eeb7a9c42a2cd3876417944143078ce514a8b9","modified":1665630913055},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/26.gif","hash":"153c5f602881b04bed23d5c7d21a977563075ee2","modified":1665630913055},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/27.gif","hash":"814bad015177103646b0216367fa9707361998d3","modified":1665630913055},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/3.gif","hash":"339482962bc4995e16e99ac9de9fc067636fd79e","modified":1665630913056},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/28.gif","hash":"5830d72546907c962b6c9003fa923798a67b0406","modified":1665630913055},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/29.gif","hash":"ef1d583626e7447f546995a5b296f34eb3364902","modified":1665630913056},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/31.gif","hash":"29043ca9d16adf6574d4d7efde1af7a615689931","modified":1665630913056},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/30.gif","hash":"886222551781040325cfd3307fbfba2a1d434a9e","modified":1665630913056},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/32.gif","hash":"9af01aea73b614e5820a00bcc890840493f9dd70","modified":1665630913057},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/33.gif","hash":"5f02bc5ec8d6220a872f1ca1fa2abaa92d46c361","modified":1665630913057},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/34.gif","hash":"e0e500feecd8274490a3bdbf64d2555c16a86261","modified":1665630913057},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/35.gif","hash":"141ae180796db9800770dc9dbb8c9beda6f170e8","modified":1665630913057},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/36.gif","hash":"55abcc242354c9c1c73538db5d8c7b984de5ca52","modified":1665630913057},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/37.gif","hash":"850b9425421c3072a4898154d41776c02a4d64f7","modified":1665630913058},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/39.gif","hash":"6380eb13d87fc4242d2c6eec57f482ac8ca1ad1f","modified":1665630913058},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/38.gif","hash":"336cb3cbe0fd6cac96cd7cd5ca847c6a01f95b50","modified":1665630913058},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/4.gif","hash":"878c3da67e6aec79c9b8dba6f34368586f4bd097","modified":1665630913058},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/41.gif","hash":"c37fb5c43ea499a005d88075a392ed2e09c331df","modified":1665630913059},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/42.gif","hash":"86f11fca6a9c42d3678ec8af35c077a9790ce777","modified":1665630913059},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/40.gif","hash":"c1b0fef186697125b66c1b4617fa3f9abc4d92eb","modified":1665630913059},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/43.gif","hash":"6a16279bea1179b3fd3a45736ecffd983a42272d","modified":1665630913059},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/44.gif","hash":"32a9fa973626a3a06646095aeeecb919923f7d16","modified":1665630913060},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/45.gif","hash":"864dfc9b99f5641f6d5a0081dc14d84872c1b3c6","modified":1665630913060},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/47.gif","hash":"653e07693ee719cafbce662bb5e410646fe4695a","modified":1665630913060},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/46.gif","hash":"b6c74edb2dc383e0f3e28a0859fa87683fea18e2","modified":1665630913060},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/48.gif","hash":"8a8483cd4e3b4b6ac0567eab41c5655ace4b3a81","modified":1665630913060},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/49.gif","hash":"dbf616c5537074ace036340bdddf7948c138c3d7","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/5.gif","hash":"cf43cfcf14bbc7f8e430b74a97eb3b260f16b08c","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/50.gif","hash":"94a521d4f9a69c4eb59f5bbe673c8803246bdf5e","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/51.gif","hash":"1ef1419f1ba2fd28e7de676ae5c388074646be53","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/52.gif","hash":"b516f6bd28cee1fe34144d897b702989782be4ec","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/53.gif","hash":"a03f9bbb0202d24d3313286f60ce08b214c013d2","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/54.gif","hash":"75c738c517217f6b09d51ca3036cf54a01891c4d","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/55.gif","hash":"c446b5eca2cce1faa7f2147a8b646cc774011de1","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/56.gif","hash":"a71c1ef36706c4ddf7959c68d6c40920db3efe67","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/57.gif","hash":"b797ac8509a8f8bc328b10153e0026449a6139ec","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/58.gif","hash":"5c70cba8adb0b42c0da4d922498c265e5d8034d7","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/59.gif","hash":"c50da42e6f2ec33112261f46c30e5ea5b4a0f889","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/6.gif","hash":"697d8f2262c535cd61808a564b21fc10ea93f0db","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/60.gif","hash":"bdb24b7ec836fbf6c60c4d7ad97d73f041a154a8","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/61.gif","hash":"a5db56b975970ebe7048a5c824604d64559392b9","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/62.gif","hash":"a839a263600c034bb11411a7f762dfa917155d10","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/63.gif","hash":"28e9ec7a3882fec8c63dd731b06a9bbcc179aff7","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/64.gif","hash":"38a537e9ac930736e162be81c13c5f708ff948bd","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/65.gif","hash":"93cab4423539955a25d17c83da6aee277a6402aa","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/66.gif","hash":"6efe452b1f7a697db1c654130a9c2b872f528654","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/67.gif","hash":"50e2ed8f7773e60ae7d40b612db98554b8277b6e","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/68.gif","hash":"e779199003a7415a29d50ecf0bbfed04e031f1ab","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/69.gif","hash":"76ac840c5bc5ad44302daa921e7217149576b89e","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/7.gif","hash":"ad4e2ea1864a85f5729a1347c2f8c49fdb3b2def","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/70.gif","hash":"7c2641bef26579d9f90bdc0b740357527dd6e484","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/71.gif","hash":"c6323d6d6d262011faed18e758e9e83e7b6812b8","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/8.gif","hash":"43baffc48b0fbe649ed920bad713e2ccab9b7344","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/9.gif","hash":"8df9fc1055efeffdb72d499c064c05445adaa9be","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/carousel.js","hash":"ff770a94f4e7edd26f4449909e3d72644de83149","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/code.js","hash":"31972b8e26aac0f3b1233ad76c45187a39f4d977","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/colorpicker.js","hash":"0234f7a6eba2238583fe4644c0a247dacd67f73b","modified":1665630913066},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/element.js","hash":"1900e7f8bca28958e0a495731c7b3957ea0157c6","modified":1665630913066},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/flow.js","hash":"b6b4ffe415022a6788767906b837e2894057371b","modified":1665630913066},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/form.js","hash":"6ed3220f5b8cbee7f287ca851dd5d294790281ee","modified":1665630913066},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laydate.js","hash":"53e871827a2c0bc04ec239e9461a5eb18a309075","modified":1665630913068},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layedit.js","hash":"ce8c049188c64ec3cd3d302f8e72d0094d85c462","modified":1665630913068},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layer.js","hash":"448f76fa3ccfb66a5d86b02cf785f67adf0d8033","modified":1665630913069},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layim.js","hash":"c79d7e577901f2ceab86f01f00cc4c26ff1b038e","modified":1665630913069},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laypage.js","hash":"fec79457cffad05f261ab518e9d69bbebab548f0","modified":1665630913069},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laytpl.js","hash":"b79191723a99f3e52b56e0afbd183d7338b9cfd4","modified":1665630913069},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/rate.js","hash":"c3a4b2dad9e829afb8cfae69203eef8ede02191b","modified":1665630913070},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/mobile.js","hash":"0f82e8ce6b6deb51afdc307f488fb24c6dd02dbc","modified":1665630913070},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/slider.js","hash":"c4e37a45ff9ae08f90492f894d86e7bec7542b26","modified":1665630913070},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/table.js","hash":"3a18563a832e11ae642bf6c2a8634a18768f2dbb","modified":1665630913070},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/transfer.js","hash":"e85e366ff7ca8a49d195e149ec971cb6893b8409","modified":1665630913071},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/tree.js","hash":"5a0c3d9b31a49d8e30e13ef187894d9d07bec69e","modified":1665630913071},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/upload.js","hash":"8eef1ed175c49a7f09f6ce472a7d12138ed8f8ed","modified":1665630913071},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/util.js","hash":"e5e39048df40763ddfff8ec271a6f8070fcb4f4e","modified":1665630913071},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/plugins/emojis/index.js","hash":"452e66f0b900282eab6f98743592793361ccbc65","modified":1665630913200},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/plugins/emojis/light.json","hash":"3ac2cd3cc07efff7c30ece9857b0527c5fc534d3","modified":1665630913200},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/layim.css","hash":"a669bd1141c1df237631738d41f9d0032f4ba0a3","modified":1665630913046},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/chatlog.html","hash":"64591e08bb5af1d22e976ba3b3175075c7e6cd12","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/find.html","hash":"ed8e6a3564bb52fc7adc8f19c7be34f25fe97222","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/mobile/layim.css","hash":"0af51b5e2280a03cefcde3e4cf6662d274cc64c6","modified":1665630913046},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/getmsg.json","hash":"3a83d94b0d8bdb96459e36ea042a72768ea3b348","modified":1665630913046},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/msgbox.html","hash":"521979a7d5b54e6c00dedaa897ae547065da9b2c","modified":1665630913046},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/1.jpg","hash":"f0ba9086fa730c9c80b89f25ff440b740a4b06df","modified":1665630913047},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/2.jpg","hash":"ee9e802e6a46b5b698a4d0c36249c0085b192c68","modified":1665630913047},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/3.jpg","hash":"56cd08ca560acd37d377626b1b67cc4947bfe314","modified":1665630913047},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/4.jpg","hash":"e018753c3fbd420f8987e53f8a9fc62428ecc18d","modified":1665630913047},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/5.jpg","hash":"a7c37d5401127afeb1ddd930c9ad9f0e3fab3d31","modified":1665630913048},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/logo.jpg","hash":"3014e3081d5d4164143936fcf61e7080e81faf38","modified":1665630913048},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/voice/default.mp3","hash":"18ac4168a61de5cd4a35f814e97365945de94ab0","modified":1665630913048},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/laydate/default/laydate.css","hash":"bc0f2f7396ca62c86bc07c2db1b73ca83de3cbdb","modified":1665630913044},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon-ext.png","hash":"ddf2a30ad34bac4e9a1250f29c46ac0823d62a12","modified":1665630913044},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon.png","hash":"fe47ec617507e9ce5f6ce7ac9b179a3c9231882b","modified":1665630913044},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-0.gif","hash":"ba81388bbac5bc223f94489b97a95a13f3c78e47","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/layer.css","hash":"ed6fefb1501b3bcd720919f9ce55bb322b5d7ec5","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-1.gif","hash":"49e54acbf5674212195e581848ec0d490282448f","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-2.gif","hash":"c641615e851254111e268da42d72ae684b3ce967","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wechat.JPG","hash":"0ed6d709610ec11148fa1da18df3df1a252628be","modified":1665630912917},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/jquery.min.js","hash":"a8c8a5caf9765b4ccb90d708045518e219a9af5d","modified":1665630913182},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1665630912958},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1665630912959},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1665630913037},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.min.js","hash":"d1c6704e94efe2d465fc161b6381e127d35acd81","modified":1665630913041},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.min.map","hash":"17a9498757f0b358580ffce586bbc97ae897e8d8","modified":1665630913042},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1665630912921},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.min.css","hash":"ed29315e0ffb3f14382431f2724235bf67f44eb3","modified":1665630912945},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1665630912947},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/bootstrap.js","hash":"542cfd539f0cad650342c8cab8baf1cdbcd5fea6","modified":1665630912949},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/layui.css","hash":"e15327d5c8f4c82909edc97977b277207e01364d","modified":1665630913043},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/jquery.js","hash":"36456de559419079e1096890c7e9a97ae1bbf1be","modified":1665630913067},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1665630912938},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1665630912954},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1665630912956},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1665630912957},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1665630913032},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.min.map","hash":"c98b6a5cb27af645c8bfb525fcad3569f3917d5b","modified":1665630913039},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.Pure.min.js","hash":"227fb19caf17f4330ac24cb952af466eeaae5c43","modified":1665630913190},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.js","hash":"d081a412c63411a75a3a880ddece65335d1c3ee8","modified":1665630913194},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1665630912921},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.js","hash":"d9494e4919cbc017d7b0d70bb70dbcd97c35fcb1","modified":1665630912923},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.js","hash":"888cb555c5e9749cfe5a5a6cad2a8f56167b9dc4","modified":1665630912930},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.css","hash":"f2183455571b19311a235bd5aa204e694ade8e94","modified":1665630912942},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/alipay.JPG","hash":"07fb99a913ca0ba0ec32df0cacab37b75e7c3d63","modified":1665630912909},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.js","hash":"77ec5d7bdb33634ff7d76837e36f0a7240c21e86","modified":1665630913040},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.umd.js","hash":"90de88757741f89ad68c8d3765174437454e2303","modified":1665630913197},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.browser.js.map","hash":"72dc603fb7be8b623d1a402419b42c36723367bb","modified":1665630913034},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.js","hash":"af32f706407ab08f800c5e697cce92466e735847","modified":1665630913037},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/layui.all.js","hash":"4fbff21286558e3cb817072d76ae326db4378c6e","modified":1665630913072},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.Pure.min.js.map","hash":"40e15912aae8beff90cbb8ae235cd6fcd36f87dc","modified":1665630913192},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.umd.js.map","hash":"6fe9ac91ca5074bcbc696f887802e8304e31aaea","modified":1665630913199},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.svg","hash":"d484cee6f2461c9194b28878a1d1a677ffdbb78c","modified":1665630913050},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.min.js","hash":"e547de978c573d0e7beda7ad74829ce6fef6b058","modified":1665630913188},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.js.map","hash":"fb6f3071e92d08b0c66808ff9cfd190a0341d93d","modified":1665630913196},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.css.map","hash":"2e1d08a9694cd5a694eabca746cfad95fb99653e","modified":1665630912945},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1665630912957},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.all.min.js","hash":"31c6669a90a33ee5af66ceaf47996ad8fd8b962e","modified":1665630913187},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1665630913021},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.js.map","hash":"6a31b3aabb3bb6e0e2b7640feec5500617d01950","modified":1665630912935},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.js.map","hash":"42ce7c8e816ffa115df320a5eb75975291b86731","modified":1665630912929},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs","hash":"c01a600693e204abd02d0bf056a98a49e8a78d6e","modified":1665630913102},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js","hash":"6bee48c26c32b90f50519f125890fcbb04779da6","modified":1665630913170},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.core.js","hash":"7952663a721317158468875349956182465b0701","modified":1665630913078},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.core.js.map","hash":"1d19d75bea55a0c0062661bb0fe5ad4135f68d8a","modified":1665630913096},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk-component.js","hash":"fe4c44fa48522e9b2675f3a652d83d8aaec11ad8","modified":1665630912977},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.js","hash":"540a80bafeba53826127d556487541332ecd6ed1","modified":1665630912998},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk-component.js.map","hash":"6f118aa575a5da5449d0c171f1c85fa5e43f80ff","modified":1665630912988},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.js.map","hash":"b5d129e59c5a1ca46395fbf7466432983178ebba","modified":1665630913018},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.map","hash":"0ad921fcf8f5f79cf5fdf5deb5b4ffc21e501ff0","modified":1665630913123},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js.map","hash":"bd1138557833d1ec29ce678d2f994e053f180423","modified":1665630913176},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.js.map","hash":"199ed9c41ad0bec69a69514beb6f39f7b3a78ae5","modified":1665630913163},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.min.js.map","hash":"6a9f6d47092f2557b346c0eabbd5907a1b12a9e7","modified":1665630913031},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.js","hash":"e1f5d58724700b9cd810bb4e295ac93b6724578d","modified":1665630913144}],"Category":[{"name":"安装文档","_id":"cl9qlthbp00028frfcai27024"},{"name":"博客相关","parent":"cl9qlthbp00028frfcai27024","_id":"cl9qlthbu000a8frfh86laqns"},{"name":"学习笔记","_id":"cl9qlthbw000e8frf21z5ezyr"},{"name":"java","parent":"cl9qlthbw000e8frf21z5ezyr","_id":"cl9qlthbx000h8frfd1rdanu4"}],"Data":[],"Page":[],"Post":[{"title":"Node.js安装与配置（详细步骤）","date":"2022-09-24T13:52:45.000Z","comments":1,"toc":true,"pic":null,"_content":"\n[TOC]\n\n\n\n# 一、安装Node.js\n\n## 1.下载\n\n[Node.js官网下载](http://nodejs.cn/download/)\n根据自身系统下载对应的安装包（我这里为Windows11 64位，故选择下载第一个安装包）\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/914dfb1bae004d71bab1d7cc2c01a671.png)\n\n## 2.安装\n\n双击安装包，点击Next，勾选使用许可协议，点击Next，选择安装位置（可根据个人情况更换路径，我这里选择安装在E:\\devTools\\nodejs）\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/493dfc78735841f395c4a116898f5c6f.png)\n\n继续点击Next，点击Next，点击Install，点击Finish完成安装。\n\n## 3.添加环境变量\n\n### 3.1 进入环境变量，编辑【系统变量】下的变量【Path】\n\n![选择Path变量](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d128a4fe1ce34016b08a2842cde77166.png)\n\n### 3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）\n\n![写入Node.js安装路径](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/4609bccc18d8419ea764fb0153454ca9.png)\n\n# 二、验证是否安装成功\n\n进入cmd命令行窗口，输入node -v查看nodejs版本\n\n``` \nnode -v\n```\n\n输入npm -v查看npm版本\n\n```\nnpm -v\n```\n\n\n如下图所示，即为安装成功：\n\n![验证是否安装成功](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ff513962ea164d019d3a9d542d26f0ba.png)\n\n# 三、修改模块下载位置\n\n<span style=\"color:yellow;background:red\">**此步骤修改以后npm全局下载模块的保存位置，可根据自身情况选择是否更改。**</span>\n\n## 1.查看npm默认存放位置\n\n使用npm get prefix查看npm全局模块的存放路径\n\n```\nnpm get prefix\n```\n\n\n使用npm get cache查看npm缓存默认存放路径\n\n```\nnpm get cache\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21684575b404a7f87f83572f8df3d4c.png)\n\n如上图所示，npm 全局模块存放位置以及cache的存放位置，默认是在 C 盘 “C:\\Users\\用户\\AppData” 下。\n\n## 2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e9847471a84c45ddb1fc416a223cdb55.png)\n\n## 3.修改默认文件夹\n\n设置全局模块的安装路径到 “node_global” 文件夹，\n\n```\nnpm config set prefix \"E:\\devTools\\nodejs\\node_global\"\n```\n\n设置缓存到 “node_cache” 文件夹\n\n```\nnpm config set cache \"E:\\devTools\\nodejs\\node_cache\"\n```\n\n\n如下图所示：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6e67a30770ff40c49f640007f96703d1.png)\n\n<span style =\"color:red\">**注意：**</span>由于 node 全局模块大多数都是可以通过命令行访问的，还要把【node_global】的路径“E:\\devTools\\nodejs\\node_global”加入到【系统变量 】下的【PATH】 变量中，方便直接使用命令行运行，如下图所示：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bb96741ac93447aba9e65f0a184e3d11.png)\n\n## 4.测试默认位置是否更改成功\n\n经过上面的步骤，nodejs下载的模块就会自动下载到我们自定义的目录，接下来我们测试一下是否更改成功。输入下面的命令：\n\n```\nnpm install express -g\n```\n\n或者\n\n```\nnpm install express --global\n```\n\n<span style=\"color:red\">**注意：**</span>“-g”等同于“–global”，“-g” 是全局安装，不加“-g”就是默认下载到当前目录。“-g” 表示安装到之前设置的【node_global】目录下，同时nodejs会自动地在node_global文件夹下创建【node_modules】子文件夹， 即自动下载到“E:\\devTools\\nodejs\\node_global\\node_modules” 路径下。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e05642e304a443ec85794f2ac3bad6a8.png)如上图所示，下载express模块成功，然后在文件管理器中查看是否保存到上面自定义的路径下。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d460d0cd30884a83bb175a6e6127aeca.png)可以看到，express模块已经成功地下载到【E:\\devTools\\nodejs\\node_global\\node_modules】下。\n\n<span style=\"color:red\">**注意：**</span>若执行命令npm install express -g出现如下报错：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6caaa64529e0401aa2d467a8a5ceec22.png)\n\n是由于对文件夹操作的权限不够，右击Nodejs文件夹->属性->安全，点击编辑，将所有权限都✔即可。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d1a6f84379d3443bad6af4c734e169d7.png)\n\n※执行npm install express -g仍然出错的话继续将nodejs下【node_cache】、【node_global】、【node_modules】这三个文件夹的所有权限勾选，再次执行：\n\n```\nnpm install express -g\n即可下载成功。\n```\n\n# 四、设置淘宝镜像\n\n## 1.将npm默认的registry修改为淘宝registry\n\n说明：npm 默认的 registry ,也就是下载 npm 包时会从国外的服务器下载，国内下载会很慢，一般更换为淘宝镜像：https://registry.npm.taobao.org。\n\n### 1.1 查看当前使用的镜像路径\n\n```\nnpm config get registry\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ef81e85548b74e06bc325a27a9914258.png)\n\n### 1.2 更换npm为淘宝镜像\n\n```\nnpm config set registry https://registry.npm.taobao.org/\n```\n\n### 1.3 检查镜像是否配置成功\n\n再次执行npm config get registry，检查当前的镜像路径：\n\n```\nnpm config get registry\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/5e6a5bd3b935462fb2521db2d9ea2577.png)\n\n如上图所示，npm默认的registry已修改为淘宝registry。\n\n## 2.全局安装基于淘宝源的cnpm\n\n说明：由于npm的服务器在海外，所以访问速度比较慢，访问不稳定 ，cnpm的服务器是由淘宝团队提供，服务器在国内，cnpm是npm镜像，一般会同步更新，相差在10分钟，所以cnpm在安装一些软件时候会比较有优势。但是cnpm一般只用于模块安装，在项目创建与卸载等相关操作时仍使用npm。\n\n### 2.1 全局安装基于淘宝源的cnpm\n\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/b1247b4bd75d4e128914eba35e2ed91f.png)\n\n### 2.2 本地查看cnpm模块\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d9dddf1705e84f5990b2062db823cde4.png)\n\n### 2.3 执行命令查看cnpm是否安装成功\n\n```\ncnpm -v\n```\n\n如下图所示，即代表cnpm配置成功。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/a73fe1fb625b45ef9a04765a1e46fbae.png)\n\n","source":"_posts/Node.js安装与配置（详细步骤）.md","raw":"---\ntitle: Node.js安装与配置（详细步骤）\ndate: 2022-09-24 21:52:45\ntags: 安装\ncomments: true\ntoc: true\ncategories:\n - 安装文档\npic:\n---\n\n[TOC]\n\n\n\n# 一、安装Node.js\n\n## 1.下载\n\n[Node.js官网下载](http://nodejs.cn/download/)\n根据自身系统下载对应的安装包（我这里为Windows11 64位，故选择下载第一个安装包）\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/914dfb1bae004d71bab1d7cc2c01a671.png)\n\n## 2.安装\n\n双击安装包，点击Next，勾选使用许可协议，点击Next，选择安装位置（可根据个人情况更换路径，我这里选择安装在E:\\devTools\\nodejs）\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/493dfc78735841f395c4a116898f5c6f.png)\n\n继续点击Next，点击Next，点击Install，点击Finish完成安装。\n\n## 3.添加环境变量\n\n### 3.1 进入环境变量，编辑【系统变量】下的变量【Path】\n\n![选择Path变量](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d128a4fe1ce34016b08a2842cde77166.png)\n\n### 3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）\n\n![写入Node.js安装路径](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/4609bccc18d8419ea764fb0153454ca9.png)\n\n# 二、验证是否安装成功\n\n进入cmd命令行窗口，输入node -v查看nodejs版本\n\n``` \nnode -v\n```\n\n输入npm -v查看npm版本\n\n```\nnpm -v\n```\n\n\n如下图所示，即为安装成功：\n\n![验证是否安装成功](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ff513962ea164d019d3a9d542d26f0ba.png)\n\n# 三、修改模块下载位置\n\n<span style=\"color:yellow;background:red\">**此步骤修改以后npm全局下载模块的保存位置，可根据自身情况选择是否更改。**</span>\n\n## 1.查看npm默认存放位置\n\n使用npm get prefix查看npm全局模块的存放路径\n\n```\nnpm get prefix\n```\n\n\n使用npm get cache查看npm缓存默认存放路径\n\n```\nnpm get cache\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21684575b404a7f87f83572f8df3d4c.png)\n\n如上图所示，npm 全局模块存放位置以及cache的存放位置，默认是在 C 盘 “C:\\Users\\用户\\AppData” 下。\n\n## 2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e9847471a84c45ddb1fc416a223cdb55.png)\n\n## 3.修改默认文件夹\n\n设置全局模块的安装路径到 “node_global” 文件夹，\n\n```\nnpm config set prefix \"E:\\devTools\\nodejs\\node_global\"\n```\n\n设置缓存到 “node_cache” 文件夹\n\n```\nnpm config set cache \"E:\\devTools\\nodejs\\node_cache\"\n```\n\n\n如下图所示：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6e67a30770ff40c49f640007f96703d1.png)\n\n<span style =\"color:red\">**注意：**</span>由于 node 全局模块大多数都是可以通过命令行访问的，还要把【node_global】的路径“E:\\devTools\\nodejs\\node_global”加入到【系统变量 】下的【PATH】 变量中，方便直接使用命令行运行，如下图所示：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bb96741ac93447aba9e65f0a184e3d11.png)\n\n## 4.测试默认位置是否更改成功\n\n经过上面的步骤，nodejs下载的模块就会自动下载到我们自定义的目录，接下来我们测试一下是否更改成功。输入下面的命令：\n\n```\nnpm install express -g\n```\n\n或者\n\n```\nnpm install express --global\n```\n\n<span style=\"color:red\">**注意：**</span>“-g”等同于“–global”，“-g” 是全局安装，不加“-g”就是默认下载到当前目录。“-g” 表示安装到之前设置的【node_global】目录下，同时nodejs会自动地在node_global文件夹下创建【node_modules】子文件夹， 即自动下载到“E:\\devTools\\nodejs\\node_global\\node_modules” 路径下。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e05642e304a443ec85794f2ac3bad6a8.png)如上图所示，下载express模块成功，然后在文件管理器中查看是否保存到上面自定义的路径下。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d460d0cd30884a83bb175a6e6127aeca.png)可以看到，express模块已经成功地下载到【E:\\devTools\\nodejs\\node_global\\node_modules】下。\n\n<span style=\"color:red\">**注意：**</span>若执行命令npm install express -g出现如下报错：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6caaa64529e0401aa2d467a8a5ceec22.png)\n\n是由于对文件夹操作的权限不够，右击Nodejs文件夹->属性->安全，点击编辑，将所有权限都✔即可。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d1a6f84379d3443bad6af4c734e169d7.png)\n\n※执行npm install express -g仍然出错的话继续将nodejs下【node_cache】、【node_global】、【node_modules】这三个文件夹的所有权限勾选，再次执行：\n\n```\nnpm install express -g\n即可下载成功。\n```\n\n# 四、设置淘宝镜像\n\n## 1.将npm默认的registry修改为淘宝registry\n\n说明：npm 默认的 registry ,也就是下载 npm 包时会从国外的服务器下载，国内下载会很慢，一般更换为淘宝镜像：https://registry.npm.taobao.org。\n\n### 1.1 查看当前使用的镜像路径\n\n```\nnpm config get registry\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ef81e85548b74e06bc325a27a9914258.png)\n\n### 1.2 更换npm为淘宝镜像\n\n```\nnpm config set registry https://registry.npm.taobao.org/\n```\n\n### 1.3 检查镜像是否配置成功\n\n再次执行npm config get registry，检查当前的镜像路径：\n\n```\nnpm config get registry\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/5e6a5bd3b935462fb2521db2d9ea2577.png)\n\n如上图所示，npm默认的registry已修改为淘宝registry。\n\n## 2.全局安装基于淘宝源的cnpm\n\n说明：由于npm的服务器在海外，所以访问速度比较慢，访问不稳定 ，cnpm的服务器是由淘宝团队提供，服务器在国内，cnpm是npm镜像，一般会同步更新，相差在10分钟，所以cnpm在安装一些软件时候会比较有优势。但是cnpm一般只用于模块安装，在项目创建与卸载等相关操作时仍使用npm。\n\n### 2.1 全局安装基于淘宝源的cnpm\n\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/b1247b4bd75d4e128914eba35e2ed91f.png)\n\n### 2.2 本地查看cnpm模块\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d9dddf1705e84f5990b2062db823cde4.png)\n\n### 2.3 执行命令查看cnpm是否安装成功\n\n```\ncnpm -v\n```\n\n如下图所示，即代表cnpm配置成功。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/a73fe1fb625b45ef9a04765a1e46fbae.png)\n\n","slug":"Node.js安装与配置（详细步骤）","published":1,"updated":"2022-10-13T03:15:14.282Z","layout":"post","photos":[],"link":"","_id":"cl9qlthbj00008frfg0a6dbmx","content":"<p>[TOC]</p>\n<h1 id=\"一、安装Node-js\"><a href=\"#一、安装Node-js\" class=\"headerlink\" title=\"一、安装Node.js\"></a>一、安装Node.js</h1><h2 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h2><p><a href=\"http://nodejs.cn/download/\">Node.js官网下载</a><br>根据自身系统下载对应的安装包（我这里为Windows11 64位，故选择下载第一个安装包）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/914dfb1bae004d71bab1d7cc2c01a671.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2.安装\"></a>2.安装</h2><p>双击安装包，点击Next，勾选使用许可协议，点击Next，选择安装位置（可根据个人情况更换路径，我这里选择安装在E:\\devTools\\nodejs）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/493dfc78735841f395c4a116898f5c6f.png\" alt=\"在这里插入图片描述\"></p>\n<p>继续点击Next，点击Next，点击Install，点击Finish完成安装。</p>\n<h2 id=\"3-添加环境变量\"><a href=\"#3-添加环境变量\" class=\"headerlink\" title=\"3.添加环境变量\"></a>3.添加环境变量</h2><h3 id=\"3-1-进入环境变量，编辑【系统变量】下的变量【Path】\"><a href=\"#3-1-进入环境变量，编辑【系统变量】下的变量【Path】\" class=\"headerlink\" title=\"3.1 进入环境变量，编辑【系统变量】下的变量【Path】\"></a>3.1 进入环境变量，编辑【系统变量】下的变量【Path】</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d128a4fe1ce34016b08a2842cde77166.png\" alt=\"选择Path变量\"></p>\n<h3 id=\"3-2-添加Node-js的安装路径（此处为E-devTools-nodejs-）\"><a href=\"#3-2-添加Node-js的安装路径（此处为E-devTools-nodejs-）\" class=\"headerlink\" title=\"3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）\"></a>3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/4609bccc18d8419ea764fb0153454ca9.png\" alt=\"写入Node.js安装路径\"></p>\n<h1 id=\"二、验证是否安装成功\"><a href=\"#二、验证是否安装成功\" class=\"headerlink\" title=\"二、验证是否安装成功\"></a>二、验证是否安装成功</h1><p>进入cmd命令行窗口，输入node -v查看nodejs版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n\n<p>输入npm -v查看npm版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n\n\n<p>如下图所示，即为安装成功：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ff513962ea164d019d3a9d542d26f0ba.png\" alt=\"验证是否安装成功\"></p>\n<h1 id=\"三、修改模块下载位置\"><a href=\"#三、修改模块下载位置\" class=\"headerlink\" title=\"三、修改模块下载位置\"></a>三、修改模块下载位置</h1><p><span style=\"color:yellow;background:red\"><strong>此步骤修改以后npm全局下载模块的保存位置，可根据自身情况选择是否更改。</strong></span></p>\n<h2 id=\"1-查看npm默认存放位置\"><a href=\"#1-查看npm默认存放位置\" class=\"headerlink\" title=\"1.查看npm默认存放位置\"></a>1.查看npm默认存放位置</h2><p>使用npm get prefix查看npm全局模块的存放路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm get prefix</span><br></pre></td></tr></table></figure>\n\n\n<p>使用npm get cache查看npm缓存默认存放路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm get cache</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21684575b404a7f87f83572f8df3d4c.png\" alt=\"在这里插入图片描述\"></p>\n<p>如上图所示，npm 全局模块存放位置以及cache的存放位置，默认是在 C 盘 “C:\\Users\\用户\\AppData” 下。</p>\n<h2 id=\"2-在-nodejs-安装目录下，创建-“node-global”-和-“node-cache”-两个文件夹\"><a href=\"#2-在-nodejs-安装目录下，创建-“node-global”-和-“node-cache”-两个文件夹\" class=\"headerlink\" title=\"2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹\"></a>2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹</h2><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e9847471a84c45ddb1fc416a223cdb55.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-修改默认文件夹\"><a href=\"#3-修改默认文件夹\" class=\"headerlink\" title=\"3.修改默认文件夹\"></a>3.修改默认文件夹</h2><p>设置全局模块的安装路径到 “node_global” 文件夹，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set prefix &quot;E:\\devTools\\nodejs\\node_global&quot;</span><br></pre></td></tr></table></figure>\n\n<p>设置缓存到 “node_cache” 文件夹</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set cache &quot;E:\\devTools\\nodejs\\node_cache&quot;</span><br></pre></td></tr></table></figure>\n\n\n<p>如下图所示：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6e67a30770ff40c49f640007f96703d1.png\" alt=\"在这里插入图片描述\"></p>\n<p><span style =\"color:red\"><strong>注意：</strong></span>由于 node 全局模块大多数都是可以通过命令行访问的，还要把【node_global】的路径“E:\\devTools\\nodejs\\node_global”加入到【系统变量 】下的【PATH】 变量中，方便直接使用命令行运行，如下图所示：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bb96741ac93447aba9e65f0a184e3d11.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"4-测试默认位置是否更改成功\"><a href=\"#4-测试默认位置是否更改成功\" class=\"headerlink\" title=\"4.测试默认位置是否更改成功\"></a>4.测试默认位置是否更改成功</h2><p>经过上面的步骤，nodejs下载的模块就会自动下载到我们自定义的目录，接下来我们测试一下是否更改成功。输入下面的命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express -g</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express --global</span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color:red\"><strong>注意：</strong></span>“-g”等同于“–global”，“-g” 是全局安装，不加“-g”就是默认下载到当前目录。“-g” 表示安装到之前设置的【node_global】目录下，同时nodejs会自动地在node_global文件夹下创建【node_modules】子文件夹， 即自动下载到“E:\\devTools\\nodejs\\node_global\\node_modules” 路径下。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e05642e304a443ec85794f2ac3bad6a8.png\" alt=\"在这里插入图片描述\">如上图所示，下载express模块成功，然后在文件管理器中查看是否保存到上面自定义的路径下。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d460d0cd30884a83bb175a6e6127aeca.png\" alt=\"在这里插入图片描述\">可以看到，express模块已经成功地下载到【E:\\devTools\\nodejs\\node_global\\node_modules】下。</p>\n<p><span style=\"color:red\"><strong>注意：</strong></span>若执行命令npm install express -g出现如下报错：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6caaa64529e0401aa2d467a8a5ceec22.png\" alt=\"在这里插入图片描述\"></p>\n<p>是由于对文件夹操作的权限不够，右击Nodejs文件夹-&gt;属性-&gt;安全，点击编辑，将所有权限都✔即可。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d1a6f84379d3443bad6af4c734e169d7.png\" alt=\"在这里插入图片描述\"></p>\n<p>※执行npm install express -g仍然出错的话继续将nodejs下【node_cache】、【node_global】、【node_modules】这三个文件夹的所有权限勾选，再次执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express -g</span><br><span class=\"line\">即可下载成功。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、设置淘宝镜像\"><a href=\"#四、设置淘宝镜像\" class=\"headerlink\" title=\"四、设置淘宝镜像\"></a>四、设置淘宝镜像</h1><h2 id=\"1-将npm默认的registry修改为淘宝registry\"><a href=\"#1-将npm默认的registry修改为淘宝registry\" class=\"headerlink\" title=\"1.将npm默认的registry修改为淘宝registry\"></a>1.将npm默认的registry修改为淘宝registry</h2><p>说明：npm 默认的 registry ,也就是下载 npm 包时会从国外的服务器下载，国内下载会很慢，一般更换为淘宝镜像：<a href=\"https://registry.npm.taobao.org./\">https://registry.npm.taobao.org。</a></p>\n<h3 id=\"1-1-查看当前使用的镜像路径\"><a href=\"#1-1-查看当前使用的镜像路径\" class=\"headerlink\" title=\"1.1 查看当前使用的镜像路径\"></a>1.1 查看当前使用的镜像路径</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ef81e85548b74e06bc325a27a9914258.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"1-2-更换npm为淘宝镜像\"><a href=\"#1-2-更换npm为淘宝镜像\" class=\"headerlink\" title=\"1.2 更换npm为淘宝镜像\"></a>1.2 更换npm为淘宝镜像</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-检查镜像是否配置成功\"><a href=\"#1-3-检查镜像是否配置成功\" class=\"headerlink\" title=\"1.3 检查镜像是否配置成功\"></a>1.3 检查镜像是否配置成功</h3><p>再次执行npm config get registry，检查当前的镜像路径：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/5e6a5bd3b935462fb2521db2d9ea2577.png\" alt=\"在这里插入图片描述\"></p>\n<p>如上图所示，npm默认的registry已修改为淘宝registry。</p>\n<h2 id=\"2-全局安装基于淘宝源的cnpm\"><a href=\"#2-全局安装基于淘宝源的cnpm\" class=\"headerlink\" title=\"2.全局安装基于淘宝源的cnpm\"></a>2.全局安装基于淘宝源的cnpm</h2><p>说明：由于npm的服务器在海外，所以访问速度比较慢，访问不稳定 ，cnpm的服务器是由淘宝团队提供，服务器在国内，cnpm是npm镜像，一般会同步更新，相差在10分钟，所以cnpm在安装一些软件时候会比较有优势。但是cnpm一般只用于模块安装，在项目创建与卸载等相关操作时仍使用npm。</p>\n<h3 id=\"2-1-全局安装基于淘宝源的cnpm\"><a href=\"#2-1-全局安装基于淘宝源的cnpm\" class=\"headerlink\" title=\"2.1 全局安装基于淘宝源的cnpm\"></a>2.1 全局安装基于淘宝源的cnpm</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/b1247b4bd75d4e128914eba35e2ed91f.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-2-本地查看cnpm模块\"><a href=\"#2-2-本地查看cnpm模块\" class=\"headerlink\" title=\"2.2 本地查看cnpm模块\"></a>2.2 本地查看cnpm模块</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d9dddf1705e84f5990b2062db823cde4.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-3-执行命令查看cnpm是否安装成功\"><a href=\"#2-3-执行命令查看cnpm是否安装成功\" class=\"headerlink\" title=\"2.3 执行命令查看cnpm是否安装成功\"></a>2.3 执行命令查看cnpm是否安装成功</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm -v</span><br></pre></td></tr></table></figure>\n\n<p>如下图所示，即代表cnpm配置成功。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/a73fe1fb625b45ef9a04765a1e46fbae.png\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"一、安装Node-js\"><a href=\"#一、安装Node-js\" class=\"headerlink\" title=\"一、安装Node.js\"></a>一、安装Node.js</h1><h2 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h2><p><a href=\"http://nodejs.cn/download/\">Node.js官网下载</a><br>根据自身系统下载对应的安装包（我这里为Windows11 64位，故选择下载第一个安装包）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/914dfb1bae004d71bab1d7cc2c01a671.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2.安装\"></a>2.安装</h2><p>双击安装包，点击Next，勾选使用许可协议，点击Next，选择安装位置（可根据个人情况更换路径，我这里选择安装在E:\\devTools\\nodejs）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/493dfc78735841f395c4a116898f5c6f.png\" alt=\"在这里插入图片描述\"></p>\n<p>继续点击Next，点击Next，点击Install，点击Finish完成安装。</p>\n<h2 id=\"3-添加环境变量\"><a href=\"#3-添加环境变量\" class=\"headerlink\" title=\"3.添加环境变量\"></a>3.添加环境变量</h2><h3 id=\"3-1-进入环境变量，编辑【系统变量】下的变量【Path】\"><a href=\"#3-1-进入环境变量，编辑【系统变量】下的变量【Path】\" class=\"headerlink\" title=\"3.1 进入环境变量，编辑【系统变量】下的变量【Path】\"></a>3.1 进入环境变量，编辑【系统变量】下的变量【Path】</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d128a4fe1ce34016b08a2842cde77166.png\" alt=\"选择Path变量\"></p>\n<h3 id=\"3-2-添加Node-js的安装路径（此处为E-devTools-nodejs-）\"><a href=\"#3-2-添加Node-js的安装路径（此处为E-devTools-nodejs-）\" class=\"headerlink\" title=\"3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）\"></a>3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/4609bccc18d8419ea764fb0153454ca9.png\" alt=\"写入Node.js安装路径\"></p>\n<h1 id=\"二、验证是否安装成功\"><a href=\"#二、验证是否安装成功\" class=\"headerlink\" title=\"二、验证是否安装成功\"></a>二、验证是否安装成功</h1><p>进入cmd命令行窗口，输入node -v查看nodejs版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n\n<p>输入npm -v查看npm版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n\n\n<p>如下图所示，即为安装成功：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ff513962ea164d019d3a9d542d26f0ba.png\" alt=\"验证是否安装成功\"></p>\n<h1 id=\"三、修改模块下载位置\"><a href=\"#三、修改模块下载位置\" class=\"headerlink\" title=\"三、修改模块下载位置\"></a>三、修改模块下载位置</h1><p><span style=\"color:yellow;background:red\"><strong>此步骤修改以后npm全局下载模块的保存位置，可根据自身情况选择是否更改。</strong></span></p>\n<h2 id=\"1-查看npm默认存放位置\"><a href=\"#1-查看npm默认存放位置\" class=\"headerlink\" title=\"1.查看npm默认存放位置\"></a>1.查看npm默认存放位置</h2><p>使用npm get prefix查看npm全局模块的存放路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm get prefix</span><br></pre></td></tr></table></figure>\n\n\n<p>使用npm get cache查看npm缓存默认存放路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm get cache</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21684575b404a7f87f83572f8df3d4c.png\" alt=\"在这里插入图片描述\"></p>\n<p>如上图所示，npm 全局模块存放位置以及cache的存放位置，默认是在 C 盘 “C:\\Users\\用户\\AppData” 下。</p>\n<h2 id=\"2-在-nodejs-安装目录下，创建-“node-global”-和-“node-cache”-两个文件夹\"><a href=\"#2-在-nodejs-安装目录下，创建-“node-global”-和-“node-cache”-两个文件夹\" class=\"headerlink\" title=\"2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹\"></a>2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹</h2><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e9847471a84c45ddb1fc416a223cdb55.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-修改默认文件夹\"><a href=\"#3-修改默认文件夹\" class=\"headerlink\" title=\"3.修改默认文件夹\"></a>3.修改默认文件夹</h2><p>设置全局模块的安装路径到 “node_global” 文件夹，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set prefix &quot;E:\\devTools\\nodejs\\node_global&quot;</span><br></pre></td></tr></table></figure>\n\n<p>设置缓存到 “node_cache” 文件夹</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set cache &quot;E:\\devTools\\nodejs\\node_cache&quot;</span><br></pre></td></tr></table></figure>\n\n\n<p>如下图所示：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6e67a30770ff40c49f640007f96703d1.png\" alt=\"在这里插入图片描述\"></p>\n<p><span style =\"color:red\"><strong>注意：</strong></span>由于 node 全局模块大多数都是可以通过命令行访问的，还要把【node_global】的路径“E:\\devTools\\nodejs\\node_global”加入到【系统变量 】下的【PATH】 变量中，方便直接使用命令行运行，如下图所示：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bb96741ac93447aba9e65f0a184e3d11.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"4-测试默认位置是否更改成功\"><a href=\"#4-测试默认位置是否更改成功\" class=\"headerlink\" title=\"4.测试默认位置是否更改成功\"></a>4.测试默认位置是否更改成功</h2><p>经过上面的步骤，nodejs下载的模块就会自动下载到我们自定义的目录，接下来我们测试一下是否更改成功。输入下面的命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express -g</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express --global</span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color:red\"><strong>注意：</strong></span>“-g”等同于“–global”，“-g” 是全局安装，不加“-g”就是默认下载到当前目录。“-g” 表示安装到之前设置的【node_global】目录下，同时nodejs会自动地在node_global文件夹下创建【node_modules】子文件夹， 即自动下载到“E:\\devTools\\nodejs\\node_global\\node_modules” 路径下。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e05642e304a443ec85794f2ac3bad6a8.png\" alt=\"在这里插入图片描述\">如上图所示，下载express模块成功，然后在文件管理器中查看是否保存到上面自定义的路径下。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d460d0cd30884a83bb175a6e6127aeca.png\" alt=\"在这里插入图片描述\">可以看到，express模块已经成功地下载到【E:\\devTools\\nodejs\\node_global\\node_modules】下。</p>\n<p><span style=\"color:red\"><strong>注意：</strong></span>若执行命令npm install express -g出现如下报错：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6caaa64529e0401aa2d467a8a5ceec22.png\" alt=\"在这里插入图片描述\"></p>\n<p>是由于对文件夹操作的权限不够，右击Nodejs文件夹-&gt;属性-&gt;安全，点击编辑，将所有权限都✔即可。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d1a6f84379d3443bad6af4c734e169d7.png\" alt=\"在这里插入图片描述\"></p>\n<p>※执行npm install express -g仍然出错的话继续将nodejs下【node_cache】、【node_global】、【node_modules】这三个文件夹的所有权限勾选，再次执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express -g</span><br><span class=\"line\">即可下载成功。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、设置淘宝镜像\"><a href=\"#四、设置淘宝镜像\" class=\"headerlink\" title=\"四、设置淘宝镜像\"></a>四、设置淘宝镜像</h1><h2 id=\"1-将npm默认的registry修改为淘宝registry\"><a href=\"#1-将npm默认的registry修改为淘宝registry\" class=\"headerlink\" title=\"1.将npm默认的registry修改为淘宝registry\"></a>1.将npm默认的registry修改为淘宝registry</h2><p>说明：npm 默认的 registry ,也就是下载 npm 包时会从国外的服务器下载，国内下载会很慢，一般更换为淘宝镜像：<a href=\"https://registry.npm.taobao.org./\">https://registry.npm.taobao.org。</a></p>\n<h3 id=\"1-1-查看当前使用的镜像路径\"><a href=\"#1-1-查看当前使用的镜像路径\" class=\"headerlink\" title=\"1.1 查看当前使用的镜像路径\"></a>1.1 查看当前使用的镜像路径</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ef81e85548b74e06bc325a27a9914258.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"1-2-更换npm为淘宝镜像\"><a href=\"#1-2-更换npm为淘宝镜像\" class=\"headerlink\" title=\"1.2 更换npm为淘宝镜像\"></a>1.2 更换npm为淘宝镜像</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-检查镜像是否配置成功\"><a href=\"#1-3-检查镜像是否配置成功\" class=\"headerlink\" title=\"1.3 检查镜像是否配置成功\"></a>1.3 检查镜像是否配置成功</h3><p>再次执行npm config get registry，检查当前的镜像路径：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/5e6a5bd3b935462fb2521db2d9ea2577.png\" alt=\"在这里插入图片描述\"></p>\n<p>如上图所示，npm默认的registry已修改为淘宝registry。</p>\n<h2 id=\"2-全局安装基于淘宝源的cnpm\"><a href=\"#2-全局安装基于淘宝源的cnpm\" class=\"headerlink\" title=\"2.全局安装基于淘宝源的cnpm\"></a>2.全局安装基于淘宝源的cnpm</h2><p>说明：由于npm的服务器在海外，所以访问速度比较慢，访问不稳定 ，cnpm的服务器是由淘宝团队提供，服务器在国内，cnpm是npm镜像，一般会同步更新，相差在10分钟，所以cnpm在安装一些软件时候会比较有优势。但是cnpm一般只用于模块安装，在项目创建与卸载等相关操作时仍使用npm。</p>\n<h3 id=\"2-1-全局安装基于淘宝源的cnpm\"><a href=\"#2-1-全局安装基于淘宝源的cnpm\" class=\"headerlink\" title=\"2.1 全局安装基于淘宝源的cnpm\"></a>2.1 全局安装基于淘宝源的cnpm</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/b1247b4bd75d4e128914eba35e2ed91f.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-2-本地查看cnpm模块\"><a href=\"#2-2-本地查看cnpm模块\" class=\"headerlink\" title=\"2.2 本地查看cnpm模块\"></a>2.2 本地查看cnpm模块</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d9dddf1705e84f5990b2062db823cde4.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-3-执行命令查看cnpm是否安装成功\"><a href=\"#2-3-执行命令查看cnpm是否安装成功\" class=\"headerlink\" title=\"2.3 执行命令查看cnpm是否安装成功\"></a>2.3 执行命令查看cnpm是否安装成功</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm -v</span><br></pre></td></tr></table></figure>\n\n<p>如下图所示，即代表cnpm配置成功。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/a73fe1fb625b45ef9a04765a1e46fbae.png\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-10-13T03:15:14.282Z","updated":"2022-10-13T03:15:14.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9qlthbn00018frf2shh6hlj","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"hexo+github搭建博客","date":"2022-09-24T13:52:45.000Z","cover":"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png","comments":1,"toc":true,"pic":null,"_content":"\n[TOC]\n\n\n\n# 环境准备\n\n## 1、安装nodejs\n\n直接到官网上下载安装即可https://nodejs.org/en/download/\n\n- [Node.js](http://nodejs.org/) (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- Node自带npm\n\n详细安装配置\n\nnodejs配置\n\n\n\n## 2、安装git\n\nWindows：下载并安装 git.\nMac：使用 Homebrew, MacPorts 或者下载 安装程序。\nLinux (Ubuntu, Debian)：sudo apt-get install git-core\nLinux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n\n![img](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png)\n\nnpm下载慢的话也可以下载淘宝下载源cnpm\n\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n![img](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21b605afbc75a0e08824e062dae3ea4.png)\n\n# 开始安装Hexo\n\n## 1.安装hexo\n\n```\nnpm install -g hexo-cli\n或者\ncnpm install -g hexo-cli\n123\n```\n\n安装完成可输入hexo -v查看版本\n\n![image-20211203164700035](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bba538484708b3e30f14af8557501c3c.png)\n\n## 2、初始化hexo，新建存储博客的文件夹\n\n```\nhexo init myblog（本地文件夹名称：可自定义）\n```\n\n![image-20211203165005655](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d01a6881209137448e5385dd3534097d.png)\n\n## 3、进入文件夹，安装一下npm\n\n```\ncd myblog\nnpm install\n```\n\n可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了\n\n![iShot2021-12-03 16.55.54](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bcf516435e0c18ccdd4bb12f2fe04e2a.png)\n\n## 4、启动服务站点\n\n```\nhexo g \nhexo server\n```\n\n![image-20211203165829687](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/af32bf9e9c204c69d873df7c3437c3a4.png)\n\n访问http://localhost:4000/ 至此hero就搭建好了。可以在本地访问了\n\n![20211203170208](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/3a611caeb2993779a773aaad9864d493.png)\n\n# 将hexo博客站点上传到github上\n\n## 1、新建guthub仓库\n\n仓库名称限制了为你的：用户名+.github.io\n\n![image-20211203213307819](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d2560d7f2d59f5f9b587a34cd2819307.png)\n\n## 2、安装hexo上传插件\n\n这里需要安装一个hexo的上传插件deploy-git\n\n```\nnpm install hexo-deployer-git --save\n```\n\n![image-20211203171157254](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/49d71ebd13729dd4acb6f52cb5b07b70.png)\n\n## 3、修改hexo配置文件指定仓库路径\n\n可在文件夹中直接打开文件，也可通过vim直接编辑\n\n![image-20211203213606004](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/57b7452a5399f57b0e3ef2ef1a5d8271.png)\n\n## 4、推送站点到github\n\n```\n推送命令\nhexo d\n```\n\n\n\n# 注意事项\n\n推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现下图：鉴权失败（用户名密码错误）\n\n\n\n# hexo文件夹详解：\n\n* node_modules：是依赖包\n*  public：存放的是生成的页面\n*  scaffolds：命令生成文章等的模板\n*  source：用命令创建的各种文章\n*  themes：主题\n*  _config.yml：整个博客的配置\n*  db.json：source解析所得到的\n*  package.json：项目所需模块项目的配置信息\n\n","source":"_posts/hexo+github搭建博客.md","raw":"---\ntitle: hexo+github搭建博客\ndate: 2022-09-24 21:52:45\ncover: https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png\ntags: 安装\ncomments: true\ntoc: true\ncategories:\n - 安装文档\n - 博客相关\npic:\n---\n\n[TOC]\n\n\n\n# 环境准备\n\n## 1、安装nodejs\n\n直接到官网上下载安装即可https://nodejs.org/en/download/\n\n- [Node.js](http://nodejs.org/) (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- Node自带npm\n\n详细安装配置\n\nnodejs配置\n\n\n\n## 2、安装git\n\nWindows：下载并安装 git.\nMac：使用 Homebrew, MacPorts 或者下载 安装程序。\nLinux (Ubuntu, Debian)：sudo apt-get install git-core\nLinux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n\n![img](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png)\n\nnpm下载慢的话也可以下载淘宝下载源cnpm\n\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n![img](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21b605afbc75a0e08824e062dae3ea4.png)\n\n# 开始安装Hexo\n\n## 1.安装hexo\n\n```\nnpm install -g hexo-cli\n或者\ncnpm install -g hexo-cli\n123\n```\n\n安装完成可输入hexo -v查看版本\n\n![image-20211203164700035](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bba538484708b3e30f14af8557501c3c.png)\n\n## 2、初始化hexo，新建存储博客的文件夹\n\n```\nhexo init myblog（本地文件夹名称：可自定义）\n```\n\n![image-20211203165005655](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d01a6881209137448e5385dd3534097d.png)\n\n## 3、进入文件夹，安装一下npm\n\n```\ncd myblog\nnpm install\n```\n\n可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了\n\n![iShot2021-12-03 16.55.54](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bcf516435e0c18ccdd4bb12f2fe04e2a.png)\n\n## 4、启动服务站点\n\n```\nhexo g \nhexo server\n```\n\n![image-20211203165829687](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/af32bf9e9c204c69d873df7c3437c3a4.png)\n\n访问http://localhost:4000/ 至此hero就搭建好了。可以在本地访问了\n\n![20211203170208](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/3a611caeb2993779a773aaad9864d493.png)\n\n# 将hexo博客站点上传到github上\n\n## 1、新建guthub仓库\n\n仓库名称限制了为你的：用户名+.github.io\n\n![image-20211203213307819](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d2560d7f2d59f5f9b587a34cd2819307.png)\n\n## 2、安装hexo上传插件\n\n这里需要安装一个hexo的上传插件deploy-git\n\n```\nnpm install hexo-deployer-git --save\n```\n\n![image-20211203171157254](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/49d71ebd13729dd4acb6f52cb5b07b70.png)\n\n## 3、修改hexo配置文件指定仓库路径\n\n可在文件夹中直接打开文件，也可通过vim直接编辑\n\n![image-20211203213606004](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/57b7452a5399f57b0e3ef2ef1a5d8271.png)\n\n## 4、推送站点到github\n\n```\n推送命令\nhexo d\n```\n\n\n\n# 注意事项\n\n推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现下图：鉴权失败（用户名密码错误）\n\n\n\n# hexo文件夹详解：\n\n* node_modules：是依赖包\n*  public：存放的是生成的页面\n*  scaffolds：命令生成文章等的模板\n*  source：用命令创建的各种文章\n*  themes：主题\n*  _config.yml：整个博客的配置\n*  db.json：source解析所得到的\n*  package.json：项目所需模块项目的配置信息\n\n","slug":"hexo+github搭建博客","published":1,"updated":"2022-10-13T03:15:14.283Z","layout":"post","photos":[],"link":"","_id":"cl9qlthbr00048frfd2vgbuun","content":"<p>[TOC]</p>\n<h1 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h1><h2 id=\"1、安装nodejs\"><a href=\"#1、安装nodejs\" class=\"headerlink\" title=\"1、安装nodejs\"></a>1、安装nodejs</h2><p>直接到官网上下载安装即可<a href=\"https://nodejs.org/en/download/\">https://nodejs.org/en/download/</a></p>\n<ul>\n<li><a href=\"http://nodejs.org/\">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>\n<li>Node自带npm</li>\n</ul>\n<p>详细安装配置</p>\n<p>nodejs配置</p>\n<h2 id=\"2、安装git\"><a href=\"#2、安装git\" class=\"headerlink\" title=\"2、安装git\"></a>2、安装git</h2><p>Windows：下载并安装 git.<br>Mac：使用 Homebrew, MacPorts 或者下载 安装程序。<br>Linux (Ubuntu, Debian)：sudo apt-get install git-core<br>Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png\" alt=\"img\"></p>\n<p>npm下载慢的话也可以下载淘宝下载源cnpm</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21b605afbc75a0e08824e062dae3ea4.png\" alt=\"img\"></p>\n<h1 id=\"开始安装Hexo\"><a href=\"#开始安装Hexo\" class=\"headerlink\" title=\"开始安装Hexo\"></a>开始安装Hexo</h1><h2 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1.安装hexo\"></a>1.安装hexo</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\">或者</span><br><span class=\"line\">cnpm install -g hexo-cli</span><br><span class=\"line\">123</span><br></pre></td></tr></table></figure>\n\n<p>安装完成可输入hexo -v查看版本</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bba538484708b3e30f14af8557501c3c.png\" alt=\"image-20211203164700035\"></p>\n<h2 id=\"2、初始化hexo，新建存储博客的文件夹\"><a href=\"#2、初始化hexo，新建存储博客的文件夹\" class=\"headerlink\" title=\"2、初始化hexo，新建存储博客的文件夹\"></a>2、初始化hexo，新建存储博客的文件夹</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init myblog（本地文件夹名称：可自定义）</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d01a6881209137448e5385dd3534097d.png\" alt=\"image-20211203165005655\"></p>\n<h2 id=\"3、进入文件夹，安装一下npm\"><a href=\"#3、进入文件夹，安装一下npm\" class=\"headerlink\" title=\"3、进入文件夹，安装一下npm\"></a>3、进入文件夹，安装一下npm</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myblog</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bcf516435e0c18ccdd4bb12f2fe04e2a.png\" alt=\"iShot2021-12-03 16.55.54\"></p>\n<h2 id=\"4、启动服务站点\"><a href=\"#4、启动服务站点\" class=\"headerlink\" title=\"4、启动服务站点\"></a>4、启动服务站点</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g </span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/af32bf9e9c204c69d873df7c3437c3a4.png\" alt=\"image-20211203165829687\"></p>\n<p>访问<a href=\"http://localhost:4000/\">http://localhost:4000/</a> 至此hero就搭建好了。可以在本地访问了</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/3a611caeb2993779a773aaad9864d493.png\" alt=\"20211203170208\"></p>\n<h1 id=\"将hexo博客站点上传到github上\"><a href=\"#将hexo博客站点上传到github上\" class=\"headerlink\" title=\"将hexo博客站点上传到github上\"></a>将hexo博客站点上传到github上</h1><h2 id=\"1、新建guthub仓库\"><a href=\"#1、新建guthub仓库\" class=\"headerlink\" title=\"1、新建guthub仓库\"></a>1、新建guthub仓库</h2><p>仓库名称限制了为你的：用户名+.github.io</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d2560d7f2d59f5f9b587a34cd2819307.png\" alt=\"image-20211203213307819\"></p>\n<h2 id=\"2、安装hexo上传插件\"><a href=\"#2、安装hexo上传插件\" class=\"headerlink\" title=\"2、安装hexo上传插件\"></a>2、安装hexo上传插件</h2><p>这里需要安装一个hexo的上传插件deploy-git</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/49d71ebd13729dd4acb6f52cb5b07b70.png\" alt=\"image-20211203171157254\"></p>\n<h2 id=\"3、修改hexo配置文件指定仓库路径\"><a href=\"#3、修改hexo配置文件指定仓库路径\" class=\"headerlink\" title=\"3、修改hexo配置文件指定仓库路径\"></a>3、修改hexo配置文件指定仓库路径</h2><p>可在文件夹中直接打开文件，也可通过vim直接编辑</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/57b7452a5399f57b0e3ef2ef1a5d8271.png\" alt=\"image-20211203213606004\"></p>\n<h2 id=\"4、推送站点到github\"><a href=\"#4、推送站点到github\" class=\"headerlink\" title=\"4、推送站点到github\"></a>4、推送站点到github</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推送命令</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p>推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现下图：鉴权失败（用户名密码错误）</p>\n<h1 id=\"hexo文件夹详解：\"><a href=\"#hexo文件夹详解：\" class=\"headerlink\" title=\"hexo文件夹详解：\"></a>hexo文件夹详解：</h1><ul>\n<li>node_modules：是依赖包</li>\n<li>public：存放的是生成的页面</li>\n<li>scaffolds：命令生成文章等的模板</li>\n<li>source：用命令创建的各种文章</li>\n<li>themes：主题</li>\n<li>_config.yml：整个博客的配置</li>\n<li>db.json：source解析所得到的</li>\n<li>package.json：项目所需模块项目的配置信息</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h1><h2 id=\"1、安装nodejs\"><a href=\"#1、安装nodejs\" class=\"headerlink\" title=\"1、安装nodejs\"></a>1、安装nodejs</h2><p>直接到官网上下载安装即可<a href=\"https://nodejs.org/en/download/\">https://nodejs.org/en/download/</a></p>\n<ul>\n<li><a href=\"http://nodejs.org/\">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>\n<li>Node自带npm</li>\n</ul>\n<p>详细安装配置</p>\n<p>nodejs配置</p>\n<h2 id=\"2、安装git\"><a href=\"#2、安装git\" class=\"headerlink\" title=\"2、安装git\"></a>2、安装git</h2><p>Windows：下载并安装 git.<br>Mac：使用 Homebrew, MacPorts 或者下载 安装程序。<br>Linux (Ubuntu, Debian)：sudo apt-get install git-core<br>Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png\" alt=\"img\"></p>\n<p>npm下载慢的话也可以下载淘宝下载源cnpm</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21b605afbc75a0e08824e062dae3ea4.png\" alt=\"img\"></p>\n<h1 id=\"开始安装Hexo\"><a href=\"#开始安装Hexo\" class=\"headerlink\" title=\"开始安装Hexo\"></a>开始安装Hexo</h1><h2 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1.安装hexo\"></a>1.安装hexo</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\">或者</span><br><span class=\"line\">cnpm install -g hexo-cli</span><br><span class=\"line\">123</span><br></pre></td></tr></table></figure>\n\n<p>安装完成可输入hexo -v查看版本</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bba538484708b3e30f14af8557501c3c.png\" alt=\"image-20211203164700035\"></p>\n<h2 id=\"2、初始化hexo，新建存储博客的文件夹\"><a href=\"#2、初始化hexo，新建存储博客的文件夹\" class=\"headerlink\" title=\"2、初始化hexo，新建存储博客的文件夹\"></a>2、初始化hexo，新建存储博客的文件夹</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init myblog（本地文件夹名称：可自定义）</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d01a6881209137448e5385dd3534097d.png\" alt=\"image-20211203165005655\"></p>\n<h2 id=\"3、进入文件夹，安装一下npm\"><a href=\"#3、进入文件夹，安装一下npm\" class=\"headerlink\" title=\"3、进入文件夹，安装一下npm\"></a>3、进入文件夹，安装一下npm</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myblog</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bcf516435e0c18ccdd4bb12f2fe04e2a.png\" alt=\"iShot2021-12-03 16.55.54\"></p>\n<h2 id=\"4、启动服务站点\"><a href=\"#4、启动服务站点\" class=\"headerlink\" title=\"4、启动服务站点\"></a>4、启动服务站点</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g </span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/af32bf9e9c204c69d873df7c3437c3a4.png\" alt=\"image-20211203165829687\"></p>\n<p>访问<a href=\"http://localhost:4000/\">http://localhost:4000/</a> 至此hero就搭建好了。可以在本地访问了</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/3a611caeb2993779a773aaad9864d493.png\" alt=\"20211203170208\"></p>\n<h1 id=\"将hexo博客站点上传到github上\"><a href=\"#将hexo博客站点上传到github上\" class=\"headerlink\" title=\"将hexo博客站点上传到github上\"></a>将hexo博客站点上传到github上</h1><h2 id=\"1、新建guthub仓库\"><a href=\"#1、新建guthub仓库\" class=\"headerlink\" title=\"1、新建guthub仓库\"></a>1、新建guthub仓库</h2><p>仓库名称限制了为你的：用户名+.github.io</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d2560d7f2d59f5f9b587a34cd2819307.png\" alt=\"image-20211203213307819\"></p>\n<h2 id=\"2、安装hexo上传插件\"><a href=\"#2、安装hexo上传插件\" class=\"headerlink\" title=\"2、安装hexo上传插件\"></a>2、安装hexo上传插件</h2><p>这里需要安装一个hexo的上传插件deploy-git</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/49d71ebd13729dd4acb6f52cb5b07b70.png\" alt=\"image-20211203171157254\"></p>\n<h2 id=\"3、修改hexo配置文件指定仓库路径\"><a href=\"#3、修改hexo配置文件指定仓库路径\" class=\"headerlink\" title=\"3、修改hexo配置文件指定仓库路径\"></a>3、修改hexo配置文件指定仓库路径</h2><p>可在文件夹中直接打开文件，也可通过vim直接编辑</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/57b7452a5399f57b0e3ef2ef1a5d8271.png\" alt=\"image-20211203213606004\"></p>\n<h2 id=\"4、推送站点到github\"><a href=\"#4、推送站点到github\" class=\"headerlink\" title=\"4、推送站点到github\"></a>4、推送站点到github</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推送命令</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p>推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现下图：鉴权失败（用户名密码错误）</p>\n<h1 id=\"hexo文件夹详解：\"><a href=\"#hexo文件夹详解：\" class=\"headerlink\" title=\"hexo文件夹详解：\"></a>hexo文件夹详解：</h1><ul>\n<li>node_modules：是依赖包</li>\n<li>public：存放的是生成的页面</li>\n<li>scaffolds：命令生成文章等的模板</li>\n<li>source：用命令创建的各种文章</li>\n<li>themes：主题</li>\n<li>_config.yml：整个博客的配置</li>\n<li>db.json：source解析所得到的</li>\n<li>package.json：项目所需模块项目的配置信息</li>\n</ul>\n"},{"title":"java基础笔记","comments":1,"toc":true,"date":"2022-10-27T04:40:00.000Z","pic":null,"_content":"\n#   java基础\n\n这是快速复习java基础的笔记\n\n## 重要编程思想\n\n**化繁为简**：现将复杂的功能转变成简单的需求。\n\n先死后活：有限考虑固定的值，再考虑变量。\n\n\n\n\n\n\n\n# java概述\n\n知识点：\n\n## [快速练习](##快速入门部分)\n\n1. 使用黑窗口编译.java文件时，注意要把需要编译的java文件编码设置与cmd黑窗口编码相同\n\n2. ```java\n   javac hello.java //编译指令\t\t\t\n   ```\n\n3. ```java\n   java hello //运行指令\t\n   //注意不要带文件后缀，否则报错\n   ```\n\n4. java执行流程分析\n\n   1. ![image-20220204113338135](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204113338135.png)\n\n## [制表符](##制表符部分)\n\n1. ```\n   \\t 一个制表位，实现对其功能\n   \\n 换行符，\n   \\\\ 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠\n   \\\t\\将\"\"：号输出显示出来，在前面添加\\\" \\\" 也可转义其他符号例如'\n   // \\r 表示一个回车 例如：System.out.println(\"韩顺平教育\\r北京\");\n   \t\t// 执行步骤：\n   \t\t// \t1. 先输出韩顺平教育\n   \t\t//  2. 执行回车后，相当于光标来到了最开头\n   \t\t//  3. 再输出北京\n   \t\t//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了\n           可以加个\\n换行防止覆盖\n   \n   ```\n\n2. ````java\n   class ChangeChar{\n   \tpublic static void main(String[] args){\n   \t\t// \\t 一个制表位，实现对其功能\n   \t\tSystem.out.println(\"beijing\\tshanghai\\tguangzhou\");\n   \t\t// \\n换行\n   \t\tSystem.out.println(\"jack\\nlisa\\nnino\");\n   \t\t// \\\\ 输出一个斜杠\\ \n   \t\t// 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠\n   \t\tSystem.out.println(\"c\\\\a\\\\v\\\\b.exe\");\n   \t\t// \\将\"\"：号输出显示出来，在前面添加\\\" \\\"\n   \t\tSystem.out.println(\"老王说：\\\"hello\\\"\");\n   \t\t// \\r 表示一个回车 System.out.println(\"韩顺平教育\\r北京\");\n   \t\t// 执行步骤：\n   \t\t// \t1. 先输出韩顺平教育\n   \t\t//  2. 执行回车后，相当于光标来到了最开头\n   \t\t//  3. 再输出北京\n   \t\t//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了\n   \t\tSystem.out.println(\"韩顺平教育\\r\\n北京\");\n   \n   \t}\n   }\n   ````\n\n# 注释\n\n1. 文档注释\n\n   1. ```\n      javadoc -d 路径文件 -xx -yy xxx.java\n      生成文档命令\n      xx yy 分别代码javadoc标签命令 例如-auther -version等\n      ```\n\n   2. ```java\n      @author 标明开发该类模块的作者 \n      @version 标明该类模块的版本 \n      @see 参考转向，也就是相关主题 \n      @param 对方法中某参数的说明 \n      @return 对方法返回值的说明 \n      @exception 对方法可能抛出的异常进行说明 \n      \n      @author 作者名 \n      @version 版本号\n      其中，@author 可以多次使用，以指明多个作者，生成的文档中每个作者之间使用逗号 (,) 隔开。@version 也可以使用多次，只有第一次有效 \n      \n      使用 @param、@return 和 @exception 说明方法 \n      这三个标记都是只用于方法的。@param 描述方法的参数，@return 描述方法的返回值，@exception 描述方法可能抛出的异常。它们的句法如下： \n      @param 参数名 参数说明 \n      @return 返回值说明 \n      @exception 异常类名 说明 \n      \n      ```\n\n# 变量\n\n## 数据类型\n\n### 变量\n\n1. 变量本质就是一个变化的值。\n\n2. 变量有三个基本要素\n\n   1. 类型\n   2. 名称\n   3. 值\n\n3. ```java\n   public static void main(String[] args){\n   \tint a=1;\n   \t//定义了一个变量，类型为int，名称为a，值为1\n   \ta=89;\n       //把89这个值赋给了a变量\n   }\n   ```\n\n4. 注意事项：\n\n   * 变量表示内存中的一个储存区域，[不同的变量，类型不同，占用的空间大小不同，比如：int 4个字节，double 8个字节]\n   * 该区域有自己的名称[变量名]和类型[数据类型]\n   * 变量必须先声明，后使用，有着自身的顺序\n   * 该区域的数据可以在同一类型范围内不断变化\n   * 变量在同一个作用域内不能重名\n   * 变量=变量名+值+数据类型，变量三要素\n\n### 运算符\n\n1. +号的使用\n   * 当左右两边为数值类型的时候，做加法运算\n   * 当左右两边有一方为字符串类型时，做拼接运算\n\n### 数据类型\n\njava数据类型\n\n1. 基本数据类型\n\n   * 数值型\n     * 整数类型，存放整数（byte[1],short[2],int[4],long[8])\n     * 浮点（小数）类型（float[4]，double[8])\n   * 字符型（char[2]），存放单个字符'a'\n   * 布尔型（Boolean[1]），存放true，false\n\n2. 引用数据类型（面向对象部分讲解）\n\n   * 类（class）\n   * 接口（interface）\n   * 数组（[]）\n\n3. 八大基本数据类型\n\n   【byte，short，int，long，float，double】，char，Boolean\n\n4. 浮点数据类型\n\n   1. 默认情况下输入的字符默认是double类型的\n\n   2. 如果想改成float类型需要在数值后面加上f或F\n\n   3. ```java\n      float a = 1.1 //错误\n      float a = 1.1F //正确\n      double b = 1.1\t//正确\n      double b = 1.1F\t//正确\n      ```\n\n   4. 平时使用默认的double类型就行，因为更为精确\n\n   5. 浮点数使用陷阱\n\n      * ```java\n        //例如\n        //2.7和8.1/3 比较\n        double a = 2.7 ;\n        double b = 8.1/3 ;//理论上数学得数是2.7\n        System.out.println(a);//2.7\n        System.out.println(b);//得数是一个接近2.7的一个小数，而不是2.7\n        //因为计算机计算机制的问题，不是数学的问题。\n        所以在做相等判断时需要小新\n        ```\n\n      * ```java\n        //类似问题的解决方法\n        double a = 2.7 ;\n        double b = 8.1/3 ;//理论上数学得数是2.7\n        System.out.println(a);//2.7\n        System.out.println(b);\n        \n        if(a == b){\n        //这样的写法会出问题\n        \tSystem.out.println(\"相等\");\n        }\n        \n        //可以使用计算其差值\n        if(Math.abs(a-b)<0.001){\n        \tSystem.out.println(\"差值非常小，到我规定的精度内，认为相等\");\n            \n           // Math方法调用java API\n           \n        }\n        ```\n\n5. 字符类型\n\n   1. char的本质就是一个整数，默认用的是Unicode编码\n   2. 字符常量用单引号引出来，\n      * 例：char a = 'a';\n      * char b = '/n';\n   3. 不能输入双引号，否则会认成字符串，会报错。\n   4. char类型时可以运算的。\n\n   字符型的本质\n\n   * 字符型储存到计算机中，需要将对应的码值（整数）找出来\n\n   * 字符和码值的对应关系是通过字符编码表决定的（是规定死的）\n\n   * ![image-20220205221255475](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220205221255475.png)\n\n6. 布尔类型\n\n   1. 只占一个字节，只允许true和false\n   2. 用于判断操作\n   3. 不可用0或非0 来代替true或false，c语言可以\n\n## 数据类型转换\n\n### 1、自动类型转换\n\n* 精度小的类型自动转换为精度大的数据类型，反之就会报错。\n\n* char < int < long < float < double \n\n* byte < short < int < long < float < double\n\n* ```java\n  //例：\n  int num = 'a';\n  ```\n\n1. 注意事项\n\n   1. 多重类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的哪种数据类型，然后再进行计算\n\n    ```java\n     //例\n     int n1 = 10;\n     float d1 = n1+1.1;\n     //这是错误的，因为转换成最大单位，1.1默认的类型是double类型的，如果是n1＋1.1f 的话就是正确的\n     double d1 = n1+1.1;\n     // 这是正确的；\n    ```\n\n   2. （ byte , short ) 和 char之间不会相互转换，当把一个具体的数赋给byte时。\n\n      1. 先判断该数是否在byte范围内，如果是就可以\n\n   3. byte，short，char 三者可以进行计算，在计算时都会先转换成int类型\n\n      * ```java\n        byte b1 = 1;\n        byte a1 = 1;\n        short b2 = 1;\n        short s2 = b1 + b2//错误\n        //因为计算时会转换成int类型，int不能再赋给比它小的类型short\n        int s2 = b1 + b2 //正确\n        byte s3 = a1 + b1//错误\n        //byte，short，char,只要涉及计算都会转换为int类型，所以错误\n        ```\n\n   4. 布尔类型 ( boolean ) 不参与类型转换\n\n   5. 自动提升原则：表达式结果的类型自动提升为 操作数中最大的类型。\n\n### 2、强制类型转换\n\n1. 简介\n\n   1. 大的数据类型转换为小的数据类型\n   2. 使用时要加上强制转换字符（类型）\n   3. 可能会出现精度降低和溢出问题\n\n2. 注意细节\n\n   1. 将数据从大到小转换，需要强制转换\n\n   2. ```java\n      //强制转换符只对最近的操作数有效，也就是只对下边的10数字有效，转换后再进行计算又会转换成double类型。\n      int x = (int)10*3.5+6*1.5;//提示编译错误，类型是double ->\n      \n      int x = (int)(10*3.5+6*1.5);//用小括号括起来即可完美解决上述问题\n      ```\n\n3、基本数据类型和String类型的转换\n\n1. 介绍\n\n   1. 在程序开发中，我们经常需要吧基本数据类型转换成String类型，或String转基本数据类型\n\n2. 方式\n\n   * 基本转String\n\n     * 基本数据类型的值+\" \" \n\n     * ```java\n       //例\n       int n1 = 123;\n       float f = 2.3f;\n       double b = 4.5;\n       String str1 = n1 +\" \";\n       String str2 = f +\"\";\n       String str3 = b +\"\";\n       \n       ```\n\n   * String 转基本\n\n     * 调用基本类型的包装类方法parseXXX 方法即可\n\n     * ```java\n       String s5= \"123\";\n       integer.parseInt(s5);\n       Double.parseDouble(s5);\n       Float.parseFloat(s5);\n       //怎么吧字符串转成字符char，含义是指吧字符串的第一个字符得到\n       system.out.println(s5.charAt(0));//获取字符串的第一个字符\n       //所以这个输出的值为1\n       ```\n\n3. 注意事项\n\n   1. string转换基本类型时，要确保string类型能够转成有效数据，可以吧'123'转换成一个整数，但不能吧\"hello\"转换成一个整数\n\n# 运算符\n\n## 运算符\n\n### 1.简介\n\n1. 是一种特殊符号，表示数据的运算、赋值和比较等\n2. 种类\n   * 算数运算符\n   * 赋值运算符\n   * 关系运算符(比较运算符)\n   * 逻辑运算符\n   * 位运算符 [ 需要二进制基础 ]\n   * 三元运算符\n\n### 2.算数运算符\n\n1. 对数值类型的变量进行运算的\n2. 预览：![image-20220211161920431](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220211161920431.png)\n3. 注意事项\n   * 取模\n   * <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">再%的本质，看一个公式 a % b = a-a / b * b</span>\n4. 面试题\n   1. ![image-20220213151013682](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213151013682.png)\n      1. 答案为 1\n         * 运行步骤为\n         * (1)先把 i 的值赋给一个临时变量tmp\n         * (2)再进行计算i++，结果为i=2\n         * (3)tmp的值重新赋给i，此时i =1\n      2. 答案为2\n         * 运行步骤为\n         * (1)再进行计算i++，结果为i=2\n         * (2)再将2移到临时变量tmp\n         * (3)tmp赋给 i\n\n### 3.关系运算符（比较运算符）\n\n1. 介绍\n   * 关系运算符的结果都是boolean型，\n   * 通常用在if条件语句结构条件中\n   * 关系运算符组成的表达式成为关系表达式\n2. 预览图\n\n![image-20220213162614379](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213162614379.png)\n\n\n\n### 4.逻辑运算符\n\n预览：\n\n1. ![image-20220213170452994](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170452994.png)\n\n2. ![image-20220213170753311](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170753311.png)\n\n3. ![image-20220213170926798](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170926798.png)\n\n4. ```\n   &&（短路与）\t只有两个条件都为true ，才为true\t//如果第一个条件为false，则后面的条件不执行，直接输出flase，效率高\n   \n   &\t（逻辑与）\t只有两个条件都为true ，才为true\t//两个条件都执行，效率低\n   ```\n\n5. ![image-20220214140501385](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220214140501385.png)\n\n6. ```java\n   取反\n   真变假，假变真\n   //a^b :叫逻辑异或，当a和b不同时，结果为true，否侧为false\n   例：\n   \tboolean b = (10>1) ^ (3<5);\n   \tSystem.out.println(\"b=\"+b);//f\n   ```\n\n### 5.赋值运算符（=）、\n\n分类：\n\n* 基本赋值运算符 = \tint a = 10；\n\n* 复合赋值运算符\n\n  ```\n  +=，-=，*=，/=，%=等等，\n  例：a += b;[等价 a=a+b;]\n  \ta -=b;[等价 a = a-b;]\n  一般情况加复合赋值运算符，前边都有基本赋值运算符\n  ```\n\n* 复合运算符会进行类型转换\n\n  ```java\n  byte a =3;\n  a += 2; //此时计算结果为int类型\n  //不会报错，因为会自动进行类型转换\n  \n  //不能直接写成\n  a=a+2; //会报错\n  \n  // 像a++，++a这种会都进行自动的类型转换\n  ```\n\n### 6.三元运算符\n\n* 语法：条件表达式？ 表达式1: 表达式2；\n\n* 运算规则：\n\n  1. 如果条件表达式为true，运算后的结果是表达式1；\n\n  2. 如果条件表达式为false，运算后的结果是表达式2；\n\n     口诀：【一灯大师：一真大师（如果为真，返回1）】\n\n  3. 例：\n\n     ```java\n     int a = 10 ;\n     int b = 99 ;\n     // 1.如果 结果为false\n     // 2.返回b--，先返回b，再进行b-1。依旧按照之前的a++,++a的计算形式\n     // 3.结果为99\n     int result = a > b ? a++; b--;\n     //如果a>b 为真，返回a++，如果为false返回b--;\n     \n     ```\n\n  4. 本质就是if，else语句\n\n### 7.运算符优先级\n\n* ![image-20220215150928654](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220215150928654.png)\n* 小结：优先级排名\n  1. () ，{}等优先级最高\n  2. 单目运算==a ，--a等；\n  3. 算术运算符+-\n  4. 位移运算符\n  5. 比较运算符\n  6. 逻辑运算符\n  7. 三元运算符\n  8. 赋值运算符\n\n## 标识符\n\n**标识符的规则和规范**\n\n1. java中对各种变量、方法和类的命名使用的字符成为标识符。\n\n* ```java\n  int num =1;\n  // num就是标识符\n  ```\n\n2. 标识符的命名规则必须遵守\n   * 标识符由26个字母的大小写，0-9，_或$符组成。\n   * 不可以用数字开头\n   * 不可以使用关键字和保留至，但能包含关键字和保留字\n   * 标识符不能包含空格\n3. 标识符命名规范\n   * 包名：多单词组成时，所有字母都小写。例：aaa.bbb.ccc\n   * 类名、接口名：多单词组成是，所有单词首字母大写，驼峰命名法\n   * 变量名、方法名：多单词组成时，第一个单词首字母小写，后面单词的首字母大写。例：aaBbCc\n   * 常量名：所有字母都大写。多单词时用下划线隔开。例：A_B_C\n\n##   键盘输入语句\n\n### 1.介绍\n\n在编程过程中需要接受用户的输入数据，可以使用键盘输入语句来获取。input.java，需要一个扫描器（对象），就是Scanner\n\n### 2.步骤\n\n1）导入该类所在的包，java.utill.*\n\n2）创建该类对象（声明变量）\n\n3）调用里面的功能\n\n### 3.案例\n\n```java\npublic class KeyboardInput {\n    public static void main(String[] args) {\n//        创建Scanner对象\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.println(\"请输入文本1\");\n//        z字符串类型\n        scanner.next();\n        System.out.println(\"请输入age\");\n//        nextint 代表接收一个int类型的输入\n        scanner.nextInt();\n//        接收double类型的\n        scanner.nextDouble();\n\n    }\n\n```\n\n\n\n\n\n## 进制\n\n### 介绍\n\n对于整数，有四种表达方式\n\n* 二进制（Bin/B）：0,1，满2进1，以0b或0B开头\n\n* 八进制（OCT/O）：0-7，满8进1。以数字0开头表示\n\n* 十进制（DEC/D）：0-9，满10进1\n\n* 十六进制（HEX/H）：0-9及A(10)-F(15)，满16进1.以0x或0X开头表示。此处的A-F不区分大小写\n\n* ```java\n  int n1 = 0b1010;\n  int n2 = 01010;\n  int n3 = 1010;\n  int n4 = 0x10101;\n  ```\n\n  \n\n### 进制转换（基本功）*\n\n第一组\n\n1. 二进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和\n\n   * ```\n     例\n     0b 1011  =1*2^0+1*2^1+0*2^2+1*2^\n     = 1+2+0+8\n     =11\n     \n     ```\n\n2. 八进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和。\n\n   * ```\n     例：0234转成十进制\n     0 234\n     =4*8^0 + 3*8^1 + 2*8^2 \n     =4+24+128\n     =156\n     ```\n\n3. 十六进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和\n\n   * ```\n     例：0x 23A转成十六进制\n     =10*16^0 + 3*16^1 + 2*16^2\n     =10 + 48 + 512\n     =570\n     A(10),B(11),C(12),D(13),E(14),F(15)\n     ```\n\n[第一部分练习](###进制部分)\n\n第二组\n\n1. 十进制转二进制\n\n   * 规则：将该数不断除2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制\n\n   * ```\n     将34转换成二进制\n     34%2\t余0\n     17%2  余1\n     8%2\t\t余0\n     4%2\t\t余0\n     2%2\t\t余0\n     1%2\t\t余1\n     反着读\n     结果：0b100010 //前缀0b的意思为二进制\n     正确答案为：0b00100010\n     因为一个字节二进制的是八位，34的出的结果是六位所以前面需要多加两个0\n     ```\n\n2. 十进制转八进制\n\n   * 规则：将该数不断除8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的八进制\n\n   * ```\n     例：将131转为八进制\n     131%8\t\t余3\n     16%8\t\t余0\n     2%8\t\t\t2\n     结果为0203前面的0代表的意思是八进制\n     ```\n\n3. 十进制转十六进制\n\n   * 规则：将该数不断除16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的十六进制\n\n   * ```\n     例：237\n     答案为 ED\n     ```\n\n   * ![image-20220216221217568](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220216221217568.png)\n\n第三组\n\n1. 二进制转八进制\n\n   * 规则：从低位开始，将二进制数的每三位一组，转成对应的八进制数即可\n\n   * ```\n     例：0b 11010101 每三个转成十进制再拼起来\n     =325\n     11100101\n     =345\n     ```\n\n2. 二进制转十六进制\n\n   * 从低位开始，将二进制数的每四位一组，转成对应的十六进制即可\n\n   * ```\n     11010101\n     =0xD5\n     1110010110\n     =0x396\t每四个转成十进制再拼起来\n     ```\n\n第四组\n\n1. 八进制转二进制\n\n   * 规则：将八进制数每一位，转成对应的3位的二进制数\n\n   * ```\n     237  每位以十进制转二进制转成对应的3位二进制数再连起来\n     2（010）3（011）7（111）\n     =010011111\n     \n     1230\n     =1(001)2(010)3(011)0(000)\n     =001010011000\n     ```\n\n2. 十六进制转二进制\n\n   * 规则：将八进制数每一位，转成对应的4位的二进制数\n\n   * ```\n     23B\n     =2(0010)3(0011)B(1011)\n     =001000111011\n     AB29\n     =A(1010)B(1011)2(0010)9(1001)\n     =1010101100101001\n     ```\n\n源码，反码，补码（重点）\n\n对于有符号的数而言（八个规则）：\n\n1. 二进制的最高位是符号位：0表示正数，1表示负数（口诀：0 - >0   1-> -）\n2. 正数的原码，反码，补码都一样（三码合一）\n3. 负数的反码 = 它的原码符号位不变，其他位取反（0->1,1->0）0变1,1变0.\n4. 负数的补码 = 它的反码+1，负数的反码 = 负数的补码-1\n5. 0的反码，补码都是0\n6. java没有无符号的数，换而言之，java中的数都是有符号的\n7. 计算机运算的时候，都是以 <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">补码的方式来运算的</span>\n8. <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">当我们看运算结果的时候，要看它的原码（！！！）</span>\n\n\n\n## 位运算\n\n* java中有七个位运算符（&，|，^，~，>>，<<和>>>）\n\n* 分别是：\n\n  * &：按位与\n\n    * 规则：两位全为1，结果为1，否则为0\n\n    * ```\n      例：\n         10011010\n        &11011101\n      -------------\n        =10011000// 两个都1结果才为1\n      ```\n\n  * |：按位或\n\n    * 规则：两位有一个为1，结果为1，否则为0\n\n    * ```\n          10011010\n        &11011101\n      -------------\n        =11011111// 两个有一个1结果才为1\n      ```\n\n  * ^：按位异或\n\n    * 规则：两位一个为0，一个为1，结果为1，否则为0\n\n    * ```\n      10011010\n      &11011101\n      ```\n\n    -------------\n\n        =01000111// 两位一个为0，一个为1，结果为1，否则为0\n\n      ```\n    \n      ```\n\n  * ~：按位取反\n\n    * 规则：0为1,1为0\n\n```\n//位移运算\nint a = 1>>2; // 1 向右位移2位\nint b = -1>>2;\nint c = 1<<2; //左移 2位\nint d = -1<<2;\nint e = 3>>>2;//无符号右移\n\n\n```\n\n[练习部分](##位运算练习)\n\n```\n2&3计算机计算流程（计算机是按照补码进行计算的）\n因为一个字节是八位，一个int类型有4个字节\n1.先得到2的补码 ===>* 源码00000000 00000000 00000000 00000010 //得到原码\n* 转成补码（正数的三码都一样）\n00000000 00000000 00000000 00000010\n2. 得到3的补码 ====>先获得原码00000000 00000000 00000000 00000011\n得到3的补码\n00000000 00000000 00000000 00000011\n\n3.计算2&3\n补码结果为：00000000 00000000 00000000 00000010\n原码也为：00000000 00000000 00000000 00000010\n最终结果为：2\n```\n\n````\n~-2计算过程\n1. 得到-2的原码10000000 00000000 00000000 00000010\n2. 算出-2的反码11111111 11111111 11111111 11111101（原符号位保持不变，其他取反）\n3. 算出-2的补码11111111 11111111 11111111 11111110\n4.再进行~-2操作00000000 00000000 00000000 00000001//运算后的补码\n5.转为原码00000000 00000000 00000000 00000001\n6.结果为1\n````\n\n```\n~2的计算过程\n1.得到2的原码00000000 00000000 00000000 00000010\n2.获取补码：00000000 00000000 00000000 00000010\n3.计算~2:11111111 11111111 11111111 11111101\n3.转为反码（）负数的反码=补码-1\n11111111 11111111 11111111 11111100\n4.转为原码：10000000 00000000 00000000 00000011\n5.结果为-3\n```\n\n* 运算符>>，<<和>>>运算规则\n\n  * 算数右移>>；低位溢出，符号位不变，并用符号位补溢出的高位\n\n    * ```\n      int a = 1>>2;\n      1:00000000 00000000 00000000 00000001\n      1 >>2 //相当于把最后边的01去掉用符号位补上\n      结果：00000000 00000000 00000000 00000000\n      最后结果为0\n      \n      简便的方法\n      1>>2 = 1/2/2= 0\n      15>>2 = 15/2/2=3  //取整\n      ```\n\n  * 算数左移<<; 符号位不变，低位补0\n\n    * ```\n      int a =1<<2;\n      1:00000000 00000000 00000000 00000001\n      1<<2\n      00000000 00000000 00000000 00000100\n      结果为4\n      \n      简便的方法\n      1<<2 =1*2*2 = 4\n      4<<3 = 4*2*2*2 = 32\n      \n      ```\n\n  * 3.>>>逻辑右移，也叫无符号右移，运算规则是：低位溢出，高位补0\n\n# 程序控制结构\n\n## 顺序控制（if,else,switch）\n\n### 介绍\n\n程序从上到下逐行执行，中间没有任何判断和跳转\n\n### 分支控制\n\n### **1）单分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块;\n}\n```\n\n说明：当条件表达式为true时，则执行{}内的代码。false就不执行。如果只有一条执行语句，可以省略{}。但不建议省略\n\n### **2）双分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块1;\n}else{\n\t执行代码块2;\n}\n```\n\n\n\n### **3）多分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块1;\n}else if(条件表达式){\n\t执行代码块2;\n}else{\n\t执行代码块....;\n}.....\n```\n\n流程图：\n\nelse只能有一个执行入口\n\n![image-20220222162201564](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220222162201564.png)\n\n特别说明：\n\n1. 多分支可以没有else，如果所有条件都不成立，则一个执行入口都没有\n2. 如果有else，如果所有的条件表达式都不成立，则默认执行else代码块。\n\n练习：\n\n```java\npublic class ifChapter {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入0-100的数字\");\n        int num = scanner.nextInt();\n        if (num<1 && num>100){\n            if (num==100){\n                System.out.println(\"信用极好\");\n            }else if (num>80 && num <= 99){\n                System.out.println(\"信用优秀\");\n            }else if (num >= 60 && num <= 80){\n                System.out.println(\"信用一般\");\n            }else if (num <60){//或直接不写这个条件语句，但这个会有bug\n                System.out.println(\"不及格\");\n            }else{\n                System.out.println(\"请输入合法数字\");\n            }\n        }else{\n            System.out.println(\"输入不合法\");\n        }\n    }\n}\n```\n\n### **4）嵌套分支**\n\n介绍：\n\n一个分支完整的嵌套了另一个分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支。\n\n规范：不建议超过三层（可读性不好）\n\n基本语法：\n\n```java\nif(){\n\tif(){\n\t\n\t}else{\n\t\tif.....\n\t}\n}\n```\n\n### 5）switch分支\n\n基本语法：\n\n```java\nswitch(表达式){ //表达式为具体的一个值\n    case 常量1:\n语句块1;\nbreak;\n    case 常量2:\n语句块2;\nbreak;\n    case ······:\nbreak;\n ...........\n       \ndefault :\ndefault语句块\nbreak;\n}\n```\n\n1. switch 关键字,表示swtich分支\n2. 表达式   对应一个值\n3. case常量1：当表达式的值等于常量1，就执行语句块1\n4. break：表示退出switch\n5. 如果case 常量1 匹配，就执行语句块1，如果没有则继续case 常量2；\n6. 如果一个都没有匹配上，就执行default\n\nSwitch流程图：\n\n![image-20220224155515378](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220224155515378.png)\n\n 注意：\n\n* 穿透\n  1. 如果case1 没有break\n  2. 则case不进行判断直接执行case2 的语句块\n\n```java\npublic static void main(String[] args) {\n        char week;\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入字母\");\n        week = scanner.next().charAt(0);\n        switch (week){\n            case 'a':\n                System.out.println(\"Monday\");\n                break;\n            case 'b':\n                System.out.println(\"Tuesday\");\n                break;\n            case 'c':\n                System.out.println(\"Wednesday\");\n            case 'd':\n                System.out.println(\"Thursday\");\n                break;\n            case 'e':\n                System.out.println(\"Friday\");\n                break;\n            case 'f':\n                System.out.println(\"Saturday\");\n                break;\n            case 'g':\n                System.out.println(\"sunday\");\n                break;\n            default:\n                System.out.println(\"输入有误，请输入a-g的字母\");\n        }\n    }\n```\n\n注意事项和细节\n\n1. 表达式数据类型，应和case后的常量类型一致，或者是可以自动转换成可以相互比较的类型，比如输入的是字符，而常量是int\n\n2. Switch(表达式)中表达式的返回值必须是：（byte，short，int，char，enum，String）\n\n   ```java\n   //比如下列例子，是不可以的\n   double a = 1.1;\n   switch(a){//错误\n   \tcase 1.1://case后面不可以有变量\n   \t\tSystem.out.println(\"···\");\n   \t\tbreak;\n   }\n   ```\n\n3. case子句中的值必须是常量，不能是变量\n\n4. default子句是可选的，当没有匹配的case时，执行default。default语句是可选的，当没有匹配的任何常量，则没有任何输出。\n\n5. break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有则会出现穿透现象，使程序执行后面所有的case语句块，除非遇到break；\n\n6. [练习](##switch练习)\n\n**switch 和if的比较**\n\n1. 如果判断的具体数值不多，而且符合byte，short，int，char，enum，string类型虽然这两个语句都可以用，建议用switch\n2. 其他情况，对区间判断，对结果为boolean配型判断，使用if，if的使用范围更广\n\n## 循环控制（for,while,dowhile,多重循环[重点]）\n\n### 1）for循环\n\n1. 基本语法\n\n   ```java\n   for(循环变量初始化；循环条件；循环变量迭代){\n   \t循环操作；(可多条语句)\n   }\n   \n   ```\n\n   \n\n2. 说明\n\n   1. for关键字，表示循环控制\n   2. for有四要素，1）循环变量初始化，2）循环条件，3）循环操作，4）循环变量迭代\n   3. 循环操作，这里可以有很多条语句，也就是我们要执行的代码块\n   4. 如果 循环操作(语句)只有一条语句，可以省略{}，建议不要省略\n\n例子：\n\n```java\npublic static void main(String[] args) {\n\n        //练习： 打印100句“韩顺平教育”\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"韩顺平教育\" +i);\n        }\n\n\n    }\n```\n\n* for循环流程图\n  * ![image-20220227123857620](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227123857620.png)\n\n#### 注意事项：\n\n* 循环条件返回一个布尔值(Boolean)\n\n* for（；循环条件；）中的初始化和变量迭代可以写到其他地方，但两边的分号不能省略\n\n  * ```java\n    //演示\n    int i = 0;\n    for (i; i < 10;) {\n                System.out.println(\"韩顺平教育\" +i);\n                 i++;\n            }\n    \n    //补充\n    for(;;){//表示一个无限循环\n       System.out.println(\"韩顺平教育\" +i);\n    }\n    ```\n\n* 循环初始值，可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开\n\n  * ```java\n    //例\n    int count =3;\n    for (i =0 ,j = 0 ;i<count; i++, j+=2){\n    \tSystem.out.println(\"i=\"+i \"j=\" +j);\n    }\n    输出 ：00 12 24\n    ```\n\n  * 00 12 24 \n\n#### **编程技巧**\n\n* 化繁为简：将复杂的需求拆解成简单的需求\n* 先死后活：先考虑固定的值，然后转成可以灵活变化的值\n\n**练习**\n\n1. 打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]\n\n   * ```\n     \n     ```\n\n   * ```java\n     //打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]\n           //1、先输出1-100循环\n           //2、在输出的过程中过滤9的倍数\n           //3、定义一个变量来累计计算个数\n           //4、定义一个变量来累计计算总和\n     public static void main(String[] args) {\n             int count= 0;\n             int sum =0;\n             for (int i = 1; i <=100 ; i++) {\n                 if (i%9==0){\n                     System.out.println(\"i=\"+i);\n                     count++;\n                     System.out.println(\"数量\"+count);\n                     sum+=i;// = sum + i\n                     System.out.println(\"sum=\"+sum);\n                 }\n     \n             }\n     ```\n\n### 2）while循环\n\n基础语法：\n\n```java\nwhile（循环条件）{\n\t循环体（语句）；\n\t循环变量迭代；\n}\n```\n\n说明：\n\n1. while循环也有四要素\n2. 只是四要素放的位置，和for不一样\n\n**流程图**\n\n![image-20220227143009846](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227143009846.png)\n\n#### 注意事项：\n\n1. 循环条件是返回布尔值\n2. while循环是先判断再执行语句\n\n\n\n### 3）do...while循环控制\n\n基础语法：\n\n```java\ndo{\n\t循环体(语句);\n\t循环变量迭代;\n}while(循环条件);\n\n```\n\n 说明:\n\n1. do  while 是关键字\n\n2. 也有循环四要素，只是位置不一样\n\n3. 先执行，在判断，也就是说，一定会执行一次\n\n4. 最后有一个分号\n\n5. while和do... while区别\n\n   * while是先判断再执行\n\n   * do .. while是先执行再判断\n\n```java\npublic static void main(String[] args) {\n\n       int i = 1;\n        do {\n            System.out.println(\"阿巴阿巴\");\n            i++;//不要忘记加上，否则容易死循环\n        }while (i<=10);\n\n        System.out.println(\"exit dowhile\");\n    }\n```\n\n\n\n流程图：\n\n![image-20220227163555197](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227163555197.png)\n\n#### 注意事项：\n\n1. 循环条件是返回一个布尔值的表达式\n2. do...while 循环是先执行后判断，因此它至少执行一次\n\n\n\n### 4）多重循环\n\n#### 介绍\n\n1. 讲一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do ...while均可以作为外层循环和内层循环 。【建议一般使用两层，最多不超过三层，否则代码可读性很差】\n\n2. 实质上，嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环\n\n3. 例：设外层循环次数为m次，内层为n次。则内层循环体实际上需要执行m*n次\n\n   ```java\n   for (int i = 0; i < 2; i++) {\n               for (int j = 0; j < 3; j++) {\n                   System.out.println(\"i = \"+i+ \",\"+\"j = \"+j);\n               }\n           }\n   \n   ------------------------输出------------------------\n   i = 0 , j =0\n   i = 0 , j =1\n   i = 0 , j =2\n   i = 1 , j =0\n   i = 1 , j =1\n   i = 1 , j =2\n   ```\n\n   \n\n#### 练习\n\n1. 统计3个班成绩情况，每个班有5名同学，求出各个班的平均成绩和所有班级的平均分【学生的成绩从键盘输入】\n\n   * ```java\n     Scanner scanner = new Scanner(System.in);\n     //        int clss = 1;\n                 int stu =0;\n                 double sum = 0;\n             for (int i = 1; i <=3 ; i++) {\n                 for ( int j = 1;j<=5;j++){\n     \n                     System.out.println(\"请输入\"+i+\"班\"+j+\"成绩\");\n                     int s = scanner.nextInt();\n                     sum = sum + s;\n                 }\n                 System.out.println(i+\"班的平均分为：\"+(sum / 5));\n                 sum =0;\n             }\n     ```\n\n     \n\n2. 打印99乘法表\n\n   * ```java\n     for (int i = 1; i <=9 ; i++) {\n        \n                 for (int j = 1; j <=i ; j++) {\n                     System.out.print(i+\"*\"+j+\"=\"+(i*j)+\"  \");\n     \n     \n                 }\n                 System.out.println(\"\");\n             }\n     ```\n\n3. 打印空心金字塔\n\n   * ```java\n     //        实心金字塔\n             for (int i = 1; i <=5 ; i++) {\n                 for (int k = 1; k <=5-i ; k++) {\n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n     \n                     System.out.print(\"*\");\n                 }\n                 System.out.println(\" \");\n             }\n     ```\n\n   * ```java\n     空心金字塔 【难点】\n             for (int i = 1; i <=5 ; i++) {\n                 for (int k = 1; k <=5-i ; k++) {\n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n                 \n                 \n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n                 \n                 \n     \t\t\t\t//1.空心金字塔的第一层和最后一层的*全部输出\n     \t\t\t\t//2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示\n     \t\t\t\t//3.再加一个条件 i == 5\n     \t\t\t\tif(j == 1 || j == 2*i-1 || i==5 ){\n     \t\t\t\t\t System.out.print(\"*\");\n     \t\t\t\t}else{\n     \t\t\t\t\t System.out.print(\" \");\n     \t\t\t\t}\n     \n     //可以将其中的5 提出来换成变量，实时控制金字塔的层数\n     \n                    \n                 }\n                 System.out.println(\" \");\n             }\n     ```\n\n     \n\n   * ```java\n     //可手动修改的\n     \n           Scanner scanner = new Scanner(System.in);\n           System.out.println(\"请输入层数\");\n           int layer = scanner.nextInt();\n     ```\n\n\n             for (int i = 1; i <=layer ; i++) {\n                 for (int k = 1; k <=layer-i ; k++) {\n    \n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n    \n                     //1.空心金字塔的第一层和最后一层的*全部输出\n                     //2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示\n                     //3.再加一个条件 i == 5\n                     if(j == 1 || j == 2*i-1 || i==layer ){\n                         System.out.print(\"*\");\n                     }else{\n                         System.out.print(\" \");\n                     }\n                 }\n                 System.out.println(\" \");\n             }\n    \n     ```\n   * 改为菱形\n     ```\n\n\n\n## break\n\n介绍\n\n1. 跳转控制语句----->break\n2. 当某个条件满足时，终止循环\n3. break语句用于终止某个语句块的执行，一般用于switch或者循环中\n\n基本语法：\n\n```java\n{\n......\nbreak;\n......\n```\n\n以while循环为例流程图：\n\n![image-20220228111326348](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228111326348.png)\n\n#### 注意事项\n\n1. break语句出现在多层嵌套语句块时，可以通过标签指明要终止的是哪一层语句块\n\n2. 标签的基本使用\n\n   ```java\n   label1:{.....\n   label2:\t\t{.....\n   label3:\t\t\t{.....\n   \t\t\t\tbreak label2;\n   \t\t\n   }\n   \t\n   }\n   \n   }\n   ```\n\n   1. break语句可以指定退出哪层\n   2. label1是标签，由程序员决定\n   3. break后指定到哪个label就退出到哪里\n   4. 在实际开发中，尽量不要使用标签\n   5. 如果没有指定break，默认退出最近的循环体\n\n## continue-跳转控制语句\n\n介绍：\n\n1. <u>**continue语句用于结束本次循环，继续执行下次循环**。</u>\n2. continue语句多出现在多层嵌套的循环语句中时，可以用过标签指明要跳过的是哪一环，这个和前面的标签使用一样\n\n基本语法\n\n```java\n{\n....\ncontinue;\n....\n}\n```\n\n流程图：\n\n![image-20220228153036178](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228153036178.png)\n\n\n\n## return-跳转控制语句\n\n介绍：\n\nreturn使用在方法，表示跳出所在的方法\n\n注意：\n\n1. 如果吧return放在main方法中会退出程序\n\n# 数组【重点】\n\n## 数组\n\n**介绍**\n\n数组可以存放 <u>多个</u>*<u>同一类型</u>* 的数据。数组也是一种数据类型，是引用数据类型。\n\n即：数（数据）组（一组）就是一组数据\n\n<span id = \"数组案例01\">案例</span>（快速入门）：\n\n```java\npublic static void main(String[] args) {\n   \t\t\tdouble totalWeght =0;\n        double[] hen = {1,2,3,4,5,6};\n  //可以通过 for循环访问数组的元素\n        for (int i = 0; i <hen.length ; i++) {\n          //可以通过下标来访问数组的元素 hen[下标]\n          //下标是从0开始的，比如【0，1，2，3】\n          //第二个元素是hen[1]\n    \n            System.out.println(\"第\"+(i+1)+\"个元素的值为\"+hen[i]);\n          totalWeght+=hen[i];\n        }\n  \t\tSystem.out.println(\"总体重为\"+totalWeght+\"平均体重为=\"+(totalWeght/hen.length));\n    }\n```\n\n### 动态初始化\n\n#### 使用方式1\n\n先new出一个数组，再动态的给它赋值。\n\n数组的定义：\n\n数据类型\t数组名[] = new 数据类型[大小]\n\n数据类型[]\t数组名 = new 数据类型[大小]\n\n以上两种写法的效果都是等价的\n\n例：\n\n```java\nint a[] = new int[5];\n\n//创建一个数组，名字为a，长度为5个int\n```\n\n内存图：\n\n![image-20220302092916369](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302092916369.png)\n\n例：\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class chapterArray01 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        //new数组类型时，记得加上数组的长度\n        double[] doubles = new double[5];\n        for (int i = 0; i < doubles.length; i++) {\n            System.out.println(\"请输入第\"+(i+1)+\"个数\");\n            doubles[i] = scanner.nextDouble();\n        }\n        System.out.println(\"========================================\");\n        for (int i = 0; i <doubles.length ; i++) {\n            System.out.println(\"输入的数为\"+doubles[i]);\n\n        }\n    }\n}\n\n```\n\n#### 使用方式2\n\n1. ***<u>先声明数组</u>***\n\n语法：\n\n* 数据类型 数组名[];\t或\t\t数据类型[] \t数组名;\n\n* int a[]  / int[]  a;\n\n2. ***<u>创建数组</u>***\n\n语法：\n\n* 数组名 = new 数据类型 [ 大小 ];\n* a = new int[5];\n\n```java\n//        double[] doubles = new double[5];\n//相当于吧使用方法1给拆分成两个\n//\t1.先声明\n        double doubles[];\n        //2.再创建\n        doubles = new double[5];\n```\n\n解释：1.先声明，在内存中相当于创建了一个空的变量，这时没有任何左右\n\n2.再创建，才使得这个数组有意义。不写的话会报空指针异常\n\n### 静态初始化\n\n语法：\n\n数据类型\t数组名[] = {元素值，元素值，元素值，......}\n\n[案例](#数组案例01)跳转\n\n### 注意事项和细节\n\n1. 数组是多核相同的数据类型的组合，实现对这些数据的统一管理\n2. 数组中的元素可以使任何数据类型，包括基本数据类型和引用数据类型，但不能混用\n3. 数组创建后，如果没有赋值，会有默认值：int 0 , short 0 , byte 0 ,long 0, float 0 ,double 0.0 , char \\u0000, boolean false , String null;\n4. 使用数组的步骤：\n   1. 声明数组并开辟空间\n   2. 给数组各个元素赋值\n   3. 使用数组\n5. 数组的下表是从0开始的 \n6. 数组下表必须在指定范围内使用，否则报：下标越界异常，比如: int[] arr = new int [5] ; 则有效下标为0-4\n7. 数组属于引用数据类型，数组行数据是对象（object）\n8. boolean 类型没有赋值的情况下默认false\n\n### 数组赋值机制\n\n1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响\n\n   ```java\n   //基本数据类型赋值，复制方式为值拷贝\n   int n1 = 2 ; \n   int n2 = n1 ;\n   \n   n2的变化不会影响n1\n       \n   ```\n\n2. 数组再默认情况下是引用传递，赋的值是地址。赋值方式为引用传递\n\n   ```java\n   int[] array1 = {1,2,3}\n   int[] array2 = array1; \n   \n   array2[0] = 10;\n   //此时运行的结果 array1的第0个元素会变成10\n   \n   ```\n\n   \n\n ![image-20220302141207302](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302141207302.png)\n\n### 数组拷贝\n\n案例：\n\n```java\nint[] arr1 = {1,2,3}\n//1. 创建一个新的数组arr2,开辟一个新的数据空间\n//2. 大小 = arr1.length\nint arr2[] = new int[arr1.length];\n\n//遍历arr1到对应的位置\nfor( i = 0; i < arr1.length; i++){\n    arr2[i] = arr1[i];\n}\n\n```\n\njvm内存图分析:\n\n![image-20220302142048498](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142048498.png)\n\n![image-20220302142253236](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142253236.png)\n\n### 数组翻转\n\n案例：\n\n要求：需要把数组的元素内容反转。\n\narr { 1 , 2 , 3 , 4 , 5 }-->{5 , 4 , 3 , 2 , 1}\n\n方式1：\n\n```java\nint[] arr = {11 , 22 , 33 , 44 , 55 , 66};\n\n//1. 把 arr[0] 和 arr[5] 进行交换\n//2. 把 arr[1] 和 arr[4] 进行交换\n//3. 把 arr[2] 和 arr[3] 进行交换\n//4. 一共要交换 3 次 = arr.length\n//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]\n  int temp = 0;\n        int len = arr.length;\n        for (int i = 0; i <len/2 ; i++) {\n            temp = arr[len-1-i];\n            arr[len-1-i] = arr[i];\n            arr[i] = temp;\n        }\n     \n     \n }\n```\n\n方式2\n\n```java\nint[] arr = {11 , 22 , 33 , 44 , 55 , 66};\n//1. 先创建一个arr2\n        //2. 逆序遍历arr，再将每个元素赋给arr2的元素中\n        //3. 增加一个循环变量j\n        int[] arr2 = new int[arr.length];\n\n        for (int i = 0,j=arr.length-1 ; j>=0; i++,j--) {\n            arr2[j] =arr[i];\n\n        }\n//4.当for循环结束，arr2就是一个逆序数组，{66 , 55 , 44 , 33 , 22 , 11}\n//5. 让arr指向arr2数据空间,此时arr原来的数据空间就没有变量引用\n//会被当做垃圾处理\narr = arr2\n    //6. 遍历输出\n  \n        for (int i = 0; i <arr.length ; i++) {\n            System.out.println(arr[i]);\n        }\n```\n\n\n\n### 数组扩容\n\n数组缩减同理\n\n数组添加\n\n要求：实现动态的给数组添加元素效果，实现对数组扩容\n\n1）原始数组使用静态分配int[] arr = {1,2,3}\n\n2）增加的元素4，直接放在数组的最后 arr = {1,2,3,4}\n\n3）用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class chapterArrayAdd {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        char key ;\n        int[] arr1 = {1,2,3};\n\n\n        do {\n            int[] arr2 = new int[arr1.length+1];\n                for (int i = 0; i < arr1.length; i++) {\n                    arr2[i] = arr1[i];\n                }\n                System.out.println(\"请输入一个要添加的值\");\n                arr2[arr2.length - 1] = scanner.nextInt();\n\n            arr1 = arr2;\n\n            System.out.println(\"是否继续添加？请输入y/n\");\n            key = scanner.next().charAt(0);\n\n            if (key=='y'){\n                System.out.println(\"继续增加\");\n            }else if (key== 'n'){\n                System.out.println(\"跳出\");\n                break ;\n            }else {\n                System.out.println(\"输入不合法\");\n            }\n//            将arry1的地址指定到arry2的地址，此时原arry1的地址被没有变量引用，所以被jvm销毁\n\n        }while (true);\n\n        for (int i = 0; i < arr1.length ; i++) {\n            System.out.println(\"arr1 = \"+arr1[i]);\n        }\n\n    }\n\n}\n\n```\n\n\n\n\n\n\n\n## 排序\n\n介绍\n\n排序的分类：\n\n1. 内部排序：\n\n* 指将需要处理的所有数据都加载到内部存储中进行排序。包括（交换式排序法，选择时排序法和插入式排序法）\n\n2. 外部排序法：\n   * 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。\n\n### 冒泡排序\n\n基本思想：通过对待排序序列从后向前（从下标较大的元素开始），一次比较相邻元素的值若发现逆序则交换，使值较大的元素从前移向后部。像水下的气泡一样逐渐向上冒。\n\n![image-20220303105607719](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220303105607719.png)\n\n特点：\n\n1. 一共有五个元素\n\n2. 一共进行了四轮排序，可以看成外层循环\n\n3. 每1轮排序可以确定一个数的位置，比如第一轮排序确最大数，第二轮确定第二大的数 的位置，依次类推\n\n4. 当进行比较时，如果前面的数大于后面的数，就交换\n\n   \n\n案例说明:\n\n将五个无序：24,69,80,57,13使用冒泡排序，从小到大排序\n\n```java\npackage com.smms.demo;\n\npublic class chapterBall {\n    public static void main(String[] args) {\n        int tmp = 0;\n        int[] a  = {24,69,80,57,13};\n       \n        for (int i = 0; i < a.length-1; i++) {\n            for (int j = 0; j < a.length; j++) {\n                if (j>=a.length-1){\n                    break;\n                } else if (a[j]<a[j+1]){\n                    System.out.println(\"不做交换\");\n                }else {\n\n                    tmp = a[j];\n                    a[j]  = a[j+1];\n                    a[j+1] = tmp;\n                    System.out.println(\"交换第\"+j+\"个数为\"+a[j]);\n                }\n            }\n        }\n        for (int i = 0; i <a.length ; i++) {\n            System.out.println(a[i]);\n        }\n\n    }\n}\n\n```\n\n\n\n## 查找\n\n### 1）顺序查找：\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class exercisesSequence {\n    public static void main(String[] args) {\n        /*有一个数列：\n        * 白眉鹰王，金毛狮王，紫衫龙王，青翼蝠王猜数游戏\n        * 从键盘任意输入一个名称，判断数列中是否包含此名称（顺序查找）\n        * 要求：如果找到了，就提示找到，并给出下标\n        */\n        String[] a ={\"白眉鹰王\",\"金毛狮王\",\"紫衫龙王\",\"青翼蝠王\"};\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入\");\n        String next = scanner.next();\n        //用于判断是否没找到\n        int nub =-1;\n        for (int i = 0; i <a.length ; i++) {\n            if (next.equals(a[i])){\n                System.out.println(\"找到了\");\n                //如果找到了就把i的值赋给sub\n                nub = i;\n                break;\n                //如果nub==-1就代表没找到\n            }else if (nub == -1){\n                System.out.println(\"没找到\");\n            }\n        }\n    }\n}\n\n```\n\n\n\n### 2）二分查找：\n\n\n\n算法部分讲解补充\n\n\n\n## 二维数组\n\n介绍：一个数组内，还有数组\n\n要理解的点：\n\n1. 看到定义形式就可知道是不是二维数组\n2. 二维数组的每一个元素都是一维数组\n3. 二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历\n4. \n\n```java\n如果需要访问第（i+1)个一维数组，第（j+1)个值。arr2d[i][j]\n 或需要访问第i个一维数组，第j个值。arr2d[i-1][j-1]   \n```\n\n\n\n案例：\n\n```java\npublic static void main(String[] args) {\n        /*\n        * 请用二维数组输入如下图形\n         0 0 0 0 0 0\n         0 0 1 0 0 0\n         0 2 0 3 0 0\n         0 0 0 0 0 0\n         */\n\n//        1. 定义形式 int[][]\n//        2.可以理解为一个数组内的每个元素都是一个数组\n        int[][] arr2d= {{0,0,0,0,0,0},{0,0,1,0,0,0},\n                        {0,2,0,3,0,0},{0,0,0,0,0,0}};\n   System.out.println(\"二维数组的元素个数\"+arr2d.length);\n//\t二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历\n    \n    \n    \n//        获取多个少个一维数组\n        for (int i = 0; i < arr2d.length; i++) {\n//            遍历二维数组的每一个元素（数组）,\n//            arr2d[i].length  获取二维数组内对应的每一个一维数组的长度\n            for (int j = 0; j < arr2d[i].length; j++) {\n                System.out.print(arr2d[i][j]+\"\\t\");\n\n            }\n            System.out.println();\n        }\n    }\n```\n\n### 二维数组内存原理图：\n\n![image-20220304165024843](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165024843.png)\n\n\n\n### 二维数组的使用方式\n\n方式1：动态初始化\n\n```\n1.语法：类型[][] 数组名 = new 类型[大小][大小];\n例如： int[][] = new int[2][3];\n\n```\n\n方式2：动态初始化\n\n```\n1. 先声明：类型 数组名[][];\n2. 再定义（开辟空间）： 数组名 = new 类型[大小][大小];\n3. 赋值（有默认值，比如int 类型默认值就是0）\n```\n\n方式3：动态初始化\n\n1. 列数不确定\n2. java不强制每个数组的长度都一样\n3. 例：![image-20220304165929272](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165929272.png)\n\n```java\npublic static void main(String[] args) {\n        /*\n            动态创建下面二维数组，并输出\n            i = 0 : 1\n            i = 1 : 2 2\n            i = 2 : 3 3 3\n         */\n        //1. 创建一个二维数组，因为数组内的每一堆数组的元素都是不确定的，所以不填。\n        // 填了的话相当于固定了长度\n        int[][] arr= new int[3][];\n        for (int i = 0; i <arr.length ; i++) {\n//            给数组内的一维数组开辟空间\n//            如果没有给一堆数组开辟空间，那么这个空间的就是null\n            arr[i] = new int[i+1];\n//            遍历一维数组，给一堆数组的每个元素赋值\n            for (int j = 0; j < arr[i].length ; j++) {\n                arr[i][j]= i+1;\n            }\n        }\n\n//        遍历出这个二维数组\n        for (int i = 0; i <arr.length ; i++) {\n            for (int j = 0; j <arr[i].length ; j++) {\n                System.out.print(arr[i][j]);\n            }\n            System.out.println();\n        }\n    }\n```\n\n杨辉三角形\n\n![image-20220305143151743](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220305143151743.png)\n\n提示：\n\n1. 第一行有一个元素，第n行有n个元素\n\n2. 第一行的第一个元素和最后一个元素都是1\n\n3. 从第三行开始，对于非第一个元素和最后一个元素的元素的值，arr[i],[j]\n\n4. ```java\n   中间的数为：\n   arr[i][j]  = arr[i-1][j]+ arr[i-1][j-1]\n     \n     \n     \n   ```\n\n   ```java\n   package basics.chapterArray;\n   \n   public class exerciseArrayYangHuiTriangle {\n       public static void main(String[] args) {\n           int[][] arr =  new int[10][];\n           for (int i = 0; i <10 ; i++) {\n               arr[i] = new int[i+1];\n               for (int j = 0; j < arr[i].length; j++) {\n                   if (j==0 || j == arr[i].length-1){\n                       arr[i][j] = 1;\n                   }else {\n                       arr[i][j] = arr[i-1][j]+arr[i-1][j-1];\n                   }\n   \n               }\n   \n           }\n           for (int i = 0; i <arr.length ; i++) {\n               for (int j = 0; j <arr[i].length ; j++) {\n                   System.out.print(arr[i][j]);\n               }\n               System.out.println();\n           }\n       }\n   }\n   \n   \n   ```\n\n\n# 面向对象\n\n## 类与对象\n\n1）类是抽象的，概念的。代表一类事物，比如人类，猫类，狗类。。。。，即它是实例\n\n```java\n例：\nclass cat{\n    //属性/也叫成员变量\n   // 成员变量 =属性 = field(字段)\n\tString name;\n\tint age;\n}\n//实例\ncat c = new ca();\n```\n\n2） 对象是具体的，实际的，代表一个具体事务，即是实例\n\n3） 类是对象的模板，对象是类的一个个体，对应一个实例\n\n属性可以使基本数据类型，也可以是引用数据类型(对象，数组)\n\n### 对象在内存中存在的形式（重要）\n\njava内存的结构分析：\n\n1. 栈：一般存放基本数据类型（局部变量）\n2. 堆：存放对象（Cat cat ，数组等）\n3. 方法区：常量池（常量，比如字符串），类加载信息\n4. 示意图：[Cat(name,age,price)]\n\n```java\nPerson p = new Person();\np.name = \"jack\";\np.age = 12;\n\n1.先加载Person类信息（属性和方法信息，只会加载一次）\n2.在堆中分配空间，进行默认初始化（看规则），\n3.把堆中的地址返回给p，p就指向对象\n4.进行指定初始化，比如：p.name = \"jack\",p.age = 12;\n\n    \n```\n\n\n\n\n\n对象和数组都是引用类型\n\n![image-20220307112129768](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307112129768.png)\n\n如果存放的数据，类型是基本数据类型则存放在堆中，引用的数据类型则存放在方法区\n\n###  注意事项\n\n1） 属性的定义语法同变量，示例：<span style=\"color:blue\">访问修饰符</span><span style= \"color:red\" > 属性类型  属性名;</span>\n\n2） 属性的定义类型可以为任意类型，包含基本类型或引用类型\n\n3） 属性如果不赋值，有默认值，规则和数组一致\n\n### 创建对象\n\n1. 先声明在创建\n\n   ```java\n   CAT cat;\n   cat  = new CAT();\n   ```\n\n2. 直接创建\n\n   ```java\n   CAT cat  = new CAT();\n   ```\n\n   \n\n访问属性\n\n```\n对象名.属性名；\ncat.xxx;\n```\n\n### 类对象的内存分配机制\n\n![image-20220307145803905](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307145803905.png)\n\n## 成员方法\n\n介绍：\n\n用于描述对象的行为，成为方法\n\n案例：\n\n![image-20220307161842380](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307161842380.png)\n\n```java\npackage com.smms.demo.method;\n\npublic class exercisesMethod01 {\n    public static void main(String[] args) {\n        Person person = new Person();\n        person.speal();\n        person.cal01();\n        person.cal02(3);\n//        调用getSum方法，并给了1,3的值\n//        用returnsum接收getSum返回的值\n        double returnsum = person.getSum(1,3);\n\n        System.out.println(\"returnsum=\"+returnsum);\n\n    }\n}\nclass Person{\n    public  void speal(){\n        System.out.println(\"我是一个好人\");\n    }\n\n    public  void cal01(){\n        int sum = 0;\n        for (int i = 0; i <= 1000; i++) {\n            sum+=i;\n        }\n        System.out.println(\"1+~+1000=\"+sum);\n    }\n    public  void cal02(int n){\n        int sum =0;\n        for (int i = 1; i <=n ; i++) {\n            sum = sum+i;\n        }\n        System.out.println(\"1+n=\"+sum);\n    }\n\n    public double getSum(double a, double b){\n        double sum=0;\n        sum = a+b;\n        System.out.println(\"a+b=\"+sum);\n//        表示返回sum\n        return sum;\n    }\n}\n```\n\n### 内存分析流程图\n\n![image-20220308162432089](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220308162432089.png)\n\n方法的优点：\n\n1. 提高了代码的复用性\n2. 可将实现的细节封装起来，然后提供其他用户来调用\n\n\n\n### 成员方法的定义\n\n```java\npublic 返回数据类型\\void（表示没有返回值）\t方法名(形参列表...){//方法体\n语句;\nreturn；//返回值\n}\n```\n\n1. 参数列表：表示成员方法输入cal(int n)\n2. 数据类型(返回类型)：表示成员方法输出，void表示没有返回值\n3. 方法主体:表示为了实现某一功能代码块\n4. return语句不是必须的\n\n\n\n### 注意事项\n\n1. 访问修饰符\n\n2. ``` java\n   访问修饰符 返回数据类型\\void（表示没有返回值）\t方法名(形参列表...){//方法体\n   语句;\n   return；//返回值\n   }\n   \n   1. 访问修饰符（作用是控制 方法的适用范围）\n       如果不写默认访问，[有四种：public protected 默认]\n   \n   ```\n\n   \n\n3. 返回数据类型\n\n```\n1. 一个方法最多有一个返回值\n\t返回多个结果，返回数组\n2. 返回类型可以为任意类型，包含基本类型和引用类型(数组，对象)\n3. 如果方法要求有返回数据类型，则方法体中最后执行的语句必须为return值；而且要求返回值类型必须和return的值的类型一致或兼容\n4. 如果方法是void，则方法体照片那个可以没有return语句，或者 只写 return；\n\n\n方法命名；使用驼峰命名法，最好见名知意\n```\n\n4. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开。例：getSum(int a,int b)\n\n5. 参数类型可以为任意类型，包含基本类型或引用类型。\n\n6. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数\n\n7. 方法定义时的参数成为形式参数（形参）；方法调用时的参数成为实际参数，简称实参。实参和形参的类型要一致或兼容、个数、顺序必须一致\n\n   * ```java\n     public static void main(){\n     \tMethod a = new Method();\n     \ta.input(123,345//这里成为实参);\n     }\n     \n     class Method{\n     \tpublic int input(int a,int b//这里成为形参){\n     \tsystem.out.print(\"xxx\");\n     \treturn xxx;\n     \t}\n     }\n     ```\n\n方法体\n\n​\t里面写完成功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义\n\n调用细节\n\n1. 同一类中的方法调用：直接调用即可\n\n   * 直接输入：方法名（参数）即可\n\n2. 跨类中的方法A类调用B类方法：需要通过对象名调用。比如：对象名.方法名(参数)\n\n\n## 成员方法传参（重要）\n\n基本数据类型\n\n1. ![image-20220310134944831](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310134944831.png)\n2. <span style = \"color:red\">基本数据类型</span>，传递的值（拷贝），形参的任何改变不影响实参！\n\n引用数据类型\n\n1. ![image-20220310140041330](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310140041330.png)\n2. 引用类型传递的是地址（传递也是值，但值是地址），可以通过形参影响实参。\n\n## 递归机制（recursion）\n\n递归调用的本质，是方法的调用\n\n1. ![image-20220310164428690](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310164428690.png)\n2. 栈是先进后出，先出后进（所以图中的test栈2先输出，然后是3，4）\n3. 每次这个栈内的方法执行完成后，外边的方法（图中test方法）都会执行一边\n4. 哪里调用就返回给哪里\n\n### 阶乘（factorial）\n\n![image-20220310203253490](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310203253490.png)\n\n###   递归调用的规则\n\n1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）\n2. 方法的局部变量是独立的，不会相互影响，比如n变量\n3. 如果方法中使用的是引用类型变量（比如数组，或者对象），就会共享该引用类型的数据。\n4. 递归必须像退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:)\n5. 当一个方法执行完毕，或者遇到return，就会执行完毕或者返回时，该方法也就执行\n\n### 斐波拉契数练习\n\n```java\npackage basics;\n\npublic class exerciseRecursion {\n    public static void main(String[] args) {\n        T t = new T();\n        int i = t.racursionNum(4);\n        System.out.println(i);\n\n    }\n\n}\n\nclass T{\n    public int racursionNum(int n1) {\n        if (n1 == 1 || n1 == 2) {\n            return 1;\n        } else {\n            return racursionNum(n1 - 1) + racursionNum(n1 - 2);\n        }\n    }\n}\n\n```\n\n解析图\n\n![image-20220310225335626](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310225335626.png)\n\n\n\n\n\n## 重载（overload）\n\n介绍：java允许同一个类中，多个同名方法的存在，但要求形参列表不一致！！！\n\n好处：\n\n1. 减轻了起名的麻烦\n2. 减轻了记名的麻烦\n\n注意细节：\n\n1. 方法名：必须相同\n2. 形参参列表：必须不同（参数类型或个数或顺序，至少有一样不同）\n3. 返回类型：无要求\n\n## 可变参数\n\n介绍：\n\njava允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法。\n\n基本语法：\n\n```java\n访问修饰符\t 返回类型\t方法名（数据类型 .... 参数名）{\n}\n```\n\n案例\n\n```java\nclass hasMestod{\n/*\n    public int sum(int a,int b){\n        return a+b;\n    }\n    public int sum(int a,int b,int c){\n        return a+b+c;\n    }\n    public int sum(int a,int b,int c,int d){\n        return a+b+c+d;\n    }\n//    ........以此类推\n*/\n\n//    可变参数优化\n//    上面三个方法名称相同，功能相同，只是参数个数不同---->使用可变参数优化\n//    1.int...表示接收的是可变参数，类型时int，即可以接收多个int（0-多）\n//    2.使用可变参数时，可以当做数组；来使用，即nums 可以当做数组使用\n    public  int sum1(int... nums){\n        System.out.println(\"接收的个数为\"+nums.length);\n        int sum = 0;\n        for (int i = 0; i < nums.length ; i++) {\n            sum=sum+nums[i];\n        }\n        return sum;\n    }\n\n}\n```\n\n注意事项：\n\n1. 可变参数的实参可以为0或任意多个\n\n2. 可变参数的实参可以为数组\n\n3. 可变参数的本质就是数组\n\n   \n\n4. 可变参数可以和普通类型的参数<u>*一起放在形参列表*</u>，但必须保证可变参数在最后\n\n5. 一个形参列表中只能出现一个可变参数\n\n\n\n## 作用域\n\n1. 在java中，主要的变量就是属性（成员变量）和局部变量\n2. 我们说的局部变量一般是指在成员方法中定义的变量\n3. 作用域的分类\n   1. 全局变量：也就是属性，作用域为整个整体\n   2. 局部变量：也就是除了属性以外的其他变量，作用域为定义它的代码块中\n4. 全局变量可以不赋值，直接使用，因为有默认值（也可指定值），局部变量必须赋值后，才能使用，因为没有默认值。    、   \n\n注意事项和细节\n\n1. 属性和局部变量可以重名，访问时遵循就近原则\n2. 在一个作用域中，比如在同一个成员方法中，两个局部变量，不能重\n3. 属性生命周期较长，伴随对象的创建而创建，伴随对象的死亡而死亡。局部变量，生命周期较短，伴随它的代码块的执行而创建，伴随代码块的结束而死亡\n4. 作用域范围不同：\n   1. 全集变量/属性：可以被本类使用，或其他类使用（通过对象调用）\n   2. 局部变量：智能在本类中对应的方法中使用\n5. 修饰符不同\n   1. 全局变量/属性可以加修饰符\n   2. 局部变量不可以加修饰符\n\n## 构造器(constructor)\n\n基本介绍：构造方法又称构造器(constructor)，是类的一种特殊方法，它的主要作用是完成对<span style = \"color:red\">新的对象初始化。</span>\n\n\n\n特点：\n\n1. 方法和类名相同\n2. 没有返回值\n3. 在创建对象时，系统会自动调用该类的构造器完成对对象的初始化\n\n\n\n需求案例：\n\n案例1:创建一个人类的对象，显示把一个对象创建好后，再给他的年龄姓名等属性赋值，如果现在我要求，在创建人类对象的时候，就直接指定这个对象的年龄和姓名。 此时可以使用构造器\n\n基本语法：\n\n```java\n[修饰符] 方法名(形参列){\n\n\t方法体;\n\n}\n```\n\n1. 构造器的修饰符可以默认，也可是public，protected，private\n2. 构造器没有返回值,也不能写void\n3. 方法名和类名必须一样\n4. 参数列表和成员方法一样的规则\n5. 构造器的调用<span style = \"color:red\">系统完成</span>\n\n\n\n细节：\n\n1. 一个类可以定义多个不同的构造器，即构造器的重载\n   * 比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄\n   * ![image-20220314163037454](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314163037454.png)\n2. 构造器是完成对象的初始化，并不是创建对象\n3. 如果程序员没有定义构造器，系统会自动生成一个默认的无参构造器(也叫默认构造方法),比如Person(){ }\n4. 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的午餐构造器，除非显示的定义一下，即自己再手写一边Person(){ }\n\n\n\n\n\n\n\n对象创建流程\n\n```java\nclass Person{\n\tint age =90;\n\tString name;\n\tPerson(String n , int a){\n\tname = n;\n\tage = a;\n\t}\n}\n\n\nPerson p = new Person(\"zhangsan\" , 20);\n```\n\n![image-20220314215432778](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png)\n\n```\n1. 先在方法区加载Person类\n2. 在堆中开辟一个空间，内部存放形参\n   1. 先初始化默认值，0和null，然后再将值赋进去\n   2. 当执行到构造器的时候，值才会赋进去\n   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值\n3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)\n```\n\n1. 加载Person.class，只会加载一次。\n\n2. 在堆中分配空间(地址)\n\n3. 完成对象初始化\n\n   3.1 默认初始化 age=0\tname = null\t\n\n   3.2 显示初始化 age=90,name=null,\n\n   3.3 构造器的初始化 age=20，name=zhangsan\n\n4. 在对象堆中的地址，返回给p(也可理解成对象的引用)\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n## this\n\n案例：\n\n```java\nclass Person{\n\tString name;\n\tint age;\n/*\n\t旧方法：\n\t\tint age =90;\n\t\tString name;\n\t\tPerson(String n , int a){ //此时形参的起名不能与属性名一致\n\t\tname = n;\n\t\tage = a;\n     1.如果可以将构造器的形参，直接写成属性名就好了\n     2.但是会出现一个问题，根据变量的作用域原则\n     3.构造器的name 是局部变量，而不是属性。相当于自己赋给自己\n     4.构造器的age 是局部变量，而不是属性、\n     5.==>此时使用this关键字\t\n*/\n    public Person(String name,int age){\n        this.name/*表示当前对象的属性*/ = name;/*表示当前构造器的局部变量*/\n        this.age = age;\n    }\n\t \n}\n```\n\n介绍：\n\njava虚拟机会给每个对象分配this，代表当前对象。\n\n分析图：\n\n每一个对象都有一个隐藏的属性this\n\n这个this它指向自己\n\n![image-20220314222909415](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314222909415.png)\n\n简单说，哪个对象调用this就指向哪个对象\n\n\n\n\n\n注意事项：\n\n1. this关键字可以用来访问本类的属性，方法，构造器\n\n2. this用于区分当前类的属性和局部变量\n\n3. 访问成员方法的语法：this.方法名(参数列表)；\n\n4. 访问构造器语法：this(参数列表);//注意，只能在构造器中访问另外一个构造器(当有访问构造器的语法this时，必须放在构造器语句里的第一行 )\n\n   * ```java\n     class T{\n         String name;\n         int age;\n     \t//无参构造器\n     \tpublic T(){\n             //当执行无参构造器时，我们想去访问有参构造器\n             this(\"zhangsan\",12);//这样访问有参构造器\n            //当有访问构造器的语法this时，必须放在构造器语句里的第一行 \n            \n     \t\tSystem.out.println(\"T() 构造器\");\n             \n             \n             \n     \t}\n     \t\n     \t//有参构造器\n     \tpublic T(String name,int age){\n             System.out.println(\"T(String name,int age) 构造器\");\n         }\n     }\n     ```\n\n5. this不能再类定义的外部使用，只能在类定义的范围中使用\n\n```java\npackage chapterObject;\n/*\n* 创建一个employee类\n* 属性有（名字，性别，年龄，职位，薪水）\n* 提供三个构造器\n* 1.名字，性别，年龄，职位，薪水\n* 2.名字，性别，年龄\n* 3.职位，薪水*/\npublic class ObjectHomeWork06 {\n}\nclass Employee{\n    String name;\n    char sex;\n    int age;\n    String post;\n    double salary;\n\n    public Employee(String name,char sex,int age){\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n    public Employee(String post,double salary){\n\n        this.post = post;\n        this.salary = salary;\n    }\n    public Employee(String name,char sex,int age,String post,double salary){\n        this(name, sex, age);\n//        因为构造器调用只能放在第一行，所以最多只能调用一个构造器\n        this.post = post;\n        this.salary = salary;\n    }\n\n//    public Employee(String name,char sex,int age,String post,double salary){\n//        this.name = name;\n//        this.sex = sex;\n//        this.age = age;\n//        this.post = post;\n//        this.salary = salary;\n//\n//    }\n}\n\n\n```\n\n\n\n# 面向对象（中级）\n\n## idea\n\n### 快捷键\n\n```\n自定义快捷键\nsettings - - > Keymap\n删除当前行 ctrl+y  自定义 alt+D\n复制当前行 ctrl+d\n\n快速格式化代码 ctrl + alt + L\n快速运行程序  自定义alt + R\n\n查看类的层级关系 ctrl + H\n将光标放在一个方法上，输入ctrl+b，可以定位到该方法的上\n自动分配变量名   在后面添加.var\n例：new Scanner(System.in).var+回车\n会生成Scanner scanner = new Scanner(System.in);\n```\n\n### 模板\n\n 设置路径\n\nfile -> settings -> editor -> live templates->\n\n可以自己自定义，也可查看预设的模板\n\n\n\n\n\n\n\n\n\n## 包\n\n三大作用：\n\n1. 区分相同名字的类\n2. 当类不同的时候，可以很好的管理\n3. 控制访问范围\n\n基本语法：\n\npackage com.xxx;\n\n1. package 关键字，表示打包\n2. com.xxx:表示包名\n\n包的本质\n\n就是创建不同的文件/目录保存文件\n\n\n\n### 包的命名\n\n规则：\n\n智能包含数字，字母，下划线，小圆点，但不能用数字开头，不能是关键字或保留字\n\n```java\ndemo.class.exec1 //falsee不允许有关键字class\ndemo.12\t\t//false,不能数字开头\ndemo.ad12.oa //true\n```\n\n规范\n\n一般是小写字母+小圆点\n\ncom.公司名.项目名.业务模块名\n\n例：com.alibaba.taobao.login\n\n```java\ncom.sina.crm.user\n等等\n```\n\n### java常用的包\n\n```java\njava.lang // lang包是基础包，默认引入，不用手动输入\n\njava.util //系统提供的工具包，工具类，例如Scanner类\n\njava.net // 网络包，网络开发\n\njava.awt  // 是做java的界面开发，GUI\n```\n\n\n\n包的引入\n\n建议需要什么类就引入什么类，不建议(java.util.* )全部引入\n\n\n\n\n\n\n\n## 访问修饰符\n\n介绍\n\njava提供了四种访问控制修饰符号控制方法和属性(成员变量)的访问权限(范围)\n\n1. 公开级别：public 修饰，对外公开\n2. 受保护级别：用protected修饰，对子类和统一包中的类公开\n3. 默认级别：没有修饰符号，向同一包的内公开\n4. 私有级别：用private修饰，只有类本身可以访问，不对外公开\n\n![image-20220317140746725](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220317140746725.png)\n\n注意事项：\n\n1. 修饰符可以用修饰类中的属性，成员方法以及类\n2. 只有默认的和public才能修饰类，并且遵循上述访问权限的特点\n3. 成员方法访问规则和属性完全一样\n\n\n\n\n\n\n\n\n\n\n\n\n\n## <u>*封装*</u>（重要）\n\n封装（encapsulation）就是把抽象出来的数据[**属性**]和对数据的操作[**方法**]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[**方法**]，才能对数据进行操作。\n\n**封装的好处**\n\n1. 隐藏实现细节  方法(连接数据库)<----调用(传入参数)\n2. 可对数据进行验证，保证安全合理\n\n\n\n封装的实现步骤 ( 三 步 ) \n\n1. 将属性进行私有化，private\n\n2. 提供一个公共的set方法，对属性进行判断并赋值\n\n   ```java\n   public void setXXX(类型\t参数名){\n   //加入数据验证的业务逻辑\n   属性 = 参数名；\n   }\n   ```\n\n3. 提供一个公共的get方法，用于获取属性的值\n\n   ```java\n   public void getXXX(类型\t参数名){\n   \treturn xx;\n   }\n   ```\n\n   \n\n\n\n## <u>*继承*</u>（重要）extends\n\n### 继承作用：\n\n解决代码复用性\n\n### 介绍：\n\n相当多个类存在相同的属性（变量）  和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些属性和方法，只需通过extend来声明继承父类即可\n\n###  基本语法\n\n```java\nclass 子类 extends 父类{\n\n}\n1. 子类会自动拥有父类定义的方法\n2. 父类又叫超类，基类\n3. 子类又叫派生类\n\n```\n\n示意图\n\n![image-20220318104942566](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318104942566.png)\n\n\n\n### 注意事项\n\n1. 子类继承了所有的属性和方法，但是私有属性不能再子类直接访问，需要通过公共方法访问\n\n2. 子类必须调用父类的构造器，完成父类的初始化\n\n3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中调用super去指定使用父类的那个构造器完成对父类的初始化工作，否则编译不通过\n\n4. 如果希望指定去调用父类的某个构造器，则显式的调用一下{super ( 参数 ) }\n\n5. super在使用时，需要放在第一行。super只能在构造器中使用\n\n6. super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器\n\n7. java所有类都是Object的子类，是所有类的基类   Ctrl+H可以看到类的继承关系\n\n   ![image-20220318165601997](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318165601997.png)\n\n8. 父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类)\n\n9. 子类对多只能继承一个父类(指直接传承)，即java中是单继承机制。\n\n10. 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系\n\n    1. person is a music\n    2. person music\n    3. music extends  person \n\n\n\n### 继承的本质（分析）\n\n当子类创建号对象以后，建立查找关系\n\n```java\n//案例：\nclass Grandpa{\n\tString name = \"爷爷\";\n\tString hobby = \"旅游\";\n}\n\nclass Father extends GrandPa{\n\tString name = \"大头爸爸\";\n\tint age = 30;\n}\n class Son extends Father{\n \tString name = \"儿子\";\n }\n \n \n Son son = new Son();\n son.name=?      //儿子\n son.age = ?\t //30\t\n son.hobby = ?\t // 旅游\n //\t\t1. 此时请注意，要按照查找关系返回信息\n /*     2. 首先看子类是否有该属性\n \t\t3. 如果子类有这个属性，并且可以访问，则返回信息\n \t\t4. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回)\n \t\t5. 如果父类没有4的规则，继续找上级，直到object\n   */  \n```\n\n### 内存原理图：\n\n ![image-20220320170828664](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320170828664.png)\n\n## Super\n\n### 基本介绍\n\nsuper代表父类的构造器，用于访问父类的属性，方法，构造器\n\n### 基本语法\n\n1. 访问父类的属性，但不能访问父类的private属性[案例]\n   * super.属性名；\n2. 访问父类的方法名，不能访问父类的private方法\n   * super.方法名(参数列表);\n3. 访问父类的构造器(这点前面用过);\n   * super(参数列表);\n   * 只能放在构造器的第一句并只能出现一句\n\n### 细节和注意事项\n\n1. 调用父类的构造器的好处（分工明确，弗雷属性由父类初始化，子类的属性由子类初始化）\n\n2. 当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果\n\n   * ```java\n     案例\n     class A{\n     \tpublic void cal(){\n     \t\tSystem.out.println(\"a类的cal方法\");\n     \t}\n     }\n     class B{\n     \tpublic void sum(){\n     \t\tSystem.out.println(\"b类的sum方法\");\n     \t/*\t\n     \t\t此时有三种方法调用cal\n     \t\t1. 找cal方法时，顺序是：先找本类，如果有，开始调用。\n     \t\t2. 如果没有。则找父类（如果有则调用）\n     \t\t3. 如果父类没有则继续找父类的父类。以此类推。直到Object类‘\n     \t\t\n     \t\t提示：如果查找的过程中找到了，但不能访问，则报错\n     \t\t\t 如果查找的过程中没找到。则提示没找到\n     \t*/\n         \tcal();\n             \n            \n             this.cal();//等价cal（）；\n             \n              /*\n             跳过本类直接查找父类\n             其他规则一样\n             */\n             super.cal();\n             \n     \t}\n     }\n     ```\n\n3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。（相当于跳过本类，从父类开始按规则找。父类找不到找爷爷类·····）\n\n### super和this的比较\n\n![image-20220320190806497](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190806497.png)\n\n![image-20220320190935663](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190935663.png)\n\n## 重写（overwrite）\n\n### 基本介绍\n\n简单地说：方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这方法覆盖了父类的方法。\n\n### 案例\n\n```java\nclass Animal{\n\tpublic void cry(){\n\t\tSystem.out.println(\"叫\");\n\t}\n}\n/*\n\t1. 因为dog是Animal的子类\n    2. Dog的cry方法和Animal的cry方法定义形式一样(名称，返回类型，参数)\n    3. 这时我们就说Dog的cry方法，重写了Animal的cry方法\n  */      \nclass dog extends Animal{\n\tpublic void cry(){\n\t\tSystem.out.println(\"汪汪汪\");\n\t}\n}\n```\n\n### 注意事项和使用细节\n\n1. 子类的方法的形参列表，方法名称，要和父类的方法的参数，方法名称完全一样。\n\n2. 子类方法的返回类型和父类方法返回类型一样，或者父类返回类型的子类\n\n   比如 父类返回类型是Object，子类方法返回类型是String\n\n   ```java\n   public Object getInfo(){}\n   ```\n\n   ```java\n   public String getInfo(){}\n   ```\n\n3. 子类方法不能缩小父类方法的访问权限public > protected > 默认(default ) > private \n\n   ```java\n   void sayOk(){}\n   ```\n\n   ```java\n   public void sayOk(){}//这样是可以的，但不能缩小\n   ```\n\n### 重写与重载的区别\n\n![image-20220320211941817](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320211941817.png)\n\n练习\n\n```java\npackage seatWork;\n\npublic class override {\n    /*\n    * 1. 编写一个Person类，包括属性/private（name,age），\n    * 构造器，方法say（返回组我介绍的字符串）\n    * 2. 编写一个student类，继承Person类，增加id，score属性/private，\n    * 以及构造器，定义say方法（返回自我介绍信息）\n    * 3. 在main方法中，分别创建Person和Student对象，调用say方法输出自我介绍*/\n\n    public static void main(String[] args) {\n        Person person = new Person(\"lisi\", 123);\n        String say1 = person.say();\n        System.out.println(say1);\n\n        Student student = new Student(\"zhangsan\",12,12345,100);\n        String say = student.say();\n        System.out.println(say);\n    }\n}\nclass Person{\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String say(){\n        System.out.println(\"我是父类\");\n//        System.out.println(\"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\");\n        return \"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\";\n    }\n}\n\nclass Student extends Person{\n    private int id;\n    private double score;\n\n    public Student(String name, int age, int id, double score) {\n        super(name, age);\n        this.id = id;\n        this.score = score;\n    }\n    public int getId() {\n        return id;\n    }\n    public void setId(int id) {\n        this.id = id;\n    }\n    public double getScore() {\n        return score;\n    }\n    public void setScore(double score) {\n        this.score = score;\n    }\n\n    public String say(){\n        return super.say()+\"id\"+getId()+\"\\t\"+\"score\"+getScore()+\"\\t\";\n//        System.out.println(\"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\"\n//        +\"id\"+getId()+\"\\t\"+\"score\"+getScore()+\"\\t\");\n    }\n}\n```\n\n## <u>*多态*</u>（重要）\n\n 多态可以提高代码的复用性\n\n### 基本介绍\n\n多态(多种)（状态）\n\n1. 方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础之上的额\n\n### 多态的具体体现\n\n#### 方法上体现\n\n1. 方法的多态\n\n   重写和重载就体现多态\n\n2. 案例说明\n\n3. 重载上体现\n\n   1. 对某一方法，传入不同的参数，调用不同的方法\n   2. ![image-20220320215939959](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320215939959.png)\n\n\n\n\n\n### 对象的多态（核心，难点，重点）\n\n要记住几点：\n\n1. 一个对象的编译类型和运行类型可以不一致\n\n   * ```\n     例如：\n     Animal animal = new Dog();【animal编译类型时Animal，运行类型是Dog】\n     animal  = new Cat(); \t【animal的运行类型变成了Cat，编译类型仍然是Animal】\n     ```\n\n2. 编译类型在定义对象时，就确定了，不能改变\n\n   * ```\n     Animal animal = new Dog()   编译类型在定以后就不能改变，所以可以直接用引用接收其他的运行类型\n     animal  = new Cat();\n     animal  = new PIG();`````\n     ```\n\n3. 运行类型是可以变化的\n\n4. 编译类型看定义时 = 号的左边，运行类型看 = 号的右边\n\n   * ```\n     Animal animal = new Dog()  animal就是变异类型，dog就是运行类型\n     ```\n\n```java\n//编译类型和运行类型的体现\nclass Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"动物在叫\");\n\t}\n}\nclass Cat extends Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"猫在叫\");\n\t}\n}\n\nclass Dog extends Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"狗在叫\");\n\t}\n}\n\nclass test{\n\tpublic static void main(String[] args){\n\t\t//animal编译类型就是Animal，运行类型Dog\n\t\tAnimal animal = new Dog();\n\t\tanimal.say();//因为运行类型是dog，animal的运行类型是dog，所以输出dog类的say方法。\n\t\t\n        animal = new Cat();\n        animal.say();//此时animal的运行类型是cat，所以输出cat类的say方法；\n    }\n}\n```\n\n\n\n### 注意事项和细节\n\n多态的前提是：两个对象(类)存在继承关系\n\n#### 多态的向上转型\n\n1. 本质：父类的引用指向了子类的对象\n\n2. 语法：父类类型    引用名 = new    子类类型()；\n\n   ```java\n   Father father = new Son();\n   //此时可称为向上转型\n   ```\n\n3. 特点：编译类型看左边，运行类型看右边\n\n   <span style=\"color:red;\">可以调用父类中的所有成员(需要遵循访问权限),</span>\n\n   <span style=\"color:red;\">不能调用子类中特有成员</span>\n\n   （<span style=\"color:red;\">因为在编译阶段，不能调用那些成员，是由编译类型来决定的。</span>）\n\n   最终运行效果按子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法\n\n   然后调用，与前面的方法调用规则一致\n\n#### 多态的向下转型\n\n语法：子类类型   引用名 = (子类类型) 父类引用;\n\n1. 只能强转父类的引用，不能强转父类的对象\n\n   ```java\n   //此时的向上转型\n   Animal animal = new Cat();\n   adimal.a();\n   //等等方法，这些方法只能调用父类子类的共同拥有的方法，不能调用子类的特殊方法\n   \n   //此时这样写\n   //强转一下，上述父类的引用\n   Cat cat =  (Cat)animal；\n       cat.catchMouse();\n   ```\n\n   \n\n2. 要求父类的引用必须指向的是当前目标类型的对象\n\n   ```java\n   //也就是说animal必须是指向对应的子类\n   Animal animal = new Cat();//必须有这句话\n   Cat cat =  (Cat)animal；//才能强转成cat类型\n   \n   ```\n\n   \n\n3. 可以调用子类类型中所有的成员\n\n\n\n#### 属性没有重写之说\n\n属性的值看编译类型\n\n```java\n例:\nclass A{\n\tint count = 1;\n}\nclass B extends A{\n\tint count = 2;\n}\n\npublic class test{\n\tpublic static void main(String[] atgs){\n\t\tA a = new B();\n\t\tpublic.out.print(a.count);\n            \n        //此时输入的值为1\n        //因为属性的值是看编译类型\n            \n        B b = new B();\n        public.out.print(a.count);\n        //此时输出2\n\t}\n}\n```\n\n\n\n#### instanceOf比较操作符，\n\n用于判断对象的类型是否为xx类型或xx类型的子类型\n\n判断对象的运行类型是否为xx类型，或这个xx类型的子类型\n\n```java\nclass A{\n\tint count = 1;\n}\nclass B extends A{\n\t count = 2;\n}\npublic class test{\n\tpublic static void main(String[] atgs){\n\tBB bb = new BB();\n\tpublic.out.print(bb instanceof BB);//true\n\tpublic.out.print(bb instanceof AA);//true\n       \n        \n        //编译类型AA ，运行类型BB\n     AA aa = new AA();\n        public.out.print(aa instanceof AA);//true\n       public.out.print(aa instanceof BB);//true \n        \t\n     Object obj   = new Object();\n        public.out.print(obj instanceof AA);//false,因为obj不是AA类，也不是AA的子类\n        \n}}\t\n```\n\n#### java动态绑定机制(重要) \n\n1. 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定\n2. 当调用对象属性时，没有动态绑定机制，哪里声明，那里使用\n\n```java\nclass A{\n\tpublic int i =10;\n\t//2\n\tpublic int sum(){\n        //3  \n\t\treturn geti()+10;//5\n\t}\n\t\n\tpublic int sum1(){\n\treturn i+10;\n\t}\n\tpublic int geti(){\n\treturn i;\n\t}\n}\n\nclass B{\n\tpublic int i =10;\n\t\n\tpublic int sum1(){\n\treturn i+10;\n\t}\n    //4\n\tpublic int geti(){\n\treturn i;\n\t}\n}\n\n\nA a  = new B()\n   //1\na.sum //40\n    \n   \n//因为执行到sum方法，开始准备执行geti方法时，因为有java动态绑定的机制，会跳到b类的geti方法执行\n    //再根据继承跳回去\n```\n\n\n\n####  多态的应用\n\n1）多态数组\n\n数组的定义类型为父类类型，里面保存的实际元素类型为子类型\n\n```java\npackage seatWork;\nimport java.security.PrivateKey;\n\npublic class polySeatwork {\n    public static void main(String[] args) {\n        /*\n        * 要求创建一个person对象name ，age\n        * 两个student 对象和2个teacher对象，统一放在数组中，\n        * 并调用每个对象的say方法\n        * */\n        Person1[] person1s = new Person1[5];\n        person1s[0] = new Person1(\"human\",00);\n        person1s[1] = new Student1(\"tom1\",12,150);\n        person1s[2] = new Student1(\"tom2\",13,143);\n        person1s[3] = new teacher(\"zhangsan\",30,4000);\n        person1s[4] = new teacher(\"lisi\",28,5000);\n\n        //循环遍历多态数组，调用say方法\n        for (int i = 0; i < person1s.length ; i++) {\n            //老韩提示， person1s[i]的编译类型是Person，\n            // 运行类型是根据实际情况而变化\n            System.out.println(person1s[i].say());\n        }\n    }\n}\nclass Person1{\n    private String name;\n    private int age;\n\n    public Person1(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String say(){\n        return \"name = \"+name+\"age = \"+age;\n    }\n}\n\nclass Student1 extends Person1{\n\n    private double score;\n\n    public Student1(String name, int age, double score) {\n        super(name, age);\n        this.score = score;\n    }\n    public double getScore() {\n        return score;\n    }\n    public void setScore(double score) {\n        this.score = score;\n    }\n\n    @Override\n    public String say() {\n        return super.say()+\"score = \"+score;\n    }\n    public void study(){\n        System.out.println(getName()+\"学习······\");\n    }\n}\n\nclass teacher extends Person1{\n    private double salary;\n\n    public teacher(String name, int age, double salary) {\n        super(name, age);\n        this.salary = salary;\n    }\n    public double getSalary() {\n        return salary;\n    }\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n\n    @Override\n    public String say() {\n        return super.say()+\"salary = \"+salary;\n    }\n    public void teach(){\n        System.out.println(getName()+\"教书·············\");\n    }\n}\n```\n\n案例升级：如何调用子类的特有方法，比如Teacher 有一个teach，Student有一个study方法。如何调用?\n\n```java\n//循环遍历多态数组，调用say方法\n        for (int i = 0; i < person1s.length ; i++) {\n            //老韩提示， person1s[i]的编译类型是Person，\n            // 运行类型是根据实际情况而变化\n\n            //判断person1s[i]的运行类型\n            if ( person1s[i] instanceof Student1){\n               Student1 student1 =  (Student1)person1s[i];\n               student1.say();\n               //也可以写成一条语句\n               ((Student1)person1s[i]).study();\n            }else if (person1s[i] instanceof teacher){\n                ((teacher)person1s[i]).teach();\n            }else{\n                System.out.println(\"============类型有误==============\");\n            }\n            System.out.println(person1s[i].say());\n        }\n```\n\n#### 多态参数\n\n方法定义的形参类型为父类型，实参类型允许为子类类型\n\n* polyParameter.java\n\n* ```java\n  package seatWork;\n  \n  public class polyParameter {\n      /*\n      * 定义员工类Employee，包含姓名和月工资[private]，以及计算年工资getAnnual的方法。\n      * 普通员工和经理继承了员工，经理类多了奖金bonus属性和管理manage方法，\n      * 普通员工类多了work方法，普通员工和经理类要求分别重写getAnnual方法\n      *\n      *\n      * 测试类中添加一个方法showEmployAnnual（Employee e ),\n      * 实现获取任何员工对象的年工资，\n      * 并在main方法中调用该方法[e.getAnnual()]\n      *\n      * 测试类中添加一个方法，testWork，如果是普通员工，\n      * 则调用work方法，如果是经理，则调用manage方法\n  */\n      public static void main(String[] args) {\n          GeneralStaff staff = new GeneralStaff(\"zhangsan\", 5000);\n          Manager manager = new Manager(\"lisi\", 5000, 10000);\n          polyParameter polyParameter = new polyParameter();\n          polyParameter.showEmployAnnual(staff);\n          polyParameter.showEmployAnnual(manager);\n  \n          polyParameter.testWork(staff);\n          polyParameter.testWork(manager);\n  \n      }\n      public void showEmployAnnual(Emplyee e){\n  \n          System.out.println(e.getAnnual());\n      }\n      /*\n      * 添加一个方法，testwork\n      * 如果是普通员工，则调用work方法\n      * 如果是经理则调用manage方法\n      * */\n      public void testWork(Emplyee e){\n          if (e instanceof GeneralStaff){\n              ((GeneralStaff) e).work();//向下转型\n          }else if (e instanceof Manager){\n              ((Manager) e).manage();//向下转型\n          }\n      }\n  \n  \n  }\n  class Emplyee {\n      private String name;\n      private double salary;\n  \n      public Emplyee(String name, double salary) {\n          this.name = name;\n          this.salary = salary;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public double getSalary() {\n          return salary;\n      }\n  \n      public void setSalary(double salary) {\n          this.salary = salary;\n      }\n  \n      public double getAnnual(){\n          double tmp = 12*salary;\n  \n          return tmp;\n      }\n  }\n  \n  class GeneralStaff extends Emplyee{\n  \n      public GeneralStaff(String name, double salary) {\n          super(name, salary);\n      }\n  \n      @Override\n      public double getAnnual() {\n          return super.getAnnual();\n      }\n  \n      public void work(){\n          System.out.println(\"work method\");\n      }\n  }\n  class Manager extends Emplyee{\n      private double bonus;\n  \n      public Manager(String name, double salary,double bonus) {\n          super(name, salary);\n          this.bonus = bonus;\n      }\n  \n      public void manage(){\n          System.out.println(\"manage method\");\n      }\n  \n      @Override\n      public double getAnnual() {\n          return super.getAnnual()+bonus;\n      }\n  }\n  \n  ```\n\n\n## Obeject类详解\n\n类Object是类的层次结构的根类，每个类都使用Object作为超类，所有对象(包括数组)都实现了这个类的方法\n\n#### equals\n\n==和equals的对比\n\n==是一个比较运算符\n\n1. 既可以判断基本类型，又可以判断引用类型\n2. 如果判断基本类型，判断值是否相等。例如：int i = 10; double b = 10.0;\n3. 如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象\n\n\n\n \n\nequals：是Object类中的方法，只能判断引用类型，\n\n判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等\n\n案例：\n\n```java\npackage seatWork;\n\npublic class equalsExercise {\n    public static void main(String[] args) {\n        Person02 person02 = new Person02(\"zhangsan\", 123, '男');\n        Person02 person03 = new Person02(\"zhangsan\", 123, '男');\n        //在没有重写equals方法时是不相等，此时的方法时比对是否指向同一对象\n        System.out.println(person02.equals(person03));\n    }\n}\nclass Person02{\n//    判断两个Person是否相等\n    private String name;\n    private int age;\n    private char gender;\n\n    public Person02(String name, int age, char gender) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public char getGender() {\n        return gender;\n    }\n\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    public boolean equals(Object obj) {\n//        1. 先判断两个是否指向同一对象\n        if (this == obj){\n            return true;\n        }\n//        2.进行类型判断\n        if (obj instanceof Person02) {\n//            3.向下转型，得到所有的属性信息进行比对\n            Person02 person02 = (Person02) obj;\n            return this.name.equals(person02.name)&&this.age== person02.age&&this.gender==person02.gender;\n        }\n//        如果不是Person类型，则直接返回false\n        return false;\n    }\n\n}\n\n```\n\n#### hashCode\n\n介绍：\n\n返回对象的哈希码值，支持此方法是为了提高哈希表的性能\n\n实际上，由object类定义的hashCode方法确定会针对不同的对象返回不同的证书，(这一般是通过将该对象的内部地址转移换成一个整数来实现的，但是java编程语言不需要这种实现技巧)\n\n老韩六小结：\n\n1. 提高具有哈希结构容器的效率\n\n2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的\n\n3. 两个引用，如果指向的是不同的对象，则哈希值是不一样的（极大概率不一样）\n\n4. 哈希值主要根据地址号来的！，不能完全将哈希值等价于地址\n\n5. 案例演示obj.hashCode() [测试 A obj1 = new A(); A obj2 = new A(); A obj3 = obj1]\n\n   ```java\n   package seatWork;\n   \n   public class hashCodeExcise {\n       public static void main(String[] args) {\n           A a = new A();\n           A a1 = new A();\n           A a3 = a;\n           System.out.println(\"a.hashCode() = \"+a.hashCode());       System.out.println(\"a1.hashCode() = \"+a1.hashCode());       System.out.println(\"a3.hashCode() = \"+a3.hashCode());\n       }\n   }\n   class A{\n   }\n   \n   ```\n\n   ![image-20220323164744164](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220323164744164.png)\n\n6. 后面在集合，中hashCode如果需要的话，也会重写\n\n#### toString\n\n介绍：\n\n默认返回：全类名+@+哈希值的十六进制，[查看object的tostring方法]\n\n子类往往会重写toString方法，用于<span style=\"color:red;background:yellow\">返回对象的属性信息</span>\n\n重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。\n\n\n\n当直接输出一个对象时，toString方法会被默认的调用\n\n```\nSystem.out.print(xxx);\n等价于System.out.print(xxx.toString);\n```\n\n\n\n#### finalize()\n\n介绍：\n\n当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法\n\n1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作\n2. 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制销毁该对象，在销毁该对象前，会先调用finalize方法\n3. 垃圾回收机制的调用，是由系统来决定的(即有自己的GC算法 )，也可以通过System.gc()主动触犯垃圾回收机制\n\n## 断点调试（debug）\n\n#### 提示：\n\n在断点调试的过程中，是运行状态，是以对象运行类型来执行的\n\n#### 介绍：\n\n​\t断点调试是指程序在的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步一步往下调，调试过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug。\n\n#### 快捷键\n\n* F7（跳入）\n  * 跳入方法内\n* F8（跳过）\n  * 逐行执行代码\n* shift+F8（跳出）\n  * 跳出方法\n* F9（resume，执行到下一个断点）\n\n![image-20220324141333874](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220324141333874.png)\n\n# 面向对象（高级）\n\n## 类变量和类方法\n\n### 一、类变量\n\n案例理解：\n\n```java\npublic Child{\nprivate String name;\n\n    \n//定义一个变量count，是一个类变量（静态变量）static静态\n    //该变量最大的特点就是会被Child类的所有的对象实例共享\npublic static int count = 0;\n\npublic Child （String name）{\n     this.name = name;\n}\n    public void join(){\n        System.out.println(name+\"加入了游戏····\")\n    }\n}\n\n\n\nmain(){\n    //定义一个变量count，统计多少小孩加入了游戏\n    //传统方法，定义一个count然后统计\n    //int count  = 0;\n    \n    Child child0 = new Child(\"xiaoming\")；\n        child0.join();\n    \t//count++;\n    \n    //改进后\n    \tchild0.count++;\n    \n    Child child1 = new Child(\"xiaoming\")；\n        child1.join();\n    \tchild1.count++;\n    \n    Child child2 = new Child(\"xiaoming\")；\n        child2.join();\n    \tchild2.count++;\n    \n    //类变量可以通过类名来访问\n    System.out.println(\"共有\"+child.count+\"小孩加入了游戏\")\n}\n```\n\nstatic变量会开辟一个独立的空间，所以new的对象空间不会再单独创建一个static变量的空间。所以这个static变量空间对于这个类的所有实例是共享的\n\n#### 内存分析\n\n![image-20220402161426676](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220402161426676.png)\n\n1. static变量是对象共享的\n2. 不管static变量在哪\n   1. static变量是同一个类，所有对象共享\n   2. static类变量，在类加载的时候就生成了\n\n#### 定义语法\n\n访问修饰符\tstatic\t数据类型\t变量名；【推荐】\n\nstatic\t访问修饰符\t数据类型\t变量名；\n\n#### 类变量访问\n\n类名.类变量名【推荐】\n\n或者\t\n\n对象名.类变量名 [静态变量的访问修饰符的访问权限和范围和普通属性是一样的]\n\n推荐使用第一种\n\n\n\n#### 使用细节\n\n1. 什么时候使用类变量？\n   * 当我们需要让某个类的所有对象都共享一个变量时，就可以使用类变量（静态变量）：比如上述的统计人数的案例\n2. 类变量与实际变量的区别\n   * 变量是该类的所有对象共享的\n   * 实例变量是每个对象独享的\n3. 加上static成为类变量或静态变量，否则称为实例变量/普通变量/非静态变量\n4. 类变量可以通过<span style=\"color:red\">类名.类变量名</span>或者<span style=\"color:red\">对象名.类变量名</span>来访问。推荐第一种方式访问（前提是得满足访问权限）\n5. 实例变量不能通过<span style=\"color:red\">类名.类变量名</span>方式访问\n6. 类变量是在类加载时就初始化了，也就是说，及时没有创建对象，只要加载类了，就可使用类变量了\n7. 类变量的声明周期是随类的加载开始，随着类的消亡而销毁\n\n### 二、类方法\n\n#### 介绍\n\n类方法也称静态方法\n\n### 格式\n\n````java\n访问修饰符\tstatic\t数据源返回类型\t方法名(){}\t【推荐】\nstatic\t访问修饰符\t数据返回类型\t方法名(){}\n````\n\n\n\n#### 类方法调用\n\n使用方式：\n\n<span style=\"color:red\">类名.类方法名</span>\n\n或\n\n<span style=\"color:red\">对象名.类方法名</span>\n\n#### 使用场景\n\n当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。\n\n比如：工具类中的方法utils\n\nMath类、Arrays类、Collections集合类\n\n#### 使用细节\n\n1. 类方法和普通方法都是随着类的加载而加载，将结构信息储存在方法区：\n   * 类方法中无this的参数\n   * 普通方法中隐含this参数\n2. 类方法可以通过类名调用，也可以通过对象名调用\n3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用\n4. 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以\n5. 类方法(静态方法)中，只能访问 静态变量和静态方法\n6. 普通成员方法，既可以访问静态的成员，非静态的方法。可以访问静态成员和非静态成员\n\n#### 总结：\n\n静态方法，只能访问静态的成员，\n\n非静态方法，可以访问静态的 成员和非静态的成员\n\n（前提是必须遵守访问权限规则）\n\n## 理解main方法语法\n\n#### 深入理解main方法\n\n解释main方法的形式：public static void main(String[] args){}\n\nmain方法是java虚拟机调用的\n\n1. java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public\n\n2. java虚拟机在执行main()方法是不必创建对象，所有该方法必须是static\n\n3. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数\n\n4. java执行的程序 参数1 参数2  参数3\n\n   ![image-20220403184106869](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220403184106869.png)\n\n#### 提示\n\n1. 在main（）方法中我们可以直接调用main方法所在类的静态方法或静态属性\n\n2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，再能通过这个对象去访问类中的非静态成员\n\n3. 例：\n\n   * ```java\n     class A{\n     \tprivate int a;\n     \tprivate static int b;\n     \t\n     \tprivate void a(){\n     \t\tSystem.out.println(\"非静态方法a\");\n     \t}\n     \tprivate static void b(){\n     \t\tSystem.out.println(\"静态方法a\");\n     \t}\n     \t\n     \t\n     \t\n     \tpublic static void main(String[] args){\n     \t\tSystem.out.println(\"id = \" +a);//错误 a是非静态变量，得实例一个对象才能调用\n             System.out.println(\"id = \" +new A().a);//这样是正确的，创建了个匿名对象调用\n             System.out.println(\"id = \" +b);//正确， 因为b是静态变量，可以直接调用\n             System.out.println(\"id = \" +a());//错误，和上述a的非静态变量的原因相同\n             System.out.println(\"id = \" +new A().a());//改成这样就是正确的，因为a()是非静态的方法\n             \n             A a = new A();\n             System.out.println(\"id = \" +a.a());//同理\n     \t}\n     }\n     ```\n\n   * \n\n\n\n## 代码块\n\n#### 介绍\n\n代码块又称初始化块，属于类中的成员【即 是类的一部分】。类似于方法，将罗技语句封装在方法体中，通过{}包围起来\n\n和方法不同，没有方法名，没有返回，没有参数，只有方法体。而且不用通过对象或类显式调用，而是在家类是，或创建对象时隐式调用。\n\n#### 基本语法\n\n```java\n[修饰符]{\n\t代码\n};\n```\n\n#### 注意：\n\n1. 修饰符 可选，要写的话，也只能写static\n2. 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块\n3. 逻辑语句可以为任何罗技语句（输入，输出，方法调用，循环，判断等）\n4. ; 号可以写上，也可以省略。\n\n#### 优点\n\n1. 相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作\n2. 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性\n\n#### 案例\n\n```java\nclass Movie{\n\tprivate String name;\n\tprivate double price;\n\tpricate String director;\n    /*\n    使用场景\n    1. 下面三个构造器都有相同的语句\n    2. 这样重写大量的代码\n    3. 可以吧相同语句提取出来，放到一个代码块中\n    4. 我们不管调用哪个构造器，创建对象，都会先执行代码块\n    5. 代码块调用的顺序都是优先于构造器\n    \n    */\n\t\n\t{\n\t\tSystem.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n\t\n\t}\n    \n    public Movie(String name){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n    }\n    public Movie(String name,double price){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n        this.price = price;\n    }\n    public Movie(String name,double price,String director){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n        this.price = price;\n        this.director = director;\n    }\n}\n```\n\n#### 使用细节\n\n1. static代码块也叫静态代码块，作用就是对类进行初始化，\n\n   而且它随着类的加载而执行\n\n   并且只会执行一次。\n\n   如果是普通代码块，每创建一个对象，就执行\n\n   ```java\n   //静态代码块\n   static{\n   \txxxx;\n   }\n   \n   //普通代码块\n   {\n   \txxxx;\n   }\n   ```\n\n2. 类什么时候被加载？[重要]\n\n   1. 创建对象实例时（new xxx)\n   2. 创建子类对象实例，父类也会被加载\n      1. 先在家父类的代码块，再执行子类的\n   3. 使用类的静态成员时（静态属性，静态方法）\n\n   案例：A类 extends B类的静态块\n\n   ​\t\t\t先执行a的静态块，然后再执行b的\n\n   ![image-20220404151232983](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220404151232983.png)\n\n3. 普通代码块，在创建对象实例时，会被隐式调用。\n\n   被创建一次，就会调用一次\n\n   如果只是使用类的静态成员时，普通代码块并不会执行\n\n   \n\n4. 创建一个对象时，在一个类 调用顺序是（重点，难点）\n\n   1. 调用静态代码块和静态属性初始化\n\n      （注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用\n\n      ```java\n      案例理解\n          \n          因为static的优先级一样，\n          所以哪个写在前面，哪个就先执行\n      class A{\n          \n          private static  int n1 = getn1();\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n      }\n      \n      ============================================\n      输出结果：\n      ============================================\n      use getn1\n      A's static codeBlock\n          \n          \n      =========================分割线=========================\n      //如果更换顺序\n      class A{\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          \n          private static  int n1 = getn1();\n          \n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n      }   \n      ============================================\n      输出结果：\n      ============================================\n       A's static codeBlock\n      use getn1\n         \n      ```\n\n      \n\n   2. 调用普通代码块和普通属性的初始化\n\n      （注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义的顺序调用） \n\n      ```java\n      //先执行静态的，和上述的一样，\n      //然后再执行非静态的，规则也是和上述一样，谁写前面先执行谁\n      class A{\n          private int b = getn2();\n      \n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }\n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      getn2 被调用\n      普通代码块被执行\n          \n          \n      =========================分割线=========================\n      class A{\n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          private int b = getn2();\n      \n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }    \n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      普通代码块被执行\n      getn2 被调用\n      ```\n\n        \n\n   3. 调用构造器\n\n      构造器优先级最低，上述的两个规则执行完成后\n      才会执行构造器\n\n      ```java\n      class A{\n          public A() {\n              System.out.println(\"构造器被执行\");\n          }\n      \n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          private int b = getn2();\n      \n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }\n      \n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      普通代码块被执行\n      getn2 被调用\n      构造器被执行\n      \n      ```\n\n5. 构造器 的最前面其实隐含了super() 和调用普通代码块\n\n   静态相关的代码块，属性初始化，在类加载时，就执行完毕。因此是优先于 构造器和普通代码块执行的\n\n   演示：\n\n   ```java\n   class A{\n   \tpublic A(){\n   \t\t//这里存在隐藏的调用\n   \t\t\t//(1) super();\n   \t\t\t//(2) 调用普通代码块\n   \t\t\t\n   \t\t System.out.println(\"xxxx\");\t\n   \t}\n   }\n   ```\n\n   ```java\n   class AAA{\n       public AAA() {\n           //这里存在隐藏的调用\n           //(1) super();\n           //(2) 调用普通代码块\n           //因为Object的代码块没有输出\n           \n           //1.先输出\n           System.out.println(\"AAA的构造器被调用\");\n       }\n   }\n   class BBB extends AAA{\n       {\n   //        根据规则父类的输出完毕后，再调用方法区\n   //        2. 再执行普通代码块\n           System.out.println(\"bbb的普通代码块执行\");\n       }\n   \n       public BBB() {\n           //这里存在隐藏的调用\n           //(1) super();\n           //(2) 调用普通代码块\n   //        等上述执行完毕后，最后执行该语句\n           System.out.println(\"BBB的无参构造被执行\");\n       }\n   }\n   ```\n\n6. 创建一个子类对象时(继承关系),他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：\n\n   1. 父类的静态代码块和静态属性（优先级一样，按定义的顺序执行）\n   2. 子类的静态代码块和静态属性（优先级一样，按定义的顺序执行）\n   3. 父类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）\n   4. 父类的构造器\n   5. 子类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）\n   6. 子类的构造器\n\n7. 静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任何成员\n\n\n\n## 单例设计模式\n\n#### 介绍\n\n1. 所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且只提供一个取得对象实例的方法\n2. 单例模式有两种方式：1）饿汉式 2）懒汉式\n   1. 二者最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例,而懒汉式在使用时才创建\n   2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题\n   3. 饿汉式存在浪费资源的可能。（因为如果程序员一个对象实例都没使用，那么饿汉式创建的对象就是浪费了，懒汉式是使用时才创建，就不存在这个问题\n   4. 在javaSE标准类中，java.lang.Runtim就是经典的单例设计模式\n\n演示：\n\n1. 恶汉式\n\n   类加载的时候，对象就被创建实例对象，可能会出现创建了，但是没有使用\n\n   步骤：\n\n   1. 构造器私有化 => 防止直接new\n\n   2. 类的内部创建对象\n\n   3. 向外露出一个静态的公共方法。\n\n   4. 代码实现\n\n   5. ```java\n      public class singleDesign {\n          public static void main(String[] args) {\n              System.out.println(GirlFriend.info());\n          }\n      \n      }\n      //有一个女朋友类\n      //只能有一个女朋友\n      class GirlFriend{\n          private String name;\n      \n      \n      //    2.创建一个对象\n      //    3.为了能够接收静态方法，需要修饰为static\n          private static GirlFriend girl = new GirlFriend(info());\n      \n      \n      \n      //    如何保证只能有一个对象实例\n      //    public girlFriend(String name) {\n      //        this.name = name;\n      //    }\n      //    1. 改成私有的构造器\n          private GirlFriend(String name) {\n              this.name = name;\n          }\n      //    4.创建一个静态方法，用于接收实例对象\n          public static String info(){\n              return \"g\";\n          }\n      \n      ```\n\n2. 懒汉式\n\n   使用时才创建实例\n\n   1. 构造器私有化=> 防止直接new\n\n   2. 类的内部创建对象\n\n   3. 向外暴露一个静态的公共方法\n\n   4. ```java\n      public class SingleDesign01 {\n          public static void main(String[] args) {\n              System.out.println(Cat.i);\n      //        此时只是初始化了cat ，但没有创建对象，其他的静态参数可以直接调用\n              System.out.println(Cat.getCat());\n      //        当只有调用了这个方法时，才会创建对象(通过判断发现没有cat类，此时创建后返回)\n          }\n      }\n      //懒汉式\n      //希望在程序运行中，只创建一个cat\n      \n      class Cat{\n          private String name;\n          public static int i =1;\n      //    2.定义一个静态属性static\n          private  static Cat cat;\n      \n      //    3.提供一个公共的static方法 可以返回一个Cat对象\n          public  static  Cat getCat(){\n              if (cat == null){ //如果还没创建对象\n                  cat = new Cat(\"little cute\");\n              }\n              return cat;\n          }\n      \n      //    1.创建私有构造器\n          private Cat(String name){\n              this.name = name;\n          }\n      }\n      ```\n\n      \n\n## final关键字\n\n#### 介绍\n\nfinal / 最后的，最终的\n\nfianl 可以修饰类、属性、方法和局部变量\n\n某些情况下，程序员可能有以下需求，就会使用到final：\n\n1. 当不希望类被继承时，可以用final修饰\n2. 当不希望父类的某个方法可以被子类覆盖/重写（override）时，可以用final关键字修饰\n3. 当不希望类的某个属性的值被修改，可以使用final修饰\n4. 当不希望某个局部变量被修改，可以使用final修饰\n\n\n\n#### 使用细节\n\n1. final修饰的属性又叫常量，一般用XX_XX_XX来命名\n\n2. final修饰的属性在定义时，必须赋初始值，并且以后都不能修改，赋值可以在如下位置之一（选择一个位置赋初始值即可）\n\n   1. 定义时：例如  public final double TAX_PATE=0.09;\n\n   2. 在构造器中\n\n   3. 在代码块中\n\n   4. ```java\n      class A{\n      //定义时赋值\n      \tpublic final double ATX_A = 0.9;\n      \t//在构造器中赋值\n      \tpublic final double ATX_B；\n      \tpublic A{\n      \t\tATX_B=0.8；\n      \t}\n      \t//在代码块中赋值\n      \tpublic final double ATX_C；\n      \t{\n      \t\tATX_C=0.2；\n      \t}\n      }\n      ```\n\n3. 如果final修饰的属性是静态的，则初始化的位置只能是\n\n   1. 定义时\n   2. 在静态代码块 \n   3. 不能再构造器中赋值\n\n4. final类不能被继承，但是可以实例化对象\n\n5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承\n\n6. 一般来说，如果一个类已经是final类，就没有必要再将方法修饰成final方法。\n\n7. final不能修饰构造方法（即构造器）\n\n8. final和static 往往搭配使用，效率更高，不会导致类的加载。底层编译器做了优化处理\n\n9. 包装类(integer,Double,Float,Boolean等等都是final),String 也是final类\n\n\n\n## 抽象类\n\n```java\n编写一个父类\n//class Animal{\nabstract Animal{\n\tString name;\n\tpublic Animal(String name){\n\t this.name = name;\n\t}\n\t/*\n\t这里的eat方法 实现了，没有什么意义\n\t即父类中的方法不确定性的问题\n\t\n\t1.考虑将该方法设计为抽象(abstract)方法\n\t2.所谓抽象方法就是没有实现的方法\n\t3.所谓的没有实现就是没有方法体\n\t4.当一个类存在抽象方法时，就需要将该类声明为abstract类\n\t\n\t一般来说，抽象类会被继承，有其子类来实现抽象方法\n\t*/\n    \n\t//public void eat(){\n\t//\tSystem.out.println(\"这个是一个吃方法，但不知道吃啥\");\n\t//}\n    \n\tpublic abstract void eat();\n}\n```\n\n\n\n#### 介绍\n\n1. 用abstract 关键字修饰的类时，这个类就是抽象类\n\n   1. ```java\n      访问修饰符 abstract 类名{\n      }\n      ```\n\n2. 用abstract 关键字来修饰一个方法时，这个方法就是抽象方法\n\n   1. ```java\n      访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体\n      ```\n\n3. 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()\n\n#### 细节\n\n1. 抽象类不能被实例化\n2. 抽象类不一定包含abstract方法。也就是说，抽象类可以没有abstract方法\n3. 一旦包含了abstract方法，则这个类必须声明为abstract \n4. abstract 只能修饰类和方法，不能修饰属性和其他的\n5. 抽象类可以有任意成员【抽象类的本质还是类】，比如：非抽象方法、构造器、静态属性等等\n6. 抽象方法不能有主体，即不能实现。例如：abstract void method()；不能有{}\n7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract 类（所谓实现就是有那个{}就可，具体内容不管）\n8. 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的\n\n#### 抽象类实践-模板设计模式\n\n现有个需求\n\n1. 有多个类，完成不同的任务job\n2. 要求能得到各自完成任务的时间\n\n```java\npackage seatWork;\n\npublic class Template {\n    public static void main(String[] args) {\n        son1 son1 = new son1();\n        son1.getCurrentTime();\n        son2 son2 = new son2();\n        son2.getCurrentTime();\n    }\n\n}\n\nabstract class Father{\n//在抽象类中定义一个抽象方法，这个方法后期会填入不同子类的不同不同方法\n    public abstract void job();\n//创建一个子类中的公共部分，在其中添加 不同的部分抽象类(方法)，\n// 由于动态绑定机制，当调用该方法时，根据实例不同的子类实现不同的输出结果\n//    也就是说相当于创建了个模板，不同的类用填不同的内容\n    public void getCurrentTime(){\n        long start = System.currentTimeMillis();\n        job();\n        long end = System.currentTimeMillis();\n        System.out.println(\"用时：\"+(end-start));\n    }\n}\nclass son1 extends Father{\n    @Override\n    public void job() {\n        int sum=0;\n        for (int i = 0; i < 10000; i++) {\n            sum+=i;\n        }\n    }\n}\nclass son2 extends Father{\n\n    @Override\n    public void job() {\n        int sum=0;\n        for (int i = 0; i < 60000; i++) {\n            sum+=i;\n        }\n    }\n} \n```\n\n## 接口（重要）\n\n#### 介绍\n\n接口就是给出一些没有实现的方法，封装到一起，起到某个类要使用的时候，在根据具体情况吧这些方法写出来\n\n#### 语法\n\n```java\ninterface 类名 implements 接口{\n 自己的属性；\n 自己的方法；\n 必须实现的接口的抽象方法；\n}\n```\n\n小结:\n\n1. jdk7之前，接口中所有方法否是抽象方法\n2. jdk8之后，接口中可以有实现方法，但需要使用default关键字修饰\n3. jdk8之后可以有静态方法\n4. abstract关键字可以省略\n\n#### 注意事项\n\n1. 接口不能被实例化\n\n2. 接口中所有的方法是public方法，接口中抽象方法，可以不用填写abstract，因为默认修饰的就是public abstract xxx。\n\n3. 一个普通类实现接口，就必须将该接口的所有方法都实现\n\n4. 抽象类实现接口，可以不用实现接口的方法\n\n5. 一个类同时可以实现多个接口\n\n6. 接口的属性，只能是final的，而且public static final 修饰符，比如：int a =1; 实际上是public static final int a =1；（必须）初始化\n\n7. 接口中属性的访问形式：接口名.属性名\n\n8. 一个接口不能继承其他的类，但是可以继承多个别的接口\n\n   ```java\n   interface A extend B,c,d...{}\n   ```\n\n9. 接口的修饰符只能是public和默认，这点和类的修饰符是一样的。\n\n小结：\n\n继承vs接口\n\n1. 当子类继承了父类，就自动拥有了父类的功能\n2. 如果子类需要拓展功能，可以通过实现接口的方式扩展\n3. 可以理解，接口是对java单继承机制的一个补充\n\n继承的价值：解决代码的复用性和可维护性\n\n接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。更加的灵活\n\n## 内部类（重点）\n\n#### 介绍：\n\n一个类的内部又完整的嵌套了另一个类结构。被嵌套的类成为内部类（inner class)，嵌套其他类的类成为外部类(out class)。是我们类的第五大成员\n\n类的五大成员：\n\n1. 属性\n2. 方法\n3. 构造器\n4. 代码块\n5. 内部类\n\n#### 基本语法\n\n```java\nclass Outer{//外部类\n\tclass inner{//内部类\n\t}\n}\n\nclass other{//外部其他类\n}\n```\n\n \n\n#### 内部类的分类\n\n定义在外部类局部位置上（比如方法内）\n\n##### 1）局部内部类（有类名）\n\n​\t\t说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名\n\n```java\n//例\nclass outclass{\n  private int n = 100;\n  //局部内部类师是定义在外部类的局部位置，通常在方法内\n // 1.第一种在局部位置\n \tclass innerClass{}\n  //2. 在方法内，（局部内部类）\n  public void mehtod(){//局部内部类（本质仍然是一个类）\n    \tclass innerClass{\n        System.out.print(\"n=\"+n);\n      }    \n  }\n}\n```\n\n1. 可以直接访问外部类的所有成员，包括私有的\n\n2. 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但可以使用final修饰，因为局部变量也可以使用final修饰符的\n\n3. 作用域：仅仅在定义它的方法或代码块中\n\n4. 局部内部类---访问---->外部类的成员【访问方式：直接访问】\n\n5. 外部类----访问---->局部内部类的成员\n\n   访问方式：创建对象，再访问（注意：必须在作用域内）\n\n6. 外部其它类---->不能访问---->局部内部类（因为 局部内部类地位是一个局部变量）\n\n7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问\n\n8. ```java\n   class Outer{\n   \tprivate int n1 = 10;\n   \tprivate static String name = \"张三\";\n   \tpublic void say(){\n   \t\tint n3 = 30;\n         //局部内部类是定义在外部类的局部位置，通常在方法  \n           //不能添加访问修饰符，可以使用final修饰\n     class localInner{//局部内部类（本质仍然是一个类）\n       int n1 = 100;\n      int n2 = 40;\n           //可以直接访问外部类的所有成员，包括私有的    \n         public void show(){\n         //默认输入内部类的n1的值 100\n   \t    System.out.print(\"n1=\"+n1);\n         //输入outer.this.n1 输出的才是外部类的n1\n         System.out.print(\"n1=\"+outer.this.n1);\n           \n         }\n   \t}\n   }\n     //外部类使用内部类\n     localInner inner = new localInner();\n     inner.show();\n    }\n   \n   \n   \n   //外部其他类\n   \n   ```\n\n9. \n\n##### 2）匿名内部类（没有类名，重点！！！！）\n\n###### 介绍：\n\n1. 本质是类\n2. 是一个内部类\n3. 该类没有名字\n4. 同时还是一个对象\n\n匿名内部类是定义在外部类的局部位置\n\n比如在方法中，并且没有类名\n\n###### 基本语法\n\n```java\nnew 类 或 接口（参数列表）{\n\t类体\n};\n\nanonymous\n```\n\n###### 演示 \n\n```java\npackage chapterObjectHeightLevel;\n\npublic class AnonymousClass {\n    public static void main(String[] args) {\n        outer outer = new outer();\n        outer.method();\n    }\n}\n\nclass outer{//外部类\n    private  int n1 =10;\n    public  void method(){\n        //现有一个需求，使用IA接口，并创建对象\n\n//        传统方法：新建一个类tiger 实现IA接口，并new tiger调用\n//        IA tiger = new Tiger();\n//        tiger.cry();\n//        当此时的需求是只需要这个Tiger类使用一次，并且以后再也不使用\n//        如果再用传统方法的话，会造成资源浪费，而且没有必要再去新建一个类\n//        此时就需要匿名内部类来简化开发，如下\n        IA tiger = new IA(){\n            /**\n             *此时底层是这样的\n             * class xxx(该类名是系统自动创建的) implements IA{\n             *     @Override\n             *     public void cry() {\n             *         System.out.println(\"老虎叫`````\");\n             *     }\n             * }\n             *\n             * 之后在让tiger指向xxx的地址\n             */\n            @Override\n            public void cry() {\n                System.out.println(\"老虎叫`````\");\n            }\n        };\n        tiger.cry();\n\n\n\n        //演示基于类的匿名内部类\n//        1. father的编译类型 Father(不加{}号)\n//        2. father的编译类型 xxx$2(加{}号）\n//        2.1 底层会创建匿名内部类\n        Father father = new Father(\"tiger\"){\n            @Override\n            public void test() {\n                System.out.println(\"override test method\");\n            }\n            /**\n            * 相当于创建了哥匿名内部类重写了test方法\n            * class xxx implement test{\n             *      @Override\n             *      public void test() {\n             *          System.out.println(\"override test method\");\n             *       }\n             * }\n             * 然后再将father指向xxx的地址\n            * */\n        };\n        father.test();\n\n    }\n\n}\n\ninterface IA{\n    public void cry();\n}\n\n//class Tiger implements IA{\n//\n//    @Override\n//    public void cry() {\n//        System.out.println(\"老虎叫`````\");\n//    }\n//}\n\nclass Father{\n    public Father(String name) {\n\n    }\n    public void test(){\n\n    }\n}\n\n```\n\n\n\n###### 注意细节\n\n1. 匿名内部类既是一个类的定义，同事它也是一个对象，因此从语法上来看，它既有定义类的特征，也有创建对象的特征，对前面的代码分析可以看出这个特点，因此调用匿名内部类方法有两种\n\n   ```java\n   //1.第一种方式\n   new A{\n   @override\n   \tpublic void cry(){\n   \tSystem.out.print(\"hello\");\n   \t}\n   }.cry();\n   \n   //2.第二种方式\n   A a=new A{\n   @override\n   \tpublic void cry(){\n   \tSystem.out.print(\"hello\");\n   \t}\n   }\n   a.cry();\n   ```\n\n2. 可以访问外部类的所有成员，包括私有的\n\n3. 不能添加访问修饰符，因为它的地位就是一个局部变量\n\n4. 作用域：方法或代码块中\n\n5. 匿名内部类--->范围跟--->外部类成员\n\n6. 外部其他类--->不能访问--->匿名内部类（因为 匿名内部类地位是一个局部变量）\n\n7. 如果外部类和内部类的成员变量重名时，内部类访问的话，默认就是就近原则，如果想访问外部，可以使用（外部类名.this.成员）去访问\n\n\n\n\n\n定义在外部类的成员位置上\n\n##### 1）成员内部类（没用static修饰）\n\n介绍：\n\n1. 成员内部类是定义在外部类的成员位置，并且没有static修饰\n\n   ```java\n   class outer{\n   \tprivate int n1 =10;\n   \tpublic String name = \"zhangsan\";\n   \t\n   \tclass inner{\n   \t\tpublic void say(){\n   \t\t\tSystem.out.print(\"outer n1 = \"+n1+\"outer name = \"+name);\n   \t\t}\n   \t}\n   }\n   ```\n\n2. 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位是一个成员\n\n3. 作用域\n\n   和外部类的其他成员一样，为整个类体比如前面的案例，在外部类的成员方法中创建成员内部类对象，再调用方法\n\n4. 成员内部类-->访问--->外部类成员\n\n   (比如属性)【访问方式：直接访问】\n\n5. 外部类 ---访问---内部类\n\n   访问方式：创建对象，再访问\n\n6. 外部其他类-----访问-----成员内部类\n\n   ```java\n   //三种方式:\n   //1\n   outer.inner class = new outer.new inner;\n   \n   // 第二种方式\n    1.定义一个方法，用于创建内部类并返回内部类的实例\n      public inner getInner(){\n      Inner inner  = new Inner();\n      return inner;\n    }\n   2. 在需要的地方new一个外部类.这个方法\n     Outer.Inner inner = new Outer.getInner();\n   \n   //3这个方法不建议使用\n     \n     new Outer().new Inner();\n   \n   ```\n\n7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问\n\n   ![image-20220409142725630](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409142725630.png)\n\n##### 2）静态内部类（使用static修饰）\n\n###### 介绍\n\n静态内部类定义在外部类的成员位置，并且有static修饰\n\n1. 可以直接访问外部的所有静态成员，包含私有的，但不能直接访问非静态成员\n2. 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员\n3. 作用域：同其他的成员，为整个类体\n\n```java\nclass outer{\nprivate int n1=10;\nprivate static String name = \"zhangsan\";\n\n//inner就是静态内部类\n  //1. 放在外部类的成员位置\n  //2. 使用static修饰\n  //3. 不能直接访问非静态成员\n  //4. 可以添加修饰符\n\tstatic class Inner{\n\t\tpublic void say(){\n      \tSystem.out.println(name);\n    }\n\t}\n}\n```\n\n4. 静态内部类---访问----外部类\n\n   （比如：静态属性）[访问方式：直接访问所有静态成员]\n\n5. 外部类--访问---静态内部类 \n\n   访问方式：创建对象，再访问\n\n6. 外部其他类 --访问 --内部类\n\n   访问方式：\n\n   ```java\n   //访问方式1\n   //因为静态内部类，是可以通过类名直接访问（前提是满足访问权限）\n   Outer.Inner inner = new Outer.Inner();\n   inner.xxx();\n   //访问方式2\n   //写一个方法，返回静态内部类的实例\n   public Inner getInner(){\n     return new Inner();\n   }\n   Outer.Inner inner = Outer.getInner();\n   \n   inner.xxx();\n   \n   //或者将方法换成静态\n   public static Inner getInner(){\n     return new Inner();\n   }\n   \n   \n   \n   ```\n\n7. 如果外部类和静态内部类的成员重名时，静态内部访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问\n\n# 枚举和注解\n\n## 枚举（enum）\n\n### 介绍\n\n1）枚举对应的英文（enumeration,简写enum）\n\n2）枚举是一组常量的集合\n\n3）可以理解：枚举属于一种特殊的类，里面只包含一组有限的特定对象（比如一年只有四个季节，建一个季节类的话只能有四个，而且有被添加其他季节的风险）\n\n\n\n### 实现方式\n\n#### 1）自定义枚举\n\n1. 不需要提供set方法，因为枚举对象通常为只读\n2. 对枚举对象/属性使用final +static共同修饰，实现底层优化\n3. 枚举对象通常使用大写，常量的命名规范\n4. 枚举对象根据需要，也可以有多个属性\n\n```java\npackage chapterEnum;\n\npublic class understandForEnum {\n    public static void main(String[] args) {\n        season autumn = season.AUTUMN;\n        System.out.println(autumn.getSeasonName()+autumn.getSeasonDescription());\n\n    }\n}\n//定义一个季节类\nclass season{\n    private String seasonName;//季节名称\n    private String seasonDescription;//季节描述\n  //1.将构造器私有化\n  //2.去掉setxx方法，防止属性被修改\n  //3.在season内部，直接创建固定的对象\n  //4.优化，添加final\n\n    public String getSeasonName() {\n        return seasonName;\n    }\n\n    public String getSeasonDescription() {\n        return seasonDescription;\n    }\n\n    private season(String seasonName, String seasonDescription) {\n        this.seasonName = seasonName;\n        this.seasonDescription = seasonDescription;\n    }\n//定义了四个对象\n    public final static season SPRING = new season(\"春天\",\"温暖\");\n    public final static season SUMMER = new season(\"夏天\",\"炎热\");\n    public final static season AUTUMN = new season(\"秋天\",\"凉爽\");\n    public final static season WINTER = new season(\"冬天\",\"寒冷\");\n}\n\n```\n\n总结：定义枚举类型有一下几个特点\n\n1. 构造器私有化\n2. 本类内部创建一组对象\n3. 对外暴露对象（添加public final static 修饰）\n4. 可以提供get方法，但不需要提供set方法\n\n#### 2）使用enum关键字实现\n\n```java\npackage chapterEnum;\n\npublic class understandForEnum02 {\n    public static void main(String[] args) {\n        System.out.println(season02.SPRING);\n    }\n}\nenum season02{\n    /**\n     * 实现步骤\n     * 1.使用enum代替class\n     * 2.直接使用 常量名(实参列表)\n     *   SPRING(\"春天\",\"温暖\"),\n     *   如果有多个常量则用,号隔开\n     *\n     * enum修饰必须将常量对象写在第一行\n     *  必须写在定义的变量和方法前面\n     *\n     * 3.编写常量，私有构造器和get方法\n     * */\n\n    SPRING(\"春天\",\"温暖\"),\n    SUMMER(\"夏天\",\"炎热\"),\n    AUTUMN(\"秋天\",\"凉爽\"),\n    WINTER(\"冬天\",\"寒冷\");\n\n\n    private String seasonName;//季节名称\n    private String seasonDescription;//季节描述\n\n    public String getSeasonName() {\n        return seasonName;\n    }\n\n    public String getSeasonDescription() {\n        return seasonDescription;\n    }\n\n    private season02(String seasonName, String seasonDescription) {\n        this.seasonName = seasonName;\n        this.seasonDescription = seasonDescription;\n    }\n\n    @Override\n    public String toString() {\n        return \"season02{\" +\n                \"seasonName='\" + seasonName + '\\'' +\n                \", seasonDescription='\" + seasonDescription + '\\'' +\n                '}';\n    }\n    //定义四个固定对象\n    /*\n    public final static season02 SPRING = new season02(\"春天\",\"温暖\");\n    public final static season02 SUMMER = new season02(\"夏天\",\"炎热\");\n    public final static season02 AUTUMN = new season02(\"秋天\",\"凉爽\");\n    public final static season02 WINTER = new season02(\"冬天\",\"寒冷\");\n*/\n\n\n}\n```\n\n##### 注意事项\n\n1. 当我们使用enum关键字开发一个枚举类时，默认会继承Enum类\n2. 传统的public static final SPRING = new season(\"春天\",\"温暖\");简化成SPRING(\"春天\",\"温暖\"),这里必须知道，它调用的是哪个构造器\n3. 如果使用无参构造器 创建枚举对象，则实参列表和小括号都可以省略\n4. 当有多个枚举对象时，使用，号间隔，最后一个分号结尾\n5. 枚举对象必须放在枚举的行首\n\n\n\n### enum常用方法说明\n\n使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类的相关方法\n\n![image-20220409204654918](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409204654918.png)\n\n```java\n    public static void main(String[] args) {\n//        使用season02 枚举类，演示各个方法\n        season02 summer = season02.SUMMER;\n//        输出枚举对象的名字\n//        summer.name();\n        System.out.println(summer.name());\n\n//        ordinal()输出的是该枚举对象的次序/编号，按枚举的顺序从0开始编号\n//        summer枚举对象时第二个，因此返回 1\n        System.out.println(summer.ordinal());\n\n//        从反编译可以看出values方法，返货season02[]\n//        含有定义所有的枚举对象\n        season02[] values = season02.values();\n        for (int i = 0; i <values.length ; i++) {\n            System.out.println(values[i].name());\n        }\n//        增强for循环演示\n//        每执行一次values就会扔一个对象给season、\n//        简单来说就是依次取出数组赋给season\n        System.out.println(\"==========增强for=========\");\n        for(season02 season:values){\n            System.out.println(season.name());\n        }\n\n//        valueOf:将字符串转换成枚举对象，要求字符串必须VT为己有的常量名，否则会报错\n//        1.根据输入的\"xia\"到season02中的枚举对象去查找\n//        2.如果找到了，就返回，如果没有找到就报错，如下这个例子\n        /*season02 vaof = chapterEnum.season02.valueOf(\"xia\");\n        System.out.println(\"vaof = \"+ vaof);*/\n//        3.只要valueOf()中的参数和枚举对象一致才能正常返回，如下\n        season02 xia = chapterEnum.season02.valueOf(\"SUMMER\");\n        System.out.println(\"xia = \" +xia);\n\n//        compareTo:比较两个枚举常量，比较的是编号\n//        就是把season02.SPRING和season02.SUMMER的编号进行比较\n//        底层是第一个的编号减去第二的编号，\n//        如果=0则是相等的，\n//        如果大于1，则代表前面那个编号大于后面一个编号\n//        如果小于1，则反之\n        System.out.println(season02.SPRING.compareTo(season02.SUMMER));//= -1\n        System.out.println(season02.SPRING.compareTo(season02.WINTER));//= -3\n\n    }\n```\n\n### 使用细节\n\n1. enum修饰的类不能在继承其他父类，因为enum会隐式继承一个Enum类\n2. enum实现的类，仍然是一个类，所以还是可以实现接口的\n\n\n\n### Switch中使用枚举\n\n案例\n\n1. ![image-20220410224921752](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410224921752.png)\n\n2. ```java\n   package homeWork.Annotation;\n   \n   public class AnnotationHomeWork08 {\n       public static void main(String[] args) {\n   //        Color.BLACK.show();\n   //        Color.RED.show();\n       Color red = Color.RED;\n   //    在小（）内放入枚举对象\n   //        在每个case后，直接写上枚举类，定义枚举对象即可\n           switch (red){\n               case RED:\n                   System.out.println(\"红色\");\n                   break;\n               case BLUE:\n                   System.out.println(\"蓝色\");\n                   break;\n               case BLACK:\n                   System.out.println(\"黑色\");\n                   break;\n               case YELLOW:\n                   System.out.println(\"黄色\");\n                   break;\n               case GREEN:\n                   System.out.println(\"绿色\");\n                   break;\n               default:\n                   System.out.println(\"没匹配到\");\n   \n           }\n       }\n   }\n   interface Tint{\n       public void show();\n   }\n   enum Color implements Tint{\n       RED(255,0,0),\n       BLUE(0,0,255),\n       BLACK(0,0,0),\n       YELLOW(255,255,0),\n       GREEN(0,255,0);\n   \n       private int redValue;\n       private int greenValue;\n       private int blueValue;\n   \n       Color(int redValue, int greenValue, int blueValue) {\n           this.redValue = redValue;\n           this.greenValue = greenValue;\n           this.blueValue = blueValue;\n       }\n   \n       @Override\n       public void show() {\n           System.out.println(redValue+\"\\t\"+greenValue+\"\\t\"+blueValue);\n       }\n   }\n   \n   ```\n\n\n\n## 注解\n\n#### 介绍\n\n1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息\n2. 和注解一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息\n3. 在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等，在javase中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替javaee旧版中所遗留 的繁冗代码和xml配置等\n\n使用Annotation时，前面要加@符号，并把Annotation当成一个修饰符使用。用于修饰它支持的程序元素\n\n1. @Override：限定某个方法，是重写父类方法，该注解只能用于方法\n\n   ```java\n   class son extends father{\n   //1.@Override注解方法fly方法上，表示子类fly方法重写了父类的fly\n   //2.如果这里没有写@Override ，还是重写了fly\n   //3.如果写了@Override注解，编译器就会去检查该方法是否真的重写了fly方法，\n   \t如果的确重写了，则编译通过。如果没有构成重写，则编译错误\n   @Override\n   public void fly(){\n    System.out.println(\"son fly...\");\n   }\n   }\n   ```\n\n   @Override只能修饰方法，不能修饰其他类\n\n2. @Deprecated：用于表示某个程序元素(类、方法等)已过时\n\n3. @SuppressWarnings：抑制编译器警告\n\n   1. 当写一些方法时，会出现一些无关不影响运行的警告。\n\n      可以使用@SuppressWarnings来抑制警告信息\n\n   2. 可以在@SuppressWarnings{\"\"}中写入希望抑制的警告信息\n\n   3. ![image-20220410190809537](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410190809537.png)\n\n   4. 位置在哪就屏蔽哪里 \n\n\n\n### 元注解（了解）\n\n@Target是修饰注解的注解，称为元注解  （了解）\n\n元注解的种类（使用不多，要求看到直到是干啥的）\n\n#### 1）Retention //指定注解的作用范围，三种SOURCE,CLASS,RUNTIME\n\n说明：\n\n只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，\n\n@Rentention包含一个RententionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值\n\n@Rentention的三种值：\n\nRententionPolicy.SOURCE //编译器使用后，直接丢弃这种策略的注释\n\nRententionPolicy.CLASS // 编译器将把注释记录在class文件中，当运行java程序时，JVM不会保留注释，这是默认值\n\nRententionPolicy.RUNTIME  //编译器将把注解记录在class文件中，当运行java程序时，JVM会保留注释，程序可以通过反射获取该注释\n\n示意图：\n\n![image-20220410203107921](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410203107921.png)\n\n#### 2）Target     //指定注解可以在哪些地方使用\n\n用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素\n\n简单来说就是在哪些元素上使用\n\n@Target   也包含一个名为value的成员变量\t\n\nTarget(value = CONSTRUCTOR（构造器）, FIELD（field） , LOACL_VARIABLE（局部变量）, METHOD（方法）,PACKAGE（包）,PARAMETER ,TYPE )\n\n#### 3）Documented    //指定该注解是否会在javadoc中体现\n\n@Documented   用于指定该元注解修饰的Annotation类将被Javadoc 工具提取成文档，即在生成文档时，可以看到注解\n\n定义Documented  注解必须设置Retention 值为RUNTIME\n\n#### 4）Inherited    //子类会继承父类注解\n\n\n\n# 异常\n\n## 异常的概念\n\n### 介绍\n\njava语言中，将程序执行中发生的不正常情况成为“异常”。（开发过程中的语法错误和逻辑错误不属于异常）\n\n执行过程中所发生的异常事件可分为两类\n\n1. Error（错误）：java虚拟机无法解决的严重问题。例如：JVM系统内部错误，资源耗尽等严重情况。例：StackOverflowError[栈溢出]和OOM（out of memory),Error是严重错误，程序会崩溃。\n2. Exception：因为，其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对想的代码进行处理，例如空指针访问，视图读取不存在的文件，网络连接中断等等，Exception分为两大类，运行时异常[程序运行发生的异常]和编译时异常[编译时，编译器查出的异常]\n\n\n\n## 异常体系图（重要）\n\n![image-20220411214601035](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411214601035.png)\n\n![image-20220411215335526](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411215335526.png)\n\n小结：\n\n1. 异常分为两大类，运行时异常和编译时异常\n\n2. 运行时异常，编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该避免出现的异常。java.lang.RuntimeException类及它的子类都是运行程序\n\n3. 对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影像\n\n4. 编译时异常，是编译器要求必须处置的异常\n\n    \n\n## 常见的异常\n\n### 常见的运行异常\n\n#### 1）NullPoniterException 空指针异常\n\n1. 当程序试图在需要对象的地方使用 null时，抛出该异常\n\n#### 2 ) ArithmeticException\t数字运算异常\n\n1. 当出现异常的运行条件时，抛出此异常\n2. 例如 一个整数\"除以零\"时，抛出此类的一个实例\n\n#### 3）ArrayIndexOutOfBoundsException\t数组下标异常\n\n1. 用非法索引访问数组时抛出的异常，如果索引为负或者大于等于数组大小，则该索引为非法索引\n\n#### 4）ClassCastException\t类型转换异常\n\n1. 当试图将对象强制转换为不是实例的子类时，抛出该异常\n\n#### 5）NumberFormatException\t数字格式不正确异常[]\n\n1. 当应用程序试图将字符串转换成一种数值类型，但该字符不能转换为适当格式时，抛出该异常\n2. 使用该异常我们可以确保输入的是满足条件的数字\n\n### 常见的编译异常\n\n#### 介绍\n\n编译异常是指在编译期间。就必须处理的异常，否则代码不能通过编译\n\n#### 常见的编译异常\n\n1. SQLException\t//操作数据库时，查询表可能发生的异常\n2. IOException\t\t//操作文件时，发生的异常\n3. FileNotFoundException\t//当操作一个不存在的文件时，发生异常\n4. ClassNotFoundException\t//加载类，该类不存在时，异常\n5. EOFException\t\t//操作文件，到文件末尾，发生异常\n6. IIIegalArguementException\t//参数异常\n\n\n\n## 异常处理概念\n\n### 基本介绍\n\n异常处理就是当异常发生时，对异常处理的方式\n\n### 异常处理方式\n\n#### 1）try-catch-finally\n\n程序员在代码中捕获发生的异常，自行处理\n\n```java\ntry{\n\t代码/可能有异常\n}catch(Exception e){\n//捕获的异常，传给e\n//1.当异常发生时\n//2.系统将异常封装成Exception对象e，传递给catch\n//3.得到异常对象后，程序员自己处理\n//4.如果没有发生异常，则catch代码块不执行\n}finally{\n    //不管try代码块是否有异常发生，始终都要执行finally\n    //通常将释放资源的代码方法finally代码块中\n}\n```\n\n\n\n#### 2）throws\n\n将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM\n\n##### 处理机制图\n\n![image-20220411224543192](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411224543192.png)\n\n\n\nthrows处理机制\n\n1. try-catch-finally和throws二选一\n2. 如果程序员，没有显示是处理异常，默认throws\n\n## 异常处理分类\n\n### try-catch方式处理异常说明\n\n#### 1）java提供try和catch块来处理异常。\n\ntry块用于包含可能出错的代码块。catch用于处理try块中发生的异常，可以根据需要在程序中有多个数量的try...catch块\n\n#### 2）基本语法\n\n```java\ntry{\n//可疑代码\n//将异常生成对应的异常对象，传递给catch块\n}catch(异常){\n//对异常的处理\n}\n//没有finally是可以通过的\n```\n\n```java\n//使用案例\ntry{\nString str = \"糖\";\nint a  = Integer.parseInt(str);\nSystem.out.println(\"数字=\"+a);\n}catch(Exception e){\nSystem.out.println(\"异常信息=\"+e.getMessage());\n}\n```\n\n#### 注意事项\n\n1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块\n\n2. 如果异常没有发生，则顺序执行try代码块，不会进入到catch块\n\n3. 如果希望不管是否能发生异常，都执行某段代码块（比如关闭链接，释放资源等）、\n\n4. 可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求是父类异异常在后，子类异常在前，比如（Exception 在后，NullPointerException 在前）如果发生异常，只会匹配一个catch\n\n   1. ```java\n      例:\n      try{\n      \n      }catch(NullPointerException e){\n      \n      }catch(Exception e){\n      \n      }finally{\n      \n      }\n      \n      ```\n\n5. 可以记性try-finally配合使用，这种方法相当于没有捕获异常，因此程序会直接崩掉\n\n   1. 应用场景：就是执行一段代码，不论是否发生异常，都必须执行某个业务逻辑\n\n#### 小结\n\n1. 如果没有出现异常，则执行try块中所有语句，不执行catch块中的语句，如果有finally，最后还要执行finally语句\n2. 如果出现异常，则try块异常发生后，剩下的语句不在执行，将执行catch块中的语句，如果有finally，最后还要执行finally里面的语句\n\n\n\n### throws异常处理\n\n#### 介绍：\n\n1）如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理异常，则此方法应显示的声明抛出异常，表明该方法将不对这些异常进行处理，而且由该方法的调用者负责处理\n\n2）在方法声明throws语句可以声明排除异常的列表，throws后面的异常类型可以是方法产生的异常类型，也可以是它的父类\n\n#### 注意事项\n\n1. 对于编译异常，程 序必须处理，比如try-catch或者throws\n2. 对于运行时异常，程序中如果没有处理，默认就是throws的方式处理\n3. 子类重写父类的方法是，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一直，要么为父类抛出的异常的类型和子类型\n4. 在throws过程中，如果有try-catch，就相当于处理异常，就可以不必throws\n5. ![image-20220412135104986](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412135104986.png)\n6. \n\n## 自定义异常  \n\n### 介绍：\n\n当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述错误信息。\n\n### 自定义异常的步骤\n\n1. 定义类：自定义异常类名（程序员自己写）继承Exceotion或RuntimeException\n2. 如果继承Ecxeption，属于编译异常\n3. 如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）\n\n```java\n//当我们接受Person对象年龄时，要求范围在18-120之间，否则抛出一个自定义异常（要求继承RuntimeException），并提示\npublic class CustomException {\n    public static void main(String[] args) {\n        int age =30;\n//        结果取反\n        if (!(age>=18&&age<=120)){\n//            通过构造器设置输出信息\n            throw new AgeException(\"年龄需要在18-120之间\");\n        }\n        System.out.println(\"你的年龄为\"+age);\n    }\n}\n//定义一个异常类继承RuntimeException\n//一般情况下，我们自定义异常都继承RuntimeException\n//也就是说大都是定义为运行时异常，好处是我们可以使用默认处理机制\n//即比较方便\nclass AgeException extends RuntimeException{\n//    定义一个构造器\n    public AgeException(String message) {\n        super(message);\n    }\n}\n```\n\n\n\n## throw和throws的对比\n\n|        | 意义                     | 位置       | 后面跟的东西 |\n| ------ | ------------------------ | ---------- | :----------: |\n| throws | 异常处理的一种方式       | 方法声明处 |   异常类型   |\n| throw  | 手动生成异常对象的关键字 | 方法体中   |   异常对象   |\n\nthrows\n\n```java\npublic void xxx() throws Exception{\n    //throws通常放在定义方法的末尾\n} \n```\n\nthrow\n\n```java\n//throw后面跟的是异常对象\nthrow new AgeException(\"年龄需要在18-120之间\");\n```\n\n\n\n# 常用类\n\n## 包装类\n\n### 包装类的分类   Wrapper\n\n1、针对八种基本数据类型相应类型的引用类型---包装类\n\n2、有了类的特点，就可以调用类中的方法\n\n| 基本数据类型 |  包装类   |\n| :----------: | :-------: |\n|   boolean    |  Boolean  |\n|     char     | Character |\n|     byte     |  `Byte`   |\n|    short     |  `Short`  |\n|     int      | `Integer` |\n|     long     |  `Long`   |\n|    float     |  `Float`  |\n|    double    |  `Doble`  |\n\n上述标出来的6个数据类型父类均为Number\n\n![image-20220412164154544](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412164154544.png)\n\n### 包装类和基本数据的转换\n\n#### 案例\n\n演示包装类和基本数据类型的相互转换，以int和integer演示\n\n1）jdk5前的手动装箱和拆箱方式，装箱：基本类型->包装类型,反之拆箱\n\n2）jdk5以后（包括jdk5）的自动装箱和拆箱方式\n\n3）自动装箱底层调用的是valueOf方法，比如integer.valueOf();\n\n4）其他类型同理\n\n```java\n//基本类型——————>包装类型[手动装箱]\nint i =10;\ninteger i1 = new Integer(i);\ninteger i2 = Integer.value(i);\n\n//包装类型————————>基本类型[手动拆箱]\nInteger j = new Integer(99);\nint j1 = j.intValue();\n```\n\n```java\n//jdk5.0之后的方式\nint m =10;\nInteger m2 =m;\nInteger n = new Integer(99);\nint n2 = n;\nSystem.out.println(\"n+100\");\nSystem.out.println(\"n*2\");\nif(n>10){\n\n}\n```\n\n### 包装类型和String类型的相互转换\n\n#### 案例\n\n以integer和String转为例\n\n```java\n//包装类型---->String类型\ninteger i =10;\n//方式1\nString s1 = i.toString();\n//方式2\nString s2 = String.valueOf(i);\n//方式3\nString s3 = i+\"\"; \nSystem.out.println(s3);\n\n//String --->包装类\n//方式1\nInteger j =new Integer(s1);\n//方式2\nInteger j2 = Integer.valueOf(s2);\n//\nInteger.parseInt(s3);\n```\n\n### Integer类和Character类常方法\n\n```java\nInteger.MIN_VALUE //返回最小值\nInteger.MAX_VALUE //返回最大值\n\nCharacter.isDigit('a');//判断是不是数字\nCharacter.isLetter('a');//判断是不是字母\nCharacter.isUpperCase('a');//判断是不是大写\nCharacter.inLowerCase('a');//判断是不是小写\n\nCharacter.isWhitespace('a')；//判断是不是空格\nCharacter.toUpperCase('a');//转成大写\nCharacter.toLowerCase('a');//转成小写\n\n```\n\n### Integer面试题\n\n1.看代码输出什么，为啥\n\n1. ![image-20220413164815801](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164815801.png)\n\n2. 因为integer的原码定义好了从-128-127之间不返回一个对象\n\n   ![image-20220413164729185](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164729185.png)\n\n   2.integer面试题总结\n\n   看下列代码输出什么结果\n\n   <span style=\"color:red;background:yellow \" >只要有基本数据类型会自动拆箱，比对的是数值。判断的是值是否相等</span>\n\n   如下的示例六和七，比对的是\n\n   ![image-20220413205739995](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413205739995.png)\n\n   \n\n   \n\n## String(重要)\n\n![image-20220413213320195](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413213320195.png)\n\nString实现了三个接口并继承了Object类\n\n* Serializable接口：说明String可以串行化。（可以在网络传输）\n* Comparable接口：说明String对象可以相互比较\n* CharSequence接口：字符序列\n\n<span style=\"color:blue;background:pink\">String类是final类，String类不能被其他类继承</span>\n\n<span style=\"color:blue;background:pink\">String 有属性，private final char value[];用于存放字符串内容（字符串的本质就是char数组）</span>\n\n<span style=\"color:red;background:pink\">(注意：value是一个final类型，不可修改（即：value不能指向新的地址，但是单个字符内容时可以变化的）)</span>\n\n\n\n\n\n### 理解\n\n1）String对象用于保存字符串，也就是一组字符序列\n\n2）字符串常量对象时用双引号括起来的字符序列。例如：\"你好\"，\"21.213\"，\"boy\"等等\n\n3）字符串的字符使用Unicode字符编码，一个字符（不区分字幕还是汉字）占两个字节\n\n4）String类较常用的构造方法（其他手册）\n\n* String s1 = new String();\n* String s2 = new String(String original);\n* String s3 = new String(char[] a);\n* String s4 = new String(char[] a,int startIndex, int count)\n\n### 创建方式\n\n#### 1）方式一：直接赋值String s = \"xxx\";\n\n创建流程：\n\n先从常量池查看是否有\"xxx\"数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址\n\n#### 2）方式二：调用构造器 String s = new String(\"xxx\")；\n\n流程：现在堆中创建空间，里面维护了value属性，指向常量池的xxx空间。如果常量池没有\"xxx\"，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址\n\n![image-20220414101904944](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414101904944.png)\n\n### String字符串的特性\n\n1）String是一个final类，代表不可变的字符序列\n\n2）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的 \n\n\n\n#### 面试题、\n\n1）String a = \"hello\"+\"abc\";创建了几个对象\n\n```java\n编译器会在后台会进行优化，判断创建的常量池对象，是否有引用指向\n优化等价于String a = \"helloabc\"；\n\n所以答案是创建了一个对象\n不是创建了三个\n```\n\n2）String a = \"hello\";\n\nString b = \"abc\";\n\nString c = a+b;\n\n总共创建了几个对象\n\n所以只创建了一个\n\n```java\n执行流程\n1. 先创建了一个StringBuilder sb = StringBuilder();\n2.执行sb.append(\"hello\");\n3.sb.append(\"abc\");\n4.String c = sb.toString();\n最后其实是c指向了堆中的对象（String）value[],堆中的对象指向了池中的“helloabc”\n```\n\n![image-20220414140922725](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414140922725.png)\n\n小结:底层是StringBuilder sb = new StringBuilder();sb.append(a);sb.append(b);sb是在堆中，并append是在原来的字符串的基础上追加的。\n\n重要规则：String c1 = \"sb\"+\"cd\";常量相加，看的是池。String c1 = a+b;变量相加，是在堆中\n\n### String类的常见方法\n\n#### 说明：\n\n​\tString类是保存字符串常量的。每次更新都需要重新开辟空间，效率低，因此java设计者还提供StringBuilder和StringBuffer来增强String的功能，并提高效率。\n\n#### Strng常见的方法\n\n![image-20220414145929644](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414145929644.png)\n\n* equals\t\t//区分大小写，判断是否相等\n\n* equalsIgnoreCase   //忽略大小写，判断内容是否相等\n\n* length  //获取字符的个数，字符窜长度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n\n* indexOf  //获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到返回-1\n\n* lastIndexOf   //获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，返回-1\n\n* substring //截取指定范围字符串\n\n* trim  //去前后空格\n\n* charAt //获取某索引处的字符，之一不能使用Str[index]这种方式\n\n* toUpperCase  //字符串转换成大写\n\n* toLowerCase  //字符串转换成小写\n\n* concat  //拼接字符串\n\n* replace  替换字符串中字符\n\n* split 分割字符串，罪域某些分割字符，我们需要转义\n\n  案例：\n\n  ```java\n  String poem =\"锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦\";\n  String[] split = poem.split(\",\");\n  //以，号为标准，分割上述整个字符串\n  //上述字符串被分割为4个部分用数组接收\n  \n  //在堆字符串进行分割时，如f\n  poem = \"E:\\\\aaa\\\\bbb\";\n  split  = poem.split(\"\\\\\\\\\");\n  ```\n\n  和 文件路径\n\n* compareTo //比较两个字符串的大小，如果前者大则返回正数，如果后者大则返回负数，\n\n  如果相等（\n\n  1.如果长度相同，并且字符串也相同返回0。\n\n  2.如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回if(c1 != c2）{\n\n  ​\t\treturn c1 - c2;\n\n  }\n\n  3.如果前面的部分都相同，就返回str1.len - str2.len）\n\n* toCharArray //字符串转成字符数组\n\n* format//格式化字符串，%s字符串，%c字符，%d 整型，%.2f 浮点型\n\n  ```java\n  //  %s%d%.2f%c成为占位符\n  //  这些占位符由后面的变量来替换\n  //  %s表示后面由字符串替换\n  //  %d表示整数替换\n  //  %.2f表示使用小数来替换，替换后，只会保留小数两位，并且会进行四舍五入的处理\n  //  %c是char类型替换\n      \n  String name =\"jack\";\n  int age = 10;\n  double score = 98.3 /3;\n  char gender ='男';\n  \n  //传统方法拼接\n  String info = \"名字是\"+name+\"年龄是\"+age+\"成绩是\"+score+\"性别：\"+gender\";\n  \n  \n  //使用format拼接\n  String info2 =String.format(\"姓名是%s年龄是%d成绩是%d性别时%c\",name,age,score,gender);\n  \n  //可以做成一个模板后面直接调用\n  String formatstr = \"姓名是%s年龄是%d成绩是%d性别时%c\";\n  \n  String info2 =String.format(formatstr,name,age,score,gender);\n  \n  System.out.println(\"info2 =\"+info2);\n  ```\n\n  \n\n## StringBuffer(重要)\n\n<span style=\"color:red;background:pink\">串行化（对象可以网络传输，可以保存到文件）</span>\n\n### 基本介绍\n\njava.lang.StringBuffer代表可变字符序列，可以对字符串内容进行增删\n\n很多方法与String相同，但StringBuffer是可变长度的\n\nStringBuffer是一个容器\n\n![image-20220415090614911](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415090614911.png)\n\n```java\nStringBuffer stringBuffer = new StringBuffer(\"hello\");\n//1.StringBuffer 的直接父类是 AbstractStringBuilder\n//2.StringBuffer 实现了Serializable，即StringBuffer的对象可以串行化\n//3.在父类中，AbstractStringBuilder 有属性 char[] value ，不是final\n\t该value 数组存放祖父穿内容，因数存放在堆中的\n//4.StringBuffer是一个final类， 不能被继承\n```\n\n### String 对比StringBuffer\n\n1）String保存的是字符串常量，里面的值不能更改，每次String类的更新实际是更改地址，效率较低//private final char value[]；\n\n2）StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用更新地址，效率较高//char[] value //这个放在堆\n\n\n\n### StringBuffer构造器\n\nStringBuffer()\n\n* 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符\n\n* ```java\n  //创建一个大小为16的char[]，用于存放字符串内容\n  StringBuffer stringBuffer = new StringBuffer();\n  ```\n\nStringBuffer(CharSequence seq)\n\n* public java.lang.StringBuffer(CharSequence seq)构造一个字符串缓冲区，它包含与指定的CharSequence 相同的字符\n\nStringBuffer(int capacity)//capacity[容量]\n\n* 构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对char[]大小进行指定\n\n* ```java\n  //通过构造器指定 char[]大小\n  StringBuffer stringBuffer = new StringBuffer(100);\n  ```\n\nStringBuffer(String str)\n\n* 构造一个字符串缓冲器，并将其内容初始化为指定的字符串内容\n\n* ```java\n  //通过给一个String 创建StringBuffer,char[] 大小就是str.length()+16\n  StringBuffer stringBuffer = new StringBuffer(\"hello\");\n  ```\n\n### String和StringBuffer\n\n#### String->StringBuffer\n\n```java\n//        String->StringBuffer\n//        方式一\n        String str =\"xxx\";\n//        注意：返回的是StringBuffer对象，对str本身是没有影响的\n        StringBuffer stringBuffer = new StringBuffer(str);\n\n\n//        方式二，使用append方法\n        StringBuffer stringBuffer1 = new StringBuffer();\n        stringBuffer1 = stringBuffer1.append(str);\n```\n\n#### StringBuffer->String\n\n```java\n\n//        StringBuffer->String\n        StringBuffer stringBuffer2 = new StringBuffer(\"xxxxxx\");\n//        方式一,使用StringBuffer提供的 toString方法;\n        String s = stringBuffer2.toString();\n\n//        方式二,使用构造器搞定\n        String s1 = new String(stringBuffer2);\n\n```\n\n\n\n### StirngBuffer类常见方法\n\n1. 增 append\n2. 删 delete(start,end)\n3. 改 replace(start,end,string)//将start---end间的内容替换掉，不含end\n4. 查 indexOf //查询字符串第1次出现的索引，如果找不回返回-1\n5. 插 insert\n6. 获取长度 length\n\n```java\n       StringBuffer stringBuffer = new StringBuffer(\"zhangsan\");\n\n        stringBuffer.append('x');\n        stringBuffer.append(\"张三\");\n        stringBuffer.append(\"wangwu\").append(true).append(10.2);\n        System.out.println(stringBuffer);\n\n//        删除\n        /*\n        * 删除索引为>=start && <end 处的字符\n        * 解读：删除11~14的字符[11,14)\n        * */\n        stringBuffer.delete(11,14);\n        System.out.println(stringBuffer);\n\n        //    改\n//        修改本质就是替换\n//        使用fff替换索引11-14的字符\n        stringBuffer.replace(11,14,\"fff\");\n        System.out.println(stringBuffer);\n\n//        查\n//        查找指定的子串在字符串出现的索引.如果找不到返回-1\n        int index = stringBuffer.indexOf(\"zhang\");\n        System.out.println(index);\n\n//        插入\n//        指定一个位置插入\n//        在索引为9的位置插入\"老王\"，原来索引为9的内容自动后移\n        stringBuffer.insert(9,\"老王\");\n        System.out.println(stringBuffer);\n\n//        获取长度\n        System.out.println(stringBuffer.length());\n    }\n\n```\n\n\n\n\n\n```java\n public static void main(String[] args) {\n        /**\n         * 输入商品名称和商品价格，要求打印效果示例，实用前面学习的方法完成\n         * 商品名  商品价格\n         * 手机123，456.56  //比如 价格价格1,456,786.5\n         * 要求：价格的小数点前面每三位用,号隔开，再输出\n        * */\n\n        String prices;\n        Scanner scanner = new Scanner(System.in);\n        String price = scanner.next();\n        StringBuffer stringBuffer = new StringBuffer(price);\n\n\n//        先完成最简单的实现21,312,412.32\n//        找到小数点的索引,然后再该位置的前三位插入,\n\n        for (int j = stringBuffer.lastIndexOf(\".\")-3; j >0 ; j-=3) {\n\n            stringBuffer = stringBuffer.insert(j, \",\");\n        }\n\n        System.out.println(stringBuffer);\n\n    }\n```\n\n\n\n\n\n## StringBuilder(重要)\n\n### 基本介绍\n\n1）一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder 不是线程安全)。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快（单线程的情况下，优先使用StringBuilder）\n\n2）在StringBuilder上主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据\n\n\n\n### StringBuilder常用方法\n\nStringBuilder和StringBuffer均代表可变字符序列，方法是一样的，所以使用和StringBuffer一样。\n\n1. StringBuilder是final类，不能被继承\n2. StringBuilder对象可以串行化\n3. 继承了AbstractStringBuilder属性 char[] value，内容存到value\n4. 实现了Serializable接口，序列化（所谓系列化既可以保存类型和数据本身）\n\n## String、StringBuffer、StringBuilder的比较☆\n\n1）StringBuilder和StringBuffer非常类似，均代表可变字符序列，而且方法也一样\n\n2）String：不可变字符序列，效率低，但是复用率高。\n\n3）StringBuffer：可变字符序列、效率较高（增删）、线程安全\n\n4）StringBuilder：可变字符序列、效率最高、线程不安全\n\n5）String使用注意事项：\n\n```java\nString s=\"a\"; //创建了一个字符串\ns+= \"b\";   //实际上原来的\"a\"字符串对象已经丢弃了，现在又产生了一个转字符串s+\"b\"（也就是\"ab\").如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=》\n//结论：如果我们对Stirng做大量修改，不要使用String\n```\n\n### 效率\n\nStringBuilder  > StringBuffer >String \n\n\n\n### 使用原则，结论\n\n1. 如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder\n2. 如果字符串存在大量的修改操作，并且在单线程的情况下使用StringBuilder\n3. 如果字符串存在大量的修改操作，并且在多线程的情况下使用StringBuffer\n4. 如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等\n\nStringBuffer和StringBuilder的方法使用一样\n\n## Math\n\n### 基本介绍\n\nMath类包含用于执行基本数学运算方法，如初等指数，对数，平方根和三角函数\n\n方法一览（均为静态方法）![image-20220415145338171](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415145338171.png)\n\n### Match常用的方法\n\n1. abs  绝对值\n\n2. pow  求幂\n\n3. ceil   向上取整  (返回>=该参数的最小整数)\n\n4. floor   向下取整  (返回<=该参数的最大整数)\n\n5. round   四舍五入\n\n6. sqrt  求开方\n\n7. random  求随机数\n\n   ```java\n   public static void main(String[] args) {\n           /*\n           random随机数\n           random默认返回 0<= x <1之间的一个随机小数\n           请写出a-b之间的一个随机整数，a,b均为整数比如a=2,b=7\n           即返回一个2 - 7 之间的随机数\n           * */\n           \n           /**\n           * random返回的是0<=x <1之间的一个随机小数\n            * Math.random()*(b-a)返回的就是0<= 数 <=b-a\n            * (1)(int)(a)<= x <(int)(a+Math.random() * (b-a +1))\n           * (2)集体使用解析\n            * (int)(a+Math.random() * (b-a +1))\n            *  = (int)(2+Math.random() * 6)\n            *  Math.random() * 6返回的就是0<= x <6小数\n            *  2+Math.random() * 6返回的就是2<= x <8小数\n            *  (int)(2+Math.random() * 6) = 2 <=x <=7\n           * */\n           \n   \n   \n   //      公式就是：(int)(a+Math.random() * (b-a +1))\n           for (int i = 0; i < 5; i++) {\n               System.out.println((int) (2 +Math.random()*(7-2+1)));\n           }\n       }\n   ```\n\n   \n\n8. max   求两个数的最大值\n\n9. min    求两个数的最小值\n\n\n\n\n\n## Date,Calender,LoaclDate.\n\n### Date[知道怎么查，怎么用即可]\n\n#### 第一代日期类\n\nDate：精确到毫秒，代表特定的瞬间\n\nSimpleDateFormat：格式和解析日期的类SimpleDateFormat 格式化和解析日期的具体类。它允许进行格式（日期->文本、解析（文本->日期）和规范化\n\n![image-20220420110144786](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420110144786.png)\n\n```java\n//获取当前时间\n//默认输出的格式是国外的格式\nDate d1 = new Date();、\n//因此需要对格式进行转换\nSimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 hh:mm:ss E\");\n//其他格式的字母意思，查看手册\nString foramt = d1.format(d1);\n\n//获取某个时间对应的毫秒数\nDate d2 = new Date(23123);\n\n//可以吧一个格式化的字符串转成对应的date\nString s = \"2000年7月五日 20:12:20 星期一\";\nDate pares = simpleDateFormat.parse(s);\n//接收的格式必须个定义的格式一样\n```\n\n### Calendar(日历)\n\n#### 第二代日期类\n\n主要就是Calendar类（日历）\n\n1）public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable<Calendar\n\n2)calendar类是一个抽象类，他为特定瞬间为一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等，日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。\n\n```java\n//创建日历对象，\nCalendar c =Calendar.getInstance();\nSystem.out.print(\"年\"+c.get(Calendar.YEAR))；\nSystem.out.print(\"月\"+c.get(Calendar.MONTH)+1)；\nSystem.out.print(\"日\"+c.get(Calendar.DAY_OF_MONTH))；\nSystem.out.print(\"小时\"+c.get(Calendar.HOUR))；\nSystem.out.print(\"分钟\"+c.get(Calendar.MINUTE))；\nSystem.out.print(\"秒\"+c.get(Calendar.SECOND))；\n//Calendar没有专门的格式化方法，所以程序员自己组合\nSystem.out.print(c.get(Calendar.SECOND)+\"年\"+(c.get(Calendar.MONTH)+1)+\"月\"+c.get(Calendar.DAY_OF_MONTH)+\"日\")；\n```\n\n### 第三代日期类\n\n前面两代的不足分析\n\n（jdk1.0中包含了一个java.Util.Date类，但是他的大多数方法已经存在JDK1.1引入Calendar类之后被弃用。Calendar也存在着很多问题\n\n1. 可变性：像日期和时间这样的类应该是不可变的。\n2. 偏移性：Date中年份是从1900开始的，而月份是从0开始的\n3. 格式化：格式化只对Date有用，Calendar则不行\n4. 此外，他们不是线程安全的，不能处理闰秒等（每隔两天多出1s）\n\n#### 第三代日期类\n\n1）LoaclDate（日期）、localTime（时间）、loacalDateTime（日期和时间内）\n\nJDK8\n\nLoaclDate：只包含日期，可以获取日期字段\n\nlocalTime：包含时间，可以获取时间字段\n\nloacalDateTime包含日期和时间，\n\n```java\nloacalDateTime ln = loacalDateTime.now();\nln.getYear();\nln.getMonth();\nln.getMonthValue();//输出数字版的月份\n```\n\n##### 2）DateTimeFormatter格式日期类\n\n类似于SimpleDateFormat\n\n```java\nDateTimeFormatter dtf = DateTimeFormatter.ofPattern(格式);//(yyyyMMdd....)\n\nString srt = dtf.format(日期对象);\n```\n\n#### Instant 时间戳\n\n类似于Date\n\n提供了一系列和Date类转换的方式\n\nInstant---->Date;\n\nDate date = Date.from(instant);\n\nDate --->Instant;\n\nInstant instant = date.toInstant();\n\n案例演示\n\n```java\nInstant now = Instant.now();\nSystem.out.print(now);\nDate date = Date.from(now);\nInstant instant = date.toInstant();\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## System\n\n### 常见方法\n\n1）exit 退出当前程序\n\n```\nSystem.exit(0);表示退出\n//0代表一个正常状态状态  。\n```\n\n2）Arraycopy：复制数组元素，比较合适底层调用，一般使用Arrays.copyOf完成数组复制。\n\n```java\nint[] src = {1,2,3};\nint[] dest = new int[3];\nSystem.arraycopy(src,0,dest,0,3)\n \tsrc:源数组\n    srcpos：从原数组的哪个索引位置开始开始拷贝\n    dest:目标数组，即吧原数组的数据拷贝到哪个数组\n    destpos：把原数组的数据拷贝到 目标数组的哪个索引\n    length:从原数组拷贝多少个数据到目标数组\n```\n\n3）currentTimeMillens：返回当前时间距离1970-1-1(1970年1月1日到现在) 的毫秒数\n\n4）gc：运行垃圾回收机制System.gc();\n\n## Arrays类\n\n### 介绍\n\nArrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）\n\n### 方法\n\n#### 1） toString返回数组的字符串形式，将数组拼接成字符串返回\n\n```java\nArrays.ToString(arr)\n```\n\n#### 2)sort排序（自然排序和定制排序）\t\n\n```java\nInteger arr[] = {1,-1,7,0,89};\n//可以直接使用该方法进行排序。不用再动手去敲方法\n//因为数组时引用类型，所以通过sort排序后，会影响到实参arr\nArrays.sort(arr);//正序排序\n//sort重载的，也可以通过传入一个接口Comparator实现定制排序\n\n1、调用定制排序时，传入两个参数\n    (1)排序数组的参数\n    (2)实现Comparator接口的匿名内部类。要求实现Compare方法\n\n    \n    \n//      这里体现了接口编程的方式\n//\n//        倒序排序\n        Arrays.sort(a, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                Integer i1 = (Integer) o1;\n                Integer i2 = (Integer) o2;\n//                return大于0 就是正序排序，小于0就是倒序\n                return i2 -i1;\n            }\n        });\n        System.out.println(Arrays.toString(a));\n\n    }\n```\n\n```java\n       bubble(a,new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                Integer i1 = (Integer) o1;\n                Integer i2 = (Integer) o2;\n                return i1 -i2 ;\n            }\n        });\n\n        System.out.println(\"定制类\"+Arrays.toString(a));\n\n    }\n\n\n//    定制排序\n    public static void bubble(Integer[] arr,Comparator c){\n        int temp;\n        for (int i = 0; i < arr.length-1 ; i++) {\n            for (int j = 0; j <arr.length-1-i; j++) {\n                if (c.compare(arr[j],arr[j+1])>0){\n                    temp =arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n```\n\n\n\n#### 3）binarySearch 二分搜索\n\nbinarySearch 通过二分搜索法进行查找，要求必须排好序\n\n```java\n //如果这个数组是有序的，可以通过该方法查找知否有这个数\n int[] arr = {1,23,45,65,78};\n//如果不存在该元素就返回，return -(low +1)//意思就是返回负的他该出现的位置的下标+1\n int index = Arrays.binarySearch(arr,3);//返回-2\n```\n\n#### 4）copyOf数组元素的复制\n\n```java\n//表示从arr数组中拷贝arr.length个长度的元素到新的arr数组中\nInteger[] newArr = Arrays.copyOf(arr,arr.length);\nInteger[] newArr = Arrays.copyOf(arr,arr.length-1);就是拷贝原数组长度-1\nInteger[] newArr = Arrays.copyOf(arr,arr.length+1);\n//如果长度超出原数组的长度，则多出来的部分元素为null   \n```\n\n#### 5)fill数组元素的填充\n\n```java\nInteger[] num = new Integer[]{9,2,1};\n//使用99去填充num数组\n//可以理解成替换原来的元素\nArrays.fill(num,99);\n\n==========运行结果======\n    [99,99,99]\n```\n\n#### 6)equals 比较两个数组元素内容是否完全一致\n\n```java\nboolean equals  = Arrays.equals(arr,arr2);\n//如果两个数组元素一样，则返回true。不一样返回false\n```\n\n#### 7)asList 将一组值，转换成list\n\n```java\nList<Integer> asList = Arrays.asList(2,3,4,5,6,1);\nSystem.out.println(\"asList\"+asList);\n```\n\n\n\n\n\n## Integer和BigDecimal类\n\n### 应用场景\n\n1）BigInteger适合保存比较大的整型(整数)\n\n```java\n//当编程中需要处理很大的整数。long不够用可以使用BigInteger类\n//使用\nBigInteger bigInteger = new BigInteger(\"2222222222222222222222222222222222222222\");\n\n//运算\n//在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）\n    \nBigInteger bigInteger 2=bigInteger.add(10)；//加\n    //也可再创建一个BigInteger相加\n```\n\n\n\n2）BigDecimal适合保存精度高的浮点型(小数)\n\n```java\n//当我们需要保存一个精度很高的值时，double不够用\n//可以使用BigDecimal\nBigDecimal bigDecimal = new BigDecimal(\"22.22222222222222222222222222\");\n//运算\n//在对BigDecimal进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）\n//需要创建一个需要操作的BigDecimal，然后调用即可\n\nBigDecimal bigDecimal=bigDecimal.add(2.3);\n    //使用删除方法时，可能会出现除不尽的情况，会抛出异常\n//解决办法：在调用divede(删除)方法是，指定精度即可\nbigDecimal.divide(1.11,BigDecimal.ROUND_CEILING)\n//如果有无限循环小数，就会保留到分子的精度\n\n```\n\n# 集合\n\n## 集合框架体系\n\n### 集合体系图\n\n背下来\n\n1）单例集合（在集合里面放单个的对象）\n\n![image-20220420163040446](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163040446.png)\n\n![image-20220420163624872](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163624872.png)\n\n2）双列集合（存放键值对形式的）\n\n![image-20220420163100945](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163100945.png)\n\n![image-20220420163609594](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163609594.png)\n\n```java\n//存放单个数据的成为单例\nArrayList  arrayList = new ArrayList();\narrayList.add(\"zhangsan\");\narrayList.add(\"lisi\");\n\n//存放双列数据的成为双例集合\nHashMap hashMap = new HashMap();\nhashMap.put(\"no1\",\"zhangsan\");\n//key,value\nhashMap.put(\"no2\",\"李四\");\n```\n\n## Collection\n\nCollection接口\n\n#### Collection接口实现类的特点\n\n```java\nPublic interface Collection<E> extends Iterable<E>\n```\n\n1. Collection实现子类可以存放多个元素，每个元素可以是 Object\n2. 有些Collection的实现类，可以存放重复的元素，有些不可以\n3. 有些Collection的实现类，有些是有序的（List），有些不是有序（Set）\n4. Collection接口没有直接实现子类，是通过它的子接口Set和List来实现的\n\n#### Collection接口和常用方法\n\n![image-20220420165341922](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420165341922.png)\n\n常用方法\n\n```java\n1)add :添加单个元素\n2)remove:删除指定元素\n3)contains:查找元素是否存在\n4）size：获取元素个数\n5）isEempty：判断是否为空\n6）clear：清空\n7）addAll：添加多个元素\n8）containsAll：查找多个元素是否都存在\n9）removeAll：删除多个元素\n说明：以ArrayList实现类演示\n```\n\n```java\npublic static void main(String[] args) {\n        ArrayList list = new ArrayList();\n//        1.添加单个元素\n        list.add(\"zhangsan\");\n        list.add(\"hahah\");\n        list.add(\"lisi\");\n        list.add(123);//等价于list.add(new Integer(123);\n        System.out.println(\"数组增加\"+list);\n//      remove：删除指定元素\n        list.remove(0);//删除第一个元素,下标从0开始\n        list.remove(\"123\");//删除指定元素\n        System.out.println(\"数组删除\"+list);\n\n//       contains 查找元素是否存在\n        System.out.println(list.contains(\"zhangsan\"));//F\n//        size,显示元素的个数\n        System.out.println(list.size());\n//      isEmpty判断是否为空\n        System.out.println(list.isEmpty());\n//        clear清空\n        list.clear();//清空集合\n        System.out.println(\"list清空=\"+list);\n\n        ArrayList list1 = new ArrayList();\n//        addAll:添加多个元素\n        list1.add(\"xxx\");\n        list1.add(\"xxxxxx\");\n\n        list.addAll(list1);\n        System.out.println(\"addAll\"+list);\n//        containsAll:查找多个元素知否存在\n        System.out.println(list.containsAll(list1));\n//        removeAll：删除多个元素\n        list.removeAll(list1);\n        System.out.println(list);\n\n    }\n```\n\n#### 使用Iterator（迭代器）\n\nCollection接口遍历元素的方式1-使用Iterator（迭代器）\n\n##### 基本介绍\n\n1）Iterator对象成为迭代器，主要用于遍历Collection集合中的元素\n\n2）所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可返回一个迭代器\n\n3）Iterator的结构![image-20220420231917444](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420231917444.png)\n\n4）Iterator仅用于遍历集合，Iterator本身并不存放对象\n\n###### 迭代器的运行原\n\n![image-20220421160914060](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220421160914060.png)\n\nhasNext用于判断\n\nnext（）；下移，并返回指向的元素\n\n```java\npublic class Iteraor {\n    public static void main(String[] args) {\n        Collection list = new ArrayList();\n        list.add(new HomeWork(\"zhansgan\",12313));\n        list.add(new HomeWork(\"haha\",231));\n\n//        使用迭代器遍历\n        Iterator iterator = list.iterator();\n//        while循环  快捷方式输入 itit\n//        ctrl+j提示所有快捷键\n     while (iterator.hasNext()) {\n//            返回下一个元素，是Object类型\n            Object next =  iterator.next();\n            System.out.println(next);\n        }\n//      当退出while循环后，这是iterator迭代器，指向最后一个元素\n//        iterator.next()  ，此时再让往下移指针会报异常：NuSuchElementException\n//        如果希望再次遍历，需要我们重置迭代器\n        iterator = list.iterator();//相当于指向了第一个元素\n\n    }\n}\n\nclass HomeWork{\n    String name;\n    Integer phoneNum;\n\n    public HomeWork() {\n    }\n\n    public HomeWork(String name, Integer phoneNum) {\n        this.name = name;\n        this.phoneNum = phoneNum;\n    }\n\n    @Override\n    public String toString() {\n        return \"HomeWork{\" +\n                \"name='\" + name + '\\'' +\n                \", phoneNum=\" + phoneNum +\n                '}';\n    }\n}\n```\n\n#### for循环增强\n\nCollection接口遍历元素的方式2-\n\n增强for循环，可以代替iterator迭代器\n\n特点：增强for就是简化版的iterator，本质一样。只能用于<span style=\"color:red\">遍历集合或数组</span>\n\n###### 基本语法\n\n```java\nfor(元素类型 元素名 : 集合名或数组){\n\t访问元素\n}\n```\n\n案例\n\n```java\n for (Object homeWork:list) {\n            System.out.println(homeWork);\n        }\n\n//        增强也可以在数组中使用\n        int[] a = {1,2,3,45,6};\n        for (int i: a){\n            System.out.println(i);\n        }\n```\n\n1. 增强for底层是迭代器\n2. 可以理解成增强for是简化版的迭代器\n\n## List\n\n基本介绍：\n\nList接口是Collection接口的子接口\n\n1）list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\n\n2）list集合中的每个元素都有其对应的顺序索引，即支持索引\n\n3）list容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素\n\n4）JDK API中的List接口实现类有：ArrayList、LinkedList和Vector\n\n```java\npublic static void main(String[] args) {\n//        list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\n        List list = new ArrayList();\n        list.add(\"jack\");\n        list.add(\"tom\");\n        list.add(\"zhangsan\");\n//        此时不会有冲突，相当于会认为有两个tom\n        list.add(\"tom\");\n//        此时输出的顺序就是存进去的顺序\n        System.out.println(\"list\"+list);\n\n//        2）list集合中的每个元素都有其对应的顺序索引，即支持索引\n//        索引从0开始\n        System.out.println(list.get(3));\n    }\n```\n\n##### List接口的常用方法\n\n1. void add（int index,Object ele）在index位置插入ele元素\n2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来\n3. Object get (int index)获取固定index位置的元素\n4. int indexOf(Object obj)  返回obj在几个中首次出现的位置\n5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置\n6. Object remove(int index) 移除指定index位置的元素，并返回此元素\n7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换\n8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合\n\n```java\npublic static void main(String[] args) {\n\n        List list = new ArrayList();\n        list.add(\"no1\");\n        list.add(\"no2\");\n//        1. void add（int index,Object ele）在index位置插入ele元素\n//        在index=1的位置插入一个对象\n        list.add(1,\"add(index,ele)\");\n        System.out.println(list);\n//        2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来\n        List list2 = new ArrayList();\n        list2.add(\"lno2\");\n        list2.add(\"lno3\");\n        list2.add(\"lno3\");\n//        在1的位置插入list2的集合\n        list.addAll(1,list2);\n        System.out.println(list);\n//        3. Object get (int index)获取固定index位置的元素\n//        4. int indexOf(Object obj)  返回obj在几个中首次出现的位置\n        System.out.println(list.indexOf(\"no1\"));\n//        5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置\n        System.out.println(list.lastIndexOf(\"lno3\"));\n//        6. Object remove(int index) 移除指定index位置的元素，并返回此元素\n        list.remove(1);\n        System.out.println( list);\n//        7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换\n//        将索引为1的改为尼诺\n        list.set(1,\"尼诺\");\n//        8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合\n        List result = list.subList(0, 2);//相当于选择了下标为0的和下标为2-1之间的元素\n        System.out.println(\"result\"+result);\n}\n```\n\n##### 注意事项\n\n1. permits all elements,including null , ArrayList 可以加入null，并且多个\n2. ArrayList 是由数组来实现数据存储的\n3. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）看源码，在多线程情况下，不建议使用ArrayList\n\n#### ArrayList\n\n#####  ArrayList底层机制和源码分析（重点）\n\n1）ArrayList中维护了一个Object类型的数组elementData\n\n​\t\ttransient Object[] elementData \n\n```\ntransient 表示瞬间，短暂的，表示该属性不会被序列化\n```\n\n\n\n2）当创建对象ArrayList时，如果使用的是无参构造器，则初始elementData容量为0\n\n3）当添加元素时，先判断是否需要扩容，则调用grow方法，否则直接添加元素到合适位置\n\n4）如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍\n\n5）如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity\n\n6）如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍\n\n\n\n#### Vector\n\n##### 介绍\n\nVevtor底层也是一个对象数组。protected Object[] elementData;\n\nVector是线程同步的，即线程安全，Vector类的操作方法带有synchronized\n\n在开发过程中，需要线程同步安全时，考虑使用Vector\n\n\n\n##### Vector 和ArrayList比较\n\n|           | 底层结构 | 版本   | 线程安全（同步）效率 | 扩容倍数                                                     |\n| --------- | -------- | ------ | -------------------- | ------------------------------------------------------------ |\n| ArrayList | 可变数组 | jdk1.2 | 不安全，效率高       | 如果有参构造1.5倍如果无参1.第一次是10，第二次按1.5扩         |\n| Vector    | 可变数组 | jdk1.0 | 安全，效率不高       | 如果是无参默认10，满后，就按两倍扩容。如果指定大小（创建）有参，则每次直接按2倍扩容 |\n\n#### LinkedList\n\n##### 说明\n\n1）LinkedList实现了双向链表和双端队列特点\n\n2）可以添加任意元素（元素可以重复），包括null\n\n3）线程不安全，没有实现同步\n\n##### LinkedList底层机制\n\n1. LinkedList底层维护了一个双向链表\n\n2. LinkedList中维护了两个属性first和last分别指向首节点和尾结点\n\n3. 每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表\n\n4. 所以LinkedList的元素的 添加和删除，不是通过该数组完成的，相对来说效率较高\n\n5. 模拟一个简单双向链表理解\n\n   ```java\n   public static void main(String[] args) {\n   //        模拟一个简单的双向链表\n           Node jack = new Node(\"jack\");\n           Node tom = new Node(\"tom\");\n           Node zhangshan = new Node(\"zhangshan\");\n   //        链接是三个结点，形成双向链表\n   //        jack->tom ->zhangsan\n           jack.next = tom;\n           tom.next =zhangshan;\n   //        zhangsan->tom->jack\n           zhangshan.pre = tom;\n           tom.pre = jack;\n   \n           Node first = jack;//让first引用指向jack，就是双向链表的头结点\n           Node last =zhangshan;//让last引用指向zhangshan，就是双向链表的尾结点\n   \n   \n   //        演示从头到尾进行遍历\n           while (true){\n               if (first == null){\n                   break;\n               }\n   //            输出first信息\n               System.out.println(first);\n               first = first.next;\n           }\n   \n   //        从未到头遍历\n           while (true){\n               if (last == null){\n                   break;\n               }\n               System.out.println(last);\n               last = last.pre;\n           }\n   \n       }\n   }\n   \n   //定义一个Node类，node对象 表示双向链表的一个结点\n   class Node{\n       public Object item;//真正存放数据\n       public Node next;//指向下一个结点\n       public Node pre;//指向前一个结点\n   \n       public Node(Object item) {\n           this.item = item;\n       }\n   \n       @Override\n       public String toString() {\n           return \"Node{\" +\n                   \"item=\" + item +\n                   '}';\n       }\n   }\n   ```\n\n   \n\n![image-20220429152321935](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429152321935.png)\n\n##### ArrayList 和LinkedList的比较\n\n|            | 底层结构 | 增删的效率         | 改查的效率 | 线程   |\n| ---------- | -------- | ------------------ | ---------- | ------ |\n| ArrayList  | 可变数组 | 较低；数组扩容     | 较高       | 不安全 |\n| LinkedList | 双向链表 | 较高，通过链表追加 | 较低       | 不安全 |\n\n何如选择\n\n1）如果我们改查的操作较多，选择ArrayList\n\n2）如果我们增删的操作多，选择LinkedList\n\n3）一般来说，在程序中80%-90%都是查询，因此大部分情况下会选择ArrayList\n\n4）在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说根据业务来进行合理选择\n\n## set\n\n介绍\n\n1）无序（添加和取出的顺序不一致），没有索引\n\n2）不允许重复元素，所以最多包含和一个null\n\n3）JDK API中Set接口的实现类有![image-20220429173926895](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429173926895.png)\n\n##### Set接口和常用方法\n\n和List接口一样，Set接口也是Collection的子接口，因此常用方法和Collection接口一样\n\n##### set接口遍历方式\n\n同Collection的遍历方式一样，因为Set接口是Collection接口的子接口\n\n* 使用迭代器\n* 增强for\n* 不能使用索引的方式获取\n\n##### 案例\n\n```java\npublic static void main(String[] args) {\n//        以set接口实现类HashSet来讲解Set接口的方法\n//        set接口的实现类的对象（set接口对象）\n//        重复添加的数据只会存进去一个，null值也是只能存放一个\n    //输出结果是无序的（存放的数据是无序的，即（添加的顺序和取出的顺序不一致））\n    //虽然取出的顺序和添加的顺序不一致，但取出的顺序是固定的，不会一直变化\n        Set set = new HashSet();\n        set.add(\"zhansgan\");\n        set.add(\"lisi\");\n        set.add(\"wa\");\n        set.add(\"zhansgan\");\n        set.add(null);\n        set.add(null);\n        System.out.println(set);\n    }\n\n//        遍历\n//        迭代器\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            Object next =  iterator.next();\n            System.out.println(next);\n        }\n//        增强for\n        for (Object o :set) {\n            System.out.println(o);\n        }\n----------------输出结果----------------------\n    [null, lisi, wa, zhansgan]\n```\n\n#### HashSet\n\n1)HashSet实现了Set接口\n\n2）HashSet实际上是HashMap，看源码\n\n![image-20220430145947382](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430145947382.png)\n\n3）可以存放null值，但是只能有一个null\n\n4）HashSet不保证元素时有序的，取决于hash之后，在确定索引的结果（即：不保证存放元素的顺序和取出的一致  ）\n\n5）不能有重复元素/对象。在前面Set接口使用已经标明\n\n```java\n//1.执行add方法后，会返回一个Boolean值\n//2.如果添加成功,返回true，否则返回false\n//3.可以通过remove指定删除哪个对象\n        HashSet set = new HashSet();\n        set.add(\"zhansgan\");\n        set.add(\"lisi\");\n        set.add(\"wa\");\n        set.add(\"zhansgan\");\n        set.add(null);\n        set.add(null);\n\n        set.remove(\"zhangsan\");\n\n        set.add(new HHHH(\"zzz\"));//添加成功\n        set.add(new HHHH(\"zzz\"));//添加成功\n    }\n}\nclass HHHH{\n    private String name;\n\n    public HHHH(String name) {\n        this.name = name;\n    }\n}\n```\n\n##### HashSet底层机制说明 \n\n1）HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树）\n\n\n\n1. HashSet底层是HashMap\n2. 添加一个元素时，先得到hash值 -会转成-索引值\n3. 找到储存数据表table，看这个索引位置是否已经存放的有元素\n4. 如果没有，直接加入\n5. 如果有调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后\n6. 在java8中，如果一条链表的元素个数到了TREEEIFY_THRESHOLD(默认是8)个，并且table的大小>=MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树）\n7. ![image-20220430160350549](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430160350549.png)\n\n源码分析\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    //定义了一个辅助变量\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //table就是HashMap的一个属性，类型是Node[]\n     //if语句表示如果当前table是null，或者大小=0\n    //就是第一次扩容，到16个空间\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n   //（1）根据key，得到hash值去计算key应该存放到table表的哪个索引位置\n    //并且把这个位置的对象赋给p\n    //（2）判断p是否为null\n    //（2.1）如果为null，表示还没有存放元素，就创建了一个Node\n    //（2.1）就放在该位置 tab[i] = newNode(hash, key, value, null); \n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n          //如果当前索引位置对应的链表的第一个元素和准备谈价的key的hash值一样\n            //并且满足下面条件之一\n            //1.准备加入的key和p指向的Node结点和key是同一个对象 \n            //2.p指向的Node结点的key的equals（）和准备加入的key比较后相同\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            //如果上述条件不满足，再判断p是不是一个红黑树\n            //如果是一颗红黑树，就调用putTreeVal，来进行添加判断\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            \n            else {\n                //依次比较链表内的内容\n                //如果table对应索引的额位置，已经是一个链表，就是用for循环比较\n                //(1)依次和链表的每一个元素比较后都不相同，则加入到该链表的最后\n                  //然后立即判断该链表是否已经达到8个结点，就调用   treeifyBin()对当前这个链表进行树化（转成红黑树）\n                //注意，在转成红黑树时，要进行判断，判断条件{if(tab == null ||(n = tab.length)<MIN_TREEIEY_CAPACITY)\n                //resize();   //table数组是否小于64，结点是否到达8个并不为空      }\n                //如果上面条件成立，先table扩容\n                //如果上面条件不成立，才进行树化\n                //(2)依次和该链表的每一个元素比较过程中，如果有相同的情况，就直接break；\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        \n                        p.next = newNode(hash, key, value, null);\n                \n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n##### HashSet的扩容和转成红黑树机制\n\n1. HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（localFactor）是0.75 =12\n2. 如果table数组实用到了临界值12，就会扩容到16*2=32，新的临界值就是32 * 0.75 = 24,依次类推\n3. 在java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8),并且table的大小>=MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树），否则仍然采用数组扩容机制\n\n\n\n### LinkedHashSet\n\n**说明**\n\n1）LinkedHashSet是HashSet的子类\n\n2）LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表\n\n3）LinkedHashSet根据元素的hashCode值来决定元素的储存位置，同时使用链表维护元素的次序（图），这使得元素看起来是以插入顺序保存的![image-20220501174705977](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220501174705977.png)\n\n4）LinkedHashSet不允许添加重复元素 \n\n![image-20220502111826275](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220502111826275.png)\n\n可以理解成不同索引的数，构成双向链表\n\n1. 在LinkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）\n\n2. 每一个结点有pre和next属性，这样可以形成双向链表\n\n3. 在添加一个元素时，先求hash值，在求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加[原则和hashset一样])\n\n   ```java\n   tail.next = newElement //简单指定\n   new Element.pre = tail\n   tail = newElement;\n   ```\n\n4. 这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致\n\n\n#### TreeSet\n\n1. 当使用无参构造器创建treeset的时候仍然是无序的\n\n2. 需求：希望添加的元素按字符串大小来排序?\n\n   1. 使用TreeSet提供的一个构造器,可以传入一个比较器（匿名内部类）\n\n   2. ```java\n      public class TreeSetDemo {\n          public static void main(String[] args) {\n      //        TreeSet treeSet = new TreeSet();\n              TreeSet treeSet = new TreeSet(new Comparator() {\n                  @Override\n                  public int compare(Object o1, Object o2) {\n      //                调用String的compareTo方法比较字符串大小\n                      return ((String)o1).compareTo((String) o2);\n                  }\n              });\n              treeSet.add(\"d\");\n              treeSet.add(\"b\");\n              treeSet.add(\"a\");\n              treeSet.add(\"c\");\n      \n              System.out.println(treeSet);\n          }}\n      ```\n\n   3. \n\n\n\n## Map\n\nMap**结构**\n\n<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220503163901620.png\" alt=\"image-20220503163901620\" style=\"zoom:50%;\" />\n\nMap接口的特点（JDK8之后的）\n\n1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）\n\n2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&Node对象中\n\n3）Map中的key不允许重复，原因和HashSet一样，前面分析过\n\n4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）\n\n5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个\n\n6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）\n\n7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n\n```java\n Map map = new HashMap();\n//        1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）\n//        2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&Node对象中\n//        3）Map中的key不允许重复，原因和HashSet一样，前面分析过\n//        4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(\"no1\",\"lisi\");\n//        5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个\n        map.put(null,null);\n        map.put(null,null);\n        map.put(\"no3\",null);\n        map.put(\"no4\",null);\n        //        6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）\n        map.put(new Object(),\"zhangsan\");\n//        7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n//        通过get方法传入key，会返回对应的value\n        System.out.println(map.get(\"no2\"));\n        System.out.println(map);\n=============输出==================\n  lisi\n{no2=lisi, null=null, no1=lisi, no4=null, no3=null, java.lang.Object@1540e19d=zhangsan}\n\n\n```\n\n8）Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，有因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry（如图）\n\n![image-20220504165516988](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220504165516988.png)\n\n数据存放在HashMap中，将set和collection作为一组对象放在Entry里面（其中不存放数据只是存放HashMap的引用）\n\n1. 将HashMap中的key和value数据 存放到一个entrySet集合（该集合不存放数据，存放的都是引用）\n\n```java\n Map map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");//k-v\n        map.put(\"no1\",\"lisi\");//k-v\n//        1.k-v最后是HashMap$Node node = newNode(hash ,key,value,null);\n//        2.k-v为了方便程序员遍历，还会创建EntrySet集合，该集合存放的元素类型（Entry），\n//        而一个Entry对象就有k-v，EntrySet<Entry<k,v>>，即：transient Set<Map.Entry<k,v>> entrySet;\n\n//        3.在entrySet中，定义的类型是Map.Entry，但是实际上存放的是HashMap$Node类型\n//        因为HashMap$Node implement Map.Entry 因为实现了Map.Entry接口，那么这个类的对象实例可以赋给这个接口类型\n//        4.当吧HashMap$Node存放到entrySet后就方便我们的遍历，因为Map.Entry提供了两个重要的方法，getKey()和getValue方法\n        Set set = map.entrySet();\n        System.out.println(set.getClass());\n//        输出：class java.util.HashMap$EntrySet\n        for (Object o :set) {\n            System.out.println(o.getClass());\n//            输出：class java.util.HashMap$Node\n//            从HashMap$Node取出k-v\n//            先做一个向下转型\n            Map.Entry entry = (Map.Entry) o;\n            System.out.println(entry.getKey() +\"\"+ entry.getValue());\n        }\n```\n\n\n\n#### map接口和常用方法\n\n1）put：添加\n\n2）remove：根据键删除映射关系\n\n3）get：根据键获取值\n\n4）size：获取元素个数\n\n5）isEmpty：判断个数是否为0\n\n6）clear；清楚\n\n7）containsKey：查找键值否存在\n\n```java\nMap map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(null,\"lisi\");\n        map.put(\"no3\",\"lisi\");\n        map.put(\"no4\",\"2\");\n\n        map.remove(null);\n        Object lisi = map.get(\"no2\");\n        System.out.println(\"lisi==\"+lisi);\n\n        System.out.println(map.size());\n\n        map.isEmpty();\n        System.out.println(map);\n        map.clear();\n        System.out.println(map);\n\n        System.out.println(map.containsKey(\"no3\"));\n\n```\n\n\n\n#### Map遍历方法\n\n1）containsKey：查找键是否存在\n\n2）KeySet：获取所有的键\n\n3）entrySet：获取所有关系\n\n4）values：获取所有的值\n\n```java\n  Map map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(null,\"sss\");\n        map.put(\"no3\",\"lisdsdsi\");\n        map.put(\"no4\",\"2\");\n\n//        第一粗：先取出所有的key，通过key取出对应的value\n        Set set = map.keySet();\n//        增强for\n        for (Object o :set) {\n            System.out.println(map.get(o));\n        }\n        System.out.println(\"迭代器\");\n//        （2） 使用迭代器\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            Object next =  iterator.next();\n            System.out.println(map.get(next));\n        }\n        System.out.println(\"=========第二中=========\");\n//      第二组：吧所有的values取出\n        Collection values = map.values();\n//        这里可以使用所有的collections使用的遍历方法\n        for (Object o :values) {\n            System.out.println(o);\n        }\n//        迭代器\n        System.out.println(\"迭代器\");\n        Iterator iterator1 = values.iterator();\n        while (iterator1.hasNext()) {\n            Object next =  iterator1.next();\n            System.out.println(next);\n        }\n\n        System.out.println(\"=========第三中=========\");\n//        通过entryset获取\n        Set set1 = map.entrySet();\n        for (Object entry :set1) {\n//            将entry转为map.entry\n            Map.Entry  entry1= (Map.Entry) entry;\n            System.out.println(entry1.getKey()+\" \"+entry1.getValue());\n        }\n        System.out.println(\"迭代器\");\n        Iterator iterator2 = set1.iterator();\n        while (iterator2.hasNext()) {\n            Object next =  iterator2.next();\n            Map.Entry m = (Map.Entry) next;\n            System.out.println(m.getKey()+\" itit \"+ m.getValue());\n        }\n```\n\n#### 小结\n\n1. Map接口的常用实现类：HashMap、Hashtable和Properties\n2. HashMap是Map接口使用频率最高的实现类\n3. HashMap是以key-value对的方式来存储数据（HashMap$Node类型）\n4. key不能重复，但值可以，允许使用null键和null值\n5. 如果添加相同的 key，则会覆盖原来的k-v，等同于修改，（key不会替换，val会替换）\n6. 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来储存的\n7. HashMap没有实现同步，因此线程不安全 的\n\n#### HashMap底层机制\n\n1）HashMap底层维护了Node类型的数组table，默认为null\n\n2）当创建对象时，将加载银子（loadfactor）初始化为0.75\n\n3）当添加key-value时，通过key的哈希值得到在table的索引，然后判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是连链表结构，做出相应处理。如果添加时发现容量不够则需扩容\n\n4）第一次添加，则需扩容table容量为16，临界值(threshold)为12\n\n5）以后再扩容，需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推\n\n6）在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小>=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化。\n\n#### HashTable\n\n**基本介绍**\n\n1）存放的元素时键值对：key-value\n\n2）hashTable的键和值都不能为null，否则会抛出空指针异常\n\n3）hashTable使用方法基本上和HashMap一样\n\n4）hashTable是线程安全的，HashMap是线程不安全的\n\n![image-20220506160740866](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220506160740866.png)\n\n#### Properties\n\n**基本介绍**\n\n1. properties类继承了Hashtable类并实现了Map接口，也是使用一种键值对(key-value)的形式来保存数据\n2. 它的使用特点和Hashtable类似\n3. properties还可用于从xxx.properties文件中，加载数据到properties类对象，并进行读取和修改\n4. 说明：工作后 xxx.properties文件常用作配置文件，io流部分(详细讲解)[www.cnblogs.com/xudong-bupt/p/3758136.html]\n\n## Collections\n\n### Collections工具类\n\n1）Collections是一个操作Set、List和Map等集合的工具类\n\n2）Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作\n\n### 排序操作（均为static方法）\n\n1. reverse（List）：反转List中元素的顺序\n\n2. shuffle（List）：对List集合元素进行随机排序\n\n3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序\n\n4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序\n\n5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换\n\n6. 案例：\n\n   ```java\n   public class Collectionsdemo {\n       public static void main(String[] args) {\n           ArrayList list = new ArrayList();\n           list.add(\"zhansgan\");\n           list.add(\"lisi\");\n           list.add(\"wngwu\");\n           list.add(\"laoliu\");\n           list.add(\"dasima\");\n           System.out.println(\"list=\"+list);\n   //        1. reverse（List）：反转List中元素的顺序\n           Collections.reverse(list);\n           System.out.println(\"reverse=\"+list);\n   //        2. shuffle（List）：对List集合元素进行随机排序\n           for (int i = 0; i < 5; i++) {\n               Collections.shuffle(list);\n               System.out.println(\"随机\"+list);\n           }\n   //        3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序\n           Collections.sort(list);\n           System.out.println(\"sort\"+list);\n   //        4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序\n           Collections.sort(list, new Comparator() {\n               @Override\n               public int compare(Object o1, Object o2) {\n                   return ((String)o1).length()-((String)o2).length();\n               }\n           });\n           System.out.println(\"字符串长度排序\"+list);\n   //        5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换\n   \n           Collections.swap(list,0,1);\n           System.out.println(\"位置交换\"+list);\n       }\n   }\n   ```\n\n\n\n### 查找、替换\n\n1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n\n2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素\n\n3. Object min（Collection)\n\n4. Object min (Collection，Comparator)\n\n5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数\n\n6. void copy（List dest，List src）：将src中的内容复制到dest中\n\n7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值\n\n8. ```java\n   public static void main(String[] args) {\n           ArrayList list = new ArrayList();\n           list.add(\"zhansgan\");\n           list.add(\"lisi\");\n           list.add(\"wngwu\");\n           list.add(\"laoliu\");\n           list.add(\"dasima\");\n           System.out.println(\"list=\"+list);\n   //        1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n           System.out.println(\"max num=\"+Collections.max(list));\n   //        2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素\n   //            获取最大长度的值\n           //        3. Object min（Collection)\n   //        4. Object min (Collection，Comparator)同理\n           Object max = Collections.max(list, new Comparator() {\n   \n               @Override\n               public int compare(Object o1, Object o2) {\n                   return ((String) o1).length() - ((String) o2).length();\n               }\n           });\n           System.out.println(\"字符串最大的值为=\"+max);\n   \n   \n   //        5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数\n   \n           System.out.println(\"lailiu=\"+ Collections.frequency(list,\"lailiu\"));\n   //        6. void copy（List dest，List src）：将src中的内容复制到dest中\n              ArrayList oldList =  new ArrayList();\n   //           为了完成一个拷贝，我们需要先给oldList赋值，大小和list一样,不然会报错\n           for (int i = 0; i < list.size(); i++) {\n               oldList.add(\"\");\n           }\n   //        拷贝\n           Collections.copy(oldList,list);\n           System.out.println(\"oldList=\"+oldList);\n   \n   //        7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值\n           Collections.replaceAll(list,\"laoliu\",\"老六\");\n           System.out.println(\"替换后=\"+list);\n       }\n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 总结\n\n在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择分析如下\n\n1）先判断储存类型（一组对象或一组键值对）\n\n2）一组对象[单列]：Collection接口\n\n* 允许重复：List\n  * 增删多：LinkedList（底层维护了一个双向链表）\n  * 改查多：ArrayList（底层维护了Object类型的可变数组）\n* 不允许重复：Set\n  * 无序：HashSet（底层是HashMap，维护了一个哈希表 即（数组+链表+红黑树））\n  * 排序：TreeSet\n  * 插入和取出顺序一直：LinkedHashSet，维护数组+双向链表\n\n3）一组键值对[双列]：Map\n\n* 键无序：HashMap（底层是：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树）\n* 键排序：TreeSet\n* 键插入和取出顺序一致：LinkedHashMap\n* 读取文件：Properties\n\n# 泛型\n\n## 泛型语法\n\n```java\npublic static void main(String[] args) {\n//        1.当我们ArrayList<Dog>表示放到ArrayList集合中的元素只能是Dog类型\n//        2.如果编译器发现添加的类型不满足，就会报错\n        ArrayList<Dog> dogs = new ArrayList<Dog>();\n        dogs.add(new Dog(\"laogou\",12));\n        dogs.add(new Dog(\"xiaogou\",1));\n    }\n//       方便遍历\n        for (Dog dog : dogs) {\n            System.out.println(dog);\n        }\n```\n\n好处：\n\n1. 编译时，检查添加元素的类型，提高了安全性\n2. 减少了类型转换的次数，提高效率\n3. 不再提示编译警告\n\n### 介绍\n\n理解：泛（广泛）型（类型）==> integer，String\n\n可以表示数据类型的数据类型![image-20220509171057972](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171057972.png)\n\n1）泛型又称参数化类型，时jdk5.0出现的新特性，解决数据类型的安全性问题\n\n2）在类声明或实例化时只要制定好需要的具体的类型即可\n\n3）java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮\n\n4）泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型\n\n![image-20220509171249826](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171249826.png)\n\n（此时E称为泛型，那么Dog->E（此时E为 ））\n\n```java\nCat<String> tianyuanmao = new Cat<>(\"tianyuanmao\");\n\nclass Cat<E> {\n    E e;//E表示 e的数据类型，改数据类型在定义Cat对象时指定的，即在编译期间，就确定是什么类型了\n\n    public Cat(E e) {//E也可在参数类型体现\n        this.e = e;\n    }\n    public E method(){//返回类型也可体现\n        return e;\n    }\n\n}\n```\n\n### 语法\n\n泛型的声明\n\n```java\ninterface 接口<T> {}\nclass类<K,V,...>{}(可以接收多个泛型等等)\n说明：\n    1.其中K,V,T不代表值，而是表示类型\n    2.任意字母都可以。常用T表示，是type的缩写\n```\n\n泛型的实例化\n\n```java\n要在类名后面指定类型参数的值（类型）。如\n//1\nList <String> strList = new ArrayList<String>();\n//2\nIterator <Customer> iterator = coustomers.iterator();\n\n```\n\n### 使用细节\n\n1. interface List<T>{},public class HashSet<E>{}....等等\n\n   1. 说明：T，E只能是引用类型\n   2. 不能是基本数据类型（八大基本数据类型,int,double 等等）\n\n2. 在指定泛型具体类型后，可以传入该类型或者其子类类型\n\n3. 泛型适用形式\n\n   1. ```java\n      List<integer> list1 =new ArrayList<Integer>{}\n      \n      List<Integer> list2 = new ArrayList<>();\n      ```\n\n4. 如果我们这样写List list3 = new ArrayList（）；默认给它的泛型是[<E> E就是Object 类型]\n\n   \n\n\n\n## 自定义泛型\n\n### 泛型类\n\n**基本语法**\n\n```java\nclass 类名<T,R....>{\n成员\n}\n```\n\n细节：\n\n1. 普通成员可以使用泛型（属性，方法）\n\n2. 使用泛型的数组，不能初始化\n\n3. 静态方法中不能使用类的泛型‘\n\n   1. 因为静态是和类相关的，在类加载时，对象还没创建\n   2. 所以，如果静态方法和静态属性使用泛型时 ，JVM就无法完成初始化\n\n4. 泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）\n\n5. 如果在创建对象时，没有指定类型，默认为object\n\n6. ```java\n   //1.demo后面有泛型，所以我们吧demo就称为自定义泛型类\n   //2.T,R,M泛型的标识符，一般是单个大写字母\n   //3.泛型标识符可以有多个\n   //4.普通成员可以使用泛型 （属性，方法）\n   //5.使用泛型的数组，不能初始化\n   \t//（因为数组在new的\n   \n   \n   class demo<T,R,M>{\n   String name;\n   T t;\n   R r;\n   M m;\n       T[] t1;//可以声明\n       \n       public demo11(String name, T t, R r, M m) {//构造器使用泛型\n           this.name = name;\n           this.t = t;\n           this.r = r;\n           this.m = m;\n       }\n       //方法使用泛型\n        public String getName() {\n           return name;\n       }\n   \n       public void setName(String name) {\n           this.name = name;\n       }\n   \n       public T getT() {\n           return t;\n       }\n   \n       public void setT(T t) {\n           this.t = t;\n       }\n   \n       public R getR() {\n           return r;\n       }\n   \n       public void setR(R r) {\n           this.r = r;\n       }\n   \n       public M getM() {\n           return m;\n       }\n   \n       public void setM(M m) {\n           this.m = m;\n       }\n   }\n   ```\n\n   \n\n\n\n\n\n### 泛型接口\n\n**基本语法**\n\n```java\ninterface  接口名 <T,R...>{\n\n}\n```\n\n细节：\n\n1. 接口中，静态成员也不能使用泛型\n\n2. 泛型接口的类型，在继承接口或者实现接口时确定\n\n3. 没有指定类型，默认为Object\n\n   \n\n### 泛型方法\n\n**基本语法**\n\n```java\n修饰符<T,R...>返回类型 方法名（番薯列表）{}\n```\n\n**注意细节**：\n\n1. 反省方法，可以定义在普通类中，也可以定义在泛型类中\n\n2. 当泛型方法被调用时，类型会确定\n\n3. public void eat（E e）{}，修饰符后没有<T,R..>eat方法不是泛型方法，而是使用了泛型\n\n4. ```java\n   //泛型方法，可以定义在普通类中，也可以定义在泛型类中\n   class Car{\n       public void run(){//普通方法\n   \n       }\n   //    1.T,R就是泛型标识符\n   //    2.提供给fly方法使用的\n       public <T,R> void  fly(T t, R r){//泛型方法\n   \n       }\n   \n   }\n   ```\n\n5. ```java\n   class Car2<T,R>{//泛型类\n       public <U,M> void  fly(U u, M m){//泛型方法\n       }\n       public void  fly2(T t){\n   //        1.该方法不是泛型方法\n   //        2.是fly2方法使用了类声明的泛型\n       }\n   ```\n\n6. ```java \n   Car car = new Car();\n           car.fly(\"baoma\",2000);\n           //在调用方法是，编译器会自动识别传入的参数的类型，就会确定型\n   ```\n\n7. 泛型方法可以使用类声明的泛型，也可使用自己声明的泛型\n\n## 泛型继承和通配符\n\n**介绍**\n\n1)泛型不具备继承性\n\n```java\nList<Object> list = new ArrayList<String>();\n//是错误的，因为泛型中没有继承性\n```\n\n2）<?>:支持任意泛型类型\n\n3）<? extend A>:支持A类以及 A类的子类，规定了泛型的上限\n\n![image-20220511142709072](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142709072.png)\n\n4）<? super A>:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限\n\n![image-20220511142730306](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142730306.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n  \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n# 知识点补充\n\n## JUnit\n\n1. 一个类有很多功能代码需要测试，为了测试，就需要写入main方法中\n2. 如果有很多个功能代码测试，就需要来回注销，切换很麻烦\n3. 如果可以直接运行一个方法，就会方便很多\n\n### 介绍：\n\n1. \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n# 练习部分\n\n## 快速入门部分\n\n1. 开发一个hello.java文件，输出：老王 is studying java！\n\n   1. ```java\n      public class hello{\n      \tpublic static void main(String[] args) {\n      \tSystem.out.println(\"lao wang is studying java\");\n      \t\n      \t}\n      }\n      ```\n\n   2. 需注意的事项：记得吧类部分带上public class 带上，不要只写个方法\n\n## 制表符部分\n\n1. ![image-20220204140604059](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204140604059.png)\n\n   1. ```java\n      public class ChangeChar {\n          public static void main(String[] args) {\n              System.out.println(\"书名\\t作者\\t价格\\t销量\\n三国\\t罗贯中\\t120\\t1000\");\n          }\n      }\n      ```\n\n## 进制部分\n\n* 第一部分\n\n  ```\n  1. 0b110001100\n     =0*2^0 + 0*2^1 + 1*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 0*2^6 + 1*2^7 + 1*2^8\n     =0+0+4+8+0+0+0+128+256\n     =396\n  02456\n  =6*8^0 + 5*8^1 + 4*8^2 + 2*8^3\n  =6+40+256+1024\n  =1326\n  \n  0xA45\n  =5*16^0 + 4*16^1 + 10*16^2\n  =5 + 64 + 2560\n  =2629\n  ```\n\n## 位运算练习\n\n```\n2|3\n1. 2的原码：00000000 00000000 00000000 00000010\n2. 2的补码：00000000 00000000 00000000 00000010\n3. 3的原码：00000000 00000000 00000000 00000011\n4. 3的补码：00000000 00000000 00000000 00000011\n5.2|3：00000000 00000000 00000000 00000010（都为1结果为1否则为0）\n6. 转为原码：00000000 00000000 00000000 00000010\n7.结果为：2\n\n2^3\n1. 2的原码：00000000 00000000 00000000 00000010\n2. 2的补码：00000000 00000000 00000000 00000010\n3. 3的原码：00000000 00000000 00000000 00000011\n4. 3的补码：00000000 00000000 00000000 00000011\n5.2^3:00000000 00000000 00000000 00000001(两位一个为0，一个为1，结果为1，否则为0)\n6.转为原码：00000000 00000000 00000000 00000001\n7.结果为1\n```\n\n## switch练习\n\n1. ![image-20220225162131420](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162131420.png)\n\n   * ![image-20220225162214945](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162214945.png)\n\n2. 3,4,5为春季。6，7，8，为夏季，9,10,11位秋季。12,1,2为冬季\n\n   * ```java\n     Scanner scanner = new Scanner(System.in);\n             System.out.println(\"请输入月份\");\n             int month = scanner.nextInt();\n             if (month>0 && month<=12){\n                 switch (month){\n                     case 3:\n                     case 4:\n                     case 5:\n                         System.out.println(\"春季\");\n                         break;\n                     case 6:\n                     case 7:\n                     case 8:\n                         System.out.println(\"夏季\");\n                         break;\n                     case 9:\n                     case 10:\n                     case 11:\n                         System.out.println(\"秋季\");\n                         break;\n                     case 12:\n                     case 1:\n                     case 2:\n                         System.out.println(\"冬季\");\n                         break;\n                 }\n             }else {\n                 System.out.println(\"输入不合法\");\n             }\n     ```\n\n## 数组部分\n\n* 已知数组{10,12,45,90}。添加一个数使该数组依然是升序的\n\n```java\n//方法1：数组扩容➕冒泡排序\n\npackage basics.chapterArray;\n\nimport java.time.OffsetDateTime;\nimport java.util.Scanner;\nimport java.util.concurrent.ForkJoinPool;\n\npublic class exercisesArryHomeWork {\n    /*\n    * 已知数组{10,12,45,90}\n    * 添加一个数使该数组依然是升序的\n    * */\n    public static void main(String[] args) {\n        int[] arr = {10,12,45,90};\n        char key;\n        Scanner scanner = new Scanner(System.in);\n        int inputnum;\n        int tmp;\n\n        do {\n            int[] arr2 = new int[arr.length+1];\n            for (int i = 0; i <arr.length ; i++) {\n                arr2[i] = arr[i];\n            }\n            System.out.println(\"请输入添加一个数\");\n            inputnum = scanner.nextInt();\n            arr2[arr2.length-1] = inputnum;\n            arr = arr2;\n            for (int i = 0; i <arr.length ; i++) {\n                System.out.print(arr[i]+\"\\t\");\n            }\n\n\n            System.out.println(\"是否继续输入? y/n\");\n            key = scanner.next().charAt(0);\n            if (key == 'y'){\n                System.out.println(\"continue\");\n            }else if (key == 'n'){\n                System.out.println(\"end\");\n                break;\n            }else {\n                System.out.println(\"input error\");\n            }\n        }while (true);\n        System.out.println(\"============数组排序==============\");\n        for (int i = 0; i < arr.length-1; i++) {\n            for (int j = 0; j <arr.length ; j++) {\n                if (j>=arr.length-1){\n                    break;\n                }else if (arr[j]<=arr[j+1]){\n                    System.out.println(\"no change\");\n                }else if (arr[j]>=arr[j+1]){\n                    tmp = arr[j+1];\n                    arr[j+1] = arr[j];\n                    arr[j] = tmp;\n                }\n\n            }\n        }\n\n\n        System.out.println(\"=============输出==============\");\n        for (int i = 0; i <arr.length ; i++) {\n            System.out.print(arr[i]+\"\\t\");\n        }\n\n\n\n\n\n    }\n}\n```\n\n方法二：定位➕扩容\n\n ```\n //1. 先定义原数组 \n //2. 遍历数组，如果发现insertnum < arr[i] ,说明i就是要插入的位置\n //3. 如果index 保留 index =i\n //4. 如果遍历完后，没有发现inserNum<=arr[i] ，说明index = arr.length\n 即：添加到arr的最后\n ```\n\n```java\npackage basics.chapterArray;\n\npublic class exercisesArrayHomeWorkmethod2 {\n    public static void main(String[] args) {\n        int[] arr = {10,12,45,90};\n        int insertNum = 23;\n        int index = -1;\n//          数组定位\n//        1.遍历数组\n        for (int i = 0; i <arr.length ; i++) {\n//            2. 如果arr[i]的这个数大于insertNum则表示这个数的位置是要添加的数的位置\n            if (insertNum<=arr[i]){\n//                3. 用index接受这个位置信息\n                index = i;\n                break;\n            }\n        }\n//        4. 数组扩容添加\n        int[] arr2 = new int[arr.length+1];\n//        创建一个j，当插入前半部分时，j指向arr的数组的数不变。\n        for (int i = 0,j=0; i <arr2.length; i++) {\n//            如果i不等于上面得到的i的位置\n            if ( i != index){\n//                则将arr的数赋给对应的新数组\n                arr2[i] = arr[j];\n                j++;\n            }else {\n\n                arr2[i] = insertNum;\n            }\n        }\n        arr = arr2;\n\n        for (int i = 0; i <arr.length ; i++) {\n            System.out.print(arr[i]+\"\\t\");\n        }\n    }\n}\n\n```\n\n\n\n### 二维数组部分\n\n1. ```java\n   //            int[][] arr = {{4,6},{1,4,5,7},{-2}};\n   //          遍历数组,求和\n   ```\n\n   * ```java\n     public static void main(String[] args) {\n      \n            int sum = 0;\n            int[][] arr = {{4,6},{1,4,5,7},{-2}};\n            for (int i = 0; i < arr.length; i++) {\n                for (int j = 0; j <arr[i].length ; j++) {\n                    sum = sum+ arr[i][j];\n                }\n            }\n            System.out.println(sum);\n        }\n     ```\n\n     \n\n## 面向对象部分\n\n```java\npackage basics.method;\n\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class chapterMethod01 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入一个整数\");\n        int num = scanner.nextInt();\n        AA aa = new AA();\n\n//        第一种写法\n//        boolean t = aa.odd(num);\n//        if (t==true){\n//            System.out.println(\"偶数\");\n//        }else {\n//            System.out.println(\"奇数\");\n//        }\n\n        /*\n        * 第二种写法，较为简洁 。后续较为常见\n        *\n        * */\n\n        if (aa.odd(1)){ //1 为true 2为false\n            System.out.println(\"偶数\");\n        }else {\n            System.out.println(\"奇数\");\n        }\n    }\n}\nclass AA{\n    public boolean odd(int a){\n\n//        if (a%2 ==0){\n//\n//            return true;\n//        }else {\n//\n//            return false;\n//        }\n    return a%2==0 ?  true : false;\n    }\n}\n```\n\n### 递归\n\n1、小球迷宫\n\n![image-20220311132440361](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220311132440361.png)\n\n1. 小球得到的路径和程序员设置的策略有关，即找到的上下左右的顺序相关\n2. 再得到小球路径时，可以先使用（下右上左），再改成（上右下左）\n\n```\n1. 先用二维数组创建迷宫 8行7列\nint[][] map =new int[8][7];\n2.先规定map数组，0表示可以走，1表示障碍物\n3. 将最上的一行，和最下面的一行。设置为1\nfor(int i=0;i<7;i++){\n\tmap[0][i]=1;\n\tmap[7][i]=1\n}\n```\n\n```java\npackage com.smms.demo.method;\n\npublic class homeworkForMaze {\n    public static void main(String[] args) {\n        //1. 先创建迷宫\n        int[][] map = new int[8][7];\n        //2. 定义数组\n        for (int i1 = 0; i1 <7 ; i1++) {\n            map[0][i1] = 1;\n            map[7][i1] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n        map[3][1]=1;\n        map[3][2]=1;\n\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[i].length; j++) {\n                System.out.print(map[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n        System.out.println(\"==================分割线======================\");\n\n        System.out.println(\"use findWay\");\n        T t = new T();\n        t.findWay(map,1,1);\n        System.out.println(\"out print\");\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j <map[i].length ; j++) {\n                System.out.print(map[i][j]+\"\\t\");\n\n            }\n            System.out.println();\n\n        }\n    }\n}\n\n// 使用递归回溯的思想解决该题\n/*\n1.创建findway方法\n2.如果找到，就返回true ，否则返回false\n3.map就是二维数组，即表示迷宫\n4.i,j 就是老鼠的位置，初始化的位置为(1,1)\n5.因为我们使用的是递归找路，所以先规定map内值的含义\n0 表示可以走，1表示障碍物，2表示可以走，3表示走过\n6.当map[6][5] =2就说明找到了通路，就可以结束，否则就继续\n\n7.定下找路的策略，下->右->上->左\n*\n* */\nclass T{\n    public boolean findWay(int[][] map,int i,int j){\n        if (map[6][5]==2){\n            return true;\n        }else {\n            if (map[i][j]==0){\n//                标记可以走通为2\n//                假定可以走通\n                map[i][j]=2;\n    //  找路策略,下->右->上->左\n                if (findWay(map,i+1,j)){\n                    return true;\n                }else if (findWay(map,i,j+1)){\n                    return true;\n                }else if (findWay(map,i-1,j)){\n                    return true;\n                }else if (findWay(map,i,j-1)){\n                    return true;\n                }else {\n                    map[i][j] =3;\n                    return false;\n                }\n            }\n            return false;\n        }\n    }\n}\n\n```\n\n2、汉诺塔\n\n```java\nclass A{\n    public void move(int num,char a,char b, char c){\n        if (num==1){\n            System.out.println(a+\"->\"+c);\n        }else {\n//            如果有多个盘num，可以直接看成2个，最下边的和最上边的\n//            1.先移动上面的盘子到b，借助c\n            move(num-1,a,c,b);\n//            2.吧下面的盘子移动到c\n            System.out.println(a+\"->\"+c);\n//            3.再把b塔的所有盘，移动到c，借助a\n            move(num-1,b,a,c);\n        }\n    }\n}\n```\n\n## 集合\n\n1）分析HashSet和TreeSet分别如何实现去重\n\n1. HashSet的去重机制：hahsCode()+equals()，底层先通过存入对象，进行运算得到一个hash值，通过hash得到对应的索引，如果发现table索引所在的位置没有数据直接存放，如果有数据，就进行equals比较（equals可由程序员重写），如果比较厚，不相同，就加入，相同就不加入\n2. TreeSet去重机制：如果传入了一个Comparator匿名对象，就使用实现Comparator去重，如果方法返回为0，就认为相同的元素/数据，就不添加。如果没有传入Comparator对象，则以添加的对象实现的Compareable的compareTo去重\n\n# 注意事项\n\n1. 一个java文件中只能有一个public类，其他类的个数不限\n   1. public的类名必须和文件名相同\n   2. 编译后每一个类都对应一个class文件\n2. equals方法两种书写方式\n   1. name.equals(\"xxx\");\n   2. \"xxx\".eqauls(name); //推荐这一种，可以避免空指针\n\n\n\n## \n\n\n\n# 面试题\n\n**相关可能问道的面试题目**\n\n1、 JDK、JRE、JVM的关系\n\n1. JDK = JRE + java开发工具\n2. JRE =  JVM ＋ 核心类库\n\n2、 环境变量path的作用\n\n1. 使dos界面能够使用java和javac 等命令\n2. 先配置JAVA_HOME 指向JDK主目录\n3. path根据JAVA_HOME 寻找其子目录\n\n3、 为什么计算机都是以补码的方式运行的\n\n* 因为它将正数负数都统一起来了\n\n4、 new一个对象时，此时内存里发生了什么？\n\n1. 先在方法区创建Person类\n2. 在堆中开辟一个空间，内部存放形参\n   1. 先初始化默认值，0和null，然后再将值赋进去\n   2. 当执行到构造器的时候，值才会赋进去\n   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值\n3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)\n4. ![image-20220314215432778](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png)\n\n\n\n","source":"_posts/java基础笔记.md","raw":"---\ntitle: java基础笔记\ncomments: true\ntoc: true\ndate: 2022-10-27 12:40:00\ncategories:\n  - 学习笔记\n  - java\ntags: java\npic:\n---\n\n#   java基础\n\n这是快速复习java基础的笔记\n\n## 重要编程思想\n\n**化繁为简**：现将复杂的功能转变成简单的需求。\n\n先死后活：有限考虑固定的值，再考虑变量。\n\n\n\n\n\n\n\n# java概述\n\n知识点：\n\n## [快速练习](##快速入门部分)\n\n1. 使用黑窗口编译.java文件时，注意要把需要编译的java文件编码设置与cmd黑窗口编码相同\n\n2. ```java\n   javac hello.java //编译指令\t\t\t\n   ```\n\n3. ```java\n   java hello //运行指令\t\n   //注意不要带文件后缀，否则报错\n   ```\n\n4. java执行流程分析\n\n   1. ![image-20220204113338135](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204113338135.png)\n\n## [制表符](##制表符部分)\n\n1. ```\n   \\t 一个制表位，实现对其功能\n   \\n 换行符，\n   \\\\ 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠\n   \\\t\\将\"\"：号输出显示出来，在前面添加\\\" \\\" 也可转义其他符号例如'\n   // \\r 表示一个回车 例如：System.out.println(\"韩顺平教育\\r北京\");\n   \t\t// 执行步骤：\n   \t\t// \t1. 先输出韩顺平教育\n   \t\t//  2. 执行回车后，相当于光标来到了最开头\n   \t\t//  3. 再输出北京\n   \t\t//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了\n           可以加个\\n换行防止覆盖\n   \n   ```\n\n2. ````java\n   class ChangeChar{\n   \tpublic static void main(String[] args){\n   \t\t// \\t 一个制表位，实现对其功能\n   \t\tSystem.out.println(\"beijing\\tshanghai\\tguangzhou\");\n   \t\t// \\n换行\n   \t\tSystem.out.println(\"jack\\nlisa\\nnino\");\n   \t\t// \\\\ 输出一个斜杠\\ \n   \t\t// 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠\n   \t\tSystem.out.println(\"c\\\\a\\\\v\\\\b.exe\");\n   \t\t// \\将\"\"：号输出显示出来，在前面添加\\\" \\\"\n   \t\tSystem.out.println(\"老王说：\\\"hello\\\"\");\n   \t\t// \\r 表示一个回车 System.out.println(\"韩顺平教育\\r北京\");\n   \t\t// 执行步骤：\n   \t\t// \t1. 先输出韩顺平教育\n   \t\t//  2. 执行回车后，相当于光标来到了最开头\n   \t\t//  3. 再输出北京\n   \t\t//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了\n   \t\tSystem.out.println(\"韩顺平教育\\r\\n北京\");\n   \n   \t}\n   }\n   ````\n\n# 注释\n\n1. 文档注释\n\n   1. ```\n      javadoc -d 路径文件 -xx -yy xxx.java\n      生成文档命令\n      xx yy 分别代码javadoc标签命令 例如-auther -version等\n      ```\n\n   2. ```java\n      @author 标明开发该类模块的作者 \n      @version 标明该类模块的版本 \n      @see 参考转向，也就是相关主题 \n      @param 对方法中某参数的说明 \n      @return 对方法返回值的说明 \n      @exception 对方法可能抛出的异常进行说明 \n      \n      @author 作者名 \n      @version 版本号\n      其中，@author 可以多次使用，以指明多个作者，生成的文档中每个作者之间使用逗号 (,) 隔开。@version 也可以使用多次，只有第一次有效 \n      \n      使用 @param、@return 和 @exception 说明方法 \n      这三个标记都是只用于方法的。@param 描述方法的参数，@return 描述方法的返回值，@exception 描述方法可能抛出的异常。它们的句法如下： \n      @param 参数名 参数说明 \n      @return 返回值说明 \n      @exception 异常类名 说明 \n      \n      ```\n\n# 变量\n\n## 数据类型\n\n### 变量\n\n1. 变量本质就是一个变化的值。\n\n2. 变量有三个基本要素\n\n   1. 类型\n   2. 名称\n   3. 值\n\n3. ```java\n   public static void main(String[] args){\n   \tint a=1;\n   \t//定义了一个变量，类型为int，名称为a，值为1\n   \ta=89;\n       //把89这个值赋给了a变量\n   }\n   ```\n\n4. 注意事项：\n\n   * 变量表示内存中的一个储存区域，[不同的变量，类型不同，占用的空间大小不同，比如：int 4个字节，double 8个字节]\n   * 该区域有自己的名称[变量名]和类型[数据类型]\n   * 变量必须先声明，后使用，有着自身的顺序\n   * 该区域的数据可以在同一类型范围内不断变化\n   * 变量在同一个作用域内不能重名\n   * 变量=变量名+值+数据类型，变量三要素\n\n### 运算符\n\n1. +号的使用\n   * 当左右两边为数值类型的时候，做加法运算\n   * 当左右两边有一方为字符串类型时，做拼接运算\n\n### 数据类型\n\njava数据类型\n\n1. 基本数据类型\n\n   * 数值型\n     * 整数类型，存放整数（byte[1],short[2],int[4],long[8])\n     * 浮点（小数）类型（float[4]，double[8])\n   * 字符型（char[2]），存放单个字符'a'\n   * 布尔型（Boolean[1]），存放true，false\n\n2. 引用数据类型（面向对象部分讲解）\n\n   * 类（class）\n   * 接口（interface）\n   * 数组（[]）\n\n3. 八大基本数据类型\n\n   【byte，short，int，long，float，double】，char，Boolean\n\n4. 浮点数据类型\n\n   1. 默认情况下输入的字符默认是double类型的\n\n   2. 如果想改成float类型需要在数值后面加上f或F\n\n   3. ```java\n      float a = 1.1 //错误\n      float a = 1.1F //正确\n      double b = 1.1\t//正确\n      double b = 1.1F\t//正确\n      ```\n\n   4. 平时使用默认的double类型就行，因为更为精确\n\n   5. 浮点数使用陷阱\n\n      * ```java\n        //例如\n        //2.7和8.1/3 比较\n        double a = 2.7 ;\n        double b = 8.1/3 ;//理论上数学得数是2.7\n        System.out.println(a);//2.7\n        System.out.println(b);//得数是一个接近2.7的一个小数，而不是2.7\n        //因为计算机计算机制的问题，不是数学的问题。\n        所以在做相等判断时需要小新\n        ```\n\n      * ```java\n        //类似问题的解决方法\n        double a = 2.7 ;\n        double b = 8.1/3 ;//理论上数学得数是2.7\n        System.out.println(a);//2.7\n        System.out.println(b);\n        \n        if(a == b){\n        //这样的写法会出问题\n        \tSystem.out.println(\"相等\");\n        }\n        \n        //可以使用计算其差值\n        if(Math.abs(a-b)<0.001){\n        \tSystem.out.println(\"差值非常小，到我规定的精度内，认为相等\");\n            \n           // Math方法调用java API\n           \n        }\n        ```\n\n5. 字符类型\n\n   1. char的本质就是一个整数，默认用的是Unicode编码\n   2. 字符常量用单引号引出来，\n      * 例：char a = 'a';\n      * char b = '/n';\n   3. 不能输入双引号，否则会认成字符串，会报错。\n   4. char类型时可以运算的。\n\n   字符型的本质\n\n   * 字符型储存到计算机中，需要将对应的码值（整数）找出来\n\n   * 字符和码值的对应关系是通过字符编码表决定的（是规定死的）\n\n   * ![image-20220205221255475](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220205221255475.png)\n\n6. 布尔类型\n\n   1. 只占一个字节，只允许true和false\n   2. 用于判断操作\n   3. 不可用0或非0 来代替true或false，c语言可以\n\n## 数据类型转换\n\n### 1、自动类型转换\n\n* 精度小的类型自动转换为精度大的数据类型，反之就会报错。\n\n* char < int < long < float < double \n\n* byte < short < int < long < float < double\n\n* ```java\n  //例：\n  int num = 'a';\n  ```\n\n1. 注意事项\n\n   1. 多重类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的哪种数据类型，然后再进行计算\n\n    ```java\n     //例\n     int n1 = 10;\n     float d1 = n1+1.1;\n     //这是错误的，因为转换成最大单位，1.1默认的类型是double类型的，如果是n1＋1.1f 的话就是正确的\n     double d1 = n1+1.1;\n     // 这是正确的；\n    ```\n\n   2. （ byte , short ) 和 char之间不会相互转换，当把一个具体的数赋给byte时。\n\n      1. 先判断该数是否在byte范围内，如果是就可以\n\n   3. byte，short，char 三者可以进行计算，在计算时都会先转换成int类型\n\n      * ```java\n        byte b1 = 1;\n        byte a1 = 1;\n        short b2 = 1;\n        short s2 = b1 + b2//错误\n        //因为计算时会转换成int类型，int不能再赋给比它小的类型short\n        int s2 = b1 + b2 //正确\n        byte s3 = a1 + b1//错误\n        //byte，short，char,只要涉及计算都会转换为int类型，所以错误\n        ```\n\n   4. 布尔类型 ( boolean ) 不参与类型转换\n\n   5. 自动提升原则：表达式结果的类型自动提升为 操作数中最大的类型。\n\n### 2、强制类型转换\n\n1. 简介\n\n   1. 大的数据类型转换为小的数据类型\n   2. 使用时要加上强制转换字符（类型）\n   3. 可能会出现精度降低和溢出问题\n\n2. 注意细节\n\n   1. 将数据从大到小转换，需要强制转换\n\n   2. ```java\n      //强制转换符只对最近的操作数有效，也就是只对下边的10数字有效，转换后再进行计算又会转换成double类型。\n      int x = (int)10*3.5+6*1.5;//提示编译错误，类型是double ->\n      \n      int x = (int)(10*3.5+6*1.5);//用小括号括起来即可完美解决上述问题\n      ```\n\n3、基本数据类型和String类型的转换\n\n1. 介绍\n\n   1. 在程序开发中，我们经常需要吧基本数据类型转换成String类型，或String转基本数据类型\n\n2. 方式\n\n   * 基本转String\n\n     * 基本数据类型的值+\" \" \n\n     * ```java\n       //例\n       int n1 = 123;\n       float f = 2.3f;\n       double b = 4.5;\n       String str1 = n1 +\" \";\n       String str2 = f +\"\";\n       String str3 = b +\"\";\n       \n       ```\n\n   * String 转基本\n\n     * 调用基本类型的包装类方法parseXXX 方法即可\n\n     * ```java\n       String s5= \"123\";\n       integer.parseInt(s5);\n       Double.parseDouble(s5);\n       Float.parseFloat(s5);\n       //怎么吧字符串转成字符char，含义是指吧字符串的第一个字符得到\n       system.out.println(s5.charAt(0));//获取字符串的第一个字符\n       //所以这个输出的值为1\n       ```\n\n3. 注意事项\n\n   1. string转换基本类型时，要确保string类型能够转成有效数据，可以吧'123'转换成一个整数，但不能吧\"hello\"转换成一个整数\n\n# 运算符\n\n## 运算符\n\n### 1.简介\n\n1. 是一种特殊符号，表示数据的运算、赋值和比较等\n2. 种类\n   * 算数运算符\n   * 赋值运算符\n   * 关系运算符(比较运算符)\n   * 逻辑运算符\n   * 位运算符 [ 需要二进制基础 ]\n   * 三元运算符\n\n### 2.算数运算符\n\n1. 对数值类型的变量进行运算的\n2. 预览：![image-20220211161920431](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220211161920431.png)\n3. 注意事项\n   * 取模\n   * <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">再%的本质，看一个公式 a % b = a-a / b * b</span>\n4. 面试题\n   1. ![image-20220213151013682](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213151013682.png)\n      1. 答案为 1\n         * 运行步骤为\n         * (1)先把 i 的值赋给一个临时变量tmp\n         * (2)再进行计算i++，结果为i=2\n         * (3)tmp的值重新赋给i，此时i =1\n      2. 答案为2\n         * 运行步骤为\n         * (1)再进行计算i++，结果为i=2\n         * (2)再将2移到临时变量tmp\n         * (3)tmp赋给 i\n\n### 3.关系运算符（比较运算符）\n\n1. 介绍\n   * 关系运算符的结果都是boolean型，\n   * 通常用在if条件语句结构条件中\n   * 关系运算符组成的表达式成为关系表达式\n2. 预览图\n\n![image-20220213162614379](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213162614379.png)\n\n\n\n### 4.逻辑运算符\n\n预览：\n\n1. ![image-20220213170452994](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170452994.png)\n\n2. ![image-20220213170753311](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170753311.png)\n\n3. ![image-20220213170926798](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170926798.png)\n\n4. ```\n   &&（短路与）\t只有两个条件都为true ，才为true\t//如果第一个条件为false，则后面的条件不执行，直接输出flase，效率高\n   \n   &\t（逻辑与）\t只有两个条件都为true ，才为true\t//两个条件都执行，效率低\n   ```\n\n5. ![image-20220214140501385](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220214140501385.png)\n\n6. ```java\n   取反\n   真变假，假变真\n   //a^b :叫逻辑异或，当a和b不同时，结果为true，否侧为false\n   例：\n   \tboolean b = (10>1) ^ (3<5);\n   \tSystem.out.println(\"b=\"+b);//f\n   ```\n\n### 5.赋值运算符（=）、\n\n分类：\n\n* 基本赋值运算符 = \tint a = 10；\n\n* 复合赋值运算符\n\n  ```\n  +=，-=，*=，/=，%=等等，\n  例：a += b;[等价 a=a+b;]\n  \ta -=b;[等价 a = a-b;]\n  一般情况加复合赋值运算符，前边都有基本赋值运算符\n  ```\n\n* 复合运算符会进行类型转换\n\n  ```java\n  byte a =3;\n  a += 2; //此时计算结果为int类型\n  //不会报错，因为会自动进行类型转换\n  \n  //不能直接写成\n  a=a+2; //会报错\n  \n  // 像a++，++a这种会都进行自动的类型转换\n  ```\n\n### 6.三元运算符\n\n* 语法：条件表达式？ 表达式1: 表达式2；\n\n* 运算规则：\n\n  1. 如果条件表达式为true，运算后的结果是表达式1；\n\n  2. 如果条件表达式为false，运算后的结果是表达式2；\n\n     口诀：【一灯大师：一真大师（如果为真，返回1）】\n\n  3. 例：\n\n     ```java\n     int a = 10 ;\n     int b = 99 ;\n     // 1.如果 结果为false\n     // 2.返回b--，先返回b，再进行b-1。依旧按照之前的a++,++a的计算形式\n     // 3.结果为99\n     int result = a > b ? a++; b--;\n     //如果a>b 为真，返回a++，如果为false返回b--;\n     \n     ```\n\n  4. 本质就是if，else语句\n\n### 7.运算符优先级\n\n* ![image-20220215150928654](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220215150928654.png)\n* 小结：优先级排名\n  1. () ，{}等优先级最高\n  2. 单目运算==a ，--a等；\n  3. 算术运算符+-\n  4. 位移运算符\n  5. 比较运算符\n  6. 逻辑运算符\n  7. 三元运算符\n  8. 赋值运算符\n\n## 标识符\n\n**标识符的规则和规范**\n\n1. java中对各种变量、方法和类的命名使用的字符成为标识符。\n\n* ```java\n  int num =1;\n  // num就是标识符\n  ```\n\n2. 标识符的命名规则必须遵守\n   * 标识符由26个字母的大小写，0-9，_或$符组成。\n   * 不可以用数字开头\n   * 不可以使用关键字和保留至，但能包含关键字和保留字\n   * 标识符不能包含空格\n3. 标识符命名规范\n   * 包名：多单词组成时，所有字母都小写。例：aaa.bbb.ccc\n   * 类名、接口名：多单词组成是，所有单词首字母大写，驼峰命名法\n   * 变量名、方法名：多单词组成时，第一个单词首字母小写，后面单词的首字母大写。例：aaBbCc\n   * 常量名：所有字母都大写。多单词时用下划线隔开。例：A_B_C\n\n##   键盘输入语句\n\n### 1.介绍\n\n在编程过程中需要接受用户的输入数据，可以使用键盘输入语句来获取。input.java，需要一个扫描器（对象），就是Scanner\n\n### 2.步骤\n\n1）导入该类所在的包，java.utill.*\n\n2）创建该类对象（声明变量）\n\n3）调用里面的功能\n\n### 3.案例\n\n```java\npublic class KeyboardInput {\n    public static void main(String[] args) {\n//        创建Scanner对象\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.println(\"请输入文本1\");\n//        z字符串类型\n        scanner.next();\n        System.out.println(\"请输入age\");\n//        nextint 代表接收一个int类型的输入\n        scanner.nextInt();\n//        接收double类型的\n        scanner.nextDouble();\n\n    }\n\n```\n\n\n\n\n\n## 进制\n\n### 介绍\n\n对于整数，有四种表达方式\n\n* 二进制（Bin/B）：0,1，满2进1，以0b或0B开头\n\n* 八进制（OCT/O）：0-7，满8进1。以数字0开头表示\n\n* 十进制（DEC/D）：0-9，满10进1\n\n* 十六进制（HEX/H）：0-9及A(10)-F(15)，满16进1.以0x或0X开头表示。此处的A-F不区分大小写\n\n* ```java\n  int n1 = 0b1010;\n  int n2 = 01010;\n  int n3 = 1010;\n  int n4 = 0x10101;\n  ```\n\n  \n\n### 进制转换（基本功）*\n\n第一组\n\n1. 二进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和\n\n   * ```\n     例\n     0b 1011  =1*2^0+1*2^1+0*2^2+1*2^\n     = 1+2+0+8\n     =11\n     \n     ```\n\n2. 八进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和。\n\n   * ```\n     例：0234转成十进制\n     0 234\n     =4*8^0 + 3*8^1 + 2*8^2 \n     =4+24+128\n     =156\n     ```\n\n3. 十六进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和\n\n   * ```\n     例：0x 23A转成十六进制\n     =10*16^0 + 3*16^1 + 2*16^2\n     =10 + 48 + 512\n     =570\n     A(10),B(11),C(12),D(13),E(14),F(15)\n     ```\n\n[第一部分练习](###进制部分)\n\n第二组\n\n1. 十进制转二进制\n\n   * 规则：将该数不断除2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制\n\n   * ```\n     将34转换成二进制\n     34%2\t余0\n     17%2  余1\n     8%2\t\t余0\n     4%2\t\t余0\n     2%2\t\t余0\n     1%2\t\t余1\n     反着读\n     结果：0b100010 //前缀0b的意思为二进制\n     正确答案为：0b00100010\n     因为一个字节二进制的是八位，34的出的结果是六位所以前面需要多加两个0\n     ```\n\n2. 十进制转八进制\n\n   * 规则：将该数不断除8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的八进制\n\n   * ```\n     例：将131转为八进制\n     131%8\t\t余3\n     16%8\t\t余0\n     2%8\t\t\t2\n     结果为0203前面的0代表的意思是八进制\n     ```\n\n3. 十进制转十六进制\n\n   * 规则：将该数不断除16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的十六进制\n\n   * ```\n     例：237\n     答案为 ED\n     ```\n\n   * ![image-20220216221217568](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220216221217568.png)\n\n第三组\n\n1. 二进制转八进制\n\n   * 规则：从低位开始，将二进制数的每三位一组，转成对应的八进制数即可\n\n   * ```\n     例：0b 11010101 每三个转成十进制再拼起来\n     =325\n     11100101\n     =345\n     ```\n\n2. 二进制转十六进制\n\n   * 从低位开始，将二进制数的每四位一组，转成对应的十六进制即可\n\n   * ```\n     11010101\n     =0xD5\n     1110010110\n     =0x396\t每四个转成十进制再拼起来\n     ```\n\n第四组\n\n1. 八进制转二进制\n\n   * 规则：将八进制数每一位，转成对应的3位的二进制数\n\n   * ```\n     237  每位以十进制转二进制转成对应的3位二进制数再连起来\n     2（010）3（011）7（111）\n     =010011111\n     \n     1230\n     =1(001)2(010)3(011)0(000)\n     =001010011000\n     ```\n\n2. 十六进制转二进制\n\n   * 规则：将八进制数每一位，转成对应的4位的二进制数\n\n   * ```\n     23B\n     =2(0010)3(0011)B(1011)\n     =001000111011\n     AB29\n     =A(1010)B(1011)2(0010)9(1001)\n     =1010101100101001\n     ```\n\n源码，反码，补码（重点）\n\n对于有符号的数而言（八个规则）：\n\n1. 二进制的最高位是符号位：0表示正数，1表示负数（口诀：0 - >0   1-> -）\n2. 正数的原码，反码，补码都一样（三码合一）\n3. 负数的反码 = 它的原码符号位不变，其他位取反（0->1,1->0）0变1,1变0.\n4. 负数的补码 = 它的反码+1，负数的反码 = 负数的补码-1\n5. 0的反码，补码都是0\n6. java没有无符号的数，换而言之，java中的数都是有符号的\n7. 计算机运算的时候，都是以 <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">补码的方式来运算的</span>\n8. <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">当我们看运算结果的时候，要看它的原码（！！！）</span>\n\n\n\n## 位运算\n\n* java中有七个位运算符（&，|，^，~，>>，<<和>>>）\n\n* 分别是：\n\n  * &：按位与\n\n    * 规则：两位全为1，结果为1，否则为0\n\n    * ```\n      例：\n         10011010\n        &11011101\n      -------------\n        =10011000// 两个都1结果才为1\n      ```\n\n  * |：按位或\n\n    * 规则：两位有一个为1，结果为1，否则为0\n\n    * ```\n          10011010\n        &11011101\n      -------------\n        =11011111// 两个有一个1结果才为1\n      ```\n\n  * ^：按位异或\n\n    * 规则：两位一个为0，一个为1，结果为1，否则为0\n\n    * ```\n      10011010\n      &11011101\n      ```\n\n    -------------\n\n        =01000111// 两位一个为0，一个为1，结果为1，否则为0\n\n      ```\n    \n      ```\n\n  * ~：按位取反\n\n    * 规则：0为1,1为0\n\n```\n//位移运算\nint a = 1>>2; // 1 向右位移2位\nint b = -1>>2;\nint c = 1<<2; //左移 2位\nint d = -1<<2;\nint e = 3>>>2;//无符号右移\n\n\n```\n\n[练习部分](##位运算练习)\n\n```\n2&3计算机计算流程（计算机是按照补码进行计算的）\n因为一个字节是八位，一个int类型有4个字节\n1.先得到2的补码 ===>* 源码00000000 00000000 00000000 00000010 //得到原码\n* 转成补码（正数的三码都一样）\n00000000 00000000 00000000 00000010\n2. 得到3的补码 ====>先获得原码00000000 00000000 00000000 00000011\n得到3的补码\n00000000 00000000 00000000 00000011\n\n3.计算2&3\n补码结果为：00000000 00000000 00000000 00000010\n原码也为：00000000 00000000 00000000 00000010\n最终结果为：2\n```\n\n````\n~-2计算过程\n1. 得到-2的原码10000000 00000000 00000000 00000010\n2. 算出-2的反码11111111 11111111 11111111 11111101（原符号位保持不变，其他取反）\n3. 算出-2的补码11111111 11111111 11111111 11111110\n4.再进行~-2操作00000000 00000000 00000000 00000001//运算后的补码\n5.转为原码00000000 00000000 00000000 00000001\n6.结果为1\n````\n\n```\n~2的计算过程\n1.得到2的原码00000000 00000000 00000000 00000010\n2.获取补码：00000000 00000000 00000000 00000010\n3.计算~2:11111111 11111111 11111111 11111101\n3.转为反码（）负数的反码=补码-1\n11111111 11111111 11111111 11111100\n4.转为原码：10000000 00000000 00000000 00000011\n5.结果为-3\n```\n\n* 运算符>>，<<和>>>运算规则\n\n  * 算数右移>>；低位溢出，符号位不变，并用符号位补溢出的高位\n\n    * ```\n      int a = 1>>2;\n      1:00000000 00000000 00000000 00000001\n      1 >>2 //相当于把最后边的01去掉用符号位补上\n      结果：00000000 00000000 00000000 00000000\n      最后结果为0\n      \n      简便的方法\n      1>>2 = 1/2/2= 0\n      15>>2 = 15/2/2=3  //取整\n      ```\n\n  * 算数左移<<; 符号位不变，低位补0\n\n    * ```\n      int a =1<<2;\n      1:00000000 00000000 00000000 00000001\n      1<<2\n      00000000 00000000 00000000 00000100\n      结果为4\n      \n      简便的方法\n      1<<2 =1*2*2 = 4\n      4<<3 = 4*2*2*2 = 32\n      \n      ```\n\n  * 3.>>>逻辑右移，也叫无符号右移，运算规则是：低位溢出，高位补0\n\n# 程序控制结构\n\n## 顺序控制（if,else,switch）\n\n### 介绍\n\n程序从上到下逐行执行，中间没有任何判断和跳转\n\n### 分支控制\n\n### **1）单分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块;\n}\n```\n\n说明：当条件表达式为true时，则执行{}内的代码。false就不执行。如果只有一条执行语句，可以省略{}。但不建议省略\n\n### **2）双分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块1;\n}else{\n\t执行代码块2;\n}\n```\n\n\n\n### **3）多分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块1;\n}else if(条件表达式){\n\t执行代码块2;\n}else{\n\t执行代码块....;\n}.....\n```\n\n流程图：\n\nelse只能有一个执行入口\n\n![image-20220222162201564](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220222162201564.png)\n\n特别说明：\n\n1. 多分支可以没有else，如果所有条件都不成立，则一个执行入口都没有\n2. 如果有else，如果所有的条件表达式都不成立，则默认执行else代码块。\n\n练习：\n\n```java\npublic class ifChapter {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入0-100的数字\");\n        int num = scanner.nextInt();\n        if (num<1 && num>100){\n            if (num==100){\n                System.out.println(\"信用极好\");\n            }else if (num>80 && num <= 99){\n                System.out.println(\"信用优秀\");\n            }else if (num >= 60 && num <= 80){\n                System.out.println(\"信用一般\");\n            }else if (num <60){//或直接不写这个条件语句，但这个会有bug\n                System.out.println(\"不及格\");\n            }else{\n                System.out.println(\"请输入合法数字\");\n            }\n        }else{\n            System.out.println(\"输入不合法\");\n        }\n    }\n}\n```\n\n### **4）嵌套分支**\n\n介绍：\n\n一个分支完整的嵌套了另一个分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支。\n\n规范：不建议超过三层（可读性不好）\n\n基本语法：\n\n```java\nif(){\n\tif(){\n\t\n\t}else{\n\t\tif.....\n\t}\n}\n```\n\n### 5）switch分支\n\n基本语法：\n\n```java\nswitch(表达式){ //表达式为具体的一个值\n    case 常量1:\n语句块1;\nbreak;\n    case 常量2:\n语句块2;\nbreak;\n    case ······:\nbreak;\n ...........\n       \ndefault :\ndefault语句块\nbreak;\n}\n```\n\n1. switch 关键字,表示swtich分支\n2. 表达式   对应一个值\n3. case常量1：当表达式的值等于常量1，就执行语句块1\n4. break：表示退出switch\n5. 如果case 常量1 匹配，就执行语句块1，如果没有则继续case 常量2；\n6. 如果一个都没有匹配上，就执行default\n\nSwitch流程图：\n\n![image-20220224155515378](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220224155515378.png)\n\n 注意：\n\n* 穿透\n  1. 如果case1 没有break\n  2. 则case不进行判断直接执行case2 的语句块\n\n```java\npublic static void main(String[] args) {\n        char week;\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入字母\");\n        week = scanner.next().charAt(0);\n        switch (week){\n            case 'a':\n                System.out.println(\"Monday\");\n                break;\n            case 'b':\n                System.out.println(\"Tuesday\");\n                break;\n            case 'c':\n                System.out.println(\"Wednesday\");\n            case 'd':\n                System.out.println(\"Thursday\");\n                break;\n            case 'e':\n                System.out.println(\"Friday\");\n                break;\n            case 'f':\n                System.out.println(\"Saturday\");\n                break;\n            case 'g':\n                System.out.println(\"sunday\");\n                break;\n            default:\n                System.out.println(\"输入有误，请输入a-g的字母\");\n        }\n    }\n```\n\n注意事项和细节\n\n1. 表达式数据类型，应和case后的常量类型一致，或者是可以自动转换成可以相互比较的类型，比如输入的是字符，而常量是int\n\n2. Switch(表达式)中表达式的返回值必须是：（byte，short，int，char，enum，String）\n\n   ```java\n   //比如下列例子，是不可以的\n   double a = 1.1;\n   switch(a){//错误\n   \tcase 1.1://case后面不可以有变量\n   \t\tSystem.out.println(\"···\");\n   \t\tbreak;\n   }\n   ```\n\n3. case子句中的值必须是常量，不能是变量\n\n4. default子句是可选的，当没有匹配的case时，执行default。default语句是可选的，当没有匹配的任何常量，则没有任何输出。\n\n5. break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有则会出现穿透现象，使程序执行后面所有的case语句块，除非遇到break；\n\n6. [练习](##switch练习)\n\n**switch 和if的比较**\n\n1. 如果判断的具体数值不多，而且符合byte，short，int，char，enum，string类型虽然这两个语句都可以用，建议用switch\n2. 其他情况，对区间判断，对结果为boolean配型判断，使用if，if的使用范围更广\n\n## 循环控制（for,while,dowhile,多重循环[重点]）\n\n### 1）for循环\n\n1. 基本语法\n\n   ```java\n   for(循环变量初始化；循环条件；循环变量迭代){\n   \t循环操作；(可多条语句)\n   }\n   \n   ```\n\n   \n\n2. 说明\n\n   1. for关键字，表示循环控制\n   2. for有四要素，1）循环变量初始化，2）循环条件，3）循环操作，4）循环变量迭代\n   3. 循环操作，这里可以有很多条语句，也就是我们要执行的代码块\n   4. 如果 循环操作(语句)只有一条语句，可以省略{}，建议不要省略\n\n例子：\n\n```java\npublic static void main(String[] args) {\n\n        //练习： 打印100句“韩顺平教育”\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"韩顺平教育\" +i);\n        }\n\n\n    }\n```\n\n* for循环流程图\n  * ![image-20220227123857620](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227123857620.png)\n\n#### 注意事项：\n\n* 循环条件返回一个布尔值(Boolean)\n\n* for（；循环条件；）中的初始化和变量迭代可以写到其他地方，但两边的分号不能省略\n\n  * ```java\n    //演示\n    int i = 0;\n    for (i; i < 10;) {\n                System.out.println(\"韩顺平教育\" +i);\n                 i++;\n            }\n    \n    //补充\n    for(;;){//表示一个无限循环\n       System.out.println(\"韩顺平教育\" +i);\n    }\n    ```\n\n* 循环初始值，可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开\n\n  * ```java\n    //例\n    int count =3;\n    for (i =0 ,j = 0 ;i<count; i++, j+=2){\n    \tSystem.out.println(\"i=\"+i \"j=\" +j);\n    }\n    输出 ：00 12 24\n    ```\n\n  * 00 12 24 \n\n#### **编程技巧**\n\n* 化繁为简：将复杂的需求拆解成简单的需求\n* 先死后活：先考虑固定的值，然后转成可以灵活变化的值\n\n**练习**\n\n1. 打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]\n\n   * ```\n     \n     ```\n\n   * ```java\n     //打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]\n           //1、先输出1-100循环\n           //2、在输出的过程中过滤9的倍数\n           //3、定义一个变量来累计计算个数\n           //4、定义一个变量来累计计算总和\n     public static void main(String[] args) {\n             int count= 0;\n             int sum =0;\n             for (int i = 1; i <=100 ; i++) {\n                 if (i%9==0){\n                     System.out.println(\"i=\"+i);\n                     count++;\n                     System.out.println(\"数量\"+count);\n                     sum+=i;// = sum + i\n                     System.out.println(\"sum=\"+sum);\n                 }\n     \n             }\n     ```\n\n### 2）while循环\n\n基础语法：\n\n```java\nwhile（循环条件）{\n\t循环体（语句）；\n\t循环变量迭代；\n}\n```\n\n说明：\n\n1. while循环也有四要素\n2. 只是四要素放的位置，和for不一样\n\n**流程图**\n\n![image-20220227143009846](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227143009846.png)\n\n#### 注意事项：\n\n1. 循环条件是返回布尔值\n2. while循环是先判断再执行语句\n\n\n\n### 3）do...while循环控制\n\n基础语法：\n\n```java\ndo{\n\t循环体(语句);\n\t循环变量迭代;\n}while(循环条件);\n\n```\n\n 说明:\n\n1. do  while 是关键字\n\n2. 也有循环四要素，只是位置不一样\n\n3. 先执行，在判断，也就是说，一定会执行一次\n\n4. 最后有一个分号\n\n5. while和do... while区别\n\n   * while是先判断再执行\n\n   * do .. while是先执行再判断\n\n```java\npublic static void main(String[] args) {\n\n       int i = 1;\n        do {\n            System.out.println(\"阿巴阿巴\");\n            i++;//不要忘记加上，否则容易死循环\n        }while (i<=10);\n\n        System.out.println(\"exit dowhile\");\n    }\n```\n\n\n\n流程图：\n\n![image-20220227163555197](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227163555197.png)\n\n#### 注意事项：\n\n1. 循环条件是返回一个布尔值的表达式\n2. do...while 循环是先执行后判断，因此它至少执行一次\n\n\n\n### 4）多重循环\n\n#### 介绍\n\n1. 讲一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do ...while均可以作为外层循环和内层循环 。【建议一般使用两层，最多不超过三层，否则代码可读性很差】\n\n2. 实质上，嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环\n\n3. 例：设外层循环次数为m次，内层为n次。则内层循环体实际上需要执行m*n次\n\n   ```java\n   for (int i = 0; i < 2; i++) {\n               for (int j = 0; j < 3; j++) {\n                   System.out.println(\"i = \"+i+ \",\"+\"j = \"+j);\n               }\n           }\n   \n   ------------------------输出------------------------\n   i = 0 , j =0\n   i = 0 , j =1\n   i = 0 , j =2\n   i = 1 , j =0\n   i = 1 , j =1\n   i = 1 , j =2\n   ```\n\n   \n\n#### 练习\n\n1. 统计3个班成绩情况，每个班有5名同学，求出各个班的平均成绩和所有班级的平均分【学生的成绩从键盘输入】\n\n   * ```java\n     Scanner scanner = new Scanner(System.in);\n     //        int clss = 1;\n                 int stu =0;\n                 double sum = 0;\n             for (int i = 1; i <=3 ; i++) {\n                 for ( int j = 1;j<=5;j++){\n     \n                     System.out.println(\"请输入\"+i+\"班\"+j+\"成绩\");\n                     int s = scanner.nextInt();\n                     sum = sum + s;\n                 }\n                 System.out.println(i+\"班的平均分为：\"+(sum / 5));\n                 sum =0;\n             }\n     ```\n\n     \n\n2. 打印99乘法表\n\n   * ```java\n     for (int i = 1; i <=9 ; i++) {\n        \n                 for (int j = 1; j <=i ; j++) {\n                     System.out.print(i+\"*\"+j+\"=\"+(i*j)+\"  \");\n     \n     \n                 }\n                 System.out.println(\"\");\n             }\n     ```\n\n3. 打印空心金字塔\n\n   * ```java\n     //        实心金字塔\n             for (int i = 1; i <=5 ; i++) {\n                 for (int k = 1; k <=5-i ; k++) {\n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n     \n                     System.out.print(\"*\");\n                 }\n                 System.out.println(\" \");\n             }\n     ```\n\n   * ```java\n     空心金字塔 【难点】\n             for (int i = 1; i <=5 ; i++) {\n                 for (int k = 1; k <=5-i ; k++) {\n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n                 \n                 \n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n                 \n                 \n     \t\t\t\t//1.空心金字塔的第一层和最后一层的*全部输出\n     \t\t\t\t//2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示\n     \t\t\t\t//3.再加一个条件 i == 5\n     \t\t\t\tif(j == 1 || j == 2*i-1 || i==5 ){\n     \t\t\t\t\t System.out.print(\"*\");\n     \t\t\t\t}else{\n     \t\t\t\t\t System.out.print(\" \");\n     \t\t\t\t}\n     \n     //可以将其中的5 提出来换成变量，实时控制金字塔的层数\n     \n                    \n                 }\n                 System.out.println(\" \");\n             }\n     ```\n\n     \n\n   * ```java\n     //可手动修改的\n     \n           Scanner scanner = new Scanner(System.in);\n           System.out.println(\"请输入层数\");\n           int layer = scanner.nextInt();\n     ```\n\n\n             for (int i = 1; i <=layer ; i++) {\n                 for (int k = 1; k <=layer-i ; k++) {\n    \n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n    \n                     //1.空心金字塔的第一层和最后一层的*全部输出\n                     //2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示\n                     //3.再加一个条件 i == 5\n                     if(j == 1 || j == 2*i-1 || i==layer ){\n                         System.out.print(\"*\");\n                     }else{\n                         System.out.print(\" \");\n                     }\n                 }\n                 System.out.println(\" \");\n             }\n    \n     ```\n   * 改为菱形\n     ```\n\n\n\n## break\n\n介绍\n\n1. 跳转控制语句----->break\n2. 当某个条件满足时，终止循环\n3. break语句用于终止某个语句块的执行，一般用于switch或者循环中\n\n基本语法：\n\n```java\n{\n......\nbreak;\n......\n```\n\n以while循环为例流程图：\n\n![image-20220228111326348](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228111326348.png)\n\n#### 注意事项\n\n1. break语句出现在多层嵌套语句块时，可以通过标签指明要终止的是哪一层语句块\n\n2. 标签的基本使用\n\n   ```java\n   label1:{.....\n   label2:\t\t{.....\n   label3:\t\t\t{.....\n   \t\t\t\tbreak label2;\n   \t\t\n   }\n   \t\n   }\n   \n   }\n   ```\n\n   1. break语句可以指定退出哪层\n   2. label1是标签，由程序员决定\n   3. break后指定到哪个label就退出到哪里\n   4. 在实际开发中，尽量不要使用标签\n   5. 如果没有指定break，默认退出最近的循环体\n\n## continue-跳转控制语句\n\n介绍：\n\n1. <u>**continue语句用于结束本次循环，继续执行下次循环**。</u>\n2. continue语句多出现在多层嵌套的循环语句中时，可以用过标签指明要跳过的是哪一环，这个和前面的标签使用一样\n\n基本语法\n\n```java\n{\n....\ncontinue;\n....\n}\n```\n\n流程图：\n\n![image-20220228153036178](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228153036178.png)\n\n\n\n## return-跳转控制语句\n\n介绍：\n\nreturn使用在方法，表示跳出所在的方法\n\n注意：\n\n1. 如果吧return放在main方法中会退出程序\n\n# 数组【重点】\n\n## 数组\n\n**介绍**\n\n数组可以存放 <u>多个</u>*<u>同一类型</u>* 的数据。数组也是一种数据类型，是引用数据类型。\n\n即：数（数据）组（一组）就是一组数据\n\n<span id = \"数组案例01\">案例</span>（快速入门）：\n\n```java\npublic static void main(String[] args) {\n   \t\t\tdouble totalWeght =0;\n        double[] hen = {1,2,3,4,5,6};\n  //可以通过 for循环访问数组的元素\n        for (int i = 0; i <hen.length ; i++) {\n          //可以通过下标来访问数组的元素 hen[下标]\n          //下标是从0开始的，比如【0，1，2，3】\n          //第二个元素是hen[1]\n    \n            System.out.println(\"第\"+(i+1)+\"个元素的值为\"+hen[i]);\n          totalWeght+=hen[i];\n        }\n  \t\tSystem.out.println(\"总体重为\"+totalWeght+\"平均体重为=\"+(totalWeght/hen.length));\n    }\n```\n\n### 动态初始化\n\n#### 使用方式1\n\n先new出一个数组，再动态的给它赋值。\n\n数组的定义：\n\n数据类型\t数组名[] = new 数据类型[大小]\n\n数据类型[]\t数组名 = new 数据类型[大小]\n\n以上两种写法的效果都是等价的\n\n例：\n\n```java\nint a[] = new int[5];\n\n//创建一个数组，名字为a，长度为5个int\n```\n\n内存图：\n\n![image-20220302092916369](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302092916369.png)\n\n例：\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class chapterArray01 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        //new数组类型时，记得加上数组的长度\n        double[] doubles = new double[5];\n        for (int i = 0; i < doubles.length; i++) {\n            System.out.println(\"请输入第\"+(i+1)+\"个数\");\n            doubles[i] = scanner.nextDouble();\n        }\n        System.out.println(\"========================================\");\n        for (int i = 0; i <doubles.length ; i++) {\n            System.out.println(\"输入的数为\"+doubles[i]);\n\n        }\n    }\n}\n\n```\n\n#### 使用方式2\n\n1. ***<u>先声明数组</u>***\n\n语法：\n\n* 数据类型 数组名[];\t或\t\t数据类型[] \t数组名;\n\n* int a[]  / int[]  a;\n\n2. ***<u>创建数组</u>***\n\n语法：\n\n* 数组名 = new 数据类型 [ 大小 ];\n* a = new int[5];\n\n```java\n//        double[] doubles = new double[5];\n//相当于吧使用方法1给拆分成两个\n//\t1.先声明\n        double doubles[];\n        //2.再创建\n        doubles = new double[5];\n```\n\n解释：1.先声明，在内存中相当于创建了一个空的变量，这时没有任何左右\n\n2.再创建，才使得这个数组有意义。不写的话会报空指针异常\n\n### 静态初始化\n\n语法：\n\n数据类型\t数组名[] = {元素值，元素值，元素值，......}\n\n[案例](#数组案例01)跳转\n\n### 注意事项和细节\n\n1. 数组是多核相同的数据类型的组合，实现对这些数据的统一管理\n2. 数组中的元素可以使任何数据类型，包括基本数据类型和引用数据类型，但不能混用\n3. 数组创建后，如果没有赋值，会有默认值：int 0 , short 0 , byte 0 ,long 0, float 0 ,double 0.0 , char \\u0000, boolean false , String null;\n4. 使用数组的步骤：\n   1. 声明数组并开辟空间\n   2. 给数组各个元素赋值\n   3. 使用数组\n5. 数组的下表是从0开始的 \n6. 数组下表必须在指定范围内使用，否则报：下标越界异常，比如: int[] arr = new int [5] ; 则有效下标为0-4\n7. 数组属于引用数据类型，数组行数据是对象（object）\n8. boolean 类型没有赋值的情况下默认false\n\n### 数组赋值机制\n\n1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响\n\n   ```java\n   //基本数据类型赋值，复制方式为值拷贝\n   int n1 = 2 ; \n   int n2 = n1 ;\n   \n   n2的变化不会影响n1\n       \n   ```\n\n2. 数组再默认情况下是引用传递，赋的值是地址。赋值方式为引用传递\n\n   ```java\n   int[] array1 = {1,2,3}\n   int[] array2 = array1; \n   \n   array2[0] = 10;\n   //此时运行的结果 array1的第0个元素会变成10\n   \n   ```\n\n   \n\n ![image-20220302141207302](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302141207302.png)\n\n### 数组拷贝\n\n案例：\n\n```java\nint[] arr1 = {1,2,3}\n//1. 创建一个新的数组arr2,开辟一个新的数据空间\n//2. 大小 = arr1.length\nint arr2[] = new int[arr1.length];\n\n//遍历arr1到对应的位置\nfor( i = 0; i < arr1.length; i++){\n    arr2[i] = arr1[i];\n}\n\n```\n\njvm内存图分析:\n\n![image-20220302142048498](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142048498.png)\n\n![image-20220302142253236](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142253236.png)\n\n### 数组翻转\n\n案例：\n\n要求：需要把数组的元素内容反转。\n\narr { 1 , 2 , 3 , 4 , 5 }-->{5 , 4 , 3 , 2 , 1}\n\n方式1：\n\n```java\nint[] arr = {11 , 22 , 33 , 44 , 55 , 66};\n\n//1. 把 arr[0] 和 arr[5] 进行交换\n//2. 把 arr[1] 和 arr[4] 进行交换\n//3. 把 arr[2] 和 arr[3] 进行交换\n//4. 一共要交换 3 次 = arr.length\n//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]\n  int temp = 0;\n        int len = arr.length;\n        for (int i = 0; i <len/2 ; i++) {\n            temp = arr[len-1-i];\n            arr[len-1-i] = arr[i];\n            arr[i] = temp;\n        }\n     \n     \n }\n```\n\n方式2\n\n```java\nint[] arr = {11 , 22 , 33 , 44 , 55 , 66};\n//1. 先创建一个arr2\n        //2. 逆序遍历arr，再将每个元素赋给arr2的元素中\n        //3. 增加一个循环变量j\n        int[] arr2 = new int[arr.length];\n\n        for (int i = 0,j=arr.length-1 ; j>=0; i++,j--) {\n            arr2[j] =arr[i];\n\n        }\n//4.当for循环结束，arr2就是一个逆序数组，{66 , 55 , 44 , 33 , 22 , 11}\n//5. 让arr指向arr2数据空间,此时arr原来的数据空间就没有变量引用\n//会被当做垃圾处理\narr = arr2\n    //6. 遍历输出\n  \n        for (int i = 0; i <arr.length ; i++) {\n            System.out.println(arr[i]);\n        }\n```\n\n\n\n### 数组扩容\n\n数组缩减同理\n\n数组添加\n\n要求：实现动态的给数组添加元素效果，实现对数组扩容\n\n1）原始数组使用静态分配int[] arr = {1,2,3}\n\n2）增加的元素4，直接放在数组的最后 arr = {1,2,3,4}\n\n3）用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class chapterArrayAdd {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        char key ;\n        int[] arr1 = {1,2,3};\n\n\n        do {\n            int[] arr2 = new int[arr1.length+1];\n                for (int i = 0; i < arr1.length; i++) {\n                    arr2[i] = arr1[i];\n                }\n                System.out.println(\"请输入一个要添加的值\");\n                arr2[arr2.length - 1] = scanner.nextInt();\n\n            arr1 = arr2;\n\n            System.out.println(\"是否继续添加？请输入y/n\");\n            key = scanner.next().charAt(0);\n\n            if (key=='y'){\n                System.out.println(\"继续增加\");\n            }else if (key== 'n'){\n                System.out.println(\"跳出\");\n                break ;\n            }else {\n                System.out.println(\"输入不合法\");\n            }\n//            将arry1的地址指定到arry2的地址，此时原arry1的地址被没有变量引用，所以被jvm销毁\n\n        }while (true);\n\n        for (int i = 0; i < arr1.length ; i++) {\n            System.out.println(\"arr1 = \"+arr1[i]);\n        }\n\n    }\n\n}\n\n```\n\n\n\n\n\n\n\n## 排序\n\n介绍\n\n排序的分类：\n\n1. 内部排序：\n\n* 指将需要处理的所有数据都加载到内部存储中进行排序。包括（交换式排序法，选择时排序法和插入式排序法）\n\n2. 外部排序法：\n   * 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。\n\n### 冒泡排序\n\n基本思想：通过对待排序序列从后向前（从下标较大的元素开始），一次比较相邻元素的值若发现逆序则交换，使值较大的元素从前移向后部。像水下的气泡一样逐渐向上冒。\n\n![image-20220303105607719](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220303105607719.png)\n\n特点：\n\n1. 一共有五个元素\n\n2. 一共进行了四轮排序，可以看成外层循环\n\n3. 每1轮排序可以确定一个数的位置，比如第一轮排序确最大数，第二轮确定第二大的数 的位置，依次类推\n\n4. 当进行比较时，如果前面的数大于后面的数，就交换\n\n   \n\n案例说明:\n\n将五个无序：24,69,80,57,13使用冒泡排序，从小到大排序\n\n```java\npackage com.smms.demo;\n\npublic class chapterBall {\n    public static void main(String[] args) {\n        int tmp = 0;\n        int[] a  = {24,69,80,57,13};\n       \n        for (int i = 0; i < a.length-1; i++) {\n            for (int j = 0; j < a.length; j++) {\n                if (j>=a.length-1){\n                    break;\n                } else if (a[j]<a[j+1]){\n                    System.out.println(\"不做交换\");\n                }else {\n\n                    tmp = a[j];\n                    a[j]  = a[j+1];\n                    a[j+1] = tmp;\n                    System.out.println(\"交换第\"+j+\"个数为\"+a[j]);\n                }\n            }\n        }\n        for (int i = 0; i <a.length ; i++) {\n            System.out.println(a[i]);\n        }\n\n    }\n}\n\n```\n\n\n\n## 查找\n\n### 1）顺序查找：\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class exercisesSequence {\n    public static void main(String[] args) {\n        /*有一个数列：\n        * 白眉鹰王，金毛狮王，紫衫龙王，青翼蝠王猜数游戏\n        * 从键盘任意输入一个名称，判断数列中是否包含此名称（顺序查找）\n        * 要求：如果找到了，就提示找到，并给出下标\n        */\n        String[] a ={\"白眉鹰王\",\"金毛狮王\",\"紫衫龙王\",\"青翼蝠王\"};\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入\");\n        String next = scanner.next();\n        //用于判断是否没找到\n        int nub =-1;\n        for (int i = 0; i <a.length ; i++) {\n            if (next.equals(a[i])){\n                System.out.println(\"找到了\");\n                //如果找到了就把i的值赋给sub\n                nub = i;\n                break;\n                //如果nub==-1就代表没找到\n            }else if (nub == -1){\n                System.out.println(\"没找到\");\n            }\n        }\n    }\n}\n\n```\n\n\n\n### 2）二分查找：\n\n\n\n算法部分讲解补充\n\n\n\n## 二维数组\n\n介绍：一个数组内，还有数组\n\n要理解的点：\n\n1. 看到定义形式就可知道是不是二维数组\n2. 二维数组的每一个元素都是一维数组\n3. 二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历\n4. \n\n```java\n如果需要访问第（i+1)个一维数组，第（j+1)个值。arr2d[i][j]\n 或需要访问第i个一维数组，第j个值。arr2d[i-1][j-1]   \n```\n\n\n\n案例：\n\n```java\npublic static void main(String[] args) {\n        /*\n        * 请用二维数组输入如下图形\n         0 0 0 0 0 0\n         0 0 1 0 0 0\n         0 2 0 3 0 0\n         0 0 0 0 0 0\n         */\n\n//        1. 定义形式 int[][]\n//        2.可以理解为一个数组内的每个元素都是一个数组\n        int[][] arr2d= {{0,0,0,0,0,0},{0,0,1,0,0,0},\n                        {0,2,0,3,0,0},{0,0,0,0,0,0}};\n   System.out.println(\"二维数组的元素个数\"+arr2d.length);\n//\t二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历\n    \n    \n    \n//        获取多个少个一维数组\n        for (int i = 0; i < arr2d.length; i++) {\n//            遍历二维数组的每一个元素（数组）,\n//            arr2d[i].length  获取二维数组内对应的每一个一维数组的长度\n            for (int j = 0; j < arr2d[i].length; j++) {\n                System.out.print(arr2d[i][j]+\"\\t\");\n\n            }\n            System.out.println();\n        }\n    }\n```\n\n### 二维数组内存原理图：\n\n![image-20220304165024843](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165024843.png)\n\n\n\n### 二维数组的使用方式\n\n方式1：动态初始化\n\n```\n1.语法：类型[][] 数组名 = new 类型[大小][大小];\n例如： int[][] = new int[2][3];\n\n```\n\n方式2：动态初始化\n\n```\n1. 先声明：类型 数组名[][];\n2. 再定义（开辟空间）： 数组名 = new 类型[大小][大小];\n3. 赋值（有默认值，比如int 类型默认值就是0）\n```\n\n方式3：动态初始化\n\n1. 列数不确定\n2. java不强制每个数组的长度都一样\n3. 例：![image-20220304165929272](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165929272.png)\n\n```java\npublic static void main(String[] args) {\n        /*\n            动态创建下面二维数组，并输出\n            i = 0 : 1\n            i = 1 : 2 2\n            i = 2 : 3 3 3\n         */\n        //1. 创建一个二维数组，因为数组内的每一堆数组的元素都是不确定的，所以不填。\n        // 填了的话相当于固定了长度\n        int[][] arr= new int[3][];\n        for (int i = 0; i <arr.length ; i++) {\n//            给数组内的一维数组开辟空间\n//            如果没有给一堆数组开辟空间，那么这个空间的就是null\n            arr[i] = new int[i+1];\n//            遍历一维数组，给一堆数组的每个元素赋值\n            for (int j = 0; j < arr[i].length ; j++) {\n                arr[i][j]= i+1;\n            }\n        }\n\n//        遍历出这个二维数组\n        for (int i = 0; i <arr.length ; i++) {\n            for (int j = 0; j <arr[i].length ; j++) {\n                System.out.print(arr[i][j]);\n            }\n            System.out.println();\n        }\n    }\n```\n\n杨辉三角形\n\n![image-20220305143151743](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220305143151743.png)\n\n提示：\n\n1. 第一行有一个元素，第n行有n个元素\n\n2. 第一行的第一个元素和最后一个元素都是1\n\n3. 从第三行开始，对于非第一个元素和最后一个元素的元素的值，arr[i],[j]\n\n4. ```java\n   中间的数为：\n   arr[i][j]  = arr[i-1][j]+ arr[i-1][j-1]\n     \n     \n     \n   ```\n\n   ```java\n   package basics.chapterArray;\n   \n   public class exerciseArrayYangHuiTriangle {\n       public static void main(String[] args) {\n           int[][] arr =  new int[10][];\n           for (int i = 0; i <10 ; i++) {\n               arr[i] = new int[i+1];\n               for (int j = 0; j < arr[i].length; j++) {\n                   if (j==0 || j == arr[i].length-1){\n                       arr[i][j] = 1;\n                   }else {\n                       arr[i][j] = arr[i-1][j]+arr[i-1][j-1];\n                   }\n   \n               }\n   \n           }\n           for (int i = 0; i <arr.length ; i++) {\n               for (int j = 0; j <arr[i].length ; j++) {\n                   System.out.print(arr[i][j]);\n               }\n               System.out.println();\n           }\n       }\n   }\n   \n   \n   ```\n\n\n# 面向对象\n\n## 类与对象\n\n1）类是抽象的，概念的。代表一类事物，比如人类，猫类，狗类。。。。，即它是实例\n\n```java\n例：\nclass cat{\n    //属性/也叫成员变量\n   // 成员变量 =属性 = field(字段)\n\tString name;\n\tint age;\n}\n//实例\ncat c = new ca();\n```\n\n2） 对象是具体的，实际的，代表一个具体事务，即是实例\n\n3） 类是对象的模板，对象是类的一个个体，对应一个实例\n\n属性可以使基本数据类型，也可以是引用数据类型(对象，数组)\n\n### 对象在内存中存在的形式（重要）\n\njava内存的结构分析：\n\n1. 栈：一般存放基本数据类型（局部变量）\n2. 堆：存放对象（Cat cat ，数组等）\n3. 方法区：常量池（常量，比如字符串），类加载信息\n4. 示意图：[Cat(name,age,price)]\n\n```java\nPerson p = new Person();\np.name = \"jack\";\np.age = 12;\n\n1.先加载Person类信息（属性和方法信息，只会加载一次）\n2.在堆中分配空间，进行默认初始化（看规则），\n3.把堆中的地址返回给p，p就指向对象\n4.进行指定初始化，比如：p.name = \"jack\",p.age = 12;\n\n    \n```\n\n\n\n\n\n对象和数组都是引用类型\n\n![image-20220307112129768](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307112129768.png)\n\n如果存放的数据，类型是基本数据类型则存放在堆中，引用的数据类型则存放在方法区\n\n###  注意事项\n\n1） 属性的定义语法同变量，示例：<span style=\"color:blue\">访问修饰符</span><span style= \"color:red\" > 属性类型  属性名;</span>\n\n2） 属性的定义类型可以为任意类型，包含基本类型或引用类型\n\n3） 属性如果不赋值，有默认值，规则和数组一致\n\n### 创建对象\n\n1. 先声明在创建\n\n   ```java\n   CAT cat;\n   cat  = new CAT();\n   ```\n\n2. 直接创建\n\n   ```java\n   CAT cat  = new CAT();\n   ```\n\n   \n\n访问属性\n\n```\n对象名.属性名；\ncat.xxx;\n```\n\n### 类对象的内存分配机制\n\n![image-20220307145803905](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307145803905.png)\n\n## 成员方法\n\n介绍：\n\n用于描述对象的行为，成为方法\n\n案例：\n\n![image-20220307161842380](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307161842380.png)\n\n```java\npackage com.smms.demo.method;\n\npublic class exercisesMethod01 {\n    public static void main(String[] args) {\n        Person person = new Person();\n        person.speal();\n        person.cal01();\n        person.cal02(3);\n//        调用getSum方法，并给了1,3的值\n//        用returnsum接收getSum返回的值\n        double returnsum = person.getSum(1,3);\n\n        System.out.println(\"returnsum=\"+returnsum);\n\n    }\n}\nclass Person{\n    public  void speal(){\n        System.out.println(\"我是一个好人\");\n    }\n\n    public  void cal01(){\n        int sum = 0;\n        for (int i = 0; i <= 1000; i++) {\n            sum+=i;\n        }\n        System.out.println(\"1+~+1000=\"+sum);\n    }\n    public  void cal02(int n){\n        int sum =0;\n        for (int i = 1; i <=n ; i++) {\n            sum = sum+i;\n        }\n        System.out.println(\"1+n=\"+sum);\n    }\n\n    public double getSum(double a, double b){\n        double sum=0;\n        sum = a+b;\n        System.out.println(\"a+b=\"+sum);\n//        表示返回sum\n        return sum;\n    }\n}\n```\n\n### 内存分析流程图\n\n![image-20220308162432089](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220308162432089.png)\n\n方法的优点：\n\n1. 提高了代码的复用性\n2. 可将实现的细节封装起来，然后提供其他用户来调用\n\n\n\n### 成员方法的定义\n\n```java\npublic 返回数据类型\\void（表示没有返回值）\t方法名(形参列表...){//方法体\n语句;\nreturn；//返回值\n}\n```\n\n1. 参数列表：表示成员方法输入cal(int n)\n2. 数据类型(返回类型)：表示成员方法输出，void表示没有返回值\n3. 方法主体:表示为了实现某一功能代码块\n4. return语句不是必须的\n\n\n\n### 注意事项\n\n1. 访问修饰符\n\n2. ``` java\n   访问修饰符 返回数据类型\\void（表示没有返回值）\t方法名(形参列表...){//方法体\n   语句;\n   return；//返回值\n   }\n   \n   1. 访问修饰符（作用是控制 方法的适用范围）\n       如果不写默认访问，[有四种：public protected 默认]\n   \n   ```\n\n   \n\n3. 返回数据类型\n\n```\n1. 一个方法最多有一个返回值\n\t返回多个结果，返回数组\n2. 返回类型可以为任意类型，包含基本类型和引用类型(数组，对象)\n3. 如果方法要求有返回数据类型，则方法体中最后执行的语句必须为return值；而且要求返回值类型必须和return的值的类型一致或兼容\n4. 如果方法是void，则方法体照片那个可以没有return语句，或者 只写 return；\n\n\n方法命名；使用驼峰命名法，最好见名知意\n```\n\n4. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开。例：getSum(int a,int b)\n\n5. 参数类型可以为任意类型，包含基本类型或引用类型。\n\n6. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数\n\n7. 方法定义时的参数成为形式参数（形参）；方法调用时的参数成为实际参数，简称实参。实参和形参的类型要一致或兼容、个数、顺序必须一致\n\n   * ```java\n     public static void main(){\n     \tMethod a = new Method();\n     \ta.input(123,345//这里成为实参);\n     }\n     \n     class Method{\n     \tpublic int input(int a,int b//这里成为形参){\n     \tsystem.out.print(\"xxx\");\n     \treturn xxx;\n     \t}\n     }\n     ```\n\n方法体\n\n​\t里面写完成功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义\n\n调用细节\n\n1. 同一类中的方法调用：直接调用即可\n\n   * 直接输入：方法名（参数）即可\n\n2. 跨类中的方法A类调用B类方法：需要通过对象名调用。比如：对象名.方法名(参数)\n\n\n## 成员方法传参（重要）\n\n基本数据类型\n\n1. ![image-20220310134944831](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310134944831.png)\n2. <span style = \"color:red\">基本数据类型</span>，传递的值（拷贝），形参的任何改变不影响实参！\n\n引用数据类型\n\n1. ![image-20220310140041330](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310140041330.png)\n2. 引用类型传递的是地址（传递也是值，但值是地址），可以通过形参影响实参。\n\n## 递归机制（recursion）\n\n递归调用的本质，是方法的调用\n\n1. ![image-20220310164428690](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310164428690.png)\n2. 栈是先进后出，先出后进（所以图中的test栈2先输出，然后是3，4）\n3. 每次这个栈内的方法执行完成后，外边的方法（图中test方法）都会执行一边\n4. 哪里调用就返回给哪里\n\n### 阶乘（factorial）\n\n![image-20220310203253490](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310203253490.png)\n\n###   递归调用的规则\n\n1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）\n2. 方法的局部变量是独立的，不会相互影响，比如n变量\n3. 如果方法中使用的是引用类型变量（比如数组，或者对象），就会共享该引用类型的数据。\n4. 递归必须像退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:)\n5. 当一个方法执行完毕，或者遇到return，就会执行完毕或者返回时，该方法也就执行\n\n### 斐波拉契数练习\n\n```java\npackage basics;\n\npublic class exerciseRecursion {\n    public static void main(String[] args) {\n        T t = new T();\n        int i = t.racursionNum(4);\n        System.out.println(i);\n\n    }\n\n}\n\nclass T{\n    public int racursionNum(int n1) {\n        if (n1 == 1 || n1 == 2) {\n            return 1;\n        } else {\n            return racursionNum(n1 - 1) + racursionNum(n1 - 2);\n        }\n    }\n}\n\n```\n\n解析图\n\n![image-20220310225335626](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310225335626.png)\n\n\n\n\n\n## 重载（overload）\n\n介绍：java允许同一个类中，多个同名方法的存在，但要求形参列表不一致！！！\n\n好处：\n\n1. 减轻了起名的麻烦\n2. 减轻了记名的麻烦\n\n注意细节：\n\n1. 方法名：必须相同\n2. 形参参列表：必须不同（参数类型或个数或顺序，至少有一样不同）\n3. 返回类型：无要求\n\n## 可变参数\n\n介绍：\n\njava允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法。\n\n基本语法：\n\n```java\n访问修饰符\t 返回类型\t方法名（数据类型 .... 参数名）{\n}\n```\n\n案例\n\n```java\nclass hasMestod{\n/*\n    public int sum(int a,int b){\n        return a+b;\n    }\n    public int sum(int a,int b,int c){\n        return a+b+c;\n    }\n    public int sum(int a,int b,int c,int d){\n        return a+b+c+d;\n    }\n//    ........以此类推\n*/\n\n//    可变参数优化\n//    上面三个方法名称相同，功能相同，只是参数个数不同---->使用可变参数优化\n//    1.int...表示接收的是可变参数，类型时int，即可以接收多个int（0-多）\n//    2.使用可变参数时，可以当做数组；来使用，即nums 可以当做数组使用\n    public  int sum1(int... nums){\n        System.out.println(\"接收的个数为\"+nums.length);\n        int sum = 0;\n        for (int i = 0; i < nums.length ; i++) {\n            sum=sum+nums[i];\n        }\n        return sum;\n    }\n\n}\n```\n\n注意事项：\n\n1. 可变参数的实参可以为0或任意多个\n\n2. 可变参数的实参可以为数组\n\n3. 可变参数的本质就是数组\n\n   \n\n4. 可变参数可以和普通类型的参数<u>*一起放在形参列表*</u>，但必须保证可变参数在最后\n\n5. 一个形参列表中只能出现一个可变参数\n\n\n\n## 作用域\n\n1. 在java中，主要的变量就是属性（成员变量）和局部变量\n2. 我们说的局部变量一般是指在成员方法中定义的变量\n3. 作用域的分类\n   1. 全局变量：也就是属性，作用域为整个整体\n   2. 局部变量：也就是除了属性以外的其他变量，作用域为定义它的代码块中\n4. 全局变量可以不赋值，直接使用，因为有默认值（也可指定值），局部变量必须赋值后，才能使用，因为没有默认值。    、   \n\n注意事项和细节\n\n1. 属性和局部变量可以重名，访问时遵循就近原则\n2. 在一个作用域中，比如在同一个成员方法中，两个局部变量，不能重\n3. 属性生命周期较长，伴随对象的创建而创建，伴随对象的死亡而死亡。局部变量，生命周期较短，伴随它的代码块的执行而创建，伴随代码块的结束而死亡\n4. 作用域范围不同：\n   1. 全集变量/属性：可以被本类使用，或其他类使用（通过对象调用）\n   2. 局部变量：智能在本类中对应的方法中使用\n5. 修饰符不同\n   1. 全局变量/属性可以加修饰符\n   2. 局部变量不可以加修饰符\n\n## 构造器(constructor)\n\n基本介绍：构造方法又称构造器(constructor)，是类的一种特殊方法，它的主要作用是完成对<span style = \"color:red\">新的对象初始化。</span>\n\n\n\n特点：\n\n1. 方法和类名相同\n2. 没有返回值\n3. 在创建对象时，系统会自动调用该类的构造器完成对对象的初始化\n\n\n\n需求案例：\n\n案例1:创建一个人类的对象，显示把一个对象创建好后，再给他的年龄姓名等属性赋值，如果现在我要求，在创建人类对象的时候，就直接指定这个对象的年龄和姓名。 此时可以使用构造器\n\n基本语法：\n\n```java\n[修饰符] 方法名(形参列){\n\n\t方法体;\n\n}\n```\n\n1. 构造器的修饰符可以默认，也可是public，protected，private\n2. 构造器没有返回值,也不能写void\n3. 方法名和类名必须一样\n4. 参数列表和成员方法一样的规则\n5. 构造器的调用<span style = \"color:red\">系统完成</span>\n\n\n\n细节：\n\n1. 一个类可以定义多个不同的构造器，即构造器的重载\n   * 比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄\n   * ![image-20220314163037454](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314163037454.png)\n2. 构造器是完成对象的初始化，并不是创建对象\n3. 如果程序员没有定义构造器，系统会自动生成一个默认的无参构造器(也叫默认构造方法),比如Person(){ }\n4. 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的午餐构造器，除非显示的定义一下，即自己再手写一边Person(){ }\n\n\n\n\n\n\n\n对象创建流程\n\n```java\nclass Person{\n\tint age =90;\n\tString name;\n\tPerson(String n , int a){\n\tname = n;\n\tage = a;\n\t}\n}\n\n\nPerson p = new Person(\"zhangsan\" , 20);\n```\n\n![image-20220314215432778](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png)\n\n```\n1. 先在方法区加载Person类\n2. 在堆中开辟一个空间，内部存放形参\n   1. 先初始化默认值，0和null，然后再将值赋进去\n   2. 当执行到构造器的时候，值才会赋进去\n   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值\n3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)\n```\n\n1. 加载Person.class，只会加载一次。\n\n2. 在堆中分配空间(地址)\n\n3. 完成对象初始化\n\n   3.1 默认初始化 age=0\tname = null\t\n\n   3.2 显示初始化 age=90,name=null,\n\n   3.3 构造器的初始化 age=20，name=zhangsan\n\n4. 在对象堆中的地址，返回给p(也可理解成对象的引用)\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n## this\n\n案例：\n\n```java\nclass Person{\n\tString name;\n\tint age;\n/*\n\t旧方法：\n\t\tint age =90;\n\t\tString name;\n\t\tPerson(String n , int a){ //此时形参的起名不能与属性名一致\n\t\tname = n;\n\t\tage = a;\n     1.如果可以将构造器的形参，直接写成属性名就好了\n     2.但是会出现一个问题，根据变量的作用域原则\n     3.构造器的name 是局部变量，而不是属性。相当于自己赋给自己\n     4.构造器的age 是局部变量，而不是属性、\n     5.==>此时使用this关键字\t\n*/\n    public Person(String name,int age){\n        this.name/*表示当前对象的属性*/ = name;/*表示当前构造器的局部变量*/\n        this.age = age;\n    }\n\t \n}\n```\n\n介绍：\n\njava虚拟机会给每个对象分配this，代表当前对象。\n\n分析图：\n\n每一个对象都有一个隐藏的属性this\n\n这个this它指向自己\n\n![image-20220314222909415](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314222909415.png)\n\n简单说，哪个对象调用this就指向哪个对象\n\n\n\n\n\n注意事项：\n\n1. this关键字可以用来访问本类的属性，方法，构造器\n\n2. this用于区分当前类的属性和局部变量\n\n3. 访问成员方法的语法：this.方法名(参数列表)；\n\n4. 访问构造器语法：this(参数列表);//注意，只能在构造器中访问另外一个构造器(当有访问构造器的语法this时，必须放在构造器语句里的第一行 )\n\n   * ```java\n     class T{\n         String name;\n         int age;\n     \t//无参构造器\n     \tpublic T(){\n             //当执行无参构造器时，我们想去访问有参构造器\n             this(\"zhangsan\",12);//这样访问有参构造器\n            //当有访问构造器的语法this时，必须放在构造器语句里的第一行 \n            \n     \t\tSystem.out.println(\"T() 构造器\");\n             \n             \n             \n     \t}\n     \t\n     \t//有参构造器\n     \tpublic T(String name,int age){\n             System.out.println(\"T(String name,int age) 构造器\");\n         }\n     }\n     ```\n\n5. this不能再类定义的外部使用，只能在类定义的范围中使用\n\n```java\npackage chapterObject;\n/*\n* 创建一个employee类\n* 属性有（名字，性别，年龄，职位，薪水）\n* 提供三个构造器\n* 1.名字，性别，年龄，职位，薪水\n* 2.名字，性别，年龄\n* 3.职位，薪水*/\npublic class ObjectHomeWork06 {\n}\nclass Employee{\n    String name;\n    char sex;\n    int age;\n    String post;\n    double salary;\n\n    public Employee(String name,char sex,int age){\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n    public Employee(String post,double salary){\n\n        this.post = post;\n        this.salary = salary;\n    }\n    public Employee(String name,char sex,int age,String post,double salary){\n        this(name, sex, age);\n//        因为构造器调用只能放在第一行，所以最多只能调用一个构造器\n        this.post = post;\n        this.salary = salary;\n    }\n\n//    public Employee(String name,char sex,int age,String post,double salary){\n//        this.name = name;\n//        this.sex = sex;\n//        this.age = age;\n//        this.post = post;\n//        this.salary = salary;\n//\n//    }\n}\n\n\n```\n\n\n\n# 面向对象（中级）\n\n## idea\n\n### 快捷键\n\n```\n自定义快捷键\nsettings - - > Keymap\n删除当前行 ctrl+y  自定义 alt+D\n复制当前行 ctrl+d\n\n快速格式化代码 ctrl + alt + L\n快速运行程序  自定义alt + R\n\n查看类的层级关系 ctrl + H\n将光标放在一个方法上，输入ctrl+b，可以定位到该方法的上\n自动分配变量名   在后面添加.var\n例：new Scanner(System.in).var+回车\n会生成Scanner scanner = new Scanner(System.in);\n```\n\n### 模板\n\n 设置路径\n\nfile -> settings -> editor -> live templates->\n\n可以自己自定义，也可查看预设的模板\n\n\n\n\n\n\n\n\n\n## 包\n\n三大作用：\n\n1. 区分相同名字的类\n2. 当类不同的时候，可以很好的管理\n3. 控制访问范围\n\n基本语法：\n\npackage com.xxx;\n\n1. package 关键字，表示打包\n2. com.xxx:表示包名\n\n包的本质\n\n就是创建不同的文件/目录保存文件\n\n\n\n### 包的命名\n\n规则：\n\n智能包含数字，字母，下划线，小圆点，但不能用数字开头，不能是关键字或保留字\n\n```java\ndemo.class.exec1 //falsee不允许有关键字class\ndemo.12\t\t//false,不能数字开头\ndemo.ad12.oa //true\n```\n\n规范\n\n一般是小写字母+小圆点\n\ncom.公司名.项目名.业务模块名\n\n例：com.alibaba.taobao.login\n\n```java\ncom.sina.crm.user\n等等\n```\n\n### java常用的包\n\n```java\njava.lang // lang包是基础包，默认引入，不用手动输入\n\njava.util //系统提供的工具包，工具类，例如Scanner类\n\njava.net // 网络包，网络开发\n\njava.awt  // 是做java的界面开发，GUI\n```\n\n\n\n包的引入\n\n建议需要什么类就引入什么类，不建议(java.util.* )全部引入\n\n\n\n\n\n\n\n## 访问修饰符\n\n介绍\n\njava提供了四种访问控制修饰符号控制方法和属性(成员变量)的访问权限(范围)\n\n1. 公开级别：public 修饰，对外公开\n2. 受保护级别：用protected修饰，对子类和统一包中的类公开\n3. 默认级别：没有修饰符号，向同一包的内公开\n4. 私有级别：用private修饰，只有类本身可以访问，不对外公开\n\n![image-20220317140746725](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220317140746725.png)\n\n注意事项：\n\n1. 修饰符可以用修饰类中的属性，成员方法以及类\n2. 只有默认的和public才能修饰类，并且遵循上述访问权限的特点\n3. 成员方法访问规则和属性完全一样\n\n\n\n\n\n\n\n\n\n\n\n\n\n## <u>*封装*</u>（重要）\n\n封装（encapsulation）就是把抽象出来的数据[**属性**]和对数据的操作[**方法**]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[**方法**]，才能对数据进行操作。\n\n**封装的好处**\n\n1. 隐藏实现细节  方法(连接数据库)<----调用(传入参数)\n2. 可对数据进行验证，保证安全合理\n\n\n\n封装的实现步骤 ( 三 步 ) \n\n1. 将属性进行私有化，private\n\n2. 提供一个公共的set方法，对属性进行判断并赋值\n\n   ```java\n   public void setXXX(类型\t参数名){\n   //加入数据验证的业务逻辑\n   属性 = 参数名；\n   }\n   ```\n\n3. 提供一个公共的get方法，用于获取属性的值\n\n   ```java\n   public void getXXX(类型\t参数名){\n   \treturn xx;\n   }\n   ```\n\n   \n\n\n\n## <u>*继承*</u>（重要）extends\n\n### 继承作用：\n\n解决代码复用性\n\n### 介绍：\n\n相当多个类存在相同的属性（变量）  和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些属性和方法，只需通过extend来声明继承父类即可\n\n###  基本语法\n\n```java\nclass 子类 extends 父类{\n\n}\n1. 子类会自动拥有父类定义的方法\n2. 父类又叫超类，基类\n3. 子类又叫派生类\n\n```\n\n示意图\n\n![image-20220318104942566](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318104942566.png)\n\n\n\n### 注意事项\n\n1. 子类继承了所有的属性和方法，但是私有属性不能再子类直接访问，需要通过公共方法访问\n\n2. 子类必须调用父类的构造器，完成父类的初始化\n\n3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中调用super去指定使用父类的那个构造器完成对父类的初始化工作，否则编译不通过\n\n4. 如果希望指定去调用父类的某个构造器，则显式的调用一下{super ( 参数 ) }\n\n5. super在使用时，需要放在第一行。super只能在构造器中使用\n\n6. super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器\n\n7. java所有类都是Object的子类，是所有类的基类   Ctrl+H可以看到类的继承关系\n\n   ![image-20220318165601997](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318165601997.png)\n\n8. 父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类)\n\n9. 子类对多只能继承一个父类(指直接传承)，即java中是单继承机制。\n\n10. 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系\n\n    1. person is a music\n    2. person music\n    3. music extends  person \n\n\n\n### 继承的本质（分析）\n\n当子类创建号对象以后，建立查找关系\n\n```java\n//案例：\nclass Grandpa{\n\tString name = \"爷爷\";\n\tString hobby = \"旅游\";\n}\n\nclass Father extends GrandPa{\n\tString name = \"大头爸爸\";\n\tint age = 30;\n}\n class Son extends Father{\n \tString name = \"儿子\";\n }\n \n \n Son son = new Son();\n son.name=?      //儿子\n son.age = ?\t //30\t\n son.hobby = ?\t // 旅游\n //\t\t1. 此时请注意，要按照查找关系返回信息\n /*     2. 首先看子类是否有该属性\n \t\t3. 如果子类有这个属性，并且可以访问，则返回信息\n \t\t4. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回)\n \t\t5. 如果父类没有4的规则，继续找上级，直到object\n   */  \n```\n\n### 内存原理图：\n\n ![image-20220320170828664](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320170828664.png)\n\n## Super\n\n### 基本介绍\n\nsuper代表父类的构造器，用于访问父类的属性，方法，构造器\n\n### 基本语法\n\n1. 访问父类的属性，但不能访问父类的private属性[案例]\n   * super.属性名；\n2. 访问父类的方法名，不能访问父类的private方法\n   * super.方法名(参数列表);\n3. 访问父类的构造器(这点前面用过);\n   * super(参数列表);\n   * 只能放在构造器的第一句并只能出现一句\n\n### 细节和注意事项\n\n1. 调用父类的构造器的好处（分工明确，弗雷属性由父类初始化，子类的属性由子类初始化）\n\n2. 当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果\n\n   * ```java\n     案例\n     class A{\n     \tpublic void cal(){\n     \t\tSystem.out.println(\"a类的cal方法\");\n     \t}\n     }\n     class B{\n     \tpublic void sum(){\n     \t\tSystem.out.println(\"b类的sum方法\");\n     \t/*\t\n     \t\t此时有三种方法调用cal\n     \t\t1. 找cal方法时，顺序是：先找本类，如果有，开始调用。\n     \t\t2. 如果没有。则找父类（如果有则调用）\n     \t\t3. 如果父类没有则继续找父类的父类。以此类推。直到Object类‘\n     \t\t\n     \t\t提示：如果查找的过程中找到了，但不能访问，则报错\n     \t\t\t 如果查找的过程中没找到。则提示没找到\n     \t*/\n         \tcal();\n             \n            \n             this.cal();//等价cal（）；\n             \n              /*\n             跳过本类直接查找父类\n             其他规则一样\n             */\n             super.cal();\n             \n     \t}\n     }\n     ```\n\n3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。（相当于跳过本类，从父类开始按规则找。父类找不到找爷爷类·····）\n\n### super和this的比较\n\n![image-20220320190806497](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190806497.png)\n\n![image-20220320190935663](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190935663.png)\n\n## 重写（overwrite）\n\n### 基本介绍\n\n简单地说：方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这方法覆盖了父类的方法。\n\n### 案例\n\n```java\nclass Animal{\n\tpublic void cry(){\n\t\tSystem.out.println(\"叫\");\n\t}\n}\n/*\n\t1. 因为dog是Animal的子类\n    2. Dog的cry方法和Animal的cry方法定义形式一样(名称，返回类型，参数)\n    3. 这时我们就说Dog的cry方法，重写了Animal的cry方法\n  */      \nclass dog extends Animal{\n\tpublic void cry(){\n\t\tSystem.out.println(\"汪汪汪\");\n\t}\n}\n```\n\n### 注意事项和使用细节\n\n1. 子类的方法的形参列表，方法名称，要和父类的方法的参数，方法名称完全一样。\n\n2. 子类方法的返回类型和父类方法返回类型一样，或者父类返回类型的子类\n\n   比如 父类返回类型是Object，子类方法返回类型是String\n\n   ```java\n   public Object getInfo(){}\n   ```\n\n   ```java\n   public String getInfo(){}\n   ```\n\n3. 子类方法不能缩小父类方法的访问权限public > protected > 默认(default ) > private \n\n   ```java\n   void sayOk(){}\n   ```\n\n   ```java\n   public void sayOk(){}//这样是可以的，但不能缩小\n   ```\n\n### 重写与重载的区别\n\n![image-20220320211941817](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320211941817.png)\n\n练习\n\n```java\npackage seatWork;\n\npublic class override {\n    /*\n    * 1. 编写一个Person类，包括属性/private（name,age），\n    * 构造器，方法say（返回组我介绍的字符串）\n    * 2. 编写一个student类，继承Person类，增加id，score属性/private，\n    * 以及构造器，定义say方法（返回自我介绍信息）\n    * 3. 在main方法中，分别创建Person和Student对象，调用say方法输出自我介绍*/\n\n    public static void main(String[] args) {\n        Person person = new Person(\"lisi\", 123);\n        String say1 = person.say();\n        System.out.println(say1);\n\n        Student student = new Student(\"zhangsan\",12,12345,100);\n        String say = student.say();\n        System.out.println(say);\n    }\n}\nclass Person{\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String say(){\n        System.out.println(\"我是父类\");\n//        System.out.println(\"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\");\n        return \"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\";\n    }\n}\n\nclass Student extends Person{\n    private int id;\n    private double score;\n\n    public Student(String name, int age, int id, double score) {\n        super(name, age);\n        this.id = id;\n        this.score = score;\n    }\n    public int getId() {\n        return id;\n    }\n    public void setId(int id) {\n        this.id = id;\n    }\n    public double getScore() {\n        return score;\n    }\n    public void setScore(double score) {\n        this.score = score;\n    }\n\n    public String say(){\n        return super.say()+\"id\"+getId()+\"\\t\"+\"score\"+getScore()+\"\\t\";\n//        System.out.println(\"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\"\n//        +\"id\"+getId()+\"\\t\"+\"score\"+getScore()+\"\\t\");\n    }\n}\n```\n\n## <u>*多态*</u>（重要）\n\n 多态可以提高代码的复用性\n\n### 基本介绍\n\n多态(多种)（状态）\n\n1. 方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础之上的额\n\n### 多态的具体体现\n\n#### 方法上体现\n\n1. 方法的多态\n\n   重写和重载就体现多态\n\n2. 案例说明\n\n3. 重载上体现\n\n   1. 对某一方法，传入不同的参数，调用不同的方法\n   2. ![image-20220320215939959](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320215939959.png)\n\n\n\n\n\n### 对象的多态（核心，难点，重点）\n\n要记住几点：\n\n1. 一个对象的编译类型和运行类型可以不一致\n\n   * ```\n     例如：\n     Animal animal = new Dog();【animal编译类型时Animal，运行类型是Dog】\n     animal  = new Cat(); \t【animal的运行类型变成了Cat，编译类型仍然是Animal】\n     ```\n\n2. 编译类型在定义对象时，就确定了，不能改变\n\n   * ```\n     Animal animal = new Dog()   编译类型在定以后就不能改变，所以可以直接用引用接收其他的运行类型\n     animal  = new Cat();\n     animal  = new PIG();`````\n     ```\n\n3. 运行类型是可以变化的\n\n4. 编译类型看定义时 = 号的左边，运行类型看 = 号的右边\n\n   * ```\n     Animal animal = new Dog()  animal就是变异类型，dog就是运行类型\n     ```\n\n```java\n//编译类型和运行类型的体现\nclass Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"动物在叫\");\n\t}\n}\nclass Cat extends Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"猫在叫\");\n\t}\n}\n\nclass Dog extends Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"狗在叫\");\n\t}\n}\n\nclass test{\n\tpublic static void main(String[] args){\n\t\t//animal编译类型就是Animal，运行类型Dog\n\t\tAnimal animal = new Dog();\n\t\tanimal.say();//因为运行类型是dog，animal的运行类型是dog，所以输出dog类的say方法。\n\t\t\n        animal = new Cat();\n        animal.say();//此时animal的运行类型是cat，所以输出cat类的say方法；\n    }\n}\n```\n\n\n\n### 注意事项和细节\n\n多态的前提是：两个对象(类)存在继承关系\n\n#### 多态的向上转型\n\n1. 本质：父类的引用指向了子类的对象\n\n2. 语法：父类类型    引用名 = new    子类类型()；\n\n   ```java\n   Father father = new Son();\n   //此时可称为向上转型\n   ```\n\n3. 特点：编译类型看左边，运行类型看右边\n\n   <span style=\"color:red;\">可以调用父类中的所有成员(需要遵循访问权限),</span>\n\n   <span style=\"color:red;\">不能调用子类中特有成员</span>\n\n   （<span style=\"color:red;\">因为在编译阶段，不能调用那些成员，是由编译类型来决定的。</span>）\n\n   最终运行效果按子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法\n\n   然后调用，与前面的方法调用规则一致\n\n#### 多态的向下转型\n\n语法：子类类型   引用名 = (子类类型) 父类引用;\n\n1. 只能强转父类的引用，不能强转父类的对象\n\n   ```java\n   //此时的向上转型\n   Animal animal = new Cat();\n   adimal.a();\n   //等等方法，这些方法只能调用父类子类的共同拥有的方法，不能调用子类的特殊方法\n   \n   //此时这样写\n   //强转一下，上述父类的引用\n   Cat cat =  (Cat)animal；\n       cat.catchMouse();\n   ```\n\n   \n\n2. 要求父类的引用必须指向的是当前目标类型的对象\n\n   ```java\n   //也就是说animal必须是指向对应的子类\n   Animal animal = new Cat();//必须有这句话\n   Cat cat =  (Cat)animal；//才能强转成cat类型\n   \n   ```\n\n   \n\n3. 可以调用子类类型中所有的成员\n\n\n\n#### 属性没有重写之说\n\n属性的值看编译类型\n\n```java\n例:\nclass A{\n\tint count = 1;\n}\nclass B extends A{\n\tint count = 2;\n}\n\npublic class test{\n\tpublic static void main(String[] atgs){\n\t\tA a = new B();\n\t\tpublic.out.print(a.count);\n            \n        //此时输入的值为1\n        //因为属性的值是看编译类型\n            \n        B b = new B();\n        public.out.print(a.count);\n        //此时输出2\n\t}\n}\n```\n\n\n\n#### instanceOf比较操作符，\n\n用于判断对象的类型是否为xx类型或xx类型的子类型\n\n判断对象的运行类型是否为xx类型，或这个xx类型的子类型\n\n```java\nclass A{\n\tint count = 1;\n}\nclass B extends A{\n\t count = 2;\n}\npublic class test{\n\tpublic static void main(String[] atgs){\n\tBB bb = new BB();\n\tpublic.out.print(bb instanceof BB);//true\n\tpublic.out.print(bb instanceof AA);//true\n       \n        \n        //编译类型AA ，运行类型BB\n     AA aa = new AA();\n        public.out.print(aa instanceof AA);//true\n       public.out.print(aa instanceof BB);//true \n        \t\n     Object obj   = new Object();\n        public.out.print(obj instanceof AA);//false,因为obj不是AA类，也不是AA的子类\n        \n}}\t\n```\n\n#### java动态绑定机制(重要) \n\n1. 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定\n2. 当调用对象属性时，没有动态绑定机制，哪里声明，那里使用\n\n```java\nclass A{\n\tpublic int i =10;\n\t//2\n\tpublic int sum(){\n        //3  \n\t\treturn geti()+10;//5\n\t}\n\t\n\tpublic int sum1(){\n\treturn i+10;\n\t}\n\tpublic int geti(){\n\treturn i;\n\t}\n}\n\nclass B{\n\tpublic int i =10;\n\t\n\tpublic int sum1(){\n\treturn i+10;\n\t}\n    //4\n\tpublic int geti(){\n\treturn i;\n\t}\n}\n\n\nA a  = new B()\n   //1\na.sum //40\n    \n   \n//因为执行到sum方法，开始准备执行geti方法时，因为有java动态绑定的机制，会跳到b类的geti方法执行\n    //再根据继承跳回去\n```\n\n\n\n####  多态的应用\n\n1）多态数组\n\n数组的定义类型为父类类型，里面保存的实际元素类型为子类型\n\n```java\npackage seatWork;\nimport java.security.PrivateKey;\n\npublic class polySeatwork {\n    public static void main(String[] args) {\n        /*\n        * 要求创建一个person对象name ，age\n        * 两个student 对象和2个teacher对象，统一放在数组中，\n        * 并调用每个对象的say方法\n        * */\n        Person1[] person1s = new Person1[5];\n        person1s[0] = new Person1(\"human\",00);\n        person1s[1] = new Student1(\"tom1\",12,150);\n        person1s[2] = new Student1(\"tom2\",13,143);\n        person1s[3] = new teacher(\"zhangsan\",30,4000);\n        person1s[4] = new teacher(\"lisi\",28,5000);\n\n        //循环遍历多态数组，调用say方法\n        for (int i = 0; i < person1s.length ; i++) {\n            //老韩提示， person1s[i]的编译类型是Person，\n            // 运行类型是根据实际情况而变化\n            System.out.println(person1s[i].say());\n        }\n    }\n}\nclass Person1{\n    private String name;\n    private int age;\n\n    public Person1(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String say(){\n        return \"name = \"+name+\"age = \"+age;\n    }\n}\n\nclass Student1 extends Person1{\n\n    private double score;\n\n    public Student1(String name, int age, double score) {\n        super(name, age);\n        this.score = score;\n    }\n    public double getScore() {\n        return score;\n    }\n    public void setScore(double score) {\n        this.score = score;\n    }\n\n    @Override\n    public String say() {\n        return super.say()+\"score = \"+score;\n    }\n    public void study(){\n        System.out.println(getName()+\"学习······\");\n    }\n}\n\nclass teacher extends Person1{\n    private double salary;\n\n    public teacher(String name, int age, double salary) {\n        super(name, age);\n        this.salary = salary;\n    }\n    public double getSalary() {\n        return salary;\n    }\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n\n    @Override\n    public String say() {\n        return super.say()+\"salary = \"+salary;\n    }\n    public void teach(){\n        System.out.println(getName()+\"教书·············\");\n    }\n}\n```\n\n案例升级：如何调用子类的特有方法，比如Teacher 有一个teach，Student有一个study方法。如何调用?\n\n```java\n//循环遍历多态数组，调用say方法\n        for (int i = 0; i < person1s.length ; i++) {\n            //老韩提示， person1s[i]的编译类型是Person，\n            // 运行类型是根据实际情况而变化\n\n            //判断person1s[i]的运行类型\n            if ( person1s[i] instanceof Student1){\n               Student1 student1 =  (Student1)person1s[i];\n               student1.say();\n               //也可以写成一条语句\n               ((Student1)person1s[i]).study();\n            }else if (person1s[i] instanceof teacher){\n                ((teacher)person1s[i]).teach();\n            }else{\n                System.out.println(\"============类型有误==============\");\n            }\n            System.out.println(person1s[i].say());\n        }\n```\n\n#### 多态参数\n\n方法定义的形参类型为父类型，实参类型允许为子类类型\n\n* polyParameter.java\n\n* ```java\n  package seatWork;\n  \n  public class polyParameter {\n      /*\n      * 定义员工类Employee，包含姓名和月工资[private]，以及计算年工资getAnnual的方法。\n      * 普通员工和经理继承了员工，经理类多了奖金bonus属性和管理manage方法，\n      * 普通员工类多了work方法，普通员工和经理类要求分别重写getAnnual方法\n      *\n      *\n      * 测试类中添加一个方法showEmployAnnual（Employee e ),\n      * 实现获取任何员工对象的年工资，\n      * 并在main方法中调用该方法[e.getAnnual()]\n      *\n      * 测试类中添加一个方法，testWork，如果是普通员工，\n      * 则调用work方法，如果是经理，则调用manage方法\n  */\n      public static void main(String[] args) {\n          GeneralStaff staff = new GeneralStaff(\"zhangsan\", 5000);\n          Manager manager = new Manager(\"lisi\", 5000, 10000);\n          polyParameter polyParameter = new polyParameter();\n          polyParameter.showEmployAnnual(staff);\n          polyParameter.showEmployAnnual(manager);\n  \n          polyParameter.testWork(staff);\n          polyParameter.testWork(manager);\n  \n      }\n      public void showEmployAnnual(Emplyee e){\n  \n          System.out.println(e.getAnnual());\n      }\n      /*\n      * 添加一个方法，testwork\n      * 如果是普通员工，则调用work方法\n      * 如果是经理则调用manage方法\n      * */\n      public void testWork(Emplyee e){\n          if (e instanceof GeneralStaff){\n              ((GeneralStaff) e).work();//向下转型\n          }else if (e instanceof Manager){\n              ((Manager) e).manage();//向下转型\n          }\n      }\n  \n  \n  }\n  class Emplyee {\n      private String name;\n      private double salary;\n  \n      public Emplyee(String name, double salary) {\n          this.name = name;\n          this.salary = salary;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public double getSalary() {\n          return salary;\n      }\n  \n      public void setSalary(double salary) {\n          this.salary = salary;\n      }\n  \n      public double getAnnual(){\n          double tmp = 12*salary;\n  \n          return tmp;\n      }\n  }\n  \n  class GeneralStaff extends Emplyee{\n  \n      public GeneralStaff(String name, double salary) {\n          super(name, salary);\n      }\n  \n      @Override\n      public double getAnnual() {\n          return super.getAnnual();\n      }\n  \n      public void work(){\n          System.out.println(\"work method\");\n      }\n  }\n  class Manager extends Emplyee{\n      private double bonus;\n  \n      public Manager(String name, double salary,double bonus) {\n          super(name, salary);\n          this.bonus = bonus;\n      }\n  \n      public void manage(){\n          System.out.println(\"manage method\");\n      }\n  \n      @Override\n      public double getAnnual() {\n          return super.getAnnual()+bonus;\n      }\n  }\n  \n  ```\n\n\n## Obeject类详解\n\n类Object是类的层次结构的根类，每个类都使用Object作为超类，所有对象(包括数组)都实现了这个类的方法\n\n#### equals\n\n==和equals的对比\n\n==是一个比较运算符\n\n1. 既可以判断基本类型，又可以判断引用类型\n2. 如果判断基本类型，判断值是否相等。例如：int i = 10; double b = 10.0;\n3. 如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象\n\n\n\n \n\nequals：是Object类中的方法，只能判断引用类型，\n\n判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等\n\n案例：\n\n```java\npackage seatWork;\n\npublic class equalsExercise {\n    public static void main(String[] args) {\n        Person02 person02 = new Person02(\"zhangsan\", 123, '男');\n        Person02 person03 = new Person02(\"zhangsan\", 123, '男');\n        //在没有重写equals方法时是不相等，此时的方法时比对是否指向同一对象\n        System.out.println(person02.equals(person03));\n    }\n}\nclass Person02{\n//    判断两个Person是否相等\n    private String name;\n    private int age;\n    private char gender;\n\n    public Person02(String name, int age, char gender) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public char getGender() {\n        return gender;\n    }\n\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    public boolean equals(Object obj) {\n//        1. 先判断两个是否指向同一对象\n        if (this == obj){\n            return true;\n        }\n//        2.进行类型判断\n        if (obj instanceof Person02) {\n//            3.向下转型，得到所有的属性信息进行比对\n            Person02 person02 = (Person02) obj;\n            return this.name.equals(person02.name)&&this.age== person02.age&&this.gender==person02.gender;\n        }\n//        如果不是Person类型，则直接返回false\n        return false;\n    }\n\n}\n\n```\n\n#### hashCode\n\n介绍：\n\n返回对象的哈希码值，支持此方法是为了提高哈希表的性能\n\n实际上，由object类定义的hashCode方法确定会针对不同的对象返回不同的证书，(这一般是通过将该对象的内部地址转移换成一个整数来实现的，但是java编程语言不需要这种实现技巧)\n\n老韩六小结：\n\n1. 提高具有哈希结构容器的效率\n\n2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的\n\n3. 两个引用，如果指向的是不同的对象，则哈希值是不一样的（极大概率不一样）\n\n4. 哈希值主要根据地址号来的！，不能完全将哈希值等价于地址\n\n5. 案例演示obj.hashCode() [测试 A obj1 = new A(); A obj2 = new A(); A obj3 = obj1]\n\n   ```java\n   package seatWork;\n   \n   public class hashCodeExcise {\n       public static void main(String[] args) {\n           A a = new A();\n           A a1 = new A();\n           A a3 = a;\n           System.out.println(\"a.hashCode() = \"+a.hashCode());       System.out.println(\"a1.hashCode() = \"+a1.hashCode());       System.out.println(\"a3.hashCode() = \"+a3.hashCode());\n       }\n   }\n   class A{\n   }\n   \n   ```\n\n   ![image-20220323164744164](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220323164744164.png)\n\n6. 后面在集合，中hashCode如果需要的话，也会重写\n\n#### toString\n\n介绍：\n\n默认返回：全类名+@+哈希值的十六进制，[查看object的tostring方法]\n\n子类往往会重写toString方法，用于<span style=\"color:red;background:yellow\">返回对象的属性信息</span>\n\n重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。\n\n\n\n当直接输出一个对象时，toString方法会被默认的调用\n\n```\nSystem.out.print(xxx);\n等价于System.out.print(xxx.toString);\n```\n\n\n\n#### finalize()\n\n介绍：\n\n当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法\n\n1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作\n2. 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制销毁该对象，在销毁该对象前，会先调用finalize方法\n3. 垃圾回收机制的调用，是由系统来决定的(即有自己的GC算法 )，也可以通过System.gc()主动触犯垃圾回收机制\n\n## 断点调试（debug）\n\n#### 提示：\n\n在断点调试的过程中，是运行状态，是以对象运行类型来执行的\n\n#### 介绍：\n\n​\t断点调试是指程序在的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步一步往下调，调试过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug。\n\n#### 快捷键\n\n* F7（跳入）\n  * 跳入方法内\n* F8（跳过）\n  * 逐行执行代码\n* shift+F8（跳出）\n  * 跳出方法\n* F9（resume，执行到下一个断点）\n\n![image-20220324141333874](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220324141333874.png)\n\n# 面向对象（高级）\n\n## 类变量和类方法\n\n### 一、类变量\n\n案例理解：\n\n```java\npublic Child{\nprivate String name;\n\n    \n//定义一个变量count，是一个类变量（静态变量）static静态\n    //该变量最大的特点就是会被Child类的所有的对象实例共享\npublic static int count = 0;\n\npublic Child （String name）{\n     this.name = name;\n}\n    public void join(){\n        System.out.println(name+\"加入了游戏····\")\n    }\n}\n\n\n\nmain(){\n    //定义一个变量count，统计多少小孩加入了游戏\n    //传统方法，定义一个count然后统计\n    //int count  = 0;\n    \n    Child child0 = new Child(\"xiaoming\")；\n        child0.join();\n    \t//count++;\n    \n    //改进后\n    \tchild0.count++;\n    \n    Child child1 = new Child(\"xiaoming\")；\n        child1.join();\n    \tchild1.count++;\n    \n    Child child2 = new Child(\"xiaoming\")；\n        child2.join();\n    \tchild2.count++;\n    \n    //类变量可以通过类名来访问\n    System.out.println(\"共有\"+child.count+\"小孩加入了游戏\")\n}\n```\n\nstatic变量会开辟一个独立的空间，所以new的对象空间不会再单独创建一个static变量的空间。所以这个static变量空间对于这个类的所有实例是共享的\n\n#### 内存分析\n\n![image-20220402161426676](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220402161426676.png)\n\n1. static变量是对象共享的\n2. 不管static变量在哪\n   1. static变量是同一个类，所有对象共享\n   2. static类变量，在类加载的时候就生成了\n\n#### 定义语法\n\n访问修饰符\tstatic\t数据类型\t变量名；【推荐】\n\nstatic\t访问修饰符\t数据类型\t变量名；\n\n#### 类变量访问\n\n类名.类变量名【推荐】\n\n或者\t\n\n对象名.类变量名 [静态变量的访问修饰符的访问权限和范围和普通属性是一样的]\n\n推荐使用第一种\n\n\n\n#### 使用细节\n\n1. 什么时候使用类变量？\n   * 当我们需要让某个类的所有对象都共享一个变量时，就可以使用类变量（静态变量）：比如上述的统计人数的案例\n2. 类变量与实际变量的区别\n   * 变量是该类的所有对象共享的\n   * 实例变量是每个对象独享的\n3. 加上static成为类变量或静态变量，否则称为实例变量/普通变量/非静态变量\n4. 类变量可以通过<span style=\"color:red\">类名.类变量名</span>或者<span style=\"color:red\">对象名.类变量名</span>来访问。推荐第一种方式访问（前提是得满足访问权限）\n5. 实例变量不能通过<span style=\"color:red\">类名.类变量名</span>方式访问\n6. 类变量是在类加载时就初始化了，也就是说，及时没有创建对象，只要加载类了，就可使用类变量了\n7. 类变量的声明周期是随类的加载开始，随着类的消亡而销毁\n\n### 二、类方法\n\n#### 介绍\n\n类方法也称静态方法\n\n### 格式\n\n````java\n访问修饰符\tstatic\t数据源返回类型\t方法名(){}\t【推荐】\nstatic\t访问修饰符\t数据返回类型\t方法名(){}\n````\n\n\n\n#### 类方法调用\n\n使用方式：\n\n<span style=\"color:red\">类名.类方法名</span>\n\n或\n\n<span style=\"color:red\">对象名.类方法名</span>\n\n#### 使用场景\n\n当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。\n\n比如：工具类中的方法utils\n\nMath类、Arrays类、Collections集合类\n\n#### 使用细节\n\n1. 类方法和普通方法都是随着类的加载而加载，将结构信息储存在方法区：\n   * 类方法中无this的参数\n   * 普通方法中隐含this参数\n2. 类方法可以通过类名调用，也可以通过对象名调用\n3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用\n4. 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以\n5. 类方法(静态方法)中，只能访问 静态变量和静态方法\n6. 普通成员方法，既可以访问静态的成员，非静态的方法。可以访问静态成员和非静态成员\n\n#### 总结：\n\n静态方法，只能访问静态的成员，\n\n非静态方法，可以访问静态的 成员和非静态的成员\n\n（前提是必须遵守访问权限规则）\n\n## 理解main方法语法\n\n#### 深入理解main方法\n\n解释main方法的形式：public static void main(String[] args){}\n\nmain方法是java虚拟机调用的\n\n1. java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public\n\n2. java虚拟机在执行main()方法是不必创建对象，所有该方法必须是static\n\n3. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数\n\n4. java执行的程序 参数1 参数2  参数3\n\n   ![image-20220403184106869](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220403184106869.png)\n\n#### 提示\n\n1. 在main（）方法中我们可以直接调用main方法所在类的静态方法或静态属性\n\n2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，再能通过这个对象去访问类中的非静态成员\n\n3. 例：\n\n   * ```java\n     class A{\n     \tprivate int a;\n     \tprivate static int b;\n     \t\n     \tprivate void a(){\n     \t\tSystem.out.println(\"非静态方法a\");\n     \t}\n     \tprivate static void b(){\n     \t\tSystem.out.println(\"静态方法a\");\n     \t}\n     \t\n     \t\n     \t\n     \tpublic static void main(String[] args){\n     \t\tSystem.out.println(\"id = \" +a);//错误 a是非静态变量，得实例一个对象才能调用\n             System.out.println(\"id = \" +new A().a);//这样是正确的，创建了个匿名对象调用\n             System.out.println(\"id = \" +b);//正确， 因为b是静态变量，可以直接调用\n             System.out.println(\"id = \" +a());//错误，和上述a的非静态变量的原因相同\n             System.out.println(\"id = \" +new A().a());//改成这样就是正确的，因为a()是非静态的方法\n             \n             A a = new A();\n             System.out.println(\"id = \" +a.a());//同理\n     \t}\n     }\n     ```\n\n   * \n\n\n\n## 代码块\n\n#### 介绍\n\n代码块又称初始化块，属于类中的成员【即 是类的一部分】。类似于方法，将罗技语句封装在方法体中，通过{}包围起来\n\n和方法不同，没有方法名，没有返回，没有参数，只有方法体。而且不用通过对象或类显式调用，而是在家类是，或创建对象时隐式调用。\n\n#### 基本语法\n\n```java\n[修饰符]{\n\t代码\n};\n```\n\n#### 注意：\n\n1. 修饰符 可选，要写的话，也只能写static\n2. 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块\n3. 逻辑语句可以为任何罗技语句（输入，输出，方法调用，循环，判断等）\n4. ; 号可以写上，也可以省略。\n\n#### 优点\n\n1. 相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作\n2. 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性\n\n#### 案例\n\n```java\nclass Movie{\n\tprivate String name;\n\tprivate double price;\n\tpricate String director;\n    /*\n    使用场景\n    1. 下面三个构造器都有相同的语句\n    2. 这样重写大量的代码\n    3. 可以吧相同语句提取出来，放到一个代码块中\n    4. 我们不管调用哪个构造器，创建对象，都会先执行代码块\n    5. 代码块调用的顺序都是优先于构造器\n    \n    */\n\t\n\t{\n\t\tSystem.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n\t\n\t}\n    \n    public Movie(String name){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n    }\n    public Movie(String name,double price){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n        this.price = price;\n    }\n    public Movie(String name,double price,String director){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n        this.price = price;\n        this.director = director;\n    }\n}\n```\n\n#### 使用细节\n\n1. static代码块也叫静态代码块，作用就是对类进行初始化，\n\n   而且它随着类的加载而执行\n\n   并且只会执行一次。\n\n   如果是普通代码块，每创建一个对象，就执行\n\n   ```java\n   //静态代码块\n   static{\n   \txxxx;\n   }\n   \n   //普通代码块\n   {\n   \txxxx;\n   }\n   ```\n\n2. 类什么时候被加载？[重要]\n\n   1. 创建对象实例时（new xxx)\n   2. 创建子类对象实例，父类也会被加载\n      1. 先在家父类的代码块，再执行子类的\n   3. 使用类的静态成员时（静态属性，静态方法）\n\n   案例：A类 extends B类的静态块\n\n   ​\t\t\t先执行a的静态块，然后再执行b的\n\n   ![image-20220404151232983](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220404151232983.png)\n\n3. 普通代码块，在创建对象实例时，会被隐式调用。\n\n   被创建一次，就会调用一次\n\n   如果只是使用类的静态成员时，普通代码块并不会执行\n\n   \n\n4. 创建一个对象时，在一个类 调用顺序是（重点，难点）\n\n   1. 调用静态代码块和静态属性初始化\n\n      （注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用\n\n      ```java\n      案例理解\n          \n          因为static的优先级一样，\n          所以哪个写在前面，哪个就先执行\n      class A{\n          \n          private static  int n1 = getn1();\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n      }\n      \n      ============================================\n      输出结果：\n      ============================================\n      use getn1\n      A's static codeBlock\n          \n          \n      =========================分割线=========================\n      //如果更换顺序\n      class A{\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          \n          private static  int n1 = getn1();\n          \n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n      }   \n      ============================================\n      输出结果：\n      ============================================\n       A's static codeBlock\n      use getn1\n         \n      ```\n\n      \n\n   2. 调用普通代码块和普通属性的初始化\n\n      （注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义的顺序调用） \n\n      ```java\n      //先执行静态的，和上述的一样，\n      //然后再执行非静态的，规则也是和上述一样，谁写前面先执行谁\n      class A{\n          private int b = getn2();\n      \n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }\n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      getn2 被调用\n      普通代码块被执行\n          \n          \n      =========================分割线=========================\n      class A{\n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          private int b = getn2();\n      \n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }    \n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      普通代码块被执行\n      getn2 被调用\n      ```\n\n        \n\n   3. 调用构造器\n\n      构造器优先级最低，上述的两个规则执行完成后\n      才会执行构造器\n\n      ```java\n      class A{\n          public A() {\n              System.out.println(\"构造器被执行\");\n          }\n      \n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          private int b = getn2();\n      \n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }\n      \n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      普通代码块被执行\n      getn2 被调用\n      构造器被执行\n      \n      ```\n\n5. 构造器 的最前面其实隐含了super() 和调用普通代码块\n\n   静态相关的代码块，属性初始化，在类加载时，就执行完毕。因此是优先于 构造器和普通代码块执行的\n\n   演示：\n\n   ```java\n   class A{\n   \tpublic A(){\n   \t\t//这里存在隐藏的调用\n   \t\t\t//(1) super();\n   \t\t\t//(2) 调用普通代码块\n   \t\t\t\n   \t\t System.out.println(\"xxxx\");\t\n   \t}\n   }\n   ```\n\n   ```java\n   class AAA{\n       public AAA() {\n           //这里存在隐藏的调用\n           //(1) super();\n           //(2) 调用普通代码块\n           //因为Object的代码块没有输出\n           \n           //1.先输出\n           System.out.println(\"AAA的构造器被调用\");\n       }\n   }\n   class BBB extends AAA{\n       {\n   //        根据规则父类的输出完毕后，再调用方法区\n   //        2. 再执行普通代码块\n           System.out.println(\"bbb的普通代码块执行\");\n       }\n   \n       public BBB() {\n           //这里存在隐藏的调用\n           //(1) super();\n           //(2) 调用普通代码块\n   //        等上述执行完毕后，最后执行该语句\n           System.out.println(\"BBB的无参构造被执行\");\n       }\n   }\n   ```\n\n6. 创建一个子类对象时(继承关系),他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：\n\n   1. 父类的静态代码块和静态属性（优先级一样，按定义的顺序执行）\n   2. 子类的静态代码块和静态属性（优先级一样，按定义的顺序执行）\n   3. 父类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）\n   4. 父类的构造器\n   5. 子类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）\n   6. 子类的构造器\n\n7. 静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任何成员\n\n\n\n## 单例设计模式\n\n#### 介绍\n\n1. 所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且只提供一个取得对象实例的方法\n2. 单例模式有两种方式：1）饿汉式 2）懒汉式\n   1. 二者最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例,而懒汉式在使用时才创建\n   2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题\n   3. 饿汉式存在浪费资源的可能。（因为如果程序员一个对象实例都没使用，那么饿汉式创建的对象就是浪费了，懒汉式是使用时才创建，就不存在这个问题\n   4. 在javaSE标准类中，java.lang.Runtim就是经典的单例设计模式\n\n演示：\n\n1. 恶汉式\n\n   类加载的时候，对象就被创建实例对象，可能会出现创建了，但是没有使用\n\n   步骤：\n\n   1. 构造器私有化 => 防止直接new\n\n   2. 类的内部创建对象\n\n   3. 向外露出一个静态的公共方法。\n\n   4. 代码实现\n\n   5. ```java\n      public class singleDesign {\n          public static void main(String[] args) {\n              System.out.println(GirlFriend.info());\n          }\n      \n      }\n      //有一个女朋友类\n      //只能有一个女朋友\n      class GirlFriend{\n          private String name;\n      \n      \n      //    2.创建一个对象\n      //    3.为了能够接收静态方法，需要修饰为static\n          private static GirlFriend girl = new GirlFriend(info());\n      \n      \n      \n      //    如何保证只能有一个对象实例\n      //    public girlFriend(String name) {\n      //        this.name = name;\n      //    }\n      //    1. 改成私有的构造器\n          private GirlFriend(String name) {\n              this.name = name;\n          }\n      //    4.创建一个静态方法，用于接收实例对象\n          public static String info(){\n              return \"g\";\n          }\n      \n      ```\n\n2. 懒汉式\n\n   使用时才创建实例\n\n   1. 构造器私有化=> 防止直接new\n\n   2. 类的内部创建对象\n\n   3. 向外暴露一个静态的公共方法\n\n   4. ```java\n      public class SingleDesign01 {\n          public static void main(String[] args) {\n              System.out.println(Cat.i);\n      //        此时只是初始化了cat ，但没有创建对象，其他的静态参数可以直接调用\n              System.out.println(Cat.getCat());\n      //        当只有调用了这个方法时，才会创建对象(通过判断发现没有cat类，此时创建后返回)\n          }\n      }\n      //懒汉式\n      //希望在程序运行中，只创建一个cat\n      \n      class Cat{\n          private String name;\n          public static int i =1;\n      //    2.定义一个静态属性static\n          private  static Cat cat;\n      \n      //    3.提供一个公共的static方法 可以返回一个Cat对象\n          public  static  Cat getCat(){\n              if (cat == null){ //如果还没创建对象\n                  cat = new Cat(\"little cute\");\n              }\n              return cat;\n          }\n      \n      //    1.创建私有构造器\n          private Cat(String name){\n              this.name = name;\n          }\n      }\n      ```\n\n      \n\n## final关键字\n\n#### 介绍\n\nfinal / 最后的，最终的\n\nfianl 可以修饰类、属性、方法和局部变量\n\n某些情况下，程序员可能有以下需求，就会使用到final：\n\n1. 当不希望类被继承时，可以用final修饰\n2. 当不希望父类的某个方法可以被子类覆盖/重写（override）时，可以用final关键字修饰\n3. 当不希望类的某个属性的值被修改，可以使用final修饰\n4. 当不希望某个局部变量被修改，可以使用final修饰\n\n\n\n#### 使用细节\n\n1. final修饰的属性又叫常量，一般用XX_XX_XX来命名\n\n2. final修饰的属性在定义时，必须赋初始值，并且以后都不能修改，赋值可以在如下位置之一（选择一个位置赋初始值即可）\n\n   1. 定义时：例如  public final double TAX_PATE=0.09;\n\n   2. 在构造器中\n\n   3. 在代码块中\n\n   4. ```java\n      class A{\n      //定义时赋值\n      \tpublic final double ATX_A = 0.9;\n      \t//在构造器中赋值\n      \tpublic final double ATX_B；\n      \tpublic A{\n      \t\tATX_B=0.8；\n      \t}\n      \t//在代码块中赋值\n      \tpublic final double ATX_C；\n      \t{\n      \t\tATX_C=0.2；\n      \t}\n      }\n      ```\n\n3. 如果final修饰的属性是静态的，则初始化的位置只能是\n\n   1. 定义时\n   2. 在静态代码块 \n   3. 不能再构造器中赋值\n\n4. final类不能被继承，但是可以实例化对象\n\n5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承\n\n6. 一般来说，如果一个类已经是final类，就没有必要再将方法修饰成final方法。\n\n7. final不能修饰构造方法（即构造器）\n\n8. final和static 往往搭配使用，效率更高，不会导致类的加载。底层编译器做了优化处理\n\n9. 包装类(integer,Double,Float,Boolean等等都是final),String 也是final类\n\n\n\n## 抽象类\n\n```java\n编写一个父类\n//class Animal{\nabstract Animal{\n\tString name;\n\tpublic Animal(String name){\n\t this.name = name;\n\t}\n\t/*\n\t这里的eat方法 实现了，没有什么意义\n\t即父类中的方法不确定性的问题\n\t\n\t1.考虑将该方法设计为抽象(abstract)方法\n\t2.所谓抽象方法就是没有实现的方法\n\t3.所谓的没有实现就是没有方法体\n\t4.当一个类存在抽象方法时，就需要将该类声明为abstract类\n\t\n\t一般来说，抽象类会被继承，有其子类来实现抽象方法\n\t*/\n    \n\t//public void eat(){\n\t//\tSystem.out.println(\"这个是一个吃方法，但不知道吃啥\");\n\t//}\n    \n\tpublic abstract void eat();\n}\n```\n\n\n\n#### 介绍\n\n1. 用abstract 关键字修饰的类时，这个类就是抽象类\n\n   1. ```java\n      访问修饰符 abstract 类名{\n      }\n      ```\n\n2. 用abstract 关键字来修饰一个方法时，这个方法就是抽象方法\n\n   1. ```java\n      访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体\n      ```\n\n3. 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()\n\n#### 细节\n\n1. 抽象类不能被实例化\n2. 抽象类不一定包含abstract方法。也就是说，抽象类可以没有abstract方法\n3. 一旦包含了abstract方法，则这个类必须声明为abstract \n4. abstract 只能修饰类和方法，不能修饰属性和其他的\n5. 抽象类可以有任意成员【抽象类的本质还是类】，比如：非抽象方法、构造器、静态属性等等\n6. 抽象方法不能有主体，即不能实现。例如：abstract void method()；不能有{}\n7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract 类（所谓实现就是有那个{}就可，具体内容不管）\n8. 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的\n\n#### 抽象类实践-模板设计模式\n\n现有个需求\n\n1. 有多个类，完成不同的任务job\n2. 要求能得到各自完成任务的时间\n\n```java\npackage seatWork;\n\npublic class Template {\n    public static void main(String[] args) {\n        son1 son1 = new son1();\n        son1.getCurrentTime();\n        son2 son2 = new son2();\n        son2.getCurrentTime();\n    }\n\n}\n\nabstract class Father{\n//在抽象类中定义一个抽象方法，这个方法后期会填入不同子类的不同不同方法\n    public abstract void job();\n//创建一个子类中的公共部分，在其中添加 不同的部分抽象类(方法)，\n// 由于动态绑定机制，当调用该方法时，根据实例不同的子类实现不同的输出结果\n//    也就是说相当于创建了个模板，不同的类用填不同的内容\n    public void getCurrentTime(){\n        long start = System.currentTimeMillis();\n        job();\n        long end = System.currentTimeMillis();\n        System.out.println(\"用时：\"+(end-start));\n    }\n}\nclass son1 extends Father{\n    @Override\n    public void job() {\n        int sum=0;\n        for (int i = 0; i < 10000; i++) {\n            sum+=i;\n        }\n    }\n}\nclass son2 extends Father{\n\n    @Override\n    public void job() {\n        int sum=0;\n        for (int i = 0; i < 60000; i++) {\n            sum+=i;\n        }\n    }\n} \n```\n\n## 接口（重要）\n\n#### 介绍\n\n接口就是给出一些没有实现的方法，封装到一起，起到某个类要使用的时候，在根据具体情况吧这些方法写出来\n\n#### 语法\n\n```java\ninterface 类名 implements 接口{\n 自己的属性；\n 自己的方法；\n 必须实现的接口的抽象方法；\n}\n```\n\n小结:\n\n1. jdk7之前，接口中所有方法否是抽象方法\n2. jdk8之后，接口中可以有实现方法，但需要使用default关键字修饰\n3. jdk8之后可以有静态方法\n4. abstract关键字可以省略\n\n#### 注意事项\n\n1. 接口不能被实例化\n\n2. 接口中所有的方法是public方法，接口中抽象方法，可以不用填写abstract，因为默认修饰的就是public abstract xxx。\n\n3. 一个普通类实现接口，就必须将该接口的所有方法都实现\n\n4. 抽象类实现接口，可以不用实现接口的方法\n\n5. 一个类同时可以实现多个接口\n\n6. 接口的属性，只能是final的，而且public static final 修饰符，比如：int a =1; 实际上是public static final int a =1；（必须）初始化\n\n7. 接口中属性的访问形式：接口名.属性名\n\n8. 一个接口不能继承其他的类，但是可以继承多个别的接口\n\n   ```java\n   interface A extend B,c,d...{}\n   ```\n\n9. 接口的修饰符只能是public和默认，这点和类的修饰符是一样的。\n\n小结：\n\n继承vs接口\n\n1. 当子类继承了父类，就自动拥有了父类的功能\n2. 如果子类需要拓展功能，可以通过实现接口的方式扩展\n3. 可以理解，接口是对java单继承机制的一个补充\n\n继承的价值：解决代码的复用性和可维护性\n\n接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。更加的灵活\n\n## 内部类（重点）\n\n#### 介绍：\n\n一个类的内部又完整的嵌套了另一个类结构。被嵌套的类成为内部类（inner class)，嵌套其他类的类成为外部类(out class)。是我们类的第五大成员\n\n类的五大成员：\n\n1. 属性\n2. 方法\n3. 构造器\n4. 代码块\n5. 内部类\n\n#### 基本语法\n\n```java\nclass Outer{//外部类\n\tclass inner{//内部类\n\t}\n}\n\nclass other{//外部其他类\n}\n```\n\n \n\n#### 内部类的分类\n\n定义在外部类局部位置上（比如方法内）\n\n##### 1）局部内部类（有类名）\n\n​\t\t说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名\n\n```java\n//例\nclass outclass{\n  private int n = 100;\n  //局部内部类师是定义在外部类的局部位置，通常在方法内\n // 1.第一种在局部位置\n \tclass innerClass{}\n  //2. 在方法内，（局部内部类）\n  public void mehtod(){//局部内部类（本质仍然是一个类）\n    \tclass innerClass{\n        System.out.print(\"n=\"+n);\n      }    \n  }\n}\n```\n\n1. 可以直接访问外部类的所有成员，包括私有的\n\n2. 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但可以使用final修饰，因为局部变量也可以使用final修饰符的\n\n3. 作用域：仅仅在定义它的方法或代码块中\n\n4. 局部内部类---访问---->外部类的成员【访问方式：直接访问】\n\n5. 外部类----访问---->局部内部类的成员\n\n   访问方式：创建对象，再访问（注意：必须在作用域内）\n\n6. 外部其它类---->不能访问---->局部内部类（因为 局部内部类地位是一个局部变量）\n\n7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问\n\n8. ```java\n   class Outer{\n   \tprivate int n1 = 10;\n   \tprivate static String name = \"张三\";\n   \tpublic void say(){\n   \t\tint n3 = 30;\n         //局部内部类是定义在外部类的局部位置，通常在方法  \n           //不能添加访问修饰符，可以使用final修饰\n     class localInner{//局部内部类（本质仍然是一个类）\n       int n1 = 100;\n      int n2 = 40;\n           //可以直接访问外部类的所有成员，包括私有的    \n         public void show(){\n         //默认输入内部类的n1的值 100\n   \t    System.out.print(\"n1=\"+n1);\n         //输入outer.this.n1 输出的才是外部类的n1\n         System.out.print(\"n1=\"+outer.this.n1);\n           \n         }\n   \t}\n   }\n     //外部类使用内部类\n     localInner inner = new localInner();\n     inner.show();\n    }\n   \n   \n   \n   //外部其他类\n   \n   ```\n\n9. \n\n##### 2）匿名内部类（没有类名，重点！！！！）\n\n###### 介绍：\n\n1. 本质是类\n2. 是一个内部类\n3. 该类没有名字\n4. 同时还是一个对象\n\n匿名内部类是定义在外部类的局部位置\n\n比如在方法中，并且没有类名\n\n###### 基本语法\n\n```java\nnew 类 或 接口（参数列表）{\n\t类体\n};\n\nanonymous\n```\n\n###### 演示 \n\n```java\npackage chapterObjectHeightLevel;\n\npublic class AnonymousClass {\n    public static void main(String[] args) {\n        outer outer = new outer();\n        outer.method();\n    }\n}\n\nclass outer{//外部类\n    private  int n1 =10;\n    public  void method(){\n        //现有一个需求，使用IA接口，并创建对象\n\n//        传统方法：新建一个类tiger 实现IA接口，并new tiger调用\n//        IA tiger = new Tiger();\n//        tiger.cry();\n//        当此时的需求是只需要这个Tiger类使用一次，并且以后再也不使用\n//        如果再用传统方法的话，会造成资源浪费，而且没有必要再去新建一个类\n//        此时就需要匿名内部类来简化开发，如下\n        IA tiger = new IA(){\n            /**\n             *此时底层是这样的\n             * class xxx(该类名是系统自动创建的) implements IA{\n             *     @Override\n             *     public void cry() {\n             *         System.out.println(\"老虎叫`````\");\n             *     }\n             * }\n             *\n             * 之后在让tiger指向xxx的地址\n             */\n            @Override\n            public void cry() {\n                System.out.println(\"老虎叫`````\");\n            }\n        };\n        tiger.cry();\n\n\n\n        //演示基于类的匿名内部类\n//        1. father的编译类型 Father(不加{}号)\n//        2. father的编译类型 xxx$2(加{}号）\n//        2.1 底层会创建匿名内部类\n        Father father = new Father(\"tiger\"){\n            @Override\n            public void test() {\n                System.out.println(\"override test method\");\n            }\n            /**\n            * 相当于创建了哥匿名内部类重写了test方法\n            * class xxx implement test{\n             *      @Override\n             *      public void test() {\n             *          System.out.println(\"override test method\");\n             *       }\n             * }\n             * 然后再将father指向xxx的地址\n            * */\n        };\n        father.test();\n\n    }\n\n}\n\ninterface IA{\n    public void cry();\n}\n\n//class Tiger implements IA{\n//\n//    @Override\n//    public void cry() {\n//        System.out.println(\"老虎叫`````\");\n//    }\n//}\n\nclass Father{\n    public Father(String name) {\n\n    }\n    public void test(){\n\n    }\n}\n\n```\n\n\n\n###### 注意细节\n\n1. 匿名内部类既是一个类的定义，同事它也是一个对象，因此从语法上来看，它既有定义类的特征，也有创建对象的特征，对前面的代码分析可以看出这个特点，因此调用匿名内部类方法有两种\n\n   ```java\n   //1.第一种方式\n   new A{\n   @override\n   \tpublic void cry(){\n   \tSystem.out.print(\"hello\");\n   \t}\n   }.cry();\n   \n   //2.第二种方式\n   A a=new A{\n   @override\n   \tpublic void cry(){\n   \tSystem.out.print(\"hello\");\n   \t}\n   }\n   a.cry();\n   ```\n\n2. 可以访问外部类的所有成员，包括私有的\n\n3. 不能添加访问修饰符，因为它的地位就是一个局部变量\n\n4. 作用域：方法或代码块中\n\n5. 匿名内部类--->范围跟--->外部类成员\n\n6. 外部其他类--->不能访问--->匿名内部类（因为 匿名内部类地位是一个局部变量）\n\n7. 如果外部类和内部类的成员变量重名时，内部类访问的话，默认就是就近原则，如果想访问外部，可以使用（外部类名.this.成员）去访问\n\n\n\n\n\n定义在外部类的成员位置上\n\n##### 1）成员内部类（没用static修饰）\n\n介绍：\n\n1. 成员内部类是定义在外部类的成员位置，并且没有static修饰\n\n   ```java\n   class outer{\n   \tprivate int n1 =10;\n   \tpublic String name = \"zhangsan\";\n   \t\n   \tclass inner{\n   \t\tpublic void say(){\n   \t\t\tSystem.out.print(\"outer n1 = \"+n1+\"outer name = \"+name);\n   \t\t}\n   \t}\n   }\n   ```\n\n2. 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位是一个成员\n\n3. 作用域\n\n   和外部类的其他成员一样，为整个类体比如前面的案例，在外部类的成员方法中创建成员内部类对象，再调用方法\n\n4. 成员内部类-->访问--->外部类成员\n\n   (比如属性)【访问方式：直接访问】\n\n5. 外部类 ---访问---内部类\n\n   访问方式：创建对象，再访问\n\n6. 外部其他类-----访问-----成员内部类\n\n   ```java\n   //三种方式:\n   //1\n   outer.inner class = new outer.new inner;\n   \n   // 第二种方式\n    1.定义一个方法，用于创建内部类并返回内部类的实例\n      public inner getInner(){\n      Inner inner  = new Inner();\n      return inner;\n    }\n   2. 在需要的地方new一个外部类.这个方法\n     Outer.Inner inner = new Outer.getInner();\n   \n   //3这个方法不建议使用\n     \n     new Outer().new Inner();\n   \n   ```\n\n7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问\n\n   ![image-20220409142725630](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409142725630.png)\n\n##### 2）静态内部类（使用static修饰）\n\n###### 介绍\n\n静态内部类定义在外部类的成员位置，并且有static修饰\n\n1. 可以直接访问外部的所有静态成员，包含私有的，但不能直接访问非静态成员\n2. 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员\n3. 作用域：同其他的成员，为整个类体\n\n```java\nclass outer{\nprivate int n1=10;\nprivate static String name = \"zhangsan\";\n\n//inner就是静态内部类\n  //1. 放在外部类的成员位置\n  //2. 使用static修饰\n  //3. 不能直接访问非静态成员\n  //4. 可以添加修饰符\n\tstatic class Inner{\n\t\tpublic void say(){\n      \tSystem.out.println(name);\n    }\n\t}\n}\n```\n\n4. 静态内部类---访问----外部类\n\n   （比如：静态属性）[访问方式：直接访问所有静态成员]\n\n5. 外部类--访问---静态内部类 \n\n   访问方式：创建对象，再访问\n\n6. 外部其他类 --访问 --内部类\n\n   访问方式：\n\n   ```java\n   //访问方式1\n   //因为静态内部类，是可以通过类名直接访问（前提是满足访问权限）\n   Outer.Inner inner = new Outer.Inner();\n   inner.xxx();\n   //访问方式2\n   //写一个方法，返回静态内部类的实例\n   public Inner getInner(){\n     return new Inner();\n   }\n   Outer.Inner inner = Outer.getInner();\n   \n   inner.xxx();\n   \n   //或者将方法换成静态\n   public static Inner getInner(){\n     return new Inner();\n   }\n   \n   \n   \n   ```\n\n7. 如果外部类和静态内部类的成员重名时，静态内部访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问\n\n# 枚举和注解\n\n## 枚举（enum）\n\n### 介绍\n\n1）枚举对应的英文（enumeration,简写enum）\n\n2）枚举是一组常量的集合\n\n3）可以理解：枚举属于一种特殊的类，里面只包含一组有限的特定对象（比如一年只有四个季节，建一个季节类的话只能有四个，而且有被添加其他季节的风险）\n\n\n\n### 实现方式\n\n#### 1）自定义枚举\n\n1. 不需要提供set方法，因为枚举对象通常为只读\n2. 对枚举对象/属性使用final +static共同修饰，实现底层优化\n3. 枚举对象通常使用大写，常量的命名规范\n4. 枚举对象根据需要，也可以有多个属性\n\n```java\npackage chapterEnum;\n\npublic class understandForEnum {\n    public static void main(String[] args) {\n        season autumn = season.AUTUMN;\n        System.out.println(autumn.getSeasonName()+autumn.getSeasonDescription());\n\n    }\n}\n//定义一个季节类\nclass season{\n    private String seasonName;//季节名称\n    private String seasonDescription;//季节描述\n  //1.将构造器私有化\n  //2.去掉setxx方法，防止属性被修改\n  //3.在season内部，直接创建固定的对象\n  //4.优化，添加final\n\n    public String getSeasonName() {\n        return seasonName;\n    }\n\n    public String getSeasonDescription() {\n        return seasonDescription;\n    }\n\n    private season(String seasonName, String seasonDescription) {\n        this.seasonName = seasonName;\n        this.seasonDescription = seasonDescription;\n    }\n//定义了四个对象\n    public final static season SPRING = new season(\"春天\",\"温暖\");\n    public final static season SUMMER = new season(\"夏天\",\"炎热\");\n    public final static season AUTUMN = new season(\"秋天\",\"凉爽\");\n    public final static season WINTER = new season(\"冬天\",\"寒冷\");\n}\n\n```\n\n总结：定义枚举类型有一下几个特点\n\n1. 构造器私有化\n2. 本类内部创建一组对象\n3. 对外暴露对象（添加public final static 修饰）\n4. 可以提供get方法，但不需要提供set方法\n\n#### 2）使用enum关键字实现\n\n```java\npackage chapterEnum;\n\npublic class understandForEnum02 {\n    public static void main(String[] args) {\n        System.out.println(season02.SPRING);\n    }\n}\nenum season02{\n    /**\n     * 实现步骤\n     * 1.使用enum代替class\n     * 2.直接使用 常量名(实参列表)\n     *   SPRING(\"春天\",\"温暖\"),\n     *   如果有多个常量则用,号隔开\n     *\n     * enum修饰必须将常量对象写在第一行\n     *  必须写在定义的变量和方法前面\n     *\n     * 3.编写常量，私有构造器和get方法\n     * */\n\n    SPRING(\"春天\",\"温暖\"),\n    SUMMER(\"夏天\",\"炎热\"),\n    AUTUMN(\"秋天\",\"凉爽\"),\n    WINTER(\"冬天\",\"寒冷\");\n\n\n    private String seasonName;//季节名称\n    private String seasonDescription;//季节描述\n\n    public String getSeasonName() {\n        return seasonName;\n    }\n\n    public String getSeasonDescription() {\n        return seasonDescription;\n    }\n\n    private season02(String seasonName, String seasonDescription) {\n        this.seasonName = seasonName;\n        this.seasonDescription = seasonDescription;\n    }\n\n    @Override\n    public String toString() {\n        return \"season02{\" +\n                \"seasonName='\" + seasonName + '\\'' +\n                \", seasonDescription='\" + seasonDescription + '\\'' +\n                '}';\n    }\n    //定义四个固定对象\n    /*\n    public final static season02 SPRING = new season02(\"春天\",\"温暖\");\n    public final static season02 SUMMER = new season02(\"夏天\",\"炎热\");\n    public final static season02 AUTUMN = new season02(\"秋天\",\"凉爽\");\n    public final static season02 WINTER = new season02(\"冬天\",\"寒冷\");\n*/\n\n\n}\n```\n\n##### 注意事项\n\n1. 当我们使用enum关键字开发一个枚举类时，默认会继承Enum类\n2. 传统的public static final SPRING = new season(\"春天\",\"温暖\");简化成SPRING(\"春天\",\"温暖\"),这里必须知道，它调用的是哪个构造器\n3. 如果使用无参构造器 创建枚举对象，则实参列表和小括号都可以省略\n4. 当有多个枚举对象时，使用，号间隔，最后一个分号结尾\n5. 枚举对象必须放在枚举的行首\n\n\n\n### enum常用方法说明\n\n使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类的相关方法\n\n![image-20220409204654918](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409204654918.png)\n\n```java\n    public static void main(String[] args) {\n//        使用season02 枚举类，演示各个方法\n        season02 summer = season02.SUMMER;\n//        输出枚举对象的名字\n//        summer.name();\n        System.out.println(summer.name());\n\n//        ordinal()输出的是该枚举对象的次序/编号，按枚举的顺序从0开始编号\n//        summer枚举对象时第二个，因此返回 1\n        System.out.println(summer.ordinal());\n\n//        从反编译可以看出values方法，返货season02[]\n//        含有定义所有的枚举对象\n        season02[] values = season02.values();\n        for (int i = 0; i <values.length ; i++) {\n            System.out.println(values[i].name());\n        }\n//        增强for循环演示\n//        每执行一次values就会扔一个对象给season、\n//        简单来说就是依次取出数组赋给season\n        System.out.println(\"==========增强for=========\");\n        for(season02 season:values){\n            System.out.println(season.name());\n        }\n\n//        valueOf:将字符串转换成枚举对象，要求字符串必须VT为己有的常量名，否则会报错\n//        1.根据输入的\"xia\"到season02中的枚举对象去查找\n//        2.如果找到了，就返回，如果没有找到就报错，如下这个例子\n        /*season02 vaof = chapterEnum.season02.valueOf(\"xia\");\n        System.out.println(\"vaof = \"+ vaof);*/\n//        3.只要valueOf()中的参数和枚举对象一致才能正常返回，如下\n        season02 xia = chapterEnum.season02.valueOf(\"SUMMER\");\n        System.out.println(\"xia = \" +xia);\n\n//        compareTo:比较两个枚举常量，比较的是编号\n//        就是把season02.SPRING和season02.SUMMER的编号进行比较\n//        底层是第一个的编号减去第二的编号，\n//        如果=0则是相等的，\n//        如果大于1，则代表前面那个编号大于后面一个编号\n//        如果小于1，则反之\n        System.out.println(season02.SPRING.compareTo(season02.SUMMER));//= -1\n        System.out.println(season02.SPRING.compareTo(season02.WINTER));//= -3\n\n    }\n```\n\n### 使用细节\n\n1. enum修饰的类不能在继承其他父类，因为enum会隐式继承一个Enum类\n2. enum实现的类，仍然是一个类，所以还是可以实现接口的\n\n\n\n### Switch中使用枚举\n\n案例\n\n1. ![image-20220410224921752](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410224921752.png)\n\n2. ```java\n   package homeWork.Annotation;\n   \n   public class AnnotationHomeWork08 {\n       public static void main(String[] args) {\n   //        Color.BLACK.show();\n   //        Color.RED.show();\n       Color red = Color.RED;\n   //    在小（）内放入枚举对象\n   //        在每个case后，直接写上枚举类，定义枚举对象即可\n           switch (red){\n               case RED:\n                   System.out.println(\"红色\");\n                   break;\n               case BLUE:\n                   System.out.println(\"蓝色\");\n                   break;\n               case BLACK:\n                   System.out.println(\"黑色\");\n                   break;\n               case YELLOW:\n                   System.out.println(\"黄色\");\n                   break;\n               case GREEN:\n                   System.out.println(\"绿色\");\n                   break;\n               default:\n                   System.out.println(\"没匹配到\");\n   \n           }\n       }\n   }\n   interface Tint{\n       public void show();\n   }\n   enum Color implements Tint{\n       RED(255,0,0),\n       BLUE(0,0,255),\n       BLACK(0,0,0),\n       YELLOW(255,255,0),\n       GREEN(0,255,0);\n   \n       private int redValue;\n       private int greenValue;\n       private int blueValue;\n   \n       Color(int redValue, int greenValue, int blueValue) {\n           this.redValue = redValue;\n           this.greenValue = greenValue;\n           this.blueValue = blueValue;\n       }\n   \n       @Override\n       public void show() {\n           System.out.println(redValue+\"\\t\"+greenValue+\"\\t\"+blueValue);\n       }\n   }\n   \n   ```\n\n\n\n## 注解\n\n#### 介绍\n\n1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息\n2. 和注解一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息\n3. 在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等，在javase中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替javaee旧版中所遗留 的繁冗代码和xml配置等\n\n使用Annotation时，前面要加@符号，并把Annotation当成一个修饰符使用。用于修饰它支持的程序元素\n\n1. @Override：限定某个方法，是重写父类方法，该注解只能用于方法\n\n   ```java\n   class son extends father{\n   //1.@Override注解方法fly方法上，表示子类fly方法重写了父类的fly\n   //2.如果这里没有写@Override ，还是重写了fly\n   //3.如果写了@Override注解，编译器就会去检查该方法是否真的重写了fly方法，\n   \t如果的确重写了，则编译通过。如果没有构成重写，则编译错误\n   @Override\n   public void fly(){\n    System.out.println(\"son fly...\");\n   }\n   }\n   ```\n\n   @Override只能修饰方法，不能修饰其他类\n\n2. @Deprecated：用于表示某个程序元素(类、方法等)已过时\n\n3. @SuppressWarnings：抑制编译器警告\n\n   1. 当写一些方法时，会出现一些无关不影响运行的警告。\n\n      可以使用@SuppressWarnings来抑制警告信息\n\n   2. 可以在@SuppressWarnings{\"\"}中写入希望抑制的警告信息\n\n   3. ![image-20220410190809537](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410190809537.png)\n\n   4. 位置在哪就屏蔽哪里 \n\n\n\n### 元注解（了解）\n\n@Target是修饰注解的注解，称为元注解  （了解）\n\n元注解的种类（使用不多，要求看到直到是干啥的）\n\n#### 1）Retention //指定注解的作用范围，三种SOURCE,CLASS,RUNTIME\n\n说明：\n\n只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，\n\n@Rentention包含一个RententionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值\n\n@Rentention的三种值：\n\nRententionPolicy.SOURCE //编译器使用后，直接丢弃这种策略的注释\n\nRententionPolicy.CLASS // 编译器将把注释记录在class文件中，当运行java程序时，JVM不会保留注释，这是默认值\n\nRententionPolicy.RUNTIME  //编译器将把注解记录在class文件中，当运行java程序时，JVM会保留注释，程序可以通过反射获取该注释\n\n示意图：\n\n![image-20220410203107921](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410203107921.png)\n\n#### 2）Target     //指定注解可以在哪些地方使用\n\n用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素\n\n简单来说就是在哪些元素上使用\n\n@Target   也包含一个名为value的成员变量\t\n\nTarget(value = CONSTRUCTOR（构造器）, FIELD（field） , LOACL_VARIABLE（局部变量）, METHOD（方法）,PACKAGE（包）,PARAMETER ,TYPE )\n\n#### 3）Documented    //指定该注解是否会在javadoc中体现\n\n@Documented   用于指定该元注解修饰的Annotation类将被Javadoc 工具提取成文档，即在生成文档时，可以看到注解\n\n定义Documented  注解必须设置Retention 值为RUNTIME\n\n#### 4）Inherited    //子类会继承父类注解\n\n\n\n# 异常\n\n## 异常的概念\n\n### 介绍\n\njava语言中，将程序执行中发生的不正常情况成为“异常”。（开发过程中的语法错误和逻辑错误不属于异常）\n\n执行过程中所发生的异常事件可分为两类\n\n1. Error（错误）：java虚拟机无法解决的严重问题。例如：JVM系统内部错误，资源耗尽等严重情况。例：StackOverflowError[栈溢出]和OOM（out of memory),Error是严重错误，程序会崩溃。\n2. Exception：因为，其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对想的代码进行处理，例如空指针访问，视图读取不存在的文件，网络连接中断等等，Exception分为两大类，运行时异常[程序运行发生的异常]和编译时异常[编译时，编译器查出的异常]\n\n\n\n## 异常体系图（重要）\n\n![image-20220411214601035](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411214601035.png)\n\n![image-20220411215335526](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411215335526.png)\n\n小结：\n\n1. 异常分为两大类，运行时异常和编译时异常\n\n2. 运行时异常，编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该避免出现的异常。java.lang.RuntimeException类及它的子类都是运行程序\n\n3. 对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影像\n\n4. 编译时异常，是编译器要求必须处置的异常\n\n    \n\n## 常见的异常\n\n### 常见的运行异常\n\n#### 1）NullPoniterException 空指针异常\n\n1. 当程序试图在需要对象的地方使用 null时，抛出该异常\n\n#### 2 ) ArithmeticException\t数字运算异常\n\n1. 当出现异常的运行条件时，抛出此异常\n2. 例如 一个整数\"除以零\"时，抛出此类的一个实例\n\n#### 3）ArrayIndexOutOfBoundsException\t数组下标异常\n\n1. 用非法索引访问数组时抛出的异常，如果索引为负或者大于等于数组大小，则该索引为非法索引\n\n#### 4）ClassCastException\t类型转换异常\n\n1. 当试图将对象强制转换为不是实例的子类时，抛出该异常\n\n#### 5）NumberFormatException\t数字格式不正确异常[]\n\n1. 当应用程序试图将字符串转换成一种数值类型，但该字符不能转换为适当格式时，抛出该异常\n2. 使用该异常我们可以确保输入的是满足条件的数字\n\n### 常见的编译异常\n\n#### 介绍\n\n编译异常是指在编译期间。就必须处理的异常，否则代码不能通过编译\n\n#### 常见的编译异常\n\n1. SQLException\t//操作数据库时，查询表可能发生的异常\n2. IOException\t\t//操作文件时，发生的异常\n3. FileNotFoundException\t//当操作一个不存在的文件时，发生异常\n4. ClassNotFoundException\t//加载类，该类不存在时，异常\n5. EOFException\t\t//操作文件，到文件末尾，发生异常\n6. IIIegalArguementException\t//参数异常\n\n\n\n## 异常处理概念\n\n### 基本介绍\n\n异常处理就是当异常发生时，对异常处理的方式\n\n### 异常处理方式\n\n#### 1）try-catch-finally\n\n程序员在代码中捕获发生的异常，自行处理\n\n```java\ntry{\n\t代码/可能有异常\n}catch(Exception e){\n//捕获的异常，传给e\n//1.当异常发生时\n//2.系统将异常封装成Exception对象e，传递给catch\n//3.得到异常对象后，程序员自己处理\n//4.如果没有发生异常，则catch代码块不执行\n}finally{\n    //不管try代码块是否有异常发生，始终都要执行finally\n    //通常将释放资源的代码方法finally代码块中\n}\n```\n\n\n\n#### 2）throws\n\n将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM\n\n##### 处理机制图\n\n![image-20220411224543192](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411224543192.png)\n\n\n\nthrows处理机制\n\n1. try-catch-finally和throws二选一\n2. 如果程序员，没有显示是处理异常，默认throws\n\n## 异常处理分类\n\n### try-catch方式处理异常说明\n\n#### 1）java提供try和catch块来处理异常。\n\ntry块用于包含可能出错的代码块。catch用于处理try块中发生的异常，可以根据需要在程序中有多个数量的try...catch块\n\n#### 2）基本语法\n\n```java\ntry{\n//可疑代码\n//将异常生成对应的异常对象，传递给catch块\n}catch(异常){\n//对异常的处理\n}\n//没有finally是可以通过的\n```\n\n```java\n//使用案例\ntry{\nString str = \"糖\";\nint a  = Integer.parseInt(str);\nSystem.out.println(\"数字=\"+a);\n}catch(Exception e){\nSystem.out.println(\"异常信息=\"+e.getMessage());\n}\n```\n\n#### 注意事项\n\n1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块\n\n2. 如果异常没有发生，则顺序执行try代码块，不会进入到catch块\n\n3. 如果希望不管是否能发生异常，都执行某段代码块（比如关闭链接，释放资源等）、\n\n4. 可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求是父类异异常在后，子类异常在前，比如（Exception 在后，NullPointerException 在前）如果发生异常，只会匹配一个catch\n\n   1. ```java\n      例:\n      try{\n      \n      }catch(NullPointerException e){\n      \n      }catch(Exception e){\n      \n      }finally{\n      \n      }\n      \n      ```\n\n5. 可以记性try-finally配合使用，这种方法相当于没有捕获异常，因此程序会直接崩掉\n\n   1. 应用场景：就是执行一段代码，不论是否发生异常，都必须执行某个业务逻辑\n\n#### 小结\n\n1. 如果没有出现异常，则执行try块中所有语句，不执行catch块中的语句，如果有finally，最后还要执行finally语句\n2. 如果出现异常，则try块异常发生后，剩下的语句不在执行，将执行catch块中的语句，如果有finally，最后还要执行finally里面的语句\n\n\n\n### throws异常处理\n\n#### 介绍：\n\n1）如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理异常，则此方法应显示的声明抛出异常，表明该方法将不对这些异常进行处理，而且由该方法的调用者负责处理\n\n2）在方法声明throws语句可以声明排除异常的列表，throws后面的异常类型可以是方法产生的异常类型，也可以是它的父类\n\n#### 注意事项\n\n1. 对于编译异常，程 序必须处理，比如try-catch或者throws\n2. 对于运行时异常，程序中如果没有处理，默认就是throws的方式处理\n3. 子类重写父类的方法是，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一直，要么为父类抛出的异常的类型和子类型\n4. 在throws过程中，如果有try-catch，就相当于处理异常，就可以不必throws\n5. ![image-20220412135104986](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412135104986.png)\n6. \n\n## 自定义异常  \n\n### 介绍：\n\n当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述错误信息。\n\n### 自定义异常的步骤\n\n1. 定义类：自定义异常类名（程序员自己写）继承Exceotion或RuntimeException\n2. 如果继承Ecxeption，属于编译异常\n3. 如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）\n\n```java\n//当我们接受Person对象年龄时，要求范围在18-120之间，否则抛出一个自定义异常（要求继承RuntimeException），并提示\npublic class CustomException {\n    public static void main(String[] args) {\n        int age =30;\n//        结果取反\n        if (!(age>=18&&age<=120)){\n//            通过构造器设置输出信息\n            throw new AgeException(\"年龄需要在18-120之间\");\n        }\n        System.out.println(\"你的年龄为\"+age);\n    }\n}\n//定义一个异常类继承RuntimeException\n//一般情况下，我们自定义异常都继承RuntimeException\n//也就是说大都是定义为运行时异常，好处是我们可以使用默认处理机制\n//即比较方便\nclass AgeException extends RuntimeException{\n//    定义一个构造器\n    public AgeException(String message) {\n        super(message);\n    }\n}\n```\n\n\n\n## throw和throws的对比\n\n|        | 意义                     | 位置       | 后面跟的东西 |\n| ------ | ------------------------ | ---------- | :----------: |\n| throws | 异常处理的一种方式       | 方法声明处 |   异常类型   |\n| throw  | 手动生成异常对象的关键字 | 方法体中   |   异常对象   |\n\nthrows\n\n```java\npublic void xxx() throws Exception{\n    //throws通常放在定义方法的末尾\n} \n```\n\nthrow\n\n```java\n//throw后面跟的是异常对象\nthrow new AgeException(\"年龄需要在18-120之间\");\n```\n\n\n\n# 常用类\n\n## 包装类\n\n### 包装类的分类   Wrapper\n\n1、针对八种基本数据类型相应类型的引用类型---包装类\n\n2、有了类的特点，就可以调用类中的方法\n\n| 基本数据类型 |  包装类   |\n| :----------: | :-------: |\n|   boolean    |  Boolean  |\n|     char     | Character |\n|     byte     |  `Byte`   |\n|    short     |  `Short`  |\n|     int      | `Integer` |\n|     long     |  `Long`   |\n|    float     |  `Float`  |\n|    double    |  `Doble`  |\n\n上述标出来的6个数据类型父类均为Number\n\n![image-20220412164154544](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412164154544.png)\n\n### 包装类和基本数据的转换\n\n#### 案例\n\n演示包装类和基本数据类型的相互转换，以int和integer演示\n\n1）jdk5前的手动装箱和拆箱方式，装箱：基本类型->包装类型,反之拆箱\n\n2）jdk5以后（包括jdk5）的自动装箱和拆箱方式\n\n3）自动装箱底层调用的是valueOf方法，比如integer.valueOf();\n\n4）其他类型同理\n\n```java\n//基本类型——————>包装类型[手动装箱]\nint i =10;\ninteger i1 = new Integer(i);\ninteger i2 = Integer.value(i);\n\n//包装类型————————>基本类型[手动拆箱]\nInteger j = new Integer(99);\nint j1 = j.intValue();\n```\n\n```java\n//jdk5.0之后的方式\nint m =10;\nInteger m2 =m;\nInteger n = new Integer(99);\nint n2 = n;\nSystem.out.println(\"n+100\");\nSystem.out.println(\"n*2\");\nif(n>10){\n\n}\n```\n\n### 包装类型和String类型的相互转换\n\n#### 案例\n\n以integer和String转为例\n\n```java\n//包装类型---->String类型\ninteger i =10;\n//方式1\nString s1 = i.toString();\n//方式2\nString s2 = String.valueOf(i);\n//方式3\nString s3 = i+\"\"; \nSystem.out.println(s3);\n\n//String --->包装类\n//方式1\nInteger j =new Integer(s1);\n//方式2\nInteger j2 = Integer.valueOf(s2);\n//\nInteger.parseInt(s3);\n```\n\n### Integer类和Character类常方法\n\n```java\nInteger.MIN_VALUE //返回最小值\nInteger.MAX_VALUE //返回最大值\n\nCharacter.isDigit('a');//判断是不是数字\nCharacter.isLetter('a');//判断是不是字母\nCharacter.isUpperCase('a');//判断是不是大写\nCharacter.inLowerCase('a');//判断是不是小写\n\nCharacter.isWhitespace('a')；//判断是不是空格\nCharacter.toUpperCase('a');//转成大写\nCharacter.toLowerCase('a');//转成小写\n\n```\n\n### Integer面试题\n\n1.看代码输出什么，为啥\n\n1. ![image-20220413164815801](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164815801.png)\n\n2. 因为integer的原码定义好了从-128-127之间不返回一个对象\n\n   ![image-20220413164729185](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164729185.png)\n\n   2.integer面试题总结\n\n   看下列代码输出什么结果\n\n   <span style=\"color:red;background:yellow \" >只要有基本数据类型会自动拆箱，比对的是数值。判断的是值是否相等</span>\n\n   如下的示例六和七，比对的是\n\n   ![image-20220413205739995](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413205739995.png)\n\n   \n\n   \n\n## String(重要)\n\n![image-20220413213320195](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413213320195.png)\n\nString实现了三个接口并继承了Object类\n\n* Serializable接口：说明String可以串行化。（可以在网络传输）\n* Comparable接口：说明String对象可以相互比较\n* CharSequence接口：字符序列\n\n<span style=\"color:blue;background:pink\">String类是final类，String类不能被其他类继承</span>\n\n<span style=\"color:blue;background:pink\">String 有属性，private final char value[];用于存放字符串内容（字符串的本质就是char数组）</span>\n\n<span style=\"color:red;background:pink\">(注意：value是一个final类型，不可修改（即：value不能指向新的地址，但是单个字符内容时可以变化的）)</span>\n\n\n\n\n\n### 理解\n\n1）String对象用于保存字符串，也就是一组字符序列\n\n2）字符串常量对象时用双引号括起来的字符序列。例如：\"你好\"，\"21.213\"，\"boy\"等等\n\n3）字符串的字符使用Unicode字符编码，一个字符（不区分字幕还是汉字）占两个字节\n\n4）String类较常用的构造方法（其他手册）\n\n* String s1 = new String();\n* String s2 = new String(String original);\n* String s3 = new String(char[] a);\n* String s4 = new String(char[] a,int startIndex, int count)\n\n### 创建方式\n\n#### 1）方式一：直接赋值String s = \"xxx\";\n\n创建流程：\n\n先从常量池查看是否有\"xxx\"数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址\n\n#### 2）方式二：调用构造器 String s = new String(\"xxx\")；\n\n流程：现在堆中创建空间，里面维护了value属性，指向常量池的xxx空间。如果常量池没有\"xxx\"，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址\n\n![image-20220414101904944](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414101904944.png)\n\n### String字符串的特性\n\n1）String是一个final类，代表不可变的字符序列\n\n2）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的 \n\n\n\n#### 面试题、\n\n1）String a = \"hello\"+\"abc\";创建了几个对象\n\n```java\n编译器会在后台会进行优化，判断创建的常量池对象，是否有引用指向\n优化等价于String a = \"helloabc\"；\n\n所以答案是创建了一个对象\n不是创建了三个\n```\n\n2）String a = \"hello\";\n\nString b = \"abc\";\n\nString c = a+b;\n\n总共创建了几个对象\n\n所以只创建了一个\n\n```java\n执行流程\n1. 先创建了一个StringBuilder sb = StringBuilder();\n2.执行sb.append(\"hello\");\n3.sb.append(\"abc\");\n4.String c = sb.toString();\n最后其实是c指向了堆中的对象（String）value[],堆中的对象指向了池中的“helloabc”\n```\n\n![image-20220414140922725](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414140922725.png)\n\n小结:底层是StringBuilder sb = new StringBuilder();sb.append(a);sb.append(b);sb是在堆中，并append是在原来的字符串的基础上追加的。\n\n重要规则：String c1 = \"sb\"+\"cd\";常量相加，看的是池。String c1 = a+b;变量相加，是在堆中\n\n### String类的常见方法\n\n#### 说明：\n\n​\tString类是保存字符串常量的。每次更新都需要重新开辟空间，效率低，因此java设计者还提供StringBuilder和StringBuffer来增强String的功能，并提高效率。\n\n#### Strng常见的方法\n\n![image-20220414145929644](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414145929644.png)\n\n* equals\t\t//区分大小写，判断是否相等\n\n* equalsIgnoreCase   //忽略大小写，判断内容是否相等\n\n* length  //获取字符的个数，字符窜长度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n\n* indexOf  //获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到返回-1\n\n* lastIndexOf   //获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，返回-1\n\n* substring //截取指定范围字符串\n\n* trim  //去前后空格\n\n* charAt //获取某索引处的字符，之一不能使用Str[index]这种方式\n\n* toUpperCase  //字符串转换成大写\n\n* toLowerCase  //字符串转换成小写\n\n* concat  //拼接字符串\n\n* replace  替换字符串中字符\n\n* split 分割字符串，罪域某些分割字符，我们需要转义\n\n  案例：\n\n  ```java\n  String poem =\"锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦\";\n  String[] split = poem.split(\",\");\n  //以，号为标准，分割上述整个字符串\n  //上述字符串被分割为4个部分用数组接收\n  \n  //在堆字符串进行分割时，如f\n  poem = \"E:\\\\aaa\\\\bbb\";\n  split  = poem.split(\"\\\\\\\\\");\n  ```\n\n  和 文件路径\n\n* compareTo //比较两个字符串的大小，如果前者大则返回正数，如果后者大则返回负数，\n\n  如果相等（\n\n  1.如果长度相同，并且字符串也相同返回0。\n\n  2.如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回if(c1 != c2）{\n\n  ​\t\treturn c1 - c2;\n\n  }\n\n  3.如果前面的部分都相同，就返回str1.len - str2.len）\n\n* toCharArray //字符串转成字符数组\n\n* format//格式化字符串，%s字符串，%c字符，%d 整型，%.2f 浮点型\n\n  ```java\n  //  %s%d%.2f%c成为占位符\n  //  这些占位符由后面的变量来替换\n  //  %s表示后面由字符串替换\n  //  %d表示整数替换\n  //  %.2f表示使用小数来替换，替换后，只会保留小数两位，并且会进行四舍五入的处理\n  //  %c是char类型替换\n      \n  String name =\"jack\";\n  int age = 10;\n  double score = 98.3 /3;\n  char gender ='男';\n  \n  //传统方法拼接\n  String info = \"名字是\"+name+\"年龄是\"+age+\"成绩是\"+score+\"性别：\"+gender\";\n  \n  \n  //使用format拼接\n  String info2 =String.format(\"姓名是%s年龄是%d成绩是%d性别时%c\",name,age,score,gender);\n  \n  //可以做成一个模板后面直接调用\n  String formatstr = \"姓名是%s年龄是%d成绩是%d性别时%c\";\n  \n  String info2 =String.format(formatstr,name,age,score,gender);\n  \n  System.out.println(\"info2 =\"+info2);\n  ```\n\n  \n\n## StringBuffer(重要)\n\n<span style=\"color:red;background:pink\">串行化（对象可以网络传输，可以保存到文件）</span>\n\n### 基本介绍\n\njava.lang.StringBuffer代表可变字符序列，可以对字符串内容进行增删\n\n很多方法与String相同，但StringBuffer是可变长度的\n\nStringBuffer是一个容器\n\n![image-20220415090614911](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415090614911.png)\n\n```java\nStringBuffer stringBuffer = new StringBuffer(\"hello\");\n//1.StringBuffer 的直接父类是 AbstractStringBuilder\n//2.StringBuffer 实现了Serializable，即StringBuffer的对象可以串行化\n//3.在父类中，AbstractStringBuilder 有属性 char[] value ，不是final\n\t该value 数组存放祖父穿内容，因数存放在堆中的\n//4.StringBuffer是一个final类， 不能被继承\n```\n\n### String 对比StringBuffer\n\n1）String保存的是字符串常量，里面的值不能更改，每次String类的更新实际是更改地址，效率较低//private final char value[]；\n\n2）StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用更新地址，效率较高//char[] value //这个放在堆\n\n\n\n### StringBuffer构造器\n\nStringBuffer()\n\n* 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符\n\n* ```java\n  //创建一个大小为16的char[]，用于存放字符串内容\n  StringBuffer stringBuffer = new StringBuffer();\n  ```\n\nStringBuffer(CharSequence seq)\n\n* public java.lang.StringBuffer(CharSequence seq)构造一个字符串缓冲区，它包含与指定的CharSequence 相同的字符\n\nStringBuffer(int capacity)//capacity[容量]\n\n* 构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对char[]大小进行指定\n\n* ```java\n  //通过构造器指定 char[]大小\n  StringBuffer stringBuffer = new StringBuffer(100);\n  ```\n\nStringBuffer(String str)\n\n* 构造一个字符串缓冲器，并将其内容初始化为指定的字符串内容\n\n* ```java\n  //通过给一个String 创建StringBuffer,char[] 大小就是str.length()+16\n  StringBuffer stringBuffer = new StringBuffer(\"hello\");\n  ```\n\n### String和StringBuffer\n\n#### String->StringBuffer\n\n```java\n//        String->StringBuffer\n//        方式一\n        String str =\"xxx\";\n//        注意：返回的是StringBuffer对象，对str本身是没有影响的\n        StringBuffer stringBuffer = new StringBuffer(str);\n\n\n//        方式二，使用append方法\n        StringBuffer stringBuffer1 = new StringBuffer();\n        stringBuffer1 = stringBuffer1.append(str);\n```\n\n#### StringBuffer->String\n\n```java\n\n//        StringBuffer->String\n        StringBuffer stringBuffer2 = new StringBuffer(\"xxxxxx\");\n//        方式一,使用StringBuffer提供的 toString方法;\n        String s = stringBuffer2.toString();\n\n//        方式二,使用构造器搞定\n        String s1 = new String(stringBuffer2);\n\n```\n\n\n\n### StirngBuffer类常见方法\n\n1. 增 append\n2. 删 delete(start,end)\n3. 改 replace(start,end,string)//将start---end间的内容替换掉，不含end\n4. 查 indexOf //查询字符串第1次出现的索引，如果找不回返回-1\n5. 插 insert\n6. 获取长度 length\n\n```java\n       StringBuffer stringBuffer = new StringBuffer(\"zhangsan\");\n\n        stringBuffer.append('x');\n        stringBuffer.append(\"张三\");\n        stringBuffer.append(\"wangwu\").append(true).append(10.2);\n        System.out.println(stringBuffer);\n\n//        删除\n        /*\n        * 删除索引为>=start && <end 处的字符\n        * 解读：删除11~14的字符[11,14)\n        * */\n        stringBuffer.delete(11,14);\n        System.out.println(stringBuffer);\n\n        //    改\n//        修改本质就是替换\n//        使用fff替换索引11-14的字符\n        stringBuffer.replace(11,14,\"fff\");\n        System.out.println(stringBuffer);\n\n//        查\n//        查找指定的子串在字符串出现的索引.如果找不到返回-1\n        int index = stringBuffer.indexOf(\"zhang\");\n        System.out.println(index);\n\n//        插入\n//        指定一个位置插入\n//        在索引为9的位置插入\"老王\"，原来索引为9的内容自动后移\n        stringBuffer.insert(9,\"老王\");\n        System.out.println(stringBuffer);\n\n//        获取长度\n        System.out.println(stringBuffer.length());\n    }\n\n```\n\n\n\n\n\n```java\n public static void main(String[] args) {\n        /**\n         * 输入商品名称和商品价格，要求打印效果示例，实用前面学习的方法完成\n         * 商品名  商品价格\n         * 手机123，456.56  //比如 价格价格1,456,786.5\n         * 要求：价格的小数点前面每三位用,号隔开，再输出\n        * */\n\n        String prices;\n        Scanner scanner = new Scanner(System.in);\n        String price = scanner.next();\n        StringBuffer stringBuffer = new StringBuffer(price);\n\n\n//        先完成最简单的实现21,312,412.32\n//        找到小数点的索引,然后再该位置的前三位插入,\n\n        for (int j = stringBuffer.lastIndexOf(\".\")-3; j >0 ; j-=3) {\n\n            stringBuffer = stringBuffer.insert(j, \",\");\n        }\n\n        System.out.println(stringBuffer);\n\n    }\n```\n\n\n\n\n\n## StringBuilder(重要)\n\n### 基本介绍\n\n1）一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder 不是线程安全)。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快（单线程的情况下，优先使用StringBuilder）\n\n2）在StringBuilder上主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据\n\n\n\n### StringBuilder常用方法\n\nStringBuilder和StringBuffer均代表可变字符序列，方法是一样的，所以使用和StringBuffer一样。\n\n1. StringBuilder是final类，不能被继承\n2. StringBuilder对象可以串行化\n3. 继承了AbstractStringBuilder属性 char[] value，内容存到value\n4. 实现了Serializable接口，序列化（所谓系列化既可以保存类型和数据本身）\n\n## String、StringBuffer、StringBuilder的比较☆\n\n1）StringBuilder和StringBuffer非常类似，均代表可变字符序列，而且方法也一样\n\n2）String：不可变字符序列，效率低，但是复用率高。\n\n3）StringBuffer：可变字符序列、效率较高（增删）、线程安全\n\n4）StringBuilder：可变字符序列、效率最高、线程不安全\n\n5）String使用注意事项：\n\n```java\nString s=\"a\"; //创建了一个字符串\ns+= \"b\";   //实际上原来的\"a\"字符串对象已经丢弃了，现在又产生了一个转字符串s+\"b\"（也就是\"ab\").如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=》\n//结论：如果我们对Stirng做大量修改，不要使用String\n```\n\n### 效率\n\nStringBuilder  > StringBuffer >String \n\n\n\n### 使用原则，结论\n\n1. 如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder\n2. 如果字符串存在大量的修改操作，并且在单线程的情况下使用StringBuilder\n3. 如果字符串存在大量的修改操作，并且在多线程的情况下使用StringBuffer\n4. 如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等\n\nStringBuffer和StringBuilder的方法使用一样\n\n## Math\n\n### 基本介绍\n\nMath类包含用于执行基本数学运算方法，如初等指数，对数，平方根和三角函数\n\n方法一览（均为静态方法）![image-20220415145338171](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415145338171.png)\n\n### Match常用的方法\n\n1. abs  绝对值\n\n2. pow  求幂\n\n3. ceil   向上取整  (返回>=该参数的最小整数)\n\n4. floor   向下取整  (返回<=该参数的最大整数)\n\n5. round   四舍五入\n\n6. sqrt  求开方\n\n7. random  求随机数\n\n   ```java\n   public static void main(String[] args) {\n           /*\n           random随机数\n           random默认返回 0<= x <1之间的一个随机小数\n           请写出a-b之间的一个随机整数，a,b均为整数比如a=2,b=7\n           即返回一个2 - 7 之间的随机数\n           * */\n           \n           /**\n           * random返回的是0<=x <1之间的一个随机小数\n            * Math.random()*(b-a)返回的就是0<= 数 <=b-a\n            * (1)(int)(a)<= x <(int)(a+Math.random() * (b-a +1))\n           * (2)集体使用解析\n            * (int)(a+Math.random() * (b-a +1))\n            *  = (int)(2+Math.random() * 6)\n            *  Math.random() * 6返回的就是0<= x <6小数\n            *  2+Math.random() * 6返回的就是2<= x <8小数\n            *  (int)(2+Math.random() * 6) = 2 <=x <=7\n           * */\n           \n   \n   \n   //      公式就是：(int)(a+Math.random() * (b-a +1))\n           for (int i = 0; i < 5; i++) {\n               System.out.println((int) (2 +Math.random()*(7-2+1)));\n           }\n       }\n   ```\n\n   \n\n8. max   求两个数的最大值\n\n9. min    求两个数的最小值\n\n\n\n\n\n## Date,Calender,LoaclDate.\n\n### Date[知道怎么查，怎么用即可]\n\n#### 第一代日期类\n\nDate：精确到毫秒，代表特定的瞬间\n\nSimpleDateFormat：格式和解析日期的类SimpleDateFormat 格式化和解析日期的具体类。它允许进行格式（日期->文本、解析（文本->日期）和规范化\n\n![image-20220420110144786](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420110144786.png)\n\n```java\n//获取当前时间\n//默认输出的格式是国外的格式\nDate d1 = new Date();、\n//因此需要对格式进行转换\nSimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 hh:mm:ss E\");\n//其他格式的字母意思，查看手册\nString foramt = d1.format(d1);\n\n//获取某个时间对应的毫秒数\nDate d2 = new Date(23123);\n\n//可以吧一个格式化的字符串转成对应的date\nString s = \"2000年7月五日 20:12:20 星期一\";\nDate pares = simpleDateFormat.parse(s);\n//接收的格式必须个定义的格式一样\n```\n\n### Calendar(日历)\n\n#### 第二代日期类\n\n主要就是Calendar类（日历）\n\n1）public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable<Calendar\n\n2)calendar类是一个抽象类，他为特定瞬间为一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等，日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。\n\n```java\n//创建日历对象，\nCalendar c =Calendar.getInstance();\nSystem.out.print(\"年\"+c.get(Calendar.YEAR))；\nSystem.out.print(\"月\"+c.get(Calendar.MONTH)+1)；\nSystem.out.print(\"日\"+c.get(Calendar.DAY_OF_MONTH))；\nSystem.out.print(\"小时\"+c.get(Calendar.HOUR))；\nSystem.out.print(\"分钟\"+c.get(Calendar.MINUTE))；\nSystem.out.print(\"秒\"+c.get(Calendar.SECOND))；\n//Calendar没有专门的格式化方法，所以程序员自己组合\nSystem.out.print(c.get(Calendar.SECOND)+\"年\"+(c.get(Calendar.MONTH)+1)+\"月\"+c.get(Calendar.DAY_OF_MONTH)+\"日\")；\n```\n\n### 第三代日期类\n\n前面两代的不足分析\n\n（jdk1.0中包含了一个java.Util.Date类，但是他的大多数方法已经存在JDK1.1引入Calendar类之后被弃用。Calendar也存在着很多问题\n\n1. 可变性：像日期和时间这样的类应该是不可变的。\n2. 偏移性：Date中年份是从1900开始的，而月份是从0开始的\n3. 格式化：格式化只对Date有用，Calendar则不行\n4. 此外，他们不是线程安全的，不能处理闰秒等（每隔两天多出1s）\n\n#### 第三代日期类\n\n1）LoaclDate（日期）、localTime（时间）、loacalDateTime（日期和时间内）\n\nJDK8\n\nLoaclDate：只包含日期，可以获取日期字段\n\nlocalTime：包含时间，可以获取时间字段\n\nloacalDateTime包含日期和时间，\n\n```java\nloacalDateTime ln = loacalDateTime.now();\nln.getYear();\nln.getMonth();\nln.getMonthValue();//输出数字版的月份\n```\n\n##### 2）DateTimeFormatter格式日期类\n\n类似于SimpleDateFormat\n\n```java\nDateTimeFormatter dtf = DateTimeFormatter.ofPattern(格式);//(yyyyMMdd....)\n\nString srt = dtf.format(日期对象);\n```\n\n#### Instant 时间戳\n\n类似于Date\n\n提供了一系列和Date类转换的方式\n\nInstant---->Date;\n\nDate date = Date.from(instant);\n\nDate --->Instant;\n\nInstant instant = date.toInstant();\n\n案例演示\n\n```java\nInstant now = Instant.now();\nSystem.out.print(now);\nDate date = Date.from(now);\nInstant instant = date.toInstant();\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## System\n\n### 常见方法\n\n1）exit 退出当前程序\n\n```\nSystem.exit(0);表示退出\n//0代表一个正常状态状态  。\n```\n\n2）Arraycopy：复制数组元素，比较合适底层调用，一般使用Arrays.copyOf完成数组复制。\n\n```java\nint[] src = {1,2,3};\nint[] dest = new int[3];\nSystem.arraycopy(src,0,dest,0,3)\n \tsrc:源数组\n    srcpos：从原数组的哪个索引位置开始开始拷贝\n    dest:目标数组，即吧原数组的数据拷贝到哪个数组\n    destpos：把原数组的数据拷贝到 目标数组的哪个索引\n    length:从原数组拷贝多少个数据到目标数组\n```\n\n3）currentTimeMillens：返回当前时间距离1970-1-1(1970年1月1日到现在) 的毫秒数\n\n4）gc：运行垃圾回收机制System.gc();\n\n## Arrays类\n\n### 介绍\n\nArrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）\n\n### 方法\n\n#### 1） toString返回数组的字符串形式，将数组拼接成字符串返回\n\n```java\nArrays.ToString(arr)\n```\n\n#### 2)sort排序（自然排序和定制排序）\t\n\n```java\nInteger arr[] = {1,-1,7,0,89};\n//可以直接使用该方法进行排序。不用再动手去敲方法\n//因为数组时引用类型，所以通过sort排序后，会影响到实参arr\nArrays.sort(arr);//正序排序\n//sort重载的，也可以通过传入一个接口Comparator实现定制排序\n\n1、调用定制排序时，传入两个参数\n    (1)排序数组的参数\n    (2)实现Comparator接口的匿名内部类。要求实现Compare方法\n\n    \n    \n//      这里体现了接口编程的方式\n//\n//        倒序排序\n        Arrays.sort(a, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                Integer i1 = (Integer) o1;\n                Integer i2 = (Integer) o2;\n//                return大于0 就是正序排序，小于0就是倒序\n                return i2 -i1;\n            }\n        });\n        System.out.println(Arrays.toString(a));\n\n    }\n```\n\n```java\n       bubble(a,new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                Integer i1 = (Integer) o1;\n                Integer i2 = (Integer) o2;\n                return i1 -i2 ;\n            }\n        });\n\n        System.out.println(\"定制类\"+Arrays.toString(a));\n\n    }\n\n\n//    定制排序\n    public static void bubble(Integer[] arr,Comparator c){\n        int temp;\n        for (int i = 0; i < arr.length-1 ; i++) {\n            for (int j = 0; j <arr.length-1-i; j++) {\n                if (c.compare(arr[j],arr[j+1])>0){\n                    temp =arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n```\n\n\n\n#### 3）binarySearch 二分搜索\n\nbinarySearch 通过二分搜索法进行查找，要求必须排好序\n\n```java\n //如果这个数组是有序的，可以通过该方法查找知否有这个数\n int[] arr = {1,23,45,65,78};\n//如果不存在该元素就返回，return -(low +1)//意思就是返回负的他该出现的位置的下标+1\n int index = Arrays.binarySearch(arr,3);//返回-2\n```\n\n#### 4）copyOf数组元素的复制\n\n```java\n//表示从arr数组中拷贝arr.length个长度的元素到新的arr数组中\nInteger[] newArr = Arrays.copyOf(arr,arr.length);\nInteger[] newArr = Arrays.copyOf(arr,arr.length-1);就是拷贝原数组长度-1\nInteger[] newArr = Arrays.copyOf(arr,arr.length+1);\n//如果长度超出原数组的长度，则多出来的部分元素为null   \n```\n\n#### 5)fill数组元素的填充\n\n```java\nInteger[] num = new Integer[]{9,2,1};\n//使用99去填充num数组\n//可以理解成替换原来的元素\nArrays.fill(num,99);\n\n==========运行结果======\n    [99,99,99]\n```\n\n#### 6)equals 比较两个数组元素内容是否完全一致\n\n```java\nboolean equals  = Arrays.equals(arr,arr2);\n//如果两个数组元素一样，则返回true。不一样返回false\n```\n\n#### 7)asList 将一组值，转换成list\n\n```java\nList<Integer> asList = Arrays.asList(2,3,4,5,6,1);\nSystem.out.println(\"asList\"+asList);\n```\n\n\n\n\n\n## Integer和BigDecimal类\n\n### 应用场景\n\n1）BigInteger适合保存比较大的整型(整数)\n\n```java\n//当编程中需要处理很大的整数。long不够用可以使用BigInteger类\n//使用\nBigInteger bigInteger = new BigInteger(\"2222222222222222222222222222222222222222\");\n\n//运算\n//在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）\n    \nBigInteger bigInteger 2=bigInteger.add(10)；//加\n    //也可再创建一个BigInteger相加\n```\n\n\n\n2）BigDecimal适合保存精度高的浮点型(小数)\n\n```java\n//当我们需要保存一个精度很高的值时，double不够用\n//可以使用BigDecimal\nBigDecimal bigDecimal = new BigDecimal(\"22.22222222222222222222222222\");\n//运算\n//在对BigDecimal进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）\n//需要创建一个需要操作的BigDecimal，然后调用即可\n\nBigDecimal bigDecimal=bigDecimal.add(2.3);\n    //使用删除方法时，可能会出现除不尽的情况，会抛出异常\n//解决办法：在调用divede(删除)方法是，指定精度即可\nbigDecimal.divide(1.11,BigDecimal.ROUND_CEILING)\n//如果有无限循环小数，就会保留到分子的精度\n\n```\n\n# 集合\n\n## 集合框架体系\n\n### 集合体系图\n\n背下来\n\n1）单例集合（在集合里面放单个的对象）\n\n![image-20220420163040446](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163040446.png)\n\n![image-20220420163624872](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163624872.png)\n\n2）双列集合（存放键值对形式的）\n\n![image-20220420163100945](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163100945.png)\n\n![image-20220420163609594](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163609594.png)\n\n```java\n//存放单个数据的成为单例\nArrayList  arrayList = new ArrayList();\narrayList.add(\"zhangsan\");\narrayList.add(\"lisi\");\n\n//存放双列数据的成为双例集合\nHashMap hashMap = new HashMap();\nhashMap.put(\"no1\",\"zhangsan\");\n//key,value\nhashMap.put(\"no2\",\"李四\");\n```\n\n## Collection\n\nCollection接口\n\n#### Collection接口实现类的特点\n\n```java\nPublic interface Collection<E> extends Iterable<E>\n```\n\n1. Collection实现子类可以存放多个元素，每个元素可以是 Object\n2. 有些Collection的实现类，可以存放重复的元素，有些不可以\n3. 有些Collection的实现类，有些是有序的（List），有些不是有序（Set）\n4. Collection接口没有直接实现子类，是通过它的子接口Set和List来实现的\n\n#### Collection接口和常用方法\n\n![image-20220420165341922](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420165341922.png)\n\n常用方法\n\n```java\n1)add :添加单个元素\n2)remove:删除指定元素\n3)contains:查找元素是否存在\n4）size：获取元素个数\n5）isEempty：判断是否为空\n6）clear：清空\n7）addAll：添加多个元素\n8）containsAll：查找多个元素是否都存在\n9）removeAll：删除多个元素\n说明：以ArrayList实现类演示\n```\n\n```java\npublic static void main(String[] args) {\n        ArrayList list = new ArrayList();\n//        1.添加单个元素\n        list.add(\"zhangsan\");\n        list.add(\"hahah\");\n        list.add(\"lisi\");\n        list.add(123);//等价于list.add(new Integer(123);\n        System.out.println(\"数组增加\"+list);\n//      remove：删除指定元素\n        list.remove(0);//删除第一个元素,下标从0开始\n        list.remove(\"123\");//删除指定元素\n        System.out.println(\"数组删除\"+list);\n\n//       contains 查找元素是否存在\n        System.out.println(list.contains(\"zhangsan\"));//F\n//        size,显示元素的个数\n        System.out.println(list.size());\n//      isEmpty判断是否为空\n        System.out.println(list.isEmpty());\n//        clear清空\n        list.clear();//清空集合\n        System.out.println(\"list清空=\"+list);\n\n        ArrayList list1 = new ArrayList();\n//        addAll:添加多个元素\n        list1.add(\"xxx\");\n        list1.add(\"xxxxxx\");\n\n        list.addAll(list1);\n        System.out.println(\"addAll\"+list);\n//        containsAll:查找多个元素知否存在\n        System.out.println(list.containsAll(list1));\n//        removeAll：删除多个元素\n        list.removeAll(list1);\n        System.out.println(list);\n\n    }\n```\n\n#### 使用Iterator（迭代器）\n\nCollection接口遍历元素的方式1-使用Iterator（迭代器）\n\n##### 基本介绍\n\n1）Iterator对象成为迭代器，主要用于遍历Collection集合中的元素\n\n2）所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可返回一个迭代器\n\n3）Iterator的结构![image-20220420231917444](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420231917444.png)\n\n4）Iterator仅用于遍历集合，Iterator本身并不存放对象\n\n###### 迭代器的运行原\n\n![image-20220421160914060](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220421160914060.png)\n\nhasNext用于判断\n\nnext（）；下移，并返回指向的元素\n\n```java\npublic class Iteraor {\n    public static void main(String[] args) {\n        Collection list = new ArrayList();\n        list.add(new HomeWork(\"zhansgan\",12313));\n        list.add(new HomeWork(\"haha\",231));\n\n//        使用迭代器遍历\n        Iterator iterator = list.iterator();\n//        while循环  快捷方式输入 itit\n//        ctrl+j提示所有快捷键\n     while (iterator.hasNext()) {\n//            返回下一个元素，是Object类型\n            Object next =  iterator.next();\n            System.out.println(next);\n        }\n//      当退出while循环后，这是iterator迭代器，指向最后一个元素\n//        iterator.next()  ，此时再让往下移指针会报异常：NuSuchElementException\n//        如果希望再次遍历，需要我们重置迭代器\n        iterator = list.iterator();//相当于指向了第一个元素\n\n    }\n}\n\nclass HomeWork{\n    String name;\n    Integer phoneNum;\n\n    public HomeWork() {\n    }\n\n    public HomeWork(String name, Integer phoneNum) {\n        this.name = name;\n        this.phoneNum = phoneNum;\n    }\n\n    @Override\n    public String toString() {\n        return \"HomeWork{\" +\n                \"name='\" + name + '\\'' +\n                \", phoneNum=\" + phoneNum +\n                '}';\n    }\n}\n```\n\n#### for循环增强\n\nCollection接口遍历元素的方式2-\n\n增强for循环，可以代替iterator迭代器\n\n特点：增强for就是简化版的iterator，本质一样。只能用于<span style=\"color:red\">遍历集合或数组</span>\n\n###### 基本语法\n\n```java\nfor(元素类型 元素名 : 集合名或数组){\n\t访问元素\n}\n```\n\n案例\n\n```java\n for (Object homeWork:list) {\n            System.out.println(homeWork);\n        }\n\n//        增强也可以在数组中使用\n        int[] a = {1,2,3,45,6};\n        for (int i: a){\n            System.out.println(i);\n        }\n```\n\n1. 增强for底层是迭代器\n2. 可以理解成增强for是简化版的迭代器\n\n## List\n\n基本介绍：\n\nList接口是Collection接口的子接口\n\n1）list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\n\n2）list集合中的每个元素都有其对应的顺序索引，即支持索引\n\n3）list容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素\n\n4）JDK API中的List接口实现类有：ArrayList、LinkedList和Vector\n\n```java\npublic static void main(String[] args) {\n//        list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\n        List list = new ArrayList();\n        list.add(\"jack\");\n        list.add(\"tom\");\n        list.add(\"zhangsan\");\n//        此时不会有冲突，相当于会认为有两个tom\n        list.add(\"tom\");\n//        此时输出的顺序就是存进去的顺序\n        System.out.println(\"list\"+list);\n\n//        2）list集合中的每个元素都有其对应的顺序索引，即支持索引\n//        索引从0开始\n        System.out.println(list.get(3));\n    }\n```\n\n##### List接口的常用方法\n\n1. void add（int index,Object ele）在index位置插入ele元素\n2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来\n3. Object get (int index)获取固定index位置的元素\n4. int indexOf(Object obj)  返回obj在几个中首次出现的位置\n5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置\n6. Object remove(int index) 移除指定index位置的元素，并返回此元素\n7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换\n8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合\n\n```java\npublic static void main(String[] args) {\n\n        List list = new ArrayList();\n        list.add(\"no1\");\n        list.add(\"no2\");\n//        1. void add（int index,Object ele）在index位置插入ele元素\n//        在index=1的位置插入一个对象\n        list.add(1,\"add(index,ele)\");\n        System.out.println(list);\n//        2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来\n        List list2 = new ArrayList();\n        list2.add(\"lno2\");\n        list2.add(\"lno3\");\n        list2.add(\"lno3\");\n//        在1的位置插入list2的集合\n        list.addAll(1,list2);\n        System.out.println(list);\n//        3. Object get (int index)获取固定index位置的元素\n//        4. int indexOf(Object obj)  返回obj在几个中首次出现的位置\n        System.out.println(list.indexOf(\"no1\"));\n//        5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置\n        System.out.println(list.lastIndexOf(\"lno3\"));\n//        6. Object remove(int index) 移除指定index位置的元素，并返回此元素\n        list.remove(1);\n        System.out.println( list);\n//        7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换\n//        将索引为1的改为尼诺\n        list.set(1,\"尼诺\");\n//        8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合\n        List result = list.subList(0, 2);//相当于选择了下标为0的和下标为2-1之间的元素\n        System.out.println(\"result\"+result);\n}\n```\n\n##### 注意事项\n\n1. permits all elements,including null , ArrayList 可以加入null，并且多个\n2. ArrayList 是由数组来实现数据存储的\n3. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）看源码，在多线程情况下，不建议使用ArrayList\n\n#### ArrayList\n\n#####  ArrayList底层机制和源码分析（重点）\n\n1）ArrayList中维护了一个Object类型的数组elementData\n\n​\t\ttransient Object[] elementData \n\n```\ntransient 表示瞬间，短暂的，表示该属性不会被序列化\n```\n\n\n\n2）当创建对象ArrayList时，如果使用的是无参构造器，则初始elementData容量为0\n\n3）当添加元素时，先判断是否需要扩容，则调用grow方法，否则直接添加元素到合适位置\n\n4）如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍\n\n5）如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity\n\n6）如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍\n\n\n\n#### Vector\n\n##### 介绍\n\nVevtor底层也是一个对象数组。protected Object[] elementData;\n\nVector是线程同步的，即线程安全，Vector类的操作方法带有synchronized\n\n在开发过程中，需要线程同步安全时，考虑使用Vector\n\n\n\n##### Vector 和ArrayList比较\n\n|           | 底层结构 | 版本   | 线程安全（同步）效率 | 扩容倍数                                                     |\n| --------- | -------- | ------ | -------------------- | ------------------------------------------------------------ |\n| ArrayList | 可变数组 | jdk1.2 | 不安全，效率高       | 如果有参构造1.5倍如果无参1.第一次是10，第二次按1.5扩         |\n| Vector    | 可变数组 | jdk1.0 | 安全，效率不高       | 如果是无参默认10，满后，就按两倍扩容。如果指定大小（创建）有参，则每次直接按2倍扩容 |\n\n#### LinkedList\n\n##### 说明\n\n1）LinkedList实现了双向链表和双端队列特点\n\n2）可以添加任意元素（元素可以重复），包括null\n\n3）线程不安全，没有实现同步\n\n##### LinkedList底层机制\n\n1. LinkedList底层维护了一个双向链表\n\n2. LinkedList中维护了两个属性first和last分别指向首节点和尾结点\n\n3. 每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表\n\n4. 所以LinkedList的元素的 添加和删除，不是通过该数组完成的，相对来说效率较高\n\n5. 模拟一个简单双向链表理解\n\n   ```java\n   public static void main(String[] args) {\n   //        模拟一个简单的双向链表\n           Node jack = new Node(\"jack\");\n           Node tom = new Node(\"tom\");\n           Node zhangshan = new Node(\"zhangshan\");\n   //        链接是三个结点，形成双向链表\n   //        jack->tom ->zhangsan\n           jack.next = tom;\n           tom.next =zhangshan;\n   //        zhangsan->tom->jack\n           zhangshan.pre = tom;\n           tom.pre = jack;\n   \n           Node first = jack;//让first引用指向jack，就是双向链表的头结点\n           Node last =zhangshan;//让last引用指向zhangshan，就是双向链表的尾结点\n   \n   \n   //        演示从头到尾进行遍历\n           while (true){\n               if (first == null){\n                   break;\n               }\n   //            输出first信息\n               System.out.println(first);\n               first = first.next;\n           }\n   \n   //        从未到头遍历\n           while (true){\n               if (last == null){\n                   break;\n               }\n               System.out.println(last);\n               last = last.pre;\n           }\n   \n       }\n   }\n   \n   //定义一个Node类，node对象 表示双向链表的一个结点\n   class Node{\n       public Object item;//真正存放数据\n       public Node next;//指向下一个结点\n       public Node pre;//指向前一个结点\n   \n       public Node(Object item) {\n           this.item = item;\n       }\n   \n       @Override\n       public String toString() {\n           return \"Node{\" +\n                   \"item=\" + item +\n                   '}';\n       }\n   }\n   ```\n\n   \n\n![image-20220429152321935](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429152321935.png)\n\n##### ArrayList 和LinkedList的比较\n\n|            | 底层结构 | 增删的效率         | 改查的效率 | 线程   |\n| ---------- | -------- | ------------------ | ---------- | ------ |\n| ArrayList  | 可变数组 | 较低；数组扩容     | 较高       | 不安全 |\n| LinkedList | 双向链表 | 较高，通过链表追加 | 较低       | 不安全 |\n\n何如选择\n\n1）如果我们改查的操作较多，选择ArrayList\n\n2）如果我们增删的操作多，选择LinkedList\n\n3）一般来说，在程序中80%-90%都是查询，因此大部分情况下会选择ArrayList\n\n4）在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说根据业务来进行合理选择\n\n## set\n\n介绍\n\n1）无序（添加和取出的顺序不一致），没有索引\n\n2）不允许重复元素，所以最多包含和一个null\n\n3）JDK API中Set接口的实现类有![image-20220429173926895](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429173926895.png)\n\n##### Set接口和常用方法\n\n和List接口一样，Set接口也是Collection的子接口，因此常用方法和Collection接口一样\n\n##### set接口遍历方式\n\n同Collection的遍历方式一样，因为Set接口是Collection接口的子接口\n\n* 使用迭代器\n* 增强for\n* 不能使用索引的方式获取\n\n##### 案例\n\n```java\npublic static void main(String[] args) {\n//        以set接口实现类HashSet来讲解Set接口的方法\n//        set接口的实现类的对象（set接口对象）\n//        重复添加的数据只会存进去一个，null值也是只能存放一个\n    //输出结果是无序的（存放的数据是无序的，即（添加的顺序和取出的顺序不一致））\n    //虽然取出的顺序和添加的顺序不一致，但取出的顺序是固定的，不会一直变化\n        Set set = new HashSet();\n        set.add(\"zhansgan\");\n        set.add(\"lisi\");\n        set.add(\"wa\");\n        set.add(\"zhansgan\");\n        set.add(null);\n        set.add(null);\n        System.out.println(set);\n    }\n\n//        遍历\n//        迭代器\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            Object next =  iterator.next();\n            System.out.println(next);\n        }\n//        增强for\n        for (Object o :set) {\n            System.out.println(o);\n        }\n----------------输出结果----------------------\n    [null, lisi, wa, zhansgan]\n```\n\n#### HashSet\n\n1)HashSet实现了Set接口\n\n2）HashSet实际上是HashMap，看源码\n\n![image-20220430145947382](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430145947382.png)\n\n3）可以存放null值，但是只能有一个null\n\n4）HashSet不保证元素时有序的，取决于hash之后，在确定索引的结果（即：不保证存放元素的顺序和取出的一致  ）\n\n5）不能有重复元素/对象。在前面Set接口使用已经标明\n\n```java\n//1.执行add方法后，会返回一个Boolean值\n//2.如果添加成功,返回true，否则返回false\n//3.可以通过remove指定删除哪个对象\n        HashSet set = new HashSet();\n        set.add(\"zhansgan\");\n        set.add(\"lisi\");\n        set.add(\"wa\");\n        set.add(\"zhansgan\");\n        set.add(null);\n        set.add(null);\n\n        set.remove(\"zhangsan\");\n\n        set.add(new HHHH(\"zzz\"));//添加成功\n        set.add(new HHHH(\"zzz\"));//添加成功\n    }\n}\nclass HHHH{\n    private String name;\n\n    public HHHH(String name) {\n        this.name = name;\n    }\n}\n```\n\n##### HashSet底层机制说明 \n\n1）HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树）\n\n\n\n1. HashSet底层是HashMap\n2. 添加一个元素时，先得到hash值 -会转成-索引值\n3. 找到储存数据表table，看这个索引位置是否已经存放的有元素\n4. 如果没有，直接加入\n5. 如果有调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后\n6. 在java8中，如果一条链表的元素个数到了TREEEIFY_THRESHOLD(默认是8)个，并且table的大小>=MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树）\n7. ![image-20220430160350549](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430160350549.png)\n\n源码分析\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    //定义了一个辅助变量\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //table就是HashMap的一个属性，类型是Node[]\n     //if语句表示如果当前table是null，或者大小=0\n    //就是第一次扩容，到16个空间\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n   //（1）根据key，得到hash值去计算key应该存放到table表的哪个索引位置\n    //并且把这个位置的对象赋给p\n    //（2）判断p是否为null\n    //（2.1）如果为null，表示还没有存放元素，就创建了一个Node\n    //（2.1）就放在该位置 tab[i] = newNode(hash, key, value, null); \n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n          //如果当前索引位置对应的链表的第一个元素和准备谈价的key的hash值一样\n            //并且满足下面条件之一\n            //1.准备加入的key和p指向的Node结点和key是同一个对象 \n            //2.p指向的Node结点的key的equals（）和准备加入的key比较后相同\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            //如果上述条件不满足，再判断p是不是一个红黑树\n            //如果是一颗红黑树，就调用putTreeVal，来进行添加判断\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            \n            else {\n                //依次比较链表内的内容\n                //如果table对应索引的额位置，已经是一个链表，就是用for循环比较\n                //(1)依次和链表的每一个元素比较后都不相同，则加入到该链表的最后\n                  //然后立即判断该链表是否已经达到8个结点，就调用   treeifyBin()对当前这个链表进行树化（转成红黑树）\n                //注意，在转成红黑树时，要进行判断，判断条件{if(tab == null ||(n = tab.length)<MIN_TREEIEY_CAPACITY)\n                //resize();   //table数组是否小于64，结点是否到达8个并不为空      }\n                //如果上面条件成立，先table扩容\n                //如果上面条件不成立，才进行树化\n                //(2)依次和该链表的每一个元素比较过程中，如果有相同的情况，就直接break；\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        \n                        p.next = newNode(hash, key, value, null);\n                \n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n##### HashSet的扩容和转成红黑树机制\n\n1. HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（localFactor）是0.75 =12\n2. 如果table数组实用到了临界值12，就会扩容到16*2=32，新的临界值就是32 * 0.75 = 24,依次类推\n3. 在java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8),并且table的大小>=MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树），否则仍然采用数组扩容机制\n\n\n\n### LinkedHashSet\n\n**说明**\n\n1）LinkedHashSet是HashSet的子类\n\n2）LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表\n\n3）LinkedHashSet根据元素的hashCode值来决定元素的储存位置，同时使用链表维护元素的次序（图），这使得元素看起来是以插入顺序保存的![image-20220501174705977](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220501174705977.png)\n\n4）LinkedHashSet不允许添加重复元素 \n\n![image-20220502111826275](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220502111826275.png)\n\n可以理解成不同索引的数，构成双向链表\n\n1. 在LinkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）\n\n2. 每一个结点有pre和next属性，这样可以形成双向链表\n\n3. 在添加一个元素时，先求hash值，在求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加[原则和hashset一样])\n\n   ```java\n   tail.next = newElement //简单指定\n   new Element.pre = tail\n   tail = newElement;\n   ```\n\n4. 这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致\n\n\n#### TreeSet\n\n1. 当使用无参构造器创建treeset的时候仍然是无序的\n\n2. 需求：希望添加的元素按字符串大小来排序?\n\n   1. 使用TreeSet提供的一个构造器,可以传入一个比较器（匿名内部类）\n\n   2. ```java\n      public class TreeSetDemo {\n          public static void main(String[] args) {\n      //        TreeSet treeSet = new TreeSet();\n              TreeSet treeSet = new TreeSet(new Comparator() {\n                  @Override\n                  public int compare(Object o1, Object o2) {\n      //                调用String的compareTo方法比较字符串大小\n                      return ((String)o1).compareTo((String) o2);\n                  }\n              });\n              treeSet.add(\"d\");\n              treeSet.add(\"b\");\n              treeSet.add(\"a\");\n              treeSet.add(\"c\");\n      \n              System.out.println(treeSet);\n          }}\n      ```\n\n   3. \n\n\n\n## Map\n\nMap**结构**\n\n<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220503163901620.png\" alt=\"image-20220503163901620\" style=\"zoom:50%;\" />\n\nMap接口的特点（JDK8之后的）\n\n1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）\n\n2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&Node对象中\n\n3）Map中的key不允许重复，原因和HashSet一样，前面分析过\n\n4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）\n\n5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个\n\n6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）\n\n7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n\n```java\n Map map = new HashMap();\n//        1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）\n//        2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&Node对象中\n//        3）Map中的key不允许重复，原因和HashSet一样，前面分析过\n//        4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(\"no1\",\"lisi\");\n//        5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个\n        map.put(null,null);\n        map.put(null,null);\n        map.put(\"no3\",null);\n        map.put(\"no4\",null);\n        //        6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）\n        map.put(new Object(),\"zhangsan\");\n//        7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n//        通过get方法传入key，会返回对应的value\n        System.out.println(map.get(\"no2\"));\n        System.out.println(map);\n=============输出==================\n  lisi\n{no2=lisi, null=null, no1=lisi, no4=null, no3=null, java.lang.Object@1540e19d=zhangsan}\n\n\n```\n\n8）Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，有因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry（如图）\n\n![image-20220504165516988](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220504165516988.png)\n\n数据存放在HashMap中，将set和collection作为一组对象放在Entry里面（其中不存放数据只是存放HashMap的引用）\n\n1. 将HashMap中的key和value数据 存放到一个entrySet集合（该集合不存放数据，存放的都是引用）\n\n```java\n Map map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");//k-v\n        map.put(\"no1\",\"lisi\");//k-v\n//        1.k-v最后是HashMap$Node node = newNode(hash ,key,value,null);\n//        2.k-v为了方便程序员遍历，还会创建EntrySet集合，该集合存放的元素类型（Entry），\n//        而一个Entry对象就有k-v，EntrySet<Entry<k,v>>，即：transient Set<Map.Entry<k,v>> entrySet;\n\n//        3.在entrySet中，定义的类型是Map.Entry，但是实际上存放的是HashMap$Node类型\n//        因为HashMap$Node implement Map.Entry 因为实现了Map.Entry接口，那么这个类的对象实例可以赋给这个接口类型\n//        4.当吧HashMap$Node存放到entrySet后就方便我们的遍历，因为Map.Entry提供了两个重要的方法，getKey()和getValue方法\n        Set set = map.entrySet();\n        System.out.println(set.getClass());\n//        输出：class java.util.HashMap$EntrySet\n        for (Object o :set) {\n            System.out.println(o.getClass());\n//            输出：class java.util.HashMap$Node\n//            从HashMap$Node取出k-v\n//            先做一个向下转型\n            Map.Entry entry = (Map.Entry) o;\n            System.out.println(entry.getKey() +\"\"+ entry.getValue());\n        }\n```\n\n\n\n#### map接口和常用方法\n\n1）put：添加\n\n2）remove：根据键删除映射关系\n\n3）get：根据键获取值\n\n4）size：获取元素个数\n\n5）isEmpty：判断个数是否为0\n\n6）clear；清楚\n\n7）containsKey：查找键值否存在\n\n```java\nMap map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(null,\"lisi\");\n        map.put(\"no3\",\"lisi\");\n        map.put(\"no4\",\"2\");\n\n        map.remove(null);\n        Object lisi = map.get(\"no2\");\n        System.out.println(\"lisi==\"+lisi);\n\n        System.out.println(map.size());\n\n        map.isEmpty();\n        System.out.println(map);\n        map.clear();\n        System.out.println(map);\n\n        System.out.println(map.containsKey(\"no3\"));\n\n```\n\n\n\n#### Map遍历方法\n\n1）containsKey：查找键是否存在\n\n2）KeySet：获取所有的键\n\n3）entrySet：获取所有关系\n\n4）values：获取所有的值\n\n```java\n  Map map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(null,\"sss\");\n        map.put(\"no3\",\"lisdsdsi\");\n        map.put(\"no4\",\"2\");\n\n//        第一粗：先取出所有的key，通过key取出对应的value\n        Set set = map.keySet();\n//        增强for\n        for (Object o :set) {\n            System.out.println(map.get(o));\n        }\n        System.out.println(\"迭代器\");\n//        （2） 使用迭代器\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            Object next =  iterator.next();\n            System.out.println(map.get(next));\n        }\n        System.out.println(\"=========第二中=========\");\n//      第二组：吧所有的values取出\n        Collection values = map.values();\n//        这里可以使用所有的collections使用的遍历方法\n        for (Object o :values) {\n            System.out.println(o);\n        }\n//        迭代器\n        System.out.println(\"迭代器\");\n        Iterator iterator1 = values.iterator();\n        while (iterator1.hasNext()) {\n            Object next =  iterator1.next();\n            System.out.println(next);\n        }\n\n        System.out.println(\"=========第三中=========\");\n//        通过entryset获取\n        Set set1 = map.entrySet();\n        for (Object entry :set1) {\n//            将entry转为map.entry\n            Map.Entry  entry1= (Map.Entry) entry;\n            System.out.println(entry1.getKey()+\" \"+entry1.getValue());\n        }\n        System.out.println(\"迭代器\");\n        Iterator iterator2 = set1.iterator();\n        while (iterator2.hasNext()) {\n            Object next =  iterator2.next();\n            Map.Entry m = (Map.Entry) next;\n            System.out.println(m.getKey()+\" itit \"+ m.getValue());\n        }\n```\n\n#### 小结\n\n1. Map接口的常用实现类：HashMap、Hashtable和Properties\n2. HashMap是Map接口使用频率最高的实现类\n3. HashMap是以key-value对的方式来存储数据（HashMap$Node类型）\n4. key不能重复，但值可以，允许使用null键和null值\n5. 如果添加相同的 key，则会覆盖原来的k-v，等同于修改，（key不会替换，val会替换）\n6. 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来储存的\n7. HashMap没有实现同步，因此线程不安全 的\n\n#### HashMap底层机制\n\n1）HashMap底层维护了Node类型的数组table，默认为null\n\n2）当创建对象时，将加载银子（loadfactor）初始化为0.75\n\n3）当添加key-value时，通过key的哈希值得到在table的索引，然后判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是连链表结构，做出相应处理。如果添加时发现容量不够则需扩容\n\n4）第一次添加，则需扩容table容量为16，临界值(threshold)为12\n\n5）以后再扩容，需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推\n\n6）在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小>=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化。\n\n#### HashTable\n\n**基本介绍**\n\n1）存放的元素时键值对：key-value\n\n2）hashTable的键和值都不能为null，否则会抛出空指针异常\n\n3）hashTable使用方法基本上和HashMap一样\n\n4）hashTable是线程安全的，HashMap是线程不安全的\n\n![image-20220506160740866](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220506160740866.png)\n\n#### Properties\n\n**基本介绍**\n\n1. properties类继承了Hashtable类并实现了Map接口，也是使用一种键值对(key-value)的形式来保存数据\n2. 它的使用特点和Hashtable类似\n3. properties还可用于从xxx.properties文件中，加载数据到properties类对象，并进行读取和修改\n4. 说明：工作后 xxx.properties文件常用作配置文件，io流部分(详细讲解)[www.cnblogs.com/xudong-bupt/p/3758136.html]\n\n## Collections\n\n### Collections工具类\n\n1）Collections是一个操作Set、List和Map等集合的工具类\n\n2）Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作\n\n### 排序操作（均为static方法）\n\n1. reverse（List）：反转List中元素的顺序\n\n2. shuffle（List）：对List集合元素进行随机排序\n\n3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序\n\n4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序\n\n5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换\n\n6. 案例：\n\n   ```java\n   public class Collectionsdemo {\n       public static void main(String[] args) {\n           ArrayList list = new ArrayList();\n           list.add(\"zhansgan\");\n           list.add(\"lisi\");\n           list.add(\"wngwu\");\n           list.add(\"laoliu\");\n           list.add(\"dasima\");\n           System.out.println(\"list=\"+list);\n   //        1. reverse（List）：反转List中元素的顺序\n           Collections.reverse(list);\n           System.out.println(\"reverse=\"+list);\n   //        2. shuffle（List）：对List集合元素进行随机排序\n           for (int i = 0; i < 5; i++) {\n               Collections.shuffle(list);\n               System.out.println(\"随机\"+list);\n           }\n   //        3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序\n           Collections.sort(list);\n           System.out.println(\"sort\"+list);\n   //        4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序\n           Collections.sort(list, new Comparator() {\n               @Override\n               public int compare(Object o1, Object o2) {\n                   return ((String)o1).length()-((String)o2).length();\n               }\n           });\n           System.out.println(\"字符串长度排序\"+list);\n   //        5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换\n   \n           Collections.swap(list,0,1);\n           System.out.println(\"位置交换\"+list);\n       }\n   }\n   ```\n\n\n\n### 查找、替换\n\n1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n\n2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素\n\n3. Object min（Collection)\n\n4. Object min (Collection，Comparator)\n\n5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数\n\n6. void copy（List dest，List src）：将src中的内容复制到dest中\n\n7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值\n\n8. ```java\n   public static void main(String[] args) {\n           ArrayList list = new ArrayList();\n           list.add(\"zhansgan\");\n           list.add(\"lisi\");\n           list.add(\"wngwu\");\n           list.add(\"laoliu\");\n           list.add(\"dasima\");\n           System.out.println(\"list=\"+list);\n   //        1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n           System.out.println(\"max num=\"+Collections.max(list));\n   //        2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素\n   //            获取最大长度的值\n           //        3. Object min（Collection)\n   //        4. Object min (Collection，Comparator)同理\n           Object max = Collections.max(list, new Comparator() {\n   \n               @Override\n               public int compare(Object o1, Object o2) {\n                   return ((String) o1).length() - ((String) o2).length();\n               }\n           });\n           System.out.println(\"字符串最大的值为=\"+max);\n   \n   \n   //        5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数\n   \n           System.out.println(\"lailiu=\"+ Collections.frequency(list,\"lailiu\"));\n   //        6. void copy（List dest，List src）：将src中的内容复制到dest中\n              ArrayList oldList =  new ArrayList();\n   //           为了完成一个拷贝，我们需要先给oldList赋值，大小和list一样,不然会报错\n           for (int i = 0; i < list.size(); i++) {\n               oldList.add(\"\");\n           }\n   //        拷贝\n           Collections.copy(oldList,list);\n           System.out.println(\"oldList=\"+oldList);\n   \n   //        7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值\n           Collections.replaceAll(list,\"laoliu\",\"老六\");\n           System.out.println(\"替换后=\"+list);\n       }\n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 总结\n\n在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择分析如下\n\n1）先判断储存类型（一组对象或一组键值对）\n\n2）一组对象[单列]：Collection接口\n\n* 允许重复：List\n  * 增删多：LinkedList（底层维护了一个双向链表）\n  * 改查多：ArrayList（底层维护了Object类型的可变数组）\n* 不允许重复：Set\n  * 无序：HashSet（底层是HashMap，维护了一个哈希表 即（数组+链表+红黑树））\n  * 排序：TreeSet\n  * 插入和取出顺序一直：LinkedHashSet，维护数组+双向链表\n\n3）一组键值对[双列]：Map\n\n* 键无序：HashMap（底层是：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树）\n* 键排序：TreeSet\n* 键插入和取出顺序一致：LinkedHashMap\n* 读取文件：Properties\n\n# 泛型\n\n## 泛型语法\n\n```java\npublic static void main(String[] args) {\n//        1.当我们ArrayList<Dog>表示放到ArrayList集合中的元素只能是Dog类型\n//        2.如果编译器发现添加的类型不满足，就会报错\n        ArrayList<Dog> dogs = new ArrayList<Dog>();\n        dogs.add(new Dog(\"laogou\",12));\n        dogs.add(new Dog(\"xiaogou\",1));\n    }\n//       方便遍历\n        for (Dog dog : dogs) {\n            System.out.println(dog);\n        }\n```\n\n好处：\n\n1. 编译时，检查添加元素的类型，提高了安全性\n2. 减少了类型转换的次数，提高效率\n3. 不再提示编译警告\n\n### 介绍\n\n理解：泛（广泛）型（类型）==> integer，String\n\n可以表示数据类型的数据类型![image-20220509171057972](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171057972.png)\n\n1）泛型又称参数化类型，时jdk5.0出现的新特性，解决数据类型的安全性问题\n\n2）在类声明或实例化时只要制定好需要的具体的类型即可\n\n3）java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮\n\n4）泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型\n\n![image-20220509171249826](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171249826.png)\n\n（此时E称为泛型，那么Dog->E（此时E为 ））\n\n```java\nCat<String> tianyuanmao = new Cat<>(\"tianyuanmao\");\n\nclass Cat<E> {\n    E e;//E表示 e的数据类型，改数据类型在定义Cat对象时指定的，即在编译期间，就确定是什么类型了\n\n    public Cat(E e) {//E也可在参数类型体现\n        this.e = e;\n    }\n    public E method(){//返回类型也可体现\n        return e;\n    }\n\n}\n```\n\n### 语法\n\n泛型的声明\n\n```java\ninterface 接口<T> {}\nclass类<K,V,...>{}(可以接收多个泛型等等)\n说明：\n    1.其中K,V,T不代表值，而是表示类型\n    2.任意字母都可以。常用T表示，是type的缩写\n```\n\n泛型的实例化\n\n```java\n要在类名后面指定类型参数的值（类型）。如\n//1\nList <String> strList = new ArrayList<String>();\n//2\nIterator <Customer> iterator = coustomers.iterator();\n\n```\n\n### 使用细节\n\n1. interface List<T>{},public class HashSet<E>{}....等等\n\n   1. 说明：T，E只能是引用类型\n   2. 不能是基本数据类型（八大基本数据类型,int,double 等等）\n\n2. 在指定泛型具体类型后，可以传入该类型或者其子类类型\n\n3. 泛型适用形式\n\n   1. ```java\n      List<integer> list1 =new ArrayList<Integer>{}\n      \n      List<Integer> list2 = new ArrayList<>();\n      ```\n\n4. 如果我们这样写List list3 = new ArrayList（）；默认给它的泛型是[<E> E就是Object 类型]\n\n   \n\n\n\n## 自定义泛型\n\n### 泛型类\n\n**基本语法**\n\n```java\nclass 类名<T,R....>{\n成员\n}\n```\n\n细节：\n\n1. 普通成员可以使用泛型（属性，方法）\n\n2. 使用泛型的数组，不能初始化\n\n3. 静态方法中不能使用类的泛型‘\n\n   1. 因为静态是和类相关的，在类加载时，对象还没创建\n   2. 所以，如果静态方法和静态属性使用泛型时 ，JVM就无法完成初始化\n\n4. 泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）\n\n5. 如果在创建对象时，没有指定类型，默认为object\n\n6. ```java\n   //1.demo后面有泛型，所以我们吧demo就称为自定义泛型类\n   //2.T,R,M泛型的标识符，一般是单个大写字母\n   //3.泛型标识符可以有多个\n   //4.普通成员可以使用泛型 （属性，方法）\n   //5.使用泛型的数组，不能初始化\n   \t//（因为数组在new的\n   \n   \n   class demo<T,R,M>{\n   String name;\n   T t;\n   R r;\n   M m;\n       T[] t1;//可以声明\n       \n       public demo11(String name, T t, R r, M m) {//构造器使用泛型\n           this.name = name;\n           this.t = t;\n           this.r = r;\n           this.m = m;\n       }\n       //方法使用泛型\n        public String getName() {\n           return name;\n       }\n   \n       public void setName(String name) {\n           this.name = name;\n       }\n   \n       public T getT() {\n           return t;\n       }\n   \n       public void setT(T t) {\n           this.t = t;\n       }\n   \n       public R getR() {\n           return r;\n       }\n   \n       public void setR(R r) {\n           this.r = r;\n       }\n   \n       public M getM() {\n           return m;\n       }\n   \n       public void setM(M m) {\n           this.m = m;\n       }\n   }\n   ```\n\n   \n\n\n\n\n\n### 泛型接口\n\n**基本语法**\n\n```java\ninterface  接口名 <T,R...>{\n\n}\n```\n\n细节：\n\n1. 接口中，静态成员也不能使用泛型\n\n2. 泛型接口的类型，在继承接口或者实现接口时确定\n\n3. 没有指定类型，默认为Object\n\n   \n\n### 泛型方法\n\n**基本语法**\n\n```java\n修饰符<T,R...>返回类型 方法名（番薯列表）{}\n```\n\n**注意细节**：\n\n1. 反省方法，可以定义在普通类中，也可以定义在泛型类中\n\n2. 当泛型方法被调用时，类型会确定\n\n3. public void eat（E e）{}，修饰符后没有<T,R..>eat方法不是泛型方法，而是使用了泛型\n\n4. ```java\n   //泛型方法，可以定义在普通类中，也可以定义在泛型类中\n   class Car{\n       public void run(){//普通方法\n   \n       }\n   //    1.T,R就是泛型标识符\n   //    2.提供给fly方法使用的\n       public <T,R> void  fly(T t, R r){//泛型方法\n   \n       }\n   \n   }\n   ```\n\n5. ```java\n   class Car2<T,R>{//泛型类\n       public <U,M> void  fly(U u, M m){//泛型方法\n       }\n       public void  fly2(T t){\n   //        1.该方法不是泛型方法\n   //        2.是fly2方法使用了类声明的泛型\n       }\n   ```\n\n6. ```java \n   Car car = new Car();\n           car.fly(\"baoma\",2000);\n           //在调用方法是，编译器会自动识别传入的参数的类型，就会确定型\n   ```\n\n7. 泛型方法可以使用类声明的泛型，也可使用自己声明的泛型\n\n## 泛型继承和通配符\n\n**介绍**\n\n1)泛型不具备继承性\n\n```java\nList<Object> list = new ArrayList<String>();\n//是错误的，因为泛型中没有继承性\n```\n\n2）<?>:支持任意泛型类型\n\n3）<? extend A>:支持A类以及 A类的子类，规定了泛型的上限\n\n![image-20220511142709072](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142709072.png)\n\n4）<? super A>:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限\n\n![image-20220511142730306](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142730306.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n  \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n# 知识点补充\n\n## JUnit\n\n1. 一个类有很多功能代码需要测试，为了测试，就需要写入main方法中\n2. 如果有很多个功能代码测试，就需要来回注销，切换很麻烦\n3. 如果可以直接运行一个方法，就会方便很多\n\n### 介绍：\n\n1. \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n# 练习部分\n\n## 快速入门部分\n\n1. 开发一个hello.java文件，输出：老王 is studying java！\n\n   1. ```java\n      public class hello{\n      \tpublic static void main(String[] args) {\n      \tSystem.out.println(\"lao wang is studying java\");\n      \t\n      \t}\n      }\n      ```\n\n   2. 需注意的事项：记得吧类部分带上public class 带上，不要只写个方法\n\n## 制表符部分\n\n1. ![image-20220204140604059](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204140604059.png)\n\n   1. ```java\n      public class ChangeChar {\n          public static void main(String[] args) {\n              System.out.println(\"书名\\t作者\\t价格\\t销量\\n三国\\t罗贯中\\t120\\t1000\");\n          }\n      }\n      ```\n\n## 进制部分\n\n* 第一部分\n\n  ```\n  1. 0b110001100\n     =0*2^0 + 0*2^1 + 1*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 0*2^6 + 1*2^7 + 1*2^8\n     =0+0+4+8+0+0+0+128+256\n     =396\n  02456\n  =6*8^0 + 5*8^1 + 4*8^2 + 2*8^3\n  =6+40+256+1024\n  =1326\n  \n  0xA45\n  =5*16^0 + 4*16^1 + 10*16^2\n  =5 + 64 + 2560\n  =2629\n  ```\n\n## 位运算练习\n\n```\n2|3\n1. 2的原码：00000000 00000000 00000000 00000010\n2. 2的补码：00000000 00000000 00000000 00000010\n3. 3的原码：00000000 00000000 00000000 00000011\n4. 3的补码：00000000 00000000 00000000 00000011\n5.2|3：00000000 00000000 00000000 00000010（都为1结果为1否则为0）\n6. 转为原码：00000000 00000000 00000000 00000010\n7.结果为：2\n\n2^3\n1. 2的原码：00000000 00000000 00000000 00000010\n2. 2的补码：00000000 00000000 00000000 00000010\n3. 3的原码：00000000 00000000 00000000 00000011\n4. 3的补码：00000000 00000000 00000000 00000011\n5.2^3:00000000 00000000 00000000 00000001(两位一个为0，一个为1，结果为1，否则为0)\n6.转为原码：00000000 00000000 00000000 00000001\n7.结果为1\n```\n\n## switch练习\n\n1. ![image-20220225162131420](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162131420.png)\n\n   * ![image-20220225162214945](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162214945.png)\n\n2. 3,4,5为春季。6，7，8，为夏季，9,10,11位秋季。12,1,2为冬季\n\n   * ```java\n     Scanner scanner = new Scanner(System.in);\n             System.out.println(\"请输入月份\");\n             int month = scanner.nextInt();\n             if (month>0 && month<=12){\n                 switch (month){\n                     case 3:\n                     case 4:\n                     case 5:\n                         System.out.println(\"春季\");\n                         break;\n                     case 6:\n                     case 7:\n                     case 8:\n                         System.out.println(\"夏季\");\n                         break;\n                     case 9:\n                     case 10:\n                     case 11:\n                         System.out.println(\"秋季\");\n                         break;\n                     case 12:\n                     case 1:\n                     case 2:\n                         System.out.println(\"冬季\");\n                         break;\n                 }\n             }else {\n                 System.out.println(\"输入不合法\");\n             }\n     ```\n\n## 数组部分\n\n* 已知数组{10,12,45,90}。添加一个数使该数组依然是升序的\n\n```java\n//方法1：数组扩容➕冒泡排序\n\npackage basics.chapterArray;\n\nimport java.time.OffsetDateTime;\nimport java.util.Scanner;\nimport java.util.concurrent.ForkJoinPool;\n\npublic class exercisesArryHomeWork {\n    /*\n    * 已知数组{10,12,45,90}\n    * 添加一个数使该数组依然是升序的\n    * */\n    public static void main(String[] args) {\n        int[] arr = {10,12,45,90};\n        char key;\n        Scanner scanner = new Scanner(System.in);\n        int inputnum;\n        int tmp;\n\n        do {\n            int[] arr2 = new int[arr.length+1];\n            for (int i = 0; i <arr.length ; i++) {\n                arr2[i] = arr[i];\n            }\n            System.out.println(\"请输入添加一个数\");\n            inputnum = scanner.nextInt();\n            arr2[arr2.length-1] = inputnum;\n            arr = arr2;\n            for (int i = 0; i <arr.length ; i++) {\n                System.out.print(arr[i]+\"\\t\");\n            }\n\n\n            System.out.println(\"是否继续输入? y/n\");\n            key = scanner.next().charAt(0);\n            if (key == 'y'){\n                System.out.println(\"continue\");\n            }else if (key == 'n'){\n                System.out.println(\"end\");\n                break;\n            }else {\n                System.out.println(\"input error\");\n            }\n        }while (true);\n        System.out.println(\"============数组排序==============\");\n        for (int i = 0; i < arr.length-1; i++) {\n            for (int j = 0; j <arr.length ; j++) {\n                if (j>=arr.length-1){\n                    break;\n                }else if (arr[j]<=arr[j+1]){\n                    System.out.println(\"no change\");\n                }else if (arr[j]>=arr[j+1]){\n                    tmp = arr[j+1];\n                    arr[j+1] = arr[j];\n                    arr[j] = tmp;\n                }\n\n            }\n        }\n\n\n        System.out.println(\"=============输出==============\");\n        for (int i = 0; i <arr.length ; i++) {\n            System.out.print(arr[i]+\"\\t\");\n        }\n\n\n\n\n\n    }\n}\n```\n\n方法二：定位➕扩容\n\n ```\n //1. 先定义原数组 \n //2. 遍历数组，如果发现insertnum < arr[i] ,说明i就是要插入的位置\n //3. 如果index 保留 index =i\n //4. 如果遍历完后，没有发现inserNum<=arr[i] ，说明index = arr.length\n 即：添加到arr的最后\n ```\n\n```java\npackage basics.chapterArray;\n\npublic class exercisesArrayHomeWorkmethod2 {\n    public static void main(String[] args) {\n        int[] arr = {10,12,45,90};\n        int insertNum = 23;\n        int index = -1;\n//          数组定位\n//        1.遍历数组\n        for (int i = 0; i <arr.length ; i++) {\n//            2. 如果arr[i]的这个数大于insertNum则表示这个数的位置是要添加的数的位置\n            if (insertNum<=arr[i]){\n//                3. 用index接受这个位置信息\n                index = i;\n                break;\n            }\n        }\n//        4. 数组扩容添加\n        int[] arr2 = new int[arr.length+1];\n//        创建一个j，当插入前半部分时，j指向arr的数组的数不变。\n        for (int i = 0,j=0; i <arr2.length; i++) {\n//            如果i不等于上面得到的i的位置\n            if ( i != index){\n//                则将arr的数赋给对应的新数组\n                arr2[i] = arr[j];\n                j++;\n            }else {\n\n                arr2[i] = insertNum;\n            }\n        }\n        arr = arr2;\n\n        for (int i = 0; i <arr.length ; i++) {\n            System.out.print(arr[i]+\"\\t\");\n        }\n    }\n}\n\n```\n\n\n\n### 二维数组部分\n\n1. ```java\n   //            int[][] arr = {{4,6},{1,4,5,7},{-2}};\n   //          遍历数组,求和\n   ```\n\n   * ```java\n     public static void main(String[] args) {\n      \n            int sum = 0;\n            int[][] arr = {{4,6},{1,4,5,7},{-2}};\n            for (int i = 0; i < arr.length; i++) {\n                for (int j = 0; j <arr[i].length ; j++) {\n                    sum = sum+ arr[i][j];\n                }\n            }\n            System.out.println(sum);\n        }\n     ```\n\n     \n\n## 面向对象部分\n\n```java\npackage basics.method;\n\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class chapterMethod01 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入一个整数\");\n        int num = scanner.nextInt();\n        AA aa = new AA();\n\n//        第一种写法\n//        boolean t = aa.odd(num);\n//        if (t==true){\n//            System.out.println(\"偶数\");\n//        }else {\n//            System.out.println(\"奇数\");\n//        }\n\n        /*\n        * 第二种写法，较为简洁 。后续较为常见\n        *\n        * */\n\n        if (aa.odd(1)){ //1 为true 2为false\n            System.out.println(\"偶数\");\n        }else {\n            System.out.println(\"奇数\");\n        }\n    }\n}\nclass AA{\n    public boolean odd(int a){\n\n//        if (a%2 ==0){\n//\n//            return true;\n//        }else {\n//\n//            return false;\n//        }\n    return a%2==0 ?  true : false;\n    }\n}\n```\n\n### 递归\n\n1、小球迷宫\n\n![image-20220311132440361](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220311132440361.png)\n\n1. 小球得到的路径和程序员设置的策略有关，即找到的上下左右的顺序相关\n2. 再得到小球路径时，可以先使用（下右上左），再改成（上右下左）\n\n```\n1. 先用二维数组创建迷宫 8行7列\nint[][] map =new int[8][7];\n2.先规定map数组，0表示可以走，1表示障碍物\n3. 将最上的一行，和最下面的一行。设置为1\nfor(int i=0;i<7;i++){\n\tmap[0][i]=1;\n\tmap[7][i]=1\n}\n```\n\n```java\npackage com.smms.demo.method;\n\npublic class homeworkForMaze {\n    public static void main(String[] args) {\n        //1. 先创建迷宫\n        int[][] map = new int[8][7];\n        //2. 定义数组\n        for (int i1 = 0; i1 <7 ; i1++) {\n            map[0][i1] = 1;\n            map[7][i1] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n        map[3][1]=1;\n        map[3][2]=1;\n\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[i].length; j++) {\n                System.out.print(map[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n        System.out.println(\"==================分割线======================\");\n\n        System.out.println(\"use findWay\");\n        T t = new T();\n        t.findWay(map,1,1);\n        System.out.println(\"out print\");\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j <map[i].length ; j++) {\n                System.out.print(map[i][j]+\"\\t\");\n\n            }\n            System.out.println();\n\n        }\n    }\n}\n\n// 使用递归回溯的思想解决该题\n/*\n1.创建findway方法\n2.如果找到，就返回true ，否则返回false\n3.map就是二维数组，即表示迷宫\n4.i,j 就是老鼠的位置，初始化的位置为(1,1)\n5.因为我们使用的是递归找路，所以先规定map内值的含义\n0 表示可以走，1表示障碍物，2表示可以走，3表示走过\n6.当map[6][5] =2就说明找到了通路，就可以结束，否则就继续\n\n7.定下找路的策略，下->右->上->左\n*\n* */\nclass T{\n    public boolean findWay(int[][] map,int i,int j){\n        if (map[6][5]==2){\n            return true;\n        }else {\n            if (map[i][j]==0){\n//                标记可以走通为2\n//                假定可以走通\n                map[i][j]=2;\n    //  找路策略,下->右->上->左\n                if (findWay(map,i+1,j)){\n                    return true;\n                }else if (findWay(map,i,j+1)){\n                    return true;\n                }else if (findWay(map,i-1,j)){\n                    return true;\n                }else if (findWay(map,i,j-1)){\n                    return true;\n                }else {\n                    map[i][j] =3;\n                    return false;\n                }\n            }\n            return false;\n        }\n    }\n}\n\n```\n\n2、汉诺塔\n\n```java\nclass A{\n    public void move(int num,char a,char b, char c){\n        if (num==1){\n            System.out.println(a+\"->\"+c);\n        }else {\n//            如果有多个盘num，可以直接看成2个，最下边的和最上边的\n//            1.先移动上面的盘子到b，借助c\n            move(num-1,a,c,b);\n//            2.吧下面的盘子移动到c\n            System.out.println(a+\"->\"+c);\n//            3.再把b塔的所有盘，移动到c，借助a\n            move(num-1,b,a,c);\n        }\n    }\n}\n```\n\n## 集合\n\n1）分析HashSet和TreeSet分别如何实现去重\n\n1. HashSet的去重机制：hahsCode()+equals()，底层先通过存入对象，进行运算得到一个hash值，通过hash得到对应的索引，如果发现table索引所在的位置没有数据直接存放，如果有数据，就进行equals比较（equals可由程序员重写），如果比较厚，不相同，就加入，相同就不加入\n2. TreeSet去重机制：如果传入了一个Comparator匿名对象，就使用实现Comparator去重，如果方法返回为0，就认为相同的元素/数据，就不添加。如果没有传入Comparator对象，则以添加的对象实现的Compareable的compareTo去重\n\n# 注意事项\n\n1. 一个java文件中只能有一个public类，其他类的个数不限\n   1. public的类名必须和文件名相同\n   2. 编译后每一个类都对应一个class文件\n2. equals方法两种书写方式\n   1. name.equals(\"xxx\");\n   2. \"xxx\".eqauls(name); //推荐这一种，可以避免空指针\n\n\n\n## \n\n\n\n# 面试题\n\n**相关可能问道的面试题目**\n\n1、 JDK、JRE、JVM的关系\n\n1. JDK = JRE + java开发工具\n2. JRE =  JVM ＋ 核心类库\n\n2、 环境变量path的作用\n\n1. 使dos界面能够使用java和javac 等命令\n2. 先配置JAVA_HOME 指向JDK主目录\n3. path根据JAVA_HOME 寻找其子目录\n\n3、 为什么计算机都是以补码的方式运行的\n\n* 因为它将正数负数都统一起来了\n\n4、 new一个对象时，此时内存里发生了什么？\n\n1. 先在方法区创建Person类\n2. 在堆中开辟一个空间，内部存放形参\n   1. 先初始化默认值，0和null，然后再将值赋进去\n   2. 当执行到构造器的时候，值才会赋进去\n   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值\n3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)\n4. ![image-20220314215432778](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png)\n\n\n\n","slug":"java基础笔记","published":1,"updated":"2022-10-27T04:54:22.434Z","layout":"post","photos":[],"link":"","_id":"cl9qlthbw000d8frfb45nau49"}],"PostAsset":[],"PostCategory":[{"post_id":"cl9qlthbj00008frfg0a6dbmx","category_id":"cl9qlthbp00028frfcai27024","_id":"cl9qlthbu00088frfg38c6xb8"},{"post_id":"cl9qlthbr00048frfd2vgbuun","category_id":"cl9qlthbp00028frfcai27024","_id":"cl9qlthbu000b8frf9hxoh8qv"},{"post_id":"cl9qlthbr00048frfd2vgbuun","category_id":"cl9qlthbu000a8frfh86laqns","_id":"cl9qlthbu000c8frfg47xdcjw"},{"post_id":"cl9qlthbw000d8frfb45nau49","category_id":"cl9qlthbw000e8frf21z5ezyr","_id":"cl9qlthbx000i8frfhriy4nb8"},{"post_id":"cl9qlthbw000d8frfb45nau49","category_id":"cl9qlthbx000h8frfd1rdanu4","_id":"cl9qlthbx000j8frf6jk5dy3t"}],"PostTag":[{"post_id":"cl9qlthbj00008frfg0a6dbmx","tag_id":"cl9qlthbq00038frfg82s3haa","_id":"cl9qlthbt00078frf2m0wbsbe"},{"post_id":"cl9qlthbr00048frfd2vgbuun","tag_id":"cl9qlthbq00038frfg82s3haa","_id":"cl9qlthbu00098frffpvecndm"},{"post_id":"cl9qlthbw000d8frfb45nau49","tag_id":"cl9qlthbw000f8frfe3s13jf8","_id":"cl9qlthbx000g8frf907pgcds"}],"Tag":[{"name":"安装","_id":"cl9qlthbq00038frfg82s3haa"},{"name":"java","_id":"cl9qlthbw000f8frfe3s13jf8"}]}}