{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-color-dark.min.css","path":"css/kr-color-dark.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kratosr.min.css","path":"css/kratosr.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/prismjs.min.css","path":"css/prismjs.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/404.webp","path":"images/404.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/about.webp","path":"images/about.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/alipay.JPG","path":"images/alipay.JPG","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/alipay.webp","path":"images/alipay.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/avatar.webp","path":"images/avatar.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/banner.webp","path":"images/banner.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/banner_dark.webp","path":"images/banner_dark.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/bg.webp","path":"images/bg.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/bg_dark.webp","path":"images/bg_dark.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/comment.webp","path":"images/comment.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/comment_dark.webp","path":"images/comment_dark.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/failure.ico","path":"images/failure.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/psr.webp","path":"images/psr.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wechat.JPG","path":"images/wechat.JPG","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wechat.webp","path":"images/wechat.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wxjb.webp","path":"images/wxjb.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/candy.min.js","path":"js/candy.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-dark.min.js","path":"js/kr-dark.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kratosr.min.js","path":"js/kratosr.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/local-search.min.js","path":"js/local-search.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/pjax.min.js","path":"js/pjax.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/snow.min.js","path":"js/snow.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/light.min.css","path":"css/highlight/light.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-blue.min.css","path":"css/highlight/night-blue.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-bright.min.css","path":"css/highlight/night-bright.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-eighties.min.css","path":"css/highlight/night-eighties.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night.min.css","path":"css/highlight/night.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/logo/logo.webp","path":"images/logo/logo.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_1.webp","path":"images/thumb/thumb_1.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_10.webp","path":"images/thumb/thumb_10.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_11.webp","path":"images/thumb/thumb_11.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_12.webp","path":"images/thumb/thumb_12.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_13.webp","path":"images/thumb/thumb_13.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_14.webp","path":"images/thumb/thumb_14.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_15.webp","path":"images/thumb/thumb_15.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_16.webp","path":"images/thumb/thumb_16.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_17.webp","path":"images/thumb/thumb_17.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_18.webp","path":"images/thumb/thumb_18.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_19.webp","path":"images/thumb/thumb_19.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_2.webp","path":"images/thumb/thumb_2.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_20.webp","path":"images/thumb/thumb_20.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_3.webp","path":"images/thumb/thumb_3.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_4.webp","path":"images/thumb/thumb_4.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_5.webp","path":"images/thumb/thumb_5.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_6.webp","path":"images/thumb/thumb_6.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_7.webp","path":"images/thumb/thumb_7.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_8.webp","path":"images/thumb/thumb_8.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_9.webp","path":"images/thumb/thumb_9.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/HELP-US-OUT.txt","path":"vendors/font-awesome@4.7.0/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/README.md","path":"vendors/font-awesome@4.7.0/README.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/package.json","path":"vendors/font-awesome@4.7.0/package.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/History.md","path":"vendors/nprogress@0.2.0/History.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/License.md","path":"vendors/nprogress@0.2.0/License.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Notes.md","path":"vendors/nprogress@0.2.0/Notes.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Readme.md","path":"vendors/nprogress@0.2.0/Readme.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/bower.json","path":"vendors/nprogress@0.2.0/bower.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/component.json","path":"vendors/nprogress@0.2.0/component.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.css","path":"vendors/nprogress@0.2.0/nprogress.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.js","path":"vendors/nprogress@0.2.0/nprogress.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/package.json","path":"vendors/nprogress@0.2.0/package.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/LICENSE","path":"vendors/qrcode_js@1.0.0/LICENSE","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/README.md","path":"vendors/qrcode_js@1.0.0/README.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/bower.json","path":"vendors/qrcode_js@1.0.0/bower.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index-svg.html","path":"vendors/qrcode_js@1.0.0/index-svg.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index.html","path":"vendors/qrcode_js@1.0.0/index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index.svg","path":"vendors/qrcode_js@1.0.0/index.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/jquery.min.js","path":"vendors/qrcode_js@1.0.0/jquery.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/package.json","path":"vendors/qrcode_js@1.0.0/package.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/qrcode.js","path":"vendors/qrcode_js@1.0.0/qrcode.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/qrcode.min.js","path":"vendors/qrcode_js@1.0.0/qrcode.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.css","path":"vendors/aplayer@1.10.1/dist/APlayer.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.css.map","path":"vendors/aplayer@1.10.1/dist/APlayer.min.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.js","path":"vendors/aplayer@1.10.1/dist/APlayer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.js.map","path":"vendors/aplayer@1.10.1/dist/APlayer.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/clipboard@2.0.6/dist/clipboard.js","path":"vendors/clipboard@2.0.6/dist/clipboard.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/clipboard@2.0.6/dist/clipboard.min.js","path":"vendors/clipboard@2.0.6/dist/clipboard.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/disqusjs@1.3.0/dist/disqus.js","path":"vendors/disqusjs@1.3.0/dist/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/disqusjs@1.3.0/dist/disqusjs.css","path":"vendors/disqusjs@1.3.0/dist/disqusjs.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css","path":"vendors/font-awesome@4.7.0/css/font-awesome.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css.map","path":"vendors/font-awesome@4.7.0/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.min.css","path":"vendors/font-awesome@4.7.0/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","path":"vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/animated.less","path":"vendors/font-awesome@4.7.0/less/animated.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/bordered-pulled.less","path":"vendors/font-awesome@4.7.0/less/bordered-pulled.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/core.less","path":"vendors/font-awesome@4.7.0/less/core.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/fixed-width.less","path":"vendors/font-awesome@4.7.0/less/fixed-width.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/icons.less","path":"vendors/font-awesome@4.7.0/less/icons.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/font-awesome.less","path":"vendors/font-awesome@4.7.0/less/font-awesome.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/larger.less","path":"vendors/font-awesome@4.7.0/less/larger.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/list.less","path":"vendors/font-awesome@4.7.0/less/list.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/mixins.less","path":"vendors/font-awesome@4.7.0/less/mixins.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/path.less","path":"vendors/font-awesome@4.7.0/less/path.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/stacked.less","path":"vendors/font-awesome@4.7.0/less/stacked.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/rotated-flipped.less","path":"vendors/font-awesome@4.7.0/less/rotated-flipped.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/variables.less","path":"vendors/font-awesome@4.7.0/less/variables.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/screen-reader.less","path":"vendors/font-awesome@4.7.0/less/screen-reader.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/font-awesome.scss","path":"vendors/font-awesome@4.7.0/scss/font-awesome.scss","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk-component.js","path":"vendors/gitalk@1.7.2/dist/gitalk-component.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk-component.js.map","path":"vendors/gitalk@1.7.2/dist/gitalk-component.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.css","path":"vendors/gitalk@1.7.2/dist/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.css.map","path":"vendors/gitalk@1.7.2/dist/gitalk.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.js","path":"vendors/gitalk@1.7.2/dist/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.js.map","path":"vendors/gitalk@1.7.2/dist/gitalk.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.min.js","path":"vendors/gitalk@1.7.2/dist/gitalk.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.min.js.map","path":"vendors/gitalk@1.7.2/dist/gitalk.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/constants.js","path":"vendors/gitment@0.0.3/dist/constants.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/constants.js.map","path":"vendors/gitment@0.0.3/dist/constants.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.browser.js","path":"vendors/gitment@0.0.3/dist/gitment.browser.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.browser.js.map","path":"vendors/gitment@0.0.3/dist/gitment.browser.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.js","path":"vendors/gitment@0.0.3/dist/gitment.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.js.map","path":"vendors/gitment@0.0.3/dist/gitment.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/icons.js","path":"vendors/gitment@0.0.3/dist/icons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/icons.js.map","path":"vendors/gitment@0.0.3/dist/icons.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/utils.js","path":"vendors/gitment@0.0.3/dist/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/utils.js.map","path":"vendors/gitment@0.0.3/dist/utils.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.js","path":"vendors/jquery@3.6.0/dist/jquery.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.min.js","path":"vendors/jquery@3.6.0/dist/jquery.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.min.map","path":"vendors/jquery@3.6.0/dist/jquery.min.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.js","path":"vendors/jquery@3.6.0/dist/jquery.slim.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.min.js","path":"vendors/jquery@3.6.0/dist/jquery.slim.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.min.map","path":"vendors/jquery@3.6.0/dist/jquery.slim.min.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/layui.all.js","path":"vendors/layui-src@2.5.5/dist/layui.all.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/layui.js","path":"vendors/layui-src@2.5.5/dist/layui.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.core.js","path":"vendors/mermaid@9.1.1/dist/mermaid.core.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.core.js.map","path":"vendors/mermaid@9.1.1/dist/mermaid.core.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs","path":"vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.LICENSE.txt","path":"vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.LICENSE.txt","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.map","path":"vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.js","path":"vendors/mermaid@9.1.1/dist/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.js.map","path":"vendors/mermaid@9.1.1/dist/mermaid.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js","path":"vendors/mermaid@9.1.1/dist/mermaid.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js.LICENSE.txt","path":"vendors/mermaid@9.1.1/dist/mermaid.min.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js.map","path":"vendors/mermaid@9.1.1/dist/mermaid.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/meting@2.0.1/dist/Meting.min.js","path":"vendors/meting@2.0.1/dist/Meting.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/component.html","path":"vendors/nprogress@0.2.0/test/component.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/test.js","path":"vendors/nprogress@0.2.0/test/test.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.all.min.js","path":"vendors/twikoo@1.5.11/dist/twikoo.all.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.all.min.js.LICENSE.txt","path":"vendors/twikoo@1.5.11/dist/twikoo.all.min.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.min.js","path":"vendors/twikoo@1.5.11/dist/twikoo.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.min.js.LICENSE.txt","path":"vendors/twikoo@1.5.11/dist/twikoo.min.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.Pure.min.js","path":"vendors/valine@1.4.18/dist/Valine.Pure.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.Pure.min.js.map","path":"vendors/valine@1.4.18/dist/Valine.Pure.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.js","path":"vendors/valine@1.4.18/dist/Valine.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.js.map","path":"vendors/valine@1.4.18/dist/Valine.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.umd.js","path":"vendors/valine@1.4.18/dist/Valine.min.umd.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.umd.js.map","path":"vendors/valine@1.4.18/dist/Valine.min.umd.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/detect.min.js","path":"vendors/valine@1.4.18/dist/detect.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/escape.min.js","path":"vendors/valine@1.4.18/dist/escape.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.css","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.js","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.d.ts","path":"vendors/@waline/client@1.6.0/dist/Waline.min.d.ts","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.js.map","path":"vendors/@waline/client@1.6.0/dist/Waline.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js","path":"vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.d.ts","path":"vendors/@waline/client@1.6.0/dist/Waline.noStyle.d.ts","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.js","path":"vendors/@waline/client@1.6.0/dist/Waline.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.js","path":"vendors/@waline/client@1.6.0/dist/Waline.noStyle.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.js.map","path":"vendors/@waline/client@1.6.0/dist/Waline.noStyle.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/index.html","path":"vendors/@waline/client@1.6.0/dist/index.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.min.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css.map","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.min.css","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.css.map","path":"vendors/bootstrap@3.3.4/dist/css/bootstrap.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.eot","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.svg","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.ttf","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff2","path":"vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/bootstrap.js","path":"vendors/bootstrap@3.3.4/dist/js/bootstrap.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js","path":"vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/npm.js","path":"vendors/bootstrap@3.3.4/dist/js/npm.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/theme/default.js","path":"vendors/gitment@0.0.3/dist/theme/default.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/theme/default.js.map","path":"vendors/gitment@0.0.3/dist/theme/default.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/layui.css","path":"vendors/layui-src@2.5.5/dist/css/layui.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/layui.mobile.css","path":"vendors/layui-src@2.5.5/dist/css/layui.mobile.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.eot","path":"vendors/layui-src@2.5.5/dist/font/iconfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.svg","path":"vendors/layui-src@2.5.5/dist/font/iconfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.ttf","path":"vendors/layui-src@2.5.5/dist/font/iconfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.woff","path":"vendors/layui-src@2.5.5/dist/font/iconfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.woff2","path":"vendors/layui-src@2.5.5/dist/font/iconfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/code.css","path":"vendors/layui-src@2.5.5/dist/css/modules/code.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/carousel.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/carousel.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/code.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/code.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/colorpicker.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/colorpicker.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/element.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/element.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/flow.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/flow.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/form.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/form.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/jquery.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/jquery.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laydate.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/laydate.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layedit.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/layedit.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layer.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/layer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layim.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/layim.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laypage.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/laypage.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laytpl.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/laytpl.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/mobile.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/mobile.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/rate.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/rate.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/slider.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/slider.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/table.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/table.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/transfer.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/transfer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/tree.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/tree.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/upload.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/upload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/util.js","path":"vendors/layui-src@2.5.5/dist/lay/modules/util.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/0.gif","path":"vendors/layui-src@2.5.5/dist/images/face/0.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/1.gif","path":"vendors/layui-src@2.5.5/dist/images/face/1.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/10.gif","path":"vendors/layui-src@2.5.5/dist/images/face/10.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/11.gif","path":"vendors/layui-src@2.5.5/dist/images/face/11.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/12.gif","path":"vendors/layui-src@2.5.5/dist/images/face/12.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/13.gif","path":"vendors/layui-src@2.5.5/dist/images/face/13.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/14.gif","path":"vendors/layui-src@2.5.5/dist/images/face/14.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/15.gif","path":"vendors/layui-src@2.5.5/dist/images/face/15.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/16.gif","path":"vendors/layui-src@2.5.5/dist/images/face/16.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/18.gif","path":"vendors/layui-src@2.5.5/dist/images/face/18.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/17.gif","path":"vendors/layui-src@2.5.5/dist/images/face/17.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/19.gif","path":"vendors/layui-src@2.5.5/dist/images/face/19.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/2.gif","path":"vendors/layui-src@2.5.5/dist/images/face/2.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/20.gif","path":"vendors/layui-src@2.5.5/dist/images/face/20.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/21.gif","path":"vendors/layui-src@2.5.5/dist/images/face/21.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/22.gif","path":"vendors/layui-src@2.5.5/dist/images/face/22.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/23.gif","path":"vendors/layui-src@2.5.5/dist/images/face/23.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/24.gif","path":"vendors/layui-src@2.5.5/dist/images/face/24.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/25.gif","path":"vendors/layui-src@2.5.5/dist/images/face/25.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/26.gif","path":"vendors/layui-src@2.5.5/dist/images/face/26.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/27.gif","path":"vendors/layui-src@2.5.5/dist/images/face/27.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/28.gif","path":"vendors/layui-src@2.5.5/dist/images/face/28.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/29.gif","path":"vendors/layui-src@2.5.5/dist/images/face/29.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/3.gif","path":"vendors/layui-src@2.5.5/dist/images/face/3.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/30.gif","path":"vendors/layui-src@2.5.5/dist/images/face/30.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/31.gif","path":"vendors/layui-src@2.5.5/dist/images/face/31.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/32.gif","path":"vendors/layui-src@2.5.5/dist/images/face/32.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/33.gif","path":"vendors/layui-src@2.5.5/dist/images/face/33.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/34.gif","path":"vendors/layui-src@2.5.5/dist/images/face/34.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/35.gif","path":"vendors/layui-src@2.5.5/dist/images/face/35.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/36.gif","path":"vendors/layui-src@2.5.5/dist/images/face/36.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/37.gif","path":"vendors/layui-src@2.5.5/dist/images/face/37.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/38.gif","path":"vendors/layui-src@2.5.5/dist/images/face/38.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/39.gif","path":"vendors/layui-src@2.5.5/dist/images/face/39.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/4.gif","path":"vendors/layui-src@2.5.5/dist/images/face/4.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/40.gif","path":"vendors/layui-src@2.5.5/dist/images/face/40.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/41.gif","path":"vendors/layui-src@2.5.5/dist/images/face/41.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/42.gif","path":"vendors/layui-src@2.5.5/dist/images/face/42.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/43.gif","path":"vendors/layui-src@2.5.5/dist/images/face/43.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/44.gif","path":"vendors/layui-src@2.5.5/dist/images/face/44.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/45.gif","path":"vendors/layui-src@2.5.5/dist/images/face/45.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/46.gif","path":"vendors/layui-src@2.5.5/dist/images/face/46.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/47.gif","path":"vendors/layui-src@2.5.5/dist/images/face/47.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/48.gif","path":"vendors/layui-src@2.5.5/dist/images/face/48.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/49.gif","path":"vendors/layui-src@2.5.5/dist/images/face/49.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/5.gif","path":"vendors/layui-src@2.5.5/dist/images/face/5.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/50.gif","path":"vendors/layui-src@2.5.5/dist/images/face/50.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/51.gif","path":"vendors/layui-src@2.5.5/dist/images/face/51.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/52.gif","path":"vendors/layui-src@2.5.5/dist/images/face/52.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/53.gif","path":"vendors/layui-src@2.5.5/dist/images/face/53.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/54.gif","path":"vendors/layui-src@2.5.5/dist/images/face/54.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/55.gif","path":"vendors/layui-src@2.5.5/dist/images/face/55.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/56.gif","path":"vendors/layui-src@2.5.5/dist/images/face/56.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/57.gif","path":"vendors/layui-src@2.5.5/dist/images/face/57.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/58.gif","path":"vendors/layui-src@2.5.5/dist/images/face/58.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/59.gif","path":"vendors/layui-src@2.5.5/dist/images/face/59.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/6.gif","path":"vendors/layui-src@2.5.5/dist/images/face/6.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/60.gif","path":"vendors/layui-src@2.5.5/dist/images/face/60.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/61.gif","path":"vendors/layui-src@2.5.5/dist/images/face/61.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/62.gif","path":"vendors/layui-src@2.5.5/dist/images/face/62.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/63.gif","path":"vendors/layui-src@2.5.5/dist/images/face/63.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/64.gif","path":"vendors/layui-src@2.5.5/dist/images/face/64.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/65.gif","path":"vendors/layui-src@2.5.5/dist/images/face/65.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/66.gif","path":"vendors/layui-src@2.5.5/dist/images/face/66.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/67.gif","path":"vendors/layui-src@2.5.5/dist/images/face/67.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/68.gif","path":"vendors/layui-src@2.5.5/dist/images/face/68.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/69.gif","path":"vendors/layui-src@2.5.5/dist/images/face/69.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/7.gif","path":"vendors/layui-src@2.5.5/dist/images/face/7.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/70.gif","path":"vendors/layui-src@2.5.5/dist/images/face/70.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/71.gif","path":"vendors/layui-src@2.5.5/dist/images/face/71.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/8.gif","path":"vendors/layui-src@2.5.5/dist/images/face/8.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/9.gif","path":"vendors/layui-src@2.5.5/dist/images/face/9.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/plugins/emojis/index.js","path":"vendors/valine@1.4.18/dist/plugins/emojis/index.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/plugins/emojis/light.json","path":"vendors/valine@1.4.18/dist/plugins/emojis/light.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/layim.css","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/layim.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/laydate/default/laydate.css","path":"vendors/layui-src@2.5.5/dist/css/modules/laydate/default/laydate.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/chatlog.html","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/chatlog.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/find.html","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/find.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/getmsg.json","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/getmsg.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/msgbox.html","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/html/msgbox.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon-ext.png","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon-ext.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon.png","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/layer.css","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/layer.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-0.gif","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-0.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-1.gif","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-1.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-2.gif","path":"vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-2.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/mobile/layim.css","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/mobile/layim.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/voice/default.mp3","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/voice/default.mp3","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/1.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/1.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/2.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/2.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/3.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/3.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/4.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/4.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/5.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/5.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/logo.jpg","path":"vendors/layui-src@2.5.5/dist/css/modules/layim/skin/logo.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1665630914283},{"_id":"source/_posts/Node.js安装与配置（详细步骤）.md","hash":"545d46850d1aa0cce8aa58c89ac806995626c0f6","modified":1665630914282},{"_id":"source/_posts/hexo+github搭建博客.md","hash":"7f111144526824d809f63c0b26dcd91596467bf5","modified":1665630914283},{"_id":"source/.DS_Store","hash":"594570bf9c908588a489c21d1846ea055a7a8fa2","modified":1666845864488},{"_id":"source/_posts/java基础笔记.md","hash":"d10981593e6a55ea0339af26cb3e04c451ed46c6","modified":1666848238499},{"_id":"node_modules/hexo-theme-kratos-rebirth/_config.yml","hash":"2bce0e11456d45290667ba8670e7b11350e75b7a","modified":1665630912896},{"_id":"node_modules/hexo-theme-kratos-rebirth/Kratos-Rebirth-Manual.md","hash":"1f2fe32940600601f88bf55b1e3f0d669ee78aa9","modified":1665630912896},{"_id":"node_modules/hexo-theme-kratos-rebirth/package.json","hash":"d037e569fd7f674f589c1e9c7317dfc8516bd52d","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/LICENSE","hash":"31a3d460bb3c7d98845187c716a30db81c44b615","modified":1665630912896},{"_id":"node_modules/hexo-theme-kratos-rebirth/ReadMe.md","hash":"b07f349495c3351002141650bbb8db33c3e20563","modified":1665630912896},{"_id":"node_modules/hexo-theme-kratos-rebirth/.demo/_config.kratos-rebirth.yml","hash":"ca33ed423a7123c50c75dd61d24392caa3c16615","modified":1665630912894},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/archive.ejs","hash":"6dec1243c2d76a415d2fa5766ab184652c90c18c","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/dependabot.yml","hash":"89c16d0b45677ff20b86b655e3bfc7f1e675b2d4","modified":1665630912895},{"_id":"node_modules/hexo-theme-kratos-rebirth/languages/zh-CN.yml","hash":"f253d94bc5171ef6e00d0511c3f4db26d3441781","modified":1665630912897},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/layout.ejs","hash":"ea86e5b8f64957145ff52f5e2660e62ff92e0b05","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/category.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/index.ejs","hash":"caf093b695c940527aebbf3532cc8cd016ed0e94","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/page.ejs","hash":"4593e0a73b36b34dce40e3fbfe4c8056a7c9eb8f","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/additional-pages.js","hash":"b99cdd8fa23d0519403abefc595f031ebaace59a","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/tag.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/check-update.js","hash":"fcadb1499a85d427d5b80fc6c64eab61ca999925","modified":1665630912903},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/FUNDING.yml","hash":"034eaa235c5cc18532e09e24106120d711af0320","modified":1665630912894},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/friends.js","hash":"4c7dfca9d47c508934d7d27a56f8037a761da7ff","modified":1665630912903},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/post.ejs","hash":"80744537a72bd31bee1162d8b69e938d989734d8","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/gulpfile.js","hash":"7d48d25a9520467cb26a34bac9222484f466f70d","modified":1665630912897},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/genconfig.js","hash":"41e8da155a1cc418e05f3f9312568f0b3b9bd128","modified":1665630912903},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/search.js","hash":"fb892991e53a272db74ec5f3d3ab26e728c8ee06","modified":1665630912904},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/cdn-optimize-helpers.js","hash":"b0865dc553d3b757757b5a0471d5bcef6fd5be41","modified":1665630912902},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/tag-widgets.js","hash":"78d14c05c6205762f73ad3df420d9c6e78b9cd4e","modified":1665630912904},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/auto-release.yml","hash":"bb8f12db86ed191d831ef4036afeb047a41dce85","modified":1665630912895},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/ISSUE_TEMPLATE/feature_request.md","hash":"40e561f1af41b0b88d146ec1ea62d7eabda3e890","modified":1665630912894},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/disqus.ejs","hash":"38a80a494e861be233b145675696ad9699aeeba0","modified":1665630912897},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/build-demo.yml","hash":"a9db5770d0840e4d3072c1de70505be07339b7f5","modified":1665630912895},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/disqusjs.ejs","hash":"703b125ce33489c9be62a2c6ccfc913af9d0ca05","modified":1665630912897},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/gitalk.ejs","hash":"1d3e0fc575a5378aa878823a0ef31aeff0b72713","modified":1665630912897},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/twikoo.ejs","hash":"7d0ac9d25737c75ab1236dd54c22d0a8c61f288e","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/build-test.yml","hash":"47e843a2c76a84720e059665cce259a8d40453f0","modified":1665630912895},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/ISSUE_TEMPLATE/bug_report.md","hash":"410f2b7b788f86585451c7f351245e4d51a87f91","modified":1665630912894},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/valine.ejs","hash":"209c463bc047bac75b9ebe45e8cf87f6255a6368","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/livere.ejs","hash":"21dc5bc91d73b54b06ac36669eefd5258b07e83e","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/gitment.ejs","hash":"7366111beed060f528e6ab6a1e907444d61519f5","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/404.ejs","hash":"b29697cfdbbf641c8efdff7d0273a4883e678f42","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_comments/waline.ejs","hash":"36ad550abddce2ab14e3948c2fe4f1846efa11ee","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/tags.ejs","hash":"70b9ce41a0e149e60788ac6d16864fea5b3311e3","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/after-footer.ejs","hash":"f397b914b34e086342e5d00effbaea9d98caf107","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/search-page.ejs","hash":"3dc81379363c8ad0bedf8489a3e6200841ff2c79","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/footer.ejs","hash":"e60e2434911c05dab7aa683ddcc84aa554c51bcd","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/head.ejs","hash":"c9c3137a870398dc7df860095b9ace4285e4d6f9","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_plugins/mermaid.ejs","hash":"e749d76fe982771637e66e505c9265c218a4b580","modified":1665630912900},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_tools/player.ejs","hash":"af36d7c6cb593af243f5342028bb337364e9afaf","modified":1665630912900},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/header.ejs","hash":"5a0c9e8d4e20bc0cc3cd397843ab4315ed9845c5","modified":1665630912899},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/categories.ejs","hash":"39a1c79de03dbc8295c9da59cebec15ae30dd632","modified":1665630912898},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/sidebar.ejs","hash":"c34bd43af8b719d8444ccea4dd9bd173b01a024e","modified":1665630912900},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_tools/share.ejs","hash":"3f7369fc6344965f12315e5214aa9eee3fe8b5f1","modified":1665630912900},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/about.ejs","hash":"25cde6dff270c41ff9bb37242e3e6aa6b85761a4","modified":1665630912900},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/category.ejs","hash":"1f24ccfd175fabc83c7ea81f3412e78e65b8f3ab","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/tagcloud.ejs","hash":"223730bfe007f26d5279cb66f1da9222c7d64c62","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/toc.ejs","hash":"09bbd53a479953600de7f1f2e68e3c72c43410c5","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/lib/cdn.js","hash":"4d408c31df9605ac9d45a3cea53fcd1ab70178df","modified":1665630912903},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/posts.ejs","hash":"43461f2e3cb32b9092dcd9a977098ff8be6a3f68","modified":1665630912901},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-color-dark.min.css","hash":"92a814c3fd3a954f77f0943f936dcf3b095f706f","modified":1665630912906},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kratosr.min.css","hash":"e1e9a22a19f9f95ec64d2449d242eb3eb26abd46","modified":1665630912906},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/about.webp","hash":"ca0fb739ab4426e7895742c1d8d52df1e14468e8","modified":1665630912907},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/prismjs.min.css","hash":"94df0fe6c26d18a094c54c30283d65c3659ccf7a","modified":1665630912906},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/bg.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1665630912910},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/404.webp","hash":"d2e2bd5cc2627a2b04d5e449a67949a2605ae13e","modified":1665630912907},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/avatar.webp","hash":"3ed6e4e1e08e9c2700aa149d1f9e068fb02947cd","modified":1665630912909},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/banner.webp","hash":"7c5093243bfd581a633ba8a905e2d379cfa78c00","modified":1665630912910},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/alipay.webp","hash":"01fa6151d2122f0470ee6f38ac8e4ced6c81912e","modified":1665630912909},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/comment.webp","hash":"7756b5a69f2a85a2d1c4251e3055bfa0218aa385","modified":1665630912911},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/bg_dark.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1665630912911},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/comment_dark.webp","hash":"7756b5a69f2a85a2d1c4251e3055bfa0218aa385","modified":1665630912911},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wechat.webp","hash":"06f3997bf554768c04cb588198c7b3d68c21b8e9","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/banner_dark.webp","hash":"5589986444825e2b75c369d419ff736d3a396bac","modified":1665630912910},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/candy.min.js","hash":"68557657a90856086aaeaeeeeed768aa1e27d73e","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/psr.webp","hash":"bf457bf84bca767bac1bd2b960d91c53ba3fbdee","modified":1665630912912},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-dark.min.js","hash":"dc01e4d5e7863537fcf5c6ee240895253e238f37","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/pjax.min.js","hash":"49b491877a535d444875fcabe242654f47fc9082","modified":1665630912919},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kratosr.min.js","hash":"19bfade8d8e04d42b48966f15e1ef70b8393eb56","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1665630912912},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wxjb.webp","hash":"722bad151afc24ee638f9cb07749666f81384b52","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/local-search.min.js","hash":"9e60a349fe6bc9b0046f99f31aac125d0d66c1c3","modified":1665630912918},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/snow.min.js","hash":"0512232ec3bc342ff998abbebe5604cd73ef8b04","modified":1665630912919},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-eighties.min.css","hash":"c3731f78911a97ed001500796a6e8d4ee9a78ab5","modified":1665630912905},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-bright.min.css","hash":"9a3a66fa13f93d5196b67e8cac24b2aac4165a2c","modified":1665630912905},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/light.min.css","hash":"c42fa620f43eaafa550bc68a7e69e6e34ada0032","modified":1665630912904},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night-blue.min.css","hash":"3a02ca54dd6a7ca6a8deb10012b5604653e398c6","modified":1665630912905},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/night.min.css","hash":"6413d0664d104edd739554011c75b5a02b9f5fde","modified":1665630912905},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/logo/logo.webp","hash":"e2a66bc21bceaf23db81afdeb86cb1dbf62bc891","modified":1665630912912},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_10.webp","hash":"4983eeca7886bbe7c09b0c79f4774302fdfa1315","modified":1665630912913},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_11.webp","hash":"08d8d91e2b01768842abb47cd48a0f07d22d070c","modified":1665630912913},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_1.webp","hash":"a818f050112ceb75e3a60dc1673a10783b254595","modified":1665630912913},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_12.webp","hash":"b6b8e1281f9146925e45e937cb4d5b28bcabe957","modified":1665630912913},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_13.webp","hash":"c4c9050637f4ffa3cb7d782f59dadc993ac3a6de","modified":1665630912914},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_14.webp","hash":"f9300e2b45c1f061ec8cc21527142dafc558a9e6","modified":1665630912914},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_15.webp","hash":"8629f2a7d3b0192549f809e6b7479159af0222da","modified":1665630912914},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_17.webp","hash":"b5a036ec234a23c820a89d1c640b1f2e8dd3dfa4","modified":1665630912914},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_16.webp","hash":"61714ccffd55d6fa74cf94bcdd5a464da04ce891","modified":1665630912914},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_18.webp","hash":"5bc78b9d6cb0a0cf6daa3a35b93e575777a49ddd","modified":1665630912915},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_2.webp","hash":"1bcf7461c2b9408b8a893013fa425eb46701faf6","modified":1665630912915},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_19.webp","hash":"15e0cd0cbe5c7166915a4b68680681beccc2afef","modified":1665630912915},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_20.webp","hash":"4ab961d94a0d3abbefc7f6d9188a889ec2225e7a","modified":1665630912915},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_3.webp","hash":"3faffd2575e0751526249c5c56a2a5045a21363b","modified":1665630912915},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_4.webp","hash":"1d0f136590632e7ba31f5510d24891ba443f1f33","modified":1665630912916},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_5.webp","hash":"ba384ada1c2a17b67036addd68ffa1f604ab5a41","modified":1665630912916},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_6.webp","hash":"c2d8b68971dacd111566526f64d94932f5c6f076","modified":1665630912916},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_7.webp","hash":"4be8fe8ea1b3563b78924062e3aa013cd5c4e82b","modified":1665630912916},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_8.webp","hash":"9e6d74786d8459440d68c409eb654364dd279f8a","modified":1665630912916},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/thumb/thumb_9.webp","hash":"bca69e7d56982b43c52e9ffa17c8d5bb268834d8","modified":1665630912917},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/README.md","hash":"3880a58a50ef7514317c4f47b5707d4fd0106c9c","modified":1665630912952},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1665630912952},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/package.json","hash":"1f2b1a268fb702727f33f348e043ffd7d0b86ec5","modified":1665630912963},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/History.md","hash":"38f837f30c75bed4b8990b36fdf540fe3c63ccd3","modified":1665630913177},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/bower.json","hash":"55980d38b6f24ec91f44579bcd38c667986368c5","modified":1665630913178},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/License.md","hash":"bc3e61d337e51c177534c644c20f190148d7905e","modified":1665630913177},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.css","hash":"17ca817a091da9dcf5fe0f2f1e1f2eea60a33149","modified":1665630913179},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Readme.md","hash":"63959b38ef0747eadd6f731b48d7aded7edc227b","modified":1665630913178},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Notes.md","hash":"e7b5de6240b6918cbdccc708a06e4b20555966c1","modified":1665630913178},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/component.json","hash":"ecbc4792d8583f73050dd4d918fea8073a7ded60","modified":1665630913178},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.js","hash":"a7e1146d2021c42e68b599dc8bcc69d44fc31df3","modified":1665630913179},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/package.json","hash":"574122118ffc8d4705e58806a13612553bc41588","modified":1665630913179},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/LICENSE","hash":"7041717dd3a7d35354f94321b666e11977c7610e","modified":1665630913180},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/README.md","hash":"1a8e6fb255a22f8233dff9815ab8790bada84b3d","modified":1665630913180},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index.html","hash":"7314a123d8a9acbd51321d4f538ba4b36b0673b5","modified":1665630913181},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index-svg.html","hash":"3c856315a2467efcd00b278c570fbc7897021d98","modified":1665630913180},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/index.svg","hash":"15730a03273bba608180e8b182453ae393b3c3e0","modified":1665630913181},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/qrcode.min.js","hash":"2d06c1f823f34c19981c6ae0b0eb0f5861c5e14b","modified":1665630913183},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/bower.json","hash":"99449e46555b0ba514eca8246f1621048db97aa5","modified":1665630913180},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/package.json","hash":"b77af52b956e89bd76c6bf75cc33f0eca47c0bf4","modified":1665630913182},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/qrcode.js","hash":"8fa3048613aab15c7f7edc3ac74a84e90375126d","modified":1665630913183},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1665630912937},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/clipboard@2.0.6/dist/clipboard.min.js","hash":"6371ec0a8e242395c7d4d008d2b98e472c9dcc52","modified":1665630912950},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1665630912936},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/disqusjs@1.3.0/dist/disqus.js","hash":"b79249dfb619836cfd1251cb3c3d5c603bc55e61","modified":1665630912951},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1665630912937},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/clipboard@2.0.6/dist/clipboard.js","hash":"8d661d3b6e11cb117361a6ff54cf54054b5d8668","modified":1665630912950},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/disqusjs@1.3.0/dist/disqusjs.css","hash":"0d8ae5946142b17f9a75683c7649cf73d6fdbe17","modified":1665630912951},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1665630912952},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1665630912953},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1665630912953},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/animated.less","hash":"421f2c4e10191f148c13b8a34e5ff3f484d4c393","modified":1665630912959},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/bordered-pulled.less","hash":"a2c292137b17406183ad0fdbf4880fd648b9a5ca","modified":1665630912960},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/fixed-width.less","hash":"ec0c24b97184dab86177660f486b8d08cd636c42","modified":1665630912960},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/core.less","hash":"1a37352286619b789d151a06eb4b7551e4c1aaa2","modified":1665630912960},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/font-awesome.less","hash":"9ffe7422dc235450a21f019f410ed359ed151f4b","modified":1665630912960},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/larger.less","hash":"e7119e82dc50540dbc3472bba7d74282815a7ecc","modified":1665630912961},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/icons.less","hash":"0285a999eb1adad868366678c2d9365b77186a45","modified":1665630912961},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/list.less","hash":"f53bc20884a1410d950b4a36a330c5181a8b55ab","modified":1665630912962},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/path.less","hash":"1afb4a849059631f76ed2a519d7fb1bd0af14802","modified":1665630912962},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/mixins.less","hash":"3c5b36b0069372b525ed8bbbcf6b3d4d2bed4e78","modified":1665630912962},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/stacked.less","hash":"f044077bc8be1a989c245254e81eb084d52d29a7","modified":1665630912963},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/rotated-flipped.less","hash":"95de5de9009714692430b04f9cd4388be8fba8f3","modified":1665630912962},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/variables.less","hash":"8a5c800747705df16117cc598c1b9f512e873bfe","modified":1665630912963},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_animated.scss","hash":"8daf189b2f8a404495b8424b6fd1ba630dd1c2dc","modified":1665630912964},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/less/screen-reader.less","hash":"71139132f170ebe7712836210f4d2c4905151899","modified":1665630912962},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_core.scss","hash":"55a14a34267edc401b82e5ee41d8bd84fbb5da3f","modified":1665630912964},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_bordered-pulled.scss","hash":"164b6a0a2b307cd293f4a914ab0fcdf643950374","modified":1665630912964},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_fixed-width.scss","hash":"224417ca266c657849afb2bbcb6dc455894ff387","modified":1665630912964},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_larger.scss","hash":"940e1c5ebc690283bfaee92560cf15fabedbf6a9","modified":1665630912965},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_icons.scss","hash":"830e0183337d16c07b1c63838f7593a33ee87b15","modified":1665630912965},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_mixins.scss","hash":"4f3881034a4c11cae8cc915f288477b498a357a2","modified":1665630912965},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_list.scss","hash":"4b53ee01513df8b9ce76442b2d8f1851613a435c","modified":1665630912965},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_path.scss","hash":"080158aeb1bf6df59ec98b2bbed44da61d9c9ca3","modified":1665630912966},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_rotated-flipped.scss","hash":"ca08a0af3da63c2f2a7d3c27a8747637744cc785","modified":1665630912966},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_screen-reader.scss","hash":"2d8563c488f68e75a28d540dd89301ee4ee08c97","modified":1665630912966},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_stacked.scss","hash":"cf6752ee609af36eb293a7197c88d31ecacbbc74","modified":1665630912966},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/font-awesome.scss","hash":"dd83648ea5bc832f87c3c1bf956c54dec065a9bd","modified":1665630912967},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/scss/_variables.scss","hash":"0d6d70535104b42e60d7f44ae6ccf9de023a7b8b","modified":1665630912966},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.css.map","hash":"9dda04c29af8da6ac13a507beefea6fce4d7032e","modified":1665630912989},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.css","hash":"61d71cb30f5f34cbb1f2b5bc469784d6cb908c22","modified":1665630912989},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/constants.js","hash":"08f6c79bf52239cbdd457bc0a94df395f578ee07","modified":1665630913031},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/constants.js.map","hash":"6b7b473ef4bba09ea572b3baaac73c122372439e","modified":1665630913032},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.js.map","hash":"2cb4d20d09b110268e0ea8c199f72501aa2d66e8","modified":1665630913034},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.js","hash":"df37d9fe8c1a0a1fb2883e5bcb93f880bb2bbf2e","modified":1665630913034},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/icons.js","hash":"d303f91799600aa8c7f5f5bb18c652fafac4359d","modified":1665630913034},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/icons.js.map","hash":"5604e4382d787a9a1976359d92bb9827f11c2c2b","modified":1665630913034},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/utils.js","hash":"df76ada59b1cf94a7ea1d44c56a6624d248b4228","modified":1665630913035},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/utils.js.map","hash":"6f99a8c2269c938d4422f3a244a8086f89800890","modified":1665630913035},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/layui.js","hash":"be7bcdcb4eb932f3e700e63584661f19b4139739","modified":1665630913072},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.LICENSE.txt","hash":"38165332beeccd3551309f85addb2354f2d18676","modified":1665630913102},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/meting@2.0.1/dist/Meting.min.js","hash":"f2b3d20b8bd64ccd031c64628f2b1323078ae324","modified":1665630913177},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js.LICENSE.txt","hash":"38165332beeccd3551309f85addb2354f2d18676","modified":1665630913170},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/component.html","hash":"5965cc7f9bb812ada1ffcd6abec39124c20a4ef8","modified":1665630913179},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/test.js","hash":"5c795debb89ec7d35ba1ec1e8ccbab0a7a353d78","modified":1665630913180},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.all.min.js.LICENSE.txt","hash":"c00fe261d987618ec25243062c089a6982d4480c","modified":1665630913187},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.min.js.LICENSE.txt","hash":"c00fe261d987618ec25243062c089a6982d4480c","modified":1665630913188},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/detect.min.js","hash":"596d6dcbe379f78a2ec655188d7bfa7182848e03","modified":1665630913200},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1665630912919},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/escape.min.js","hash":"4f91bb0e3a71ce6421b303c6c32bb3fb3e751192","modified":1665630913200},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1665630912921},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.d.ts","hash":"e8ff14efdfb197dec848f18bbdc337c18cf00956","modified":1665630912922},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.d.ts","hash":"e8ff14efdfb197dec848f18bbdc337c18cf00956","modified":1665630912929},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/index.html","hash":"c720f2027fb93454bbc7eb14ae4eb274a47e8642","modified":1665630912936},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css","hash":"a22e254bf086bf442a09344afe0e6cf188f5a1d5","modified":1665630912939},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.min.css","hash":"fc6b4268fbd57ad95d2b41a1d4d6866f222fbdb2","modified":1665630912941},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css.map","hash":"ccb7ff3435bb5cff1fe9643fc0ac8cdde2dcd177","modified":1665630912940},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1665630912946},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1665630912947},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js","hash":"27947c0c0fa837da9bdfdfc36f649c25f54bd1c0","modified":1665630912949},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1665630912948},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1665630912948},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/npm.js","hash":"e2b7590d6ec1fdac66b01fdf66ae0879f53b1262","modified":1665630912950},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/theme/default.js","hash":"449e59ac4b6b9c66384ee123e1523b5392d684a5","modified":1665630913035},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/theme/default.js.map","hash":"0b7317800be0ea17fa142c7bb26f7e8158b54447","modified":1665630913035},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/layui.mobile.css","hash":"f15da6c149002dd57ea25b8346534c8161c86e3c","modified":1665630913043},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.eot","hash":"de1bec30d0ef87af6ab83ab6a269c3c59bc83124","modified":1665630913049},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.woff","hash":"6133b92b4e5c3866675b2656ceae14606fa01eb0","modified":1665630913051},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.woff2","hash":"c9b04ae5b10f88f8bc7c48840164f468ee7b10b0","modified":1665630913051},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.ttf","hash":"5d2b8777c623bb6e96577cee675489d0299ffa1f","modified":1665630913051},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/carousel.js","hash":"ff770a94f4e7edd26f4449909e3d72644de83149","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/code.css","hash":"d7adeb3ada7c3c069aa6d098f953e0a87cfb49ef","modified":1665630913044},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/code.js","hash":"31972b8e26aac0f3b1233ad76c45187a39f4d977","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/colorpicker.js","hash":"0234f7a6eba2238583fe4644c0a247dacd67f73b","modified":1665630913066},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/element.js","hash":"1900e7f8bca28958e0a495731c7b3957ea0157c6","modified":1665630913066},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/flow.js","hash":"b6b4ffe415022a6788767906b837e2894057371b","modified":1665630913066},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/form.js","hash":"6ed3220f5b8cbee7f287ca851dd5d294790281ee","modified":1665630913066},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laydate.js","hash":"53e871827a2c0bc04ec239e9461a5eb18a309075","modified":1665630913068},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layedit.js","hash":"ce8c049188c64ec3cd3d302f8e72d0094d85c462","modified":1665630913068},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layer.js","hash":"448f76fa3ccfb66a5d86b02cf785f67adf0d8033","modified":1665630913069},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laypage.js","hash":"fec79457cffad05f261ab518e9d69bbebab548f0","modified":1665630913069},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/laytpl.js","hash":"b79191723a99f3e52b56e0afbd183d7338b9cfd4","modified":1665630913069},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/layim.js","hash":"c79d7e577901f2ceab86f01f00cc4c26ff1b038e","modified":1665630913069},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/rate.js","hash":"c3a4b2dad9e829afb8cfae69203eef8ede02191b","modified":1665630913070},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/slider.js","hash":"c4e37a45ff9ae08f90492f894d86e7bec7542b26","modified":1665630913070},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/mobile.js","hash":"0f82e8ce6b6deb51afdc307f488fb24c6dd02dbc","modified":1665630913070},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/table.js","hash":"3a18563a832e11ae642bf6c2a8634a18768f2dbb","modified":1665630913070},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/transfer.js","hash":"e85e366ff7ca8a49d195e149ec971cb6893b8409","modified":1665630913071},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/tree.js","hash":"5a0c3d9b31a49d8e30e13ef187894d9d07bec69e","modified":1665630913071},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/upload.js","hash":"8eef1ed175c49a7f09f6ce472a7d12138ed8f8ed","modified":1665630913071},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/util.js","hash":"e5e39048df40763ddfff8ec271a6f8070fcb4f4e","modified":1665630913071},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/1.gif","hash":"e6da9a45ecb8c766a8f7c2362ccf2976d20d17a9","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/0.gif","hash":"87db440c06299666a8a1f407a6008c5bf6d70817","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/10.gif","hash":"04fe5b26b7e2c980d12ad7157a4ce908c2a74f14","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/12.gif","hash":"f5da3f33448e67537e3df8ff63b010247b06841c","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/11.gif","hash":"170c2e16dd383e26d9d68406eb217dbf191ea14e","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/14.gif","hash":"1af45520e97328498b1a281b6955df5029fc9679","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/13.gif","hash":"0afcb6c47cb53fa4a8467d7d7bf00ec464df2f8e","modified":1665630913052},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/15.gif","hash":"a0f216d0aaaeec369109e4b581eacd4e83e5ccb6","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/18.gif","hash":"eeee84a351d6e84d291b0c27e5d70014a3a2748d","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/16.gif","hash":"54db2506b93b76c58174177245dcc6ef3fd0591f","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/17.gif","hash":"0b88c01b477d4ca98eb99a665c0ab8738551aeec","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/19.gif","hash":"620b2afa4c36cbfdd09c57807d8a662a5267ea51","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/2.gif","hash":"43b3ca892341431f697e1326aa693c1f252922be","modified":1665630913053},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/20.gif","hash":"7f1cefe1db5c5ee6a9b0eea4d9618cba4b1ac790","modified":1665630913054},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/21.gif","hash":"86d3d5273ffd13841d246698eb648d85e178c4dc","modified":1665630913054},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/22.gif","hash":"dcad257d86505e921618f7d85b60bf6ac2ce319d","modified":1665630913054},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/23.gif","hash":"43295056d287f3da526dfb77915edc3de7551e3e","modified":1665630913054},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/24.gif","hash":"02a263028625496740eea9a50141a4ad98d826a1","modified":1665630913054},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/25.gif","hash":"05eeb7a9c42a2cd3876417944143078ce514a8b9","modified":1665630913055},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/26.gif","hash":"153c5f602881b04bed23d5c7d21a977563075ee2","modified":1665630913055},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/27.gif","hash":"814bad015177103646b0216367fa9707361998d3","modified":1665630913055},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/28.gif","hash":"5830d72546907c962b6c9003fa923798a67b0406","modified":1665630913055},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/29.gif","hash":"ef1d583626e7447f546995a5b296f34eb3364902","modified":1665630913056},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/3.gif","hash":"339482962bc4995e16e99ac9de9fc067636fd79e","modified":1665630913056},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/32.gif","hash":"9af01aea73b614e5820a00bcc890840493f9dd70","modified":1665630913057},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/30.gif","hash":"886222551781040325cfd3307fbfba2a1d434a9e","modified":1665630913056},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/31.gif","hash":"29043ca9d16adf6574d4d7efde1af7a615689931","modified":1665630913056},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/33.gif","hash":"5f02bc5ec8d6220a872f1ca1fa2abaa92d46c361","modified":1665630913057},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/34.gif","hash":"e0e500feecd8274490a3bdbf64d2555c16a86261","modified":1665630913057},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/35.gif","hash":"141ae180796db9800770dc9dbb8c9beda6f170e8","modified":1665630913057},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/36.gif","hash":"55abcc242354c9c1c73538db5d8c7b984de5ca52","modified":1665630913057},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/38.gif","hash":"336cb3cbe0fd6cac96cd7cd5ca847c6a01f95b50","modified":1665630913058},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/37.gif","hash":"850b9425421c3072a4898154d41776c02a4d64f7","modified":1665630913058},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/4.gif","hash":"878c3da67e6aec79c9b8dba6f34368586f4bd097","modified":1665630913058},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/40.gif","hash":"c1b0fef186697125b66c1b4617fa3f9abc4d92eb","modified":1665630913059},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/42.gif","hash":"86f11fca6a9c42d3678ec8af35c077a9790ce777","modified":1665630913059},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/39.gif","hash":"6380eb13d87fc4242d2c6eec57f482ac8ca1ad1f","modified":1665630913058},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/41.gif","hash":"c37fb5c43ea499a005d88075a392ed2e09c331df","modified":1665630913059},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/43.gif","hash":"6a16279bea1179b3fd3a45736ecffd983a42272d","modified":1665630913059},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/44.gif","hash":"32a9fa973626a3a06646095aeeecb919923f7d16","modified":1665630913060},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/46.gif","hash":"b6c74edb2dc383e0f3e28a0859fa87683fea18e2","modified":1665630913060},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/45.gif","hash":"864dfc9b99f5641f6d5a0081dc14d84872c1b3c6","modified":1665630913060},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/47.gif","hash":"653e07693ee719cafbce662bb5e410646fe4695a","modified":1665630913060},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/48.gif","hash":"8a8483cd4e3b4b6ac0567eab41c5655ace4b3a81","modified":1665630913060},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/49.gif","hash":"dbf616c5537074ace036340bdddf7948c138c3d7","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/5.gif","hash":"cf43cfcf14bbc7f8e430b74a97eb3b260f16b08c","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/50.gif","hash":"94a521d4f9a69c4eb59f5bbe673c8803246bdf5e","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/51.gif","hash":"1ef1419f1ba2fd28e7de676ae5c388074646be53","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/52.gif","hash":"b516f6bd28cee1fe34144d897b702989782be4ec","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/53.gif","hash":"a03f9bbb0202d24d3313286f60ce08b214c013d2","modified":1665630913061},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/54.gif","hash":"75c738c517217f6b09d51ca3036cf54a01891c4d","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/55.gif","hash":"c446b5eca2cce1faa7f2147a8b646cc774011de1","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/56.gif","hash":"a71c1ef36706c4ddf7959c68d6c40920db3efe67","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/57.gif","hash":"b797ac8509a8f8bc328b10153e0026449a6139ec","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/58.gif","hash":"5c70cba8adb0b42c0da4d922498c265e5d8034d7","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/59.gif","hash":"c50da42e6f2ec33112261f46c30e5ea5b4a0f889","modified":1665630913062},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/6.gif","hash":"697d8f2262c535cd61808a564b21fc10ea93f0db","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/60.gif","hash":"bdb24b7ec836fbf6c60c4d7ad97d73f041a154a8","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/62.gif","hash":"a839a263600c034bb11411a7f762dfa917155d10","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/61.gif","hash":"a5db56b975970ebe7048a5c824604d64559392b9","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/63.gif","hash":"28e9ec7a3882fec8c63dd731b06a9bbcc179aff7","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/64.gif","hash":"38a537e9ac930736e162be81c13c5f708ff948bd","modified":1665630913063},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/65.gif","hash":"93cab4423539955a25d17c83da6aee277a6402aa","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/67.gif","hash":"50e2ed8f7773e60ae7d40b612db98554b8277b6e","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/66.gif","hash":"6efe452b1f7a697db1c654130a9c2b872f528654","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/68.gif","hash":"e779199003a7415a29d50ecf0bbfed04e031f1ab","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/69.gif","hash":"76ac840c5bc5ad44302daa921e7217149576b89e","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/7.gif","hash":"ad4e2ea1864a85f5729a1347c2f8c49fdb3b2def","modified":1665630913064},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/70.gif","hash":"7c2641bef26579d9f90bdc0b740357527dd6e484","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/71.gif","hash":"c6323d6d6d262011faed18e758e9e83e7b6812b8","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/8.gif","hash":"43baffc48b0fbe649ed920bad713e2ccab9b7344","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/images/face/9.gif","hash":"8df9fc1055efeffdb72d499c064c05445adaa9be","modified":1665630913065},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/plugins/emojis/light.json","hash":"3ac2cd3cc07efff7c30ece9857b0527c5fc534d3","modified":1665630913200},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/plugins/emojis/index.js","hash":"452e66f0b900282eab6f98743592793361ccbc65","modified":1665630913200},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/layim.css","hash":"a669bd1141c1df237631738d41f9d0032f4ba0a3","modified":1665630913046},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/laydate/default/laydate.css","hash":"bc0f2f7396ca62c86bc07c2db1b73ca83de3cbdb","modified":1665630913044},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/chatlog.html","hash":"64591e08bb5af1d22e976ba3b3175075c7e6cd12","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/find.html","hash":"ed8e6a3564bb52fc7adc8f19c7be34f25fe97222","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/getmsg.json","hash":"3a83d94b0d8bdb96459e36ea042a72768ea3b348","modified":1665630913046},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/html/msgbox.html","hash":"521979a7d5b54e6c00dedaa897ae547065da9b2c","modified":1665630913046},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon-ext.png","hash":"ddf2a30ad34bac4e9a1250f29c46ac0823d62a12","modified":1665630913044},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-2.gif","hash":"c641615e851254111e268da42d72ae684b3ce967","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon.png","hash":"fe47ec617507e9ce5f6ce7ac9b179a3c9231882b","modified":1665630913044},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-0.gif","hash":"ba81388bbac5bc223f94489b97a95a13f3c78e47","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/layer.css","hash":"ed6fefb1501b3bcd720919f9ce55bb322b5d7ec5","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-1.gif","hash":"49e54acbf5674212195e581848ec0d490282448f","modified":1665630913045},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/mobile/layim.css","hash":"0af51b5e2280a03cefcde3e4cf6662d274cc64c6","modified":1665630913046},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/1.jpg","hash":"f0ba9086fa730c9c80b89f25ff440b740a4b06df","modified":1665630913047},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/voice/default.mp3","hash":"18ac4168a61de5cd4a35f814e97365945de94ab0","modified":1665630913048},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/2.jpg","hash":"ee9e802e6a46b5b698a4d0c36249c0085b192c68","modified":1665630913047},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/3.jpg","hash":"56cd08ca560acd37d377626b1b67cc4947bfe314","modified":1665630913047},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/logo.jpg","hash":"3014e3081d5d4164143936fcf61e7080e81faf38","modified":1665630913048},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/4.jpg","hash":"e018753c3fbd420f8987e53f8a9fc62428ecc18d","modified":1665630913047},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/5.jpg","hash":"a7c37d5401127afeb1ddd930c9ad9f0e3fab3d31","modified":1665630913048},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/wechat.JPG","hash":"0ed6d709610ec11148fa1da18df3df1a252628be","modified":1665630912917},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qrcode_js@1.0.0/jquery.min.js","hash":"a8c8a5caf9765b4ccb90d708045518e219a9af5d","modified":1665630913182},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1665630912959},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1665630912958},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1665630913037},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.min.map","hash":"17a9498757f0b358580ffce586bbc97ae897e8d8","modified":1665630913042},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.min.js","hash":"d1c6704e94efe2d465fc161b6381e127d35acd81","modified":1665630913041},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1665630912921},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.min.css","hash":"ed29315e0ffb3f14382431f2724235bf67f44eb3","modified":1665630912945},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1665630912947},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/js/bootstrap.js","hash":"542cfd539f0cad650342c8cab8baf1cdbcd5fea6","modified":1665630912949},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/css/layui.css","hash":"e15327d5c8f4c82909edc97977b277207e01364d","modified":1665630913043},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/lay/modules/jquery.js","hash":"36456de559419079e1096890c7e9a97ae1bbf1be","modified":1665630913067},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/aplayer@1.10.1/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1665630912938},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1665630912956},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1665630912957},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1665630912954},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1665630913032},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.min.map","hash":"c98b6a5cb27af645c8bfb525fcad3569f3917d5b","modified":1665630913039},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.Pure.min.js","hash":"227fb19caf17f4330ac24cb952af466eeaae5c43","modified":1665630913190},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.js","hash":"d081a412c63411a75a3a880ddece65335d1c3ee8","modified":1665630913194},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1665630912921},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.js","hash":"d9494e4919cbc017d7b0d70bb70dbcd97c35fcb1","modified":1665630912923},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.js","hash":"888cb555c5e9749cfe5a5a6cad2a8f56167b9dc4","modified":1665630912930},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.css","hash":"f2183455571b19311a235bd5aa204e694ade8e94","modified":1665630912942},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/alipay.JPG","hash":"07fb99a913ca0ba0ec32df0cacab37b75e7c3d63","modified":1665630912909},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.slim.js","hash":"77ec5d7bdb33634ff7d76837e36f0a7240c21e86","modified":1665630913040},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.umd.js","hash":"90de88757741f89ad68c8d3765174437454e2303","modified":1665630913197},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitment@0.0.3/dist/gitment.browser.js.map","hash":"72dc603fb7be8b623d1a402419b42c36723367bb","modified":1665630913034},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/jquery@3.6.0/dist/jquery.js","hash":"af32f706407ab08f800c5e697cce92466e735847","modified":1665630913037},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/layui.all.js","hash":"4fbff21286558e3cb817072d76ae326db4378c6e","modified":1665630913072},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.Pure.min.js.map","hash":"40e15912aae8beff90cbb8ae235cd6fcd36f87dc","modified":1665630913192},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.umd.js.map","hash":"6fe9ac91ca5074bcbc696f887802e8304e31aaea","modified":1665630913199},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/layui-src@2.5.5/dist/font/iconfont.svg","hash":"d484cee6f2461c9194b28878a1d1a677ffdbb78c","modified":1665630913050},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.min.js","hash":"e547de978c573d0e7beda7ad74829ce6fef6b058","modified":1665630913188},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/valine@1.4.18/dist/Valine.min.js.map","hash":"fb6f3071e92d08b0c66808ff9cfd190a0341d93d","modified":1665630913196},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/bootstrap@3.3.4/dist/css/bootstrap.css.map","hash":"2e1d08a9694cd5a694eabca746cfad95fb99653e","modified":1665630912945},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1665630912957},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/twikoo@1.5.11/dist/twikoo.all.min.js","hash":"31c6669a90a33ee5af66ceaf47996ad8fd8b962e","modified":1665630913187},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1665630913021},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.noStyle.js.map","hash":"6a31b3aabb3bb6e0e2b7640feec5500617d01950","modified":1665630912935},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/@waline/client@1.6.0/dist/Waline.min.js.map","hash":"42ce7c8e816ffa115df320a5eb75975291b86731","modified":1665630912929},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs","hash":"c01a600693e204abd02d0bf056a98a49e8a78d6e","modified":1665630913102},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js","hash":"6bee48c26c32b90f50519f125890fcbb04779da6","modified":1665630913170},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.core.js","hash":"7952663a721317158468875349956182465b0701","modified":1665630913078},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.core.js.map","hash":"1d19d75bea55a0c0062661bb0fe5ad4135f68d8a","modified":1665630913096},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk-component.js","hash":"fe4c44fa48522e9b2675f3a652d83d8aaec11ad8","modified":1665630912977},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.js","hash":"540a80bafeba53826127d556487541332ecd6ed1","modified":1665630912998},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk-component.js.map","hash":"6f118aa575a5da5449d0c171f1c85fa5e43f80ff","modified":1665630912988},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.js.map","hash":"b5d129e59c5a1ca46395fbf7466432983178ebba","modified":1665630913018},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.map","hash":"0ad921fcf8f5f79cf5fdf5deb5b4ffc21e501ff0","modified":1665630913123},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.min.js.map","hash":"bd1138557833d1ec29ce678d2f994e053f180423","modified":1665630913176},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.js.map","hash":"199ed9c41ad0bec69a69514beb6f39f7b3a78ae5","modified":1665630913163},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/gitalk@1.7.2/dist/gitalk.min.js.map","hash":"6a9f6d47092f2557b346c0eabbd5907a1b12a9e7","modified":1665630913031},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/mermaid@9.1.1/dist/mermaid.js","hash":"e1f5d58724700b9cd810bb4e295ac93b6724578d","modified":1665630913144},{"_id":"public/config/main.json","hash":"907998b2e57172d106ba8819c3dfe7fab2e0f74a","modified":1666848248687},{"_id":"public/search.json","hash":"d94a9e93cb8a938e7bcc52af543d3ea289bf9702","modified":1666848248687},{"_id":"public/categories/安装文档/博客相关/index.html","hash":"76d36462709c36a06ee10b3908f2513db51c5eff","modified":1666848248687},{"_id":"public/categories/学习笔记/index.html","hash":"b75ba674885f85c0c8ec9ee372a261316f3ee57c","modified":1666848248687},{"_id":"public/categories/学习笔记/java/index.html","hash":"6cf5607e69c5055d060aa4bc59f31a2bc64e18e2","modified":1666848248687},{"_id":"public/tags/java/index.html","hash":"1931ae83d7b6c8389c4823d4cb3a4dfa012af441","modified":1666848248687},{"_id":"public/tags/index.html","hash":"c16b58fb6d46733b1e6b6ff0dedabc10321e1248","modified":1666848248687},{"_id":"public/404.html","hash":"ebf55481205c0b773940ede22211a4f47dcee857","modified":1666848248687},{"_id":"public/categories/index.html","hash":"138dac5e4196d5b1d379cd4598aed4390fc730f5","modified":1666848248687},{"_id":"public/search/index.html","hash":"39f3ee24461aaa883b696484c6e991d3d20f21c9","modified":1666848248687},{"_id":"public/2022/10/27/java基础笔记/index.html","hash":"bb7fb790401f0b3750a30c41ed29962e0a6292d2","modified":1666848248687},{"_id":"public/2022/10/13/hello-world/index.html","hash":"07899d957311119def6bf741cd0fc0a94501def9","modified":1666848248687},{"_id":"public/2022/09/24/Node.js安装与配置（详细步骤）/index.html","hash":"f6758bc9cc4b82cb954709b576e7e8a85e79fafb","modified":1666848248687},{"_id":"public/2022/09/24/hexo+github搭建博客/index.html","hash":"816daacb1967230f25c029f9d40335b5ac27a207","modified":1666848248687},{"_id":"public/archives/index.html","hash":"df140e07ab17e43e50b5eef9003cdfa4fcfe9f2e","modified":1666848248687},{"_id":"public/archives/2022/index.html","hash":"ef7bb0bf587d1e3b9b88eb890928026236363ff2","modified":1666848248687},{"_id":"public/archives/2022/09/index.html","hash":"992cc3a83f3940d023d34af9dcd920e9cdd02097","modified":1666848248687},{"_id":"public/archives/2022/10/index.html","hash":"0139779e2bfdfad9ad811490f1f1c0929e1f2f73","modified":1666848248687},{"_id":"public/categories/安装文档/index.html","hash":"4c780072312db20d58a724def18303570514ea48","modified":1666848248687},{"_id":"public/index.html","hash":"5112780a27f0a078866fa66bcb05f82b6e68efbf","modified":1666848248687},{"_id":"public/tags/安装/index.html","hash":"783923d494c4327786b55e420a88d25026a592d3","modified":1666848248687},{"_id":"public/images/404.webp","hash":"d2e2bd5cc2627a2b04d5e449a67949a2605ae13e","modified":1666848248687},{"_id":"public/images/avatar.webp","hash":"3ed6e4e1e08e9c2700aa149d1f9e068fb02947cd","modified":1666848248687},{"_id":"public/images/alipay.webp","hash":"01fa6151d2122f0470ee6f38ac8e4ced6c81912e","modified":1666848248687},{"_id":"public/images/about.webp","hash":"ca0fb739ab4426e7895742c1d8d52df1e14468e8","modified":1666848248687},{"_id":"public/images/banner.webp","hash":"7c5093243bfd581a633ba8a905e2d379cfa78c00","modified":1666848248687},{"_id":"public/images/banner_dark.webp","hash":"5589986444825e2b75c369d419ff736d3a396bac","modified":1666848248687},{"_id":"public/images/bg.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1666848248687},{"_id":"public/images/comment.webp","hash":"7756b5a69f2a85a2d1c4251e3055bfa0218aa385","modified":1666848248687},{"_id":"public/images/bg_dark.webp","hash":"f232b442b64eaa90f45a48ff04d8e7d352caf212","modified":1666848248687},{"_id":"public/images/comment_dark.webp","hash":"7756b5a69f2a85a2d1c4251e3055bfa0218aa385","modified":1666848248687},{"_id":"public/images/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1666848248687},{"_id":"public/images/wechat.webp","hash":"06f3997bf554768c04cb588198c7b3d68c21b8e9","modified":1666848248687},{"_id":"public/images/psr.webp","hash":"bf457bf84bca767bac1bd2b960d91c53ba3fbdee","modified":1666848248687},{"_id":"public/images/wxjb.webp","hash":"722bad151afc24ee638f9cb07749666f81384b52","modified":1666848248687},{"_id":"public/images/logo/logo.webp","hash":"e2a66bc21bceaf23db81afdeb86cb1dbf62bc891","modified":1666848248687},{"_id":"public/images/thumb/thumb_10.webp","hash":"4983eeca7886bbe7c09b0c79f4774302fdfa1315","modified":1666848248687},{"_id":"public/images/thumb/thumb_1.webp","hash":"a818f050112ceb75e3a60dc1673a10783b254595","modified":1666848248687},{"_id":"public/images/thumb/thumb_11.webp","hash":"08d8d91e2b01768842abb47cd48a0f07d22d070c","modified":1666848248687},{"_id":"public/images/thumb/thumb_12.webp","hash":"b6b8e1281f9146925e45e937cb4d5b28bcabe957","modified":1666848248687},{"_id":"public/images/thumb/thumb_14.webp","hash":"f9300e2b45c1f061ec8cc21527142dafc558a9e6","modified":1666848248687},{"_id":"public/images/thumb/thumb_13.webp","hash":"c4c9050637f4ffa3cb7d782f59dadc993ac3a6de","modified":1666848248687},{"_id":"public/images/thumb/thumb_15.webp","hash":"8629f2a7d3b0192549f809e6b7479159af0222da","modified":1666848248687},{"_id":"public/images/thumb/thumb_16.webp","hash":"61714ccffd55d6fa74cf94bcdd5a464da04ce891","modified":1666848248687},{"_id":"public/images/thumb/thumb_17.webp","hash":"b5a036ec234a23c820a89d1c640b1f2e8dd3dfa4","modified":1666848248687},{"_id":"public/images/thumb/thumb_18.webp","hash":"5bc78b9d6cb0a0cf6daa3a35b93e575777a49ddd","modified":1666848248687},{"_id":"public/images/thumb/thumb_19.webp","hash":"15e0cd0cbe5c7166915a4b68680681beccc2afef","modified":1666848248687},{"_id":"public/images/thumb/thumb_20.webp","hash":"4ab961d94a0d3abbefc7f6d9188a889ec2225e7a","modified":1666848248687},{"_id":"public/images/thumb/thumb_2.webp","hash":"1bcf7461c2b9408b8a893013fa425eb46701faf6","modified":1666848248687},{"_id":"public/images/thumb/thumb_3.webp","hash":"3faffd2575e0751526249c5c56a2a5045a21363b","modified":1666848248687},{"_id":"public/images/thumb/thumb_4.webp","hash":"1d0f136590632e7ba31f5510d24891ba443f1f33","modified":1666848248687},{"_id":"public/images/thumb/thumb_5.webp","hash":"ba384ada1c2a17b67036addd68ffa1f604ab5a41","modified":1666848248687},{"_id":"public/images/thumb/thumb_7.webp","hash":"4be8fe8ea1b3563b78924062e3aa013cd5c4e82b","modified":1666848248687},{"_id":"public/images/thumb/thumb_6.webp","hash":"c2d8b68971dacd111566526f64d94932f5c6f076","modified":1666848248687},{"_id":"public/images/thumb/thumb_8.webp","hash":"9e6d74786d8459440d68c409eb654364dd279f8a","modified":1666848248687},{"_id":"public/images/thumb/thumb_9.webp","hash":"bca69e7d56982b43c52e9ffa17c8d5bb268834d8","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1666848248687},{"_id":"public/vendors/qrcode_js@1.0.0/LICENSE","hash":"7041717dd3a7d35354f94321b666e11977c7610e","modified":1666848248687},{"_id":"public/vendors/qrcode_js@1.0.0/index.svg","hash":"15730a03273bba608180e8b182453ae393b3c3e0","modified":1666848248687},{"_id":"public/vendors/aplayer@1.10.1/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/animated.less","hash":"421f2c4e10191f148c13b8a34e5ff3f484d4c393","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/bordered-pulled.less","hash":"a2c292137b17406183ad0fdbf4880fd648b9a5ca","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/core.less","hash":"1a37352286619b789d151a06eb4b7551e4c1aaa2","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/fixed-width.less","hash":"ec0c24b97184dab86177660f486b8d08cd636c42","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/font-awesome.less","hash":"9ffe7422dc235450a21f019f410ed359ed151f4b","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/icons.less","hash":"0285a999eb1adad868366678c2d9365b77186a45","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/larger.less","hash":"e7119e82dc50540dbc3472bba7d74282815a7ecc","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/list.less","hash":"f53bc20884a1410d950b4a36a330c5181a8b55ab","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/mixins.less","hash":"3c5b36b0069372b525ed8bbbcf6b3d4d2bed4e78","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/stacked.less","hash":"f044077bc8be1a989c245254e81eb084d52d29a7","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/path.less","hash":"1afb4a849059631f76ed2a519d7fb1bd0af14802","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/rotated-flipped.less","hash":"95de5de9009714692430b04f9cd4388be8fba8f3","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/variables.less","hash":"8a5c800747705df16117cc598c1b9f512e873bfe","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/less/screen-reader.less","hash":"71139132f170ebe7712836210f4d2c4905151899","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/scss/font-awesome.scss","hash":"dd83648ea5bc832f87c3c1bf956c54dec065a9bd","modified":1666848248687},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.css.map","hash":"9dda04c29af8da6ac13a507beefea6fce4d7032e","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/constants.js.map","hash":"6b7b473ef4bba09ea572b3baaac73c122372439e","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/gitment.js.map","hash":"2cb4d20d09b110268e0ea8c199f72501aa2d66e8","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/icons.js.map","hash":"5604e4382d787a9a1976359d92bb9827f11c2c2b","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/utils.js.map","hash":"6f99a8c2269c938d4422f3a244a8086f89800890","modified":1666848248687},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.LICENSE.txt","hash":"38165332beeccd3551309f85addb2354f2d18676","modified":1666848248687},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.min.js.LICENSE.txt","hash":"38165332beeccd3551309f85addb2354f2d18676","modified":1666848248687},{"_id":"public/vendors/twikoo@1.5.11/dist/twikoo.all.min.js.LICENSE.txt","hash":"c00fe261d987618ec25243062c089a6982d4480c","modified":1666848248687},{"_id":"public/vendors/twikoo@1.5.11/dist/twikoo.min.js.LICENSE.txt","hash":"c00fe261d987618ec25243062c089a6982d4480c","modified":1666848248687},{"_id":"public/vendors/@waline/client@1.6.0/dist/Waline.min.d.ts","hash":"e8ff14efdfb197dec848f18bbdc337c18cf00956","modified":1666848248687},{"_id":"public/vendors/@waline/client@1.6.0/dist/Waline.noStyle.d.ts","hash":"e8ff14efdfb197dec848f18bbdc337c18cf00956","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css.map","hash":"ccb7ff3435bb5cff1fe9643fc0ac8cdde2dcd177","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/theme/default.js.map","hash":"0b7317800be0ea17fa142c7bb26f7e8158b54447","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/font/iconfont.eot","hash":"de1bec30d0ef87af6ab83ab6a269c3c59bc83124","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/font/iconfont.ttf","hash":"5d2b8777c623bb6e96577cee675489d0299ffa1f","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/font/iconfont.woff","hash":"6133b92b4e5c3866675b2656ceae14606fa01eb0","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/font/iconfont.woff2","hash":"c9b04ae5b10f88f8bc7c48840164f468ee7b10b0","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/0.gif","hash":"87db440c06299666a8a1f407a6008c5bf6d70817","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/10.gif","hash":"04fe5b26b7e2c980d12ad7157a4ce908c2a74f14","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/1.gif","hash":"e6da9a45ecb8c766a8f7c2362ccf2976d20d17a9","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/11.gif","hash":"170c2e16dd383e26d9d68406eb217dbf191ea14e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/12.gif","hash":"f5da3f33448e67537e3df8ff63b010247b06841c","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/13.gif","hash":"0afcb6c47cb53fa4a8467d7d7bf00ec464df2f8e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/14.gif","hash":"1af45520e97328498b1a281b6955df5029fc9679","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/15.gif","hash":"a0f216d0aaaeec369109e4b581eacd4e83e5ccb6","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/18.gif","hash":"eeee84a351d6e84d291b0c27e5d70014a3a2748d","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/16.gif","hash":"54db2506b93b76c58174177245dcc6ef3fd0591f","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/17.gif","hash":"0b88c01b477d4ca98eb99a665c0ab8738551aeec","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/19.gif","hash":"620b2afa4c36cbfdd09c57807d8a662a5267ea51","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/2.gif","hash":"43b3ca892341431f697e1326aa693c1f252922be","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/20.gif","hash":"7f1cefe1db5c5ee6a9b0eea4d9618cba4b1ac790","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/21.gif","hash":"86d3d5273ffd13841d246698eb648d85e178c4dc","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/22.gif","hash":"dcad257d86505e921618f7d85b60bf6ac2ce319d","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/23.gif","hash":"43295056d287f3da526dfb77915edc3de7551e3e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/25.gif","hash":"05eeb7a9c42a2cd3876417944143078ce514a8b9","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/24.gif","hash":"02a263028625496740eea9a50141a4ad98d826a1","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/26.gif","hash":"153c5f602881b04bed23d5c7d21a977563075ee2","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/27.gif","hash":"814bad015177103646b0216367fa9707361998d3","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/28.gif","hash":"5830d72546907c962b6c9003fa923798a67b0406","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/29.gif","hash":"ef1d583626e7447f546995a5b296f34eb3364902","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/3.gif","hash":"339482962bc4995e16e99ac9de9fc067636fd79e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/31.gif","hash":"29043ca9d16adf6574d4d7efde1af7a615689931","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/30.gif","hash":"886222551781040325cfd3307fbfba2a1d434a9e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/32.gif","hash":"9af01aea73b614e5820a00bcc890840493f9dd70","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/33.gif","hash":"5f02bc5ec8d6220a872f1ca1fa2abaa92d46c361","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/34.gif","hash":"e0e500feecd8274490a3bdbf64d2555c16a86261","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/35.gif","hash":"141ae180796db9800770dc9dbb8c9beda6f170e8","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/36.gif","hash":"55abcc242354c9c1c73538db5d8c7b984de5ca52","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/37.gif","hash":"850b9425421c3072a4898154d41776c02a4d64f7","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/38.gif","hash":"336cb3cbe0fd6cac96cd7cd5ca847c6a01f95b50","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/39.gif","hash":"6380eb13d87fc4242d2c6eec57f482ac8ca1ad1f","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/4.gif","hash":"878c3da67e6aec79c9b8dba6f34368586f4bd097","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/40.gif","hash":"c1b0fef186697125b66c1b4617fa3f9abc4d92eb","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/41.gif","hash":"c37fb5c43ea499a005d88075a392ed2e09c331df","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/42.gif","hash":"86f11fca6a9c42d3678ec8af35c077a9790ce777","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/43.gif","hash":"6a16279bea1179b3fd3a45736ecffd983a42272d","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/44.gif","hash":"32a9fa973626a3a06646095aeeecb919923f7d16","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/46.gif","hash":"b6c74edb2dc383e0f3e28a0859fa87683fea18e2","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/45.gif","hash":"864dfc9b99f5641f6d5a0081dc14d84872c1b3c6","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/47.gif","hash":"653e07693ee719cafbce662bb5e410646fe4695a","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/48.gif","hash":"8a8483cd4e3b4b6ac0567eab41c5655ace4b3a81","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/49.gif","hash":"dbf616c5537074ace036340bdddf7948c138c3d7","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/50.gif","hash":"94a521d4f9a69c4eb59f5bbe673c8803246bdf5e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/5.gif","hash":"cf43cfcf14bbc7f8e430b74a97eb3b260f16b08c","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/51.gif","hash":"1ef1419f1ba2fd28e7de676ae5c388074646be53","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/52.gif","hash":"b516f6bd28cee1fe34144d897b702989782be4ec","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/53.gif","hash":"a03f9bbb0202d24d3313286f60ce08b214c013d2","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/54.gif","hash":"75c738c517217f6b09d51ca3036cf54a01891c4d","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/55.gif","hash":"c446b5eca2cce1faa7f2147a8b646cc774011de1","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/56.gif","hash":"a71c1ef36706c4ddf7959c68d6c40920db3efe67","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/57.gif","hash":"b797ac8509a8f8bc328b10153e0026449a6139ec","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/58.gif","hash":"5c70cba8adb0b42c0da4d922498c265e5d8034d7","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/6.gif","hash":"697d8f2262c535cd61808a564b21fc10ea93f0db","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/59.gif","hash":"c50da42e6f2ec33112261f46c30e5ea5b4a0f889","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/60.gif","hash":"bdb24b7ec836fbf6c60c4d7ad97d73f041a154a8","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/61.gif","hash":"a5db56b975970ebe7048a5c824604d64559392b9","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/62.gif","hash":"a839a263600c034bb11411a7f762dfa917155d10","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/64.gif","hash":"38a537e9ac930736e162be81c13c5f708ff948bd","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/63.gif","hash":"28e9ec7a3882fec8c63dd731b06a9bbcc179aff7","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/65.gif","hash":"93cab4423539955a25d17c83da6aee277a6402aa","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/67.gif","hash":"50e2ed8f7773e60ae7d40b612db98554b8277b6e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/66.gif","hash":"6efe452b1f7a697db1c654130a9c2b872f528654","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/69.gif","hash":"76ac840c5bc5ad44302daa921e7217149576b89e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/7.gif","hash":"ad4e2ea1864a85f5729a1347c2f8c49fdb3b2def","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/68.gif","hash":"e779199003a7415a29d50ecf0bbfed04e031f1ab","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/70.gif","hash":"7c2641bef26579d9f90bdc0b740357527dd6e484","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/71.gif","hash":"c6323d6d6d262011faed18e758e9e83e7b6812b8","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/8.gif","hash":"43baffc48b0fbe649ed920bad713e2ccab9b7344","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/images/face/9.gif","hash":"8df9fc1055efeffdb72d499c064c05445adaa9be","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon-ext.png","hash":"ddf2a30ad34bac4e9a1250f29c46ac0823d62a12","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/icon.png","hash":"fe47ec617507e9ce5f6ce7ac9b179a3c9231882b","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-2.gif","hash":"c641615e851254111e268da42d72ae684b3ce967","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-1.gif","hash":"49e54acbf5674212195e581848ec0d490282448f","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/loading-0.gif","hash":"ba81388bbac5bc223f94489b97a95a13f3c78e47","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/voice/default.mp3","hash":"18ac4168a61de5cd4a35f814e97365945de94ab0","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/1.jpg","hash":"f0ba9086fa730c9c80b89f25ff440b740a4b06df","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/2.jpg","hash":"ee9e802e6a46b5b698a4d0c36249c0085b192c68","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/3.jpg","hash":"56cd08ca560acd37d377626b1b67cc4947bfe314","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/5.jpg","hash":"a7c37d5401127afeb1ddd930c9ad9f0e3fab3d31","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/4.jpg","hash":"e018753c3fbd420f8987e53f8a9fc62428ecc18d","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/skin/logo.jpg","hash":"3014e3081d5d4164143936fcf61e7080e81faf38","modified":1666848248687},{"_id":"public/images/wechat.JPG","hash":"0ed6d709610ec11148fa1da18df3df1a252628be","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1666848248687},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.slim.min.map","hash":"17a9498757f0b358580ffce586bbc97ae897e8d8","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1666848248687},{"_id":"public/css/kr-color-dark.min.css","hash":"92a814c3fd3a954f77f0943f936dcf3b095f706f","modified":1666848248687},{"_id":"public/css/prismjs.min.css","hash":"94df0fe6c26d18a094c54c30283d65c3659ccf7a","modified":1666848248687},{"_id":"public/js/candy.min.js","hash":"68557657a90856086aaeaeeeeed768aa1e27d73e","modified":1666848248687},{"_id":"public/js/kratosr.min.js","hash":"19bfade8d8e04d42b48966f15e1ef70b8393eb56","modified":1666848248687},{"_id":"public/js/kr-dark.min.js","hash":"dc01e4d5e7863537fcf5c6ee240895253e238f37","modified":1666848248687},{"_id":"public/js/pjax.min.js","hash":"49b491877a535d444875fcabe242654f47fc9082","modified":1666848248687},{"_id":"public/js/snow.min.js","hash":"0512232ec3bc342ff998abbebe5604cd73ef8b04","modified":1666848248687},{"_id":"public/js/local-search.min.js","hash":"9e60a349fe6bc9b0046f99f31aac125d0d66c1c3","modified":1666848248687},{"_id":"public/css/highlight/night-bright.min.css","hash":"9a3a66fa13f93d5196b67e8cac24b2aac4165a2c","modified":1666848248687},{"_id":"public/css/highlight/night-blue.min.css","hash":"3a02ca54dd6a7ca6a8deb10012b5604653e398c6","modified":1666848248687},{"_id":"public/css/highlight/night-eighties.min.css","hash":"c3731f78911a97ed001500796a6e8d4ee9a78ab5","modified":1666848248687},{"_id":"public/css/highlight/light.min.css","hash":"c42fa620f43eaafa550bc68a7e69e6e34ada0032","modified":1666848248687},{"_id":"public/css/highlight/night.min.css","hash":"6413d0664d104edd739554011c75b5a02b9f5fde","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/README.html","hash":"cb320302fd7b93aef0f311dbea2628a3d71b7946","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/History.html","hash":"576033eb7d1287eeaf5490b6eb3b67bf10a5c660","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/License.html","hash":"3c0164de84ebc7a78d5ec706f718917f38e3d51e","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/package.json","hash":"166a52895a194d9bacec7fbca5140c0fea5ce9d6","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/Notes.html","hash":"b9e3e7915863568cff48a5c4dc9dbddfc88d692d","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/bower.json","hash":"1877b30670d27ff643245d681b3d9abf6651ddb2","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/component.json","hash":"d4264f50a37fedfe55d6d2aef7c99ab08614be80","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/Readme.html","hash":"448a4e51ef0b14d32b094d68057628703f0e5848","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/nprogress.js","hash":"a7e1146d2021c42e68b599dc8bcc69d44fc31df3","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/package.json","hash":"3818c6a9823f00b3f62c365077764b2567bc9be0","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/nprogress.css","hash":"17ca817a091da9dcf5fe0f2f1e1f2eea60a33149","modified":1666848248687},{"_id":"public/vendors/qrcode_js@1.0.0/README.html","hash":"067c801ff5318365b2caddcf66b7afa873e504eb","modified":1666848248687},{"_id":"public/vendors/qrcode_js@1.0.0/index.html","hash":"7314a123d8a9acbd51321d4f538ba4b36b0673b5","modified":1666848248687},{"_id":"public/vendors/qrcode_js@1.0.0/index-svg.html","hash":"3c856315a2467efcd00b278c570fbc7897021d98","modified":1666848248687},{"_id":"public/vendors/qrcode_js@1.0.0/package.json","hash":"6acacb64a9f64d33725a45caedccd5ebbc09204b","modified":1666848248687},{"_id":"public/vendors/qrcode_js@1.0.0/bower.json","hash":"bfceae0aa93856efb11b7b42982f6eb47827cbc5","modified":1666848248687},{"_id":"public/vendors/aplayer@1.10.1/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1666848248687},{"_id":"public/vendors/clipboard@2.0.6/dist/clipboard.min.js","hash":"6371ec0a8e242395c7d4d008d2b98e472c9dcc52","modified":1666848248687},{"_id":"public/vendors/disqusjs@1.3.0/dist/disqusjs.css","hash":"0d8ae5946142b17f9a75683c7649cf73d6fdbe17","modified":1666848248687},{"_id":"public/vendors/disqusjs@1.3.0/dist/disqus.js","hash":"b79249dfb619836cfd1251cb3c3d5c603bc55e61","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/constants.js","hash":"08f6c79bf52239cbdd457bc0a94df395f578ee07","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/gitment.js","hash":"df37d9fe8c1a0a1fb2883e5bcb93f880bb2bbf2e","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/icons.js","hash":"d303f91799600aa8c7f5f5bb18c652fafac4359d","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/utils.js","hash":"df76ada59b1cf94a7ea1d44c56a6624d248b4228","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/layui.js","hash":"be7bcdcb4eb932f3e700e63584661f19b4139739","modified":1666848248687},{"_id":"public/vendors/meting@2.0.1/dist/Meting.min.js","hash":"f2b3d20b8bd64ccd031c64628f2b1323078ae324","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/test/component.html","hash":"5965cc7f9bb812ada1ffcd6abec39124c20a4ef8","modified":1666848248687},{"_id":"public/vendors/nprogress@0.2.0/test/test.js","hash":"5c795debb89ec7d35ba1ec1e8ccbab0a7a353d78","modified":1666848248687},{"_id":"public/vendors/valine@1.4.18/dist/detect.min.js","hash":"596d6dcbe379f78a2ec655188d7bfa7182848e03","modified":1666848248687},{"_id":"public/vendors/valine@1.4.18/dist/escape.min.js","hash":"4f91bb0e3a71ce6421b303c6c32bb3fb3e751192","modified":1666848248687},{"_id":"public/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1666848248687},{"_id":"public/vendors/@waline/client@1.6.0/dist/index.html","hash":"c720f2027fb93454bbc7eb14ae4eb274a47e8642","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/theme/default.js","hash":"449e59ac4b6b9c66384ee123e1523b5392d684a5","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/js/npm.js","hash":"e2b7590d6ec1fdac66b01fdf66ae0879f53b1262","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/layui.mobile.css","hash":"f15da6c149002dd57ea25b8346534c8161c86e3c","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/carousel.js","hash":"ff770a94f4e7edd26f4449909e3d72644de83149","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/code.css","hash":"d7adeb3ada7c3c069aa6d098f953e0a87cfb49ef","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/colorpicker.js","hash":"0234f7a6eba2238583fe4644c0a247dacd67f73b","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/code.js","hash":"31972b8e26aac0f3b1233ad76c45187a39f4d977","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/element.js","hash":"1900e7f8bca28958e0a495731c7b3957ea0157c6","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/flow.js","hash":"b6b4ffe415022a6788767906b837e2894057371b","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/form.js","hash":"6ed3220f5b8cbee7f287ca851dd5d294790281ee","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/layedit.js","hash":"ce8c049188c64ec3cd3d302f8e72d0094d85c462","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/laytpl.js","hash":"b79191723a99f3e52b56e0afbd183d7338b9cfd4","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/laypage.js","hash":"fec79457cffad05f261ab518e9d69bbebab548f0","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/rate.js","hash":"c3a4b2dad9e829afb8cfae69203eef8ede02191b","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/slider.js","hash":"c4e37a45ff9ae08f90492f894d86e7bec7542b26","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/transfer.js","hash":"e85e366ff7ca8a49d195e149ec971cb6893b8409","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/tree.js","hash":"5a0c3d9b31a49d8e30e13ef187894d9d07bec69e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/util.js","hash":"e5e39048df40763ddfff8ec271a6f8070fcb4f4e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/upload.js","hash":"8eef1ed175c49a7f09f6ce472a7d12138ed8f8ed","modified":1666848248687},{"_id":"public/vendors/valine@1.4.18/dist/plugins/emojis/index.js","hash":"452e66f0b900282eab6f98743592793361ccbc65","modified":1666848248687},{"_id":"public/vendors/valine@1.4.18/dist/plugins/emojis/light.json","hash":"6d6234de38a90d00582d3413239954bb6609e01e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/layim.css","hash":"a669bd1141c1df237631738d41f9d0032f4ba0a3","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/laydate/default/laydate.css","hash":"bc0f2f7396ca62c86bc07c2db1b73ca83de3cbdb","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/html/chatlog.html","hash":"64591e08bb5af1d22e976ba3b3175075c7e6cd12","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/html/find.html","hash":"ed8e6a3564bb52fc7adc8f19c7be34f25fe97222","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/html/getmsg.json","hash":"15f2e7c561b0de87b8e2ea84682d3bf10f41b6f2","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/html/msgbox.html","hash":"521979a7d5b54e6c00dedaa897ae547065da9b2c","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layim/mobile/layim.css","hash":"0af51b5e2280a03cefcde3e4cf6662d274cc64c6","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/modules/layer/default/layer.css","hash":"ed6fefb1501b3bcd720919f9ce55bb322b5d7ec5","modified":1666848248687},{"_id":"public/css/kratosr.min.css","hash":"e1e9a22a19f9f95ec64d2449d242eb3eb26abd46","modified":1666848248687},{"_id":"public/vendors/qrcode_js@1.0.0/qrcode.min.js","hash":"2d06c1f823f34c19981c6ae0b0eb0f5861c5e14b","modified":1666848248687},{"_id":"public/vendors/qrcode_js@1.0.0/qrcode.js","hash":"8fa3048613aab15c7f7edc3ac74a84e90375126d","modified":1666848248687},{"_id":"public/vendors/clipboard@2.0.6/dist/clipboard.js","hash":"8d661d3b6e11cb117361a6ff54cf54054b5d8668","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1666848248687},{"_id":"public/vendors/aplayer@1.10.1/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1666848248687},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.css","hash":"61d71cb30f5f34cbb1f2b5bc469784d6cb908c22","modified":1666848248687},{"_id":"public/vendors/qrcode_js@1.0.0/jquery.min.js","hash":"a8c8a5caf9765b4ccb90d708045518e219a9af5d","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1666848248687},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.js","hash":"af32f706407ab08f800c5e697cce92466e735847","modified":1666848248687},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.slim.js","hash":"77ec5d7bdb33634ff7d76837e36f0a7240c21e86","modified":1666848248687},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1666848248687},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.slim.min.js","hash":"d1c6704e94efe2d465fc161b6381e127d35acd81","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/layui.all.js","hash":"4fbff21286558e3cb817072d76ae326db4378c6e","modified":1666848248687},{"_id":"public/vendors/twikoo@1.5.11/dist/twikoo.min.js","hash":"e547de978c573d0e7beda7ad74829ce6fef6b058","modified":1666848248687},{"_id":"public/vendors/valine@1.4.18/dist/Valine.Pure.min.js","hash":"227fb19caf17f4330ac24cb952af466eeaae5c43","modified":1666848248687},{"_id":"public/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1666848248687},{"_id":"public/vendors/valine@1.4.18/dist/Valine.min.js","hash":"d081a412c63411a75a3a880ddece65335d1c3ee8","modified":1666848248687},{"_id":"public/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1666848248687},{"_id":"public/vendors/valine@1.4.18/dist/Valine.min.umd.js","hash":"90de88757741f89ad68c8d3765174437454e2303","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.css","hash":"a22e254bf086bf442a09344afe0e6cf188f5a1d5","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap-theme.min.css","hash":"fc6b4268fbd57ad95d2b41a1d4d6866f222fbdb2","modified":1666848248687},{"_id":"public/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1666848248687},{"_id":"public/vendors/@waline/client@1.6.0/dist/Waline.min.js","hash":"d9494e4919cbc017d7b0d70bb70dbcd97c35fcb1","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js","hash":"27947c0c0fa837da9bdfdfc36f649c25f54bd1c0","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/js/bootstrap.js","hash":"542cfd539f0cad650342c8cab8baf1cdbcd5fea6","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap.min.css","hash":"ed29315e0ffb3f14382431f2724235bf67f44eb3","modified":1666848248687},{"_id":"public/vendors/@waline/client@1.6.0/dist/Waline.noStyle.js","hash":"888cb555c5e9749cfe5a5a6cad2a8f56167b9dc4","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap.css","hash":"f2183455571b19311a235bd5aa204e694ade8e94","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/css/layui.css","hash":"e15327d5c8f4c82909edc97977b277207e01364d","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/layer.js","hash":"448f76fa3ccfb66a5d86b02cf785f67adf0d8033","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/laydate.js","hash":"53e871827a2c0bc04ec239e9461a5eb18a309075","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/layim.js","hash":"c79d7e577901f2ceab86f01f00cc4c26ff1b038e","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/table.js","hash":"3a18563a832e11ae642bf6c2a8634a18768f2dbb","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/mobile.js","hash":"0f82e8ce6b6deb51afdc307f488fb24c6dd02dbc","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/lay/modules/jquery.js","hash":"36456de559419079e1096890c7e9a97ae1bbf1be","modified":1666848248687},{"_id":"public/vendors/aplayer@1.10.1/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1666848248687},{"_id":"public/vendors/jquery@3.6.0/dist/jquery.min.map","hash":"c98b6a5cb27af645c8bfb525fcad3569f3917d5b","modified":1666848248687},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.min.js","hash":"564fc7c731d05fa70d71ef853a2c8cc7725739e2","modified":1666848248687},{"_id":"public/vendors/twikoo@1.5.11/dist/twikoo.all.min.js","hash":"31c6669a90a33ee5af66ceaf47996ad8fd8b962e","modified":1666848248687},{"_id":"public/images/alipay.JPG","hash":"07fb99a913ca0ba0ec32df0cacab37b75e7c3d63","modified":1666848248687},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.min.js","hash":"6bee48c26c32b90f50519f125890fcbb04779da6","modified":1666848248687},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.core.js","hash":"7952663a721317158468875349956182465b0701","modified":1666848248687},{"_id":"public/vendors/gitment@0.0.3/dist/gitment.browser.js.map","hash":"72dc603fb7be8b623d1a402419b42c36723367bb","modified":1666848248687},{"_id":"public/vendors/valine@1.4.18/dist/Valine.Pure.min.js.map","hash":"40e15912aae8beff90cbb8ae235cd6fcd36f87dc","modified":1666848248687},{"_id":"public/vendors/valine@1.4.18/dist/Valine.min.umd.js.map","hash":"6fe9ac91ca5074bcbc696f887802e8304e31aaea","modified":1666848248687},{"_id":"public/vendors/layui-src@2.5.5/dist/font/iconfont.svg","hash":"d484cee6f2461c9194b28878a1d1a677ffdbb78c","modified":1666848248687},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk-component.js","hash":"fe4c44fa48522e9b2675f3a652d83d8aaec11ad8","modified":1666848248687},{"_id":"public/vendors/valine@1.4.18/dist/Valine.min.js.map","hash":"fb6f3071e92d08b0c66808ff9cfd190a0341d93d","modified":1666848248687},{"_id":"public/vendors/bootstrap@3.3.4/dist/css/bootstrap.css.map","hash":"2e1d08a9694cd5a694eabca746cfad95fb99653e","modified":1666848248687},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.js","hash":"540a80bafeba53826127d556487541332ecd6ed1","modified":1666848248687},{"_id":"public/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1666848248687},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.js","hash":"e1f5d58724700b9cd810bb4e295ac93b6724578d","modified":1666848248687},{"_id":"public/vendors/@waline/client@1.6.0/dist/Waline.noStyle.js.map","hash":"6a31b3aabb3bb6e0e2b7640feec5500617d01950","modified":1666848248687},{"_id":"public/vendors/@waline/client@1.6.0/dist/Waline.min.js.map","hash":"42ce7c8e816ffa115df320a5eb75975291b86731","modified":1666848248687},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs","hash":"c01a600693e204abd02d0bf056a98a49e8a78d6e","modified":1666848248687},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.core.js.map","hash":"1d19d75bea55a0c0062661bb0fe5ad4135f68d8a","modified":1666848248687},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk-component.js.map","hash":"6f118aa575a5da5449d0c171f1c85fa5e43f80ff","modified":1666848248687},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.js.map","hash":"b5d129e59c5a1ca46395fbf7466432983178ebba","modified":1666848248687},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.esm.min.mjs.map","hash":"0ad921fcf8f5f79cf5fdf5deb5b4ffc21e501ff0","modified":1666848248687},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.min.js.map","hash":"bd1138557833d1ec29ce678d2f994e053f180423","modified":1666848248687},{"_id":"public/vendors/mermaid@9.1.1/dist/mermaid.js.map","hash":"199ed9c41ad0bec69a69514beb6f39f7b3a78ae5","modified":1666848248687},{"_id":"public/vendors/gitalk@1.7.2/dist/gitalk.min.js.map","hash":"6a9f6d47092f2557b346c0eabbd5907a1b12a9e7","modified":1666848248687}],"Category":[{"name":"安装文档","_id":"cl9qmes7h0002iorf04umejyt"},{"name":"博客相关","parent":"cl9qmes7h0002iorf04umejyt","_id":"cl9qmes7n000aiorf9wd1fxqr"},{"name":"学习笔记","_id":"cl9qmes7p000eiorf9pfeewj1"},{"name":"java","parent":"cl9qmes7p000eiorf9pfeewj1","_id":"cl9qmes7q000hiorfd8kt0562"}],"Data":[],"Page":[],"Post":[{"title":"Node.js安装与配置（详细步骤）","date":"2022-09-24T13:52:45.000Z","comments":1,"toc":true,"pic":null,"_content":"\n[TOC]\n\n\n\n# 一、安装Node.js\n\n## 1.下载\n\n[Node.js官网下载](http://nodejs.cn/download/)\n根据自身系统下载对应的安装包（我这里为Windows11 64位，故选择下载第一个安装包）\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/914dfb1bae004d71bab1d7cc2c01a671.png)\n\n## 2.安装\n\n双击安装包，点击Next，勾选使用许可协议，点击Next，选择安装位置（可根据个人情况更换路径，我这里选择安装在E:\\devTools\\nodejs）\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/493dfc78735841f395c4a116898f5c6f.png)\n\n继续点击Next，点击Next，点击Install，点击Finish完成安装。\n\n## 3.添加环境变量\n\n### 3.1 进入环境变量，编辑【系统变量】下的变量【Path】\n\n![选择Path变量](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d128a4fe1ce34016b08a2842cde77166.png)\n\n### 3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）\n\n![写入Node.js安装路径](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/4609bccc18d8419ea764fb0153454ca9.png)\n\n# 二、验证是否安装成功\n\n进入cmd命令行窗口，输入node -v查看nodejs版本\n\n``` \nnode -v\n```\n\n输入npm -v查看npm版本\n\n```\nnpm -v\n```\n\n\n如下图所示，即为安装成功：\n\n![验证是否安装成功](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ff513962ea164d019d3a9d542d26f0ba.png)\n\n# 三、修改模块下载位置\n\n<span style=\"color:yellow;background:red\">**此步骤修改以后npm全局下载模块的保存位置，可根据自身情况选择是否更改。**</span>\n\n## 1.查看npm默认存放位置\n\n使用npm get prefix查看npm全局模块的存放路径\n\n```\nnpm get prefix\n```\n\n\n使用npm get cache查看npm缓存默认存放路径\n\n```\nnpm get cache\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21684575b404a7f87f83572f8df3d4c.png)\n\n如上图所示，npm 全局模块存放位置以及cache的存放位置，默认是在 C 盘 “C:\\Users\\用户\\AppData” 下。\n\n## 2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e9847471a84c45ddb1fc416a223cdb55.png)\n\n## 3.修改默认文件夹\n\n设置全局模块的安装路径到 “node_global” 文件夹，\n\n```\nnpm config set prefix \"E:\\devTools\\nodejs\\node_global\"\n```\n\n设置缓存到 “node_cache” 文件夹\n\n```\nnpm config set cache \"E:\\devTools\\nodejs\\node_cache\"\n```\n\n\n如下图所示：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6e67a30770ff40c49f640007f96703d1.png)\n\n<span style =\"color:red\">**注意：**</span>由于 node 全局模块大多数都是可以通过命令行访问的，还要把【node_global】的路径“E:\\devTools\\nodejs\\node_global”加入到【系统变量 】下的【PATH】 变量中，方便直接使用命令行运行，如下图所示：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bb96741ac93447aba9e65f0a184e3d11.png)\n\n## 4.测试默认位置是否更改成功\n\n经过上面的步骤，nodejs下载的模块就会自动下载到我们自定义的目录，接下来我们测试一下是否更改成功。输入下面的命令：\n\n```\nnpm install express -g\n```\n\n或者\n\n```\nnpm install express --global\n```\n\n<span style=\"color:red\">**注意：**</span>“-g”等同于“–global”，“-g” 是全局安装，不加“-g”就是默认下载到当前目录。“-g” 表示安装到之前设置的【node_global】目录下，同时nodejs会自动地在node_global文件夹下创建【node_modules】子文件夹， 即自动下载到“E:\\devTools\\nodejs\\node_global\\node_modules” 路径下。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e05642e304a443ec85794f2ac3bad6a8.png)如上图所示，下载express模块成功，然后在文件管理器中查看是否保存到上面自定义的路径下。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d460d0cd30884a83bb175a6e6127aeca.png)可以看到，express模块已经成功地下载到【E:\\devTools\\nodejs\\node_global\\node_modules】下。\n\n<span style=\"color:red\">**注意：**</span>若执行命令npm install express -g出现如下报错：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6caaa64529e0401aa2d467a8a5ceec22.png)\n\n是由于对文件夹操作的权限不够，右击Nodejs文件夹->属性->安全，点击编辑，将所有权限都✔即可。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d1a6f84379d3443bad6af4c734e169d7.png)\n\n※执行npm install express -g仍然出错的话继续将nodejs下【node_cache】、【node_global】、【node_modules】这三个文件夹的所有权限勾选，再次执行：\n\n```\nnpm install express -g\n即可下载成功。\n```\n\n# 四、设置淘宝镜像\n\n## 1.将npm默认的registry修改为淘宝registry\n\n说明：npm 默认的 registry ,也就是下载 npm 包时会从国外的服务器下载，国内下载会很慢，一般更换为淘宝镜像：https://registry.npm.taobao.org。\n\n### 1.1 查看当前使用的镜像路径\n\n```\nnpm config get registry\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ef81e85548b74e06bc325a27a9914258.png)\n\n### 1.2 更换npm为淘宝镜像\n\n```\nnpm config set registry https://registry.npm.taobao.org/\n```\n\n### 1.3 检查镜像是否配置成功\n\n再次执行npm config get registry，检查当前的镜像路径：\n\n```\nnpm config get registry\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/5e6a5bd3b935462fb2521db2d9ea2577.png)\n\n如上图所示，npm默认的registry已修改为淘宝registry。\n\n## 2.全局安装基于淘宝源的cnpm\n\n说明：由于npm的服务器在海外，所以访问速度比较慢，访问不稳定 ，cnpm的服务器是由淘宝团队提供，服务器在国内，cnpm是npm镜像，一般会同步更新，相差在10分钟，所以cnpm在安装一些软件时候会比较有优势。但是cnpm一般只用于模块安装，在项目创建与卸载等相关操作时仍使用npm。\n\n### 2.1 全局安装基于淘宝源的cnpm\n\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/b1247b4bd75d4e128914eba35e2ed91f.png)\n\n### 2.2 本地查看cnpm模块\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d9dddf1705e84f5990b2062db823cde4.png)\n\n### 2.3 执行命令查看cnpm是否安装成功\n\n```\ncnpm -v\n```\n\n如下图所示，即代表cnpm配置成功。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/a73fe1fb625b45ef9a04765a1e46fbae.png)\n\n","source":"_posts/Node.js安装与配置（详细步骤）.md","raw":"---\ntitle: Node.js安装与配置（详细步骤）\ndate: 2022-09-24 21:52:45\ntags: 安装\ncomments: true\ntoc: true\ncategories:\n - 安装文档\npic:\n---\n\n[TOC]\n\n\n\n# 一、安装Node.js\n\n## 1.下载\n\n[Node.js官网下载](http://nodejs.cn/download/)\n根据自身系统下载对应的安装包（我这里为Windows11 64位，故选择下载第一个安装包）\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/914dfb1bae004d71bab1d7cc2c01a671.png)\n\n## 2.安装\n\n双击安装包，点击Next，勾选使用许可协议，点击Next，选择安装位置（可根据个人情况更换路径，我这里选择安装在E:\\devTools\\nodejs）\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/493dfc78735841f395c4a116898f5c6f.png)\n\n继续点击Next，点击Next，点击Install，点击Finish完成安装。\n\n## 3.添加环境变量\n\n### 3.1 进入环境变量，编辑【系统变量】下的变量【Path】\n\n![选择Path变量](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d128a4fe1ce34016b08a2842cde77166.png)\n\n### 3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）\n\n![写入Node.js安装路径](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/4609bccc18d8419ea764fb0153454ca9.png)\n\n# 二、验证是否安装成功\n\n进入cmd命令行窗口，输入node -v查看nodejs版本\n\n``` \nnode -v\n```\n\n输入npm -v查看npm版本\n\n```\nnpm -v\n```\n\n\n如下图所示，即为安装成功：\n\n![验证是否安装成功](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ff513962ea164d019d3a9d542d26f0ba.png)\n\n# 三、修改模块下载位置\n\n<span style=\"color:yellow;background:red\">**此步骤修改以后npm全局下载模块的保存位置，可根据自身情况选择是否更改。**</span>\n\n## 1.查看npm默认存放位置\n\n使用npm get prefix查看npm全局模块的存放路径\n\n```\nnpm get prefix\n```\n\n\n使用npm get cache查看npm缓存默认存放路径\n\n```\nnpm get cache\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21684575b404a7f87f83572f8df3d4c.png)\n\n如上图所示，npm 全局模块存放位置以及cache的存放位置，默认是在 C 盘 “C:\\Users\\用户\\AppData” 下。\n\n## 2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e9847471a84c45ddb1fc416a223cdb55.png)\n\n## 3.修改默认文件夹\n\n设置全局模块的安装路径到 “node_global” 文件夹，\n\n```\nnpm config set prefix \"E:\\devTools\\nodejs\\node_global\"\n```\n\n设置缓存到 “node_cache” 文件夹\n\n```\nnpm config set cache \"E:\\devTools\\nodejs\\node_cache\"\n```\n\n\n如下图所示：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6e67a30770ff40c49f640007f96703d1.png)\n\n<span style =\"color:red\">**注意：**</span>由于 node 全局模块大多数都是可以通过命令行访问的，还要把【node_global】的路径“E:\\devTools\\nodejs\\node_global”加入到【系统变量 】下的【PATH】 变量中，方便直接使用命令行运行，如下图所示：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bb96741ac93447aba9e65f0a184e3d11.png)\n\n## 4.测试默认位置是否更改成功\n\n经过上面的步骤，nodejs下载的模块就会自动下载到我们自定义的目录，接下来我们测试一下是否更改成功。输入下面的命令：\n\n```\nnpm install express -g\n```\n\n或者\n\n```\nnpm install express --global\n```\n\n<span style=\"color:red\">**注意：**</span>“-g”等同于“–global”，“-g” 是全局安装，不加“-g”就是默认下载到当前目录。“-g” 表示安装到之前设置的【node_global】目录下，同时nodejs会自动地在node_global文件夹下创建【node_modules】子文件夹， 即自动下载到“E:\\devTools\\nodejs\\node_global\\node_modules” 路径下。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e05642e304a443ec85794f2ac3bad6a8.png)如上图所示，下载express模块成功，然后在文件管理器中查看是否保存到上面自定义的路径下。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d460d0cd30884a83bb175a6e6127aeca.png)可以看到，express模块已经成功地下载到【E:\\devTools\\nodejs\\node_global\\node_modules】下。\n\n<span style=\"color:red\">**注意：**</span>若执行命令npm install express -g出现如下报错：\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6caaa64529e0401aa2d467a8a5ceec22.png)\n\n是由于对文件夹操作的权限不够，右击Nodejs文件夹->属性->安全，点击编辑，将所有权限都✔即可。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d1a6f84379d3443bad6af4c734e169d7.png)\n\n※执行npm install express -g仍然出错的话继续将nodejs下【node_cache】、【node_global】、【node_modules】这三个文件夹的所有权限勾选，再次执行：\n\n```\nnpm install express -g\n即可下载成功。\n```\n\n# 四、设置淘宝镜像\n\n## 1.将npm默认的registry修改为淘宝registry\n\n说明：npm 默认的 registry ,也就是下载 npm 包时会从国外的服务器下载，国内下载会很慢，一般更换为淘宝镜像：https://registry.npm.taobao.org。\n\n### 1.1 查看当前使用的镜像路径\n\n```\nnpm config get registry\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ef81e85548b74e06bc325a27a9914258.png)\n\n### 1.2 更换npm为淘宝镜像\n\n```\nnpm config set registry https://registry.npm.taobao.org/\n```\n\n### 1.3 检查镜像是否配置成功\n\n再次执行npm config get registry，检查当前的镜像路径：\n\n```\nnpm config get registry\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/5e6a5bd3b935462fb2521db2d9ea2577.png)\n\n如上图所示，npm默认的registry已修改为淘宝registry。\n\n## 2.全局安装基于淘宝源的cnpm\n\n说明：由于npm的服务器在海外，所以访问速度比较慢，访问不稳定 ，cnpm的服务器是由淘宝团队提供，服务器在国内，cnpm是npm镜像，一般会同步更新，相差在10分钟，所以cnpm在安装一些软件时候会比较有优势。但是cnpm一般只用于模块安装，在项目创建与卸载等相关操作时仍使用npm。\n\n### 2.1 全局安装基于淘宝源的cnpm\n\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/b1247b4bd75d4e128914eba35e2ed91f.png)\n\n### 2.2 本地查看cnpm模块\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d9dddf1705e84f5990b2062db823cde4.png)\n\n### 2.3 执行命令查看cnpm是否安装成功\n\n```\ncnpm -v\n```\n\n如下图所示，即代表cnpm配置成功。\n\n![在这里插入图片描述](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/a73fe1fb625b45ef9a04765a1e46fbae.png)\n\n","slug":"Node.js安装与配置（详细步骤）","published":1,"updated":"2022-10-13T03:15:14.282Z","layout":"post","photos":[],"link":"","_id":"cl9qmes790000iorfguxec5lk","content":"<p>[TOC]</p>\n<h1 id=\"一、安装Node-js\"><a href=\"#一、安装Node-js\" class=\"headerlink\" title=\"一、安装Node.js\"></a>一、安装Node.js</h1><h2 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h2><p><a href=\"http://nodejs.cn/download/\">Node.js官网下载</a><br>根据自身系统下载对应的安装包（我这里为Windows11 64位，故选择下载第一个安装包）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/914dfb1bae004d71bab1d7cc2c01a671.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2.安装\"></a>2.安装</h2><p>双击安装包，点击Next，勾选使用许可协议，点击Next，选择安装位置（可根据个人情况更换路径，我这里选择安装在E:\\devTools\\nodejs）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/493dfc78735841f395c4a116898f5c6f.png\" alt=\"在这里插入图片描述\"></p>\n<p>继续点击Next，点击Next，点击Install，点击Finish完成安装。</p>\n<h2 id=\"3-添加环境变量\"><a href=\"#3-添加环境变量\" class=\"headerlink\" title=\"3.添加环境变量\"></a>3.添加环境变量</h2><h3 id=\"3-1-进入环境变量，编辑【系统变量】下的变量【Path】\"><a href=\"#3-1-进入环境变量，编辑【系统变量】下的变量【Path】\" class=\"headerlink\" title=\"3.1 进入环境变量，编辑【系统变量】下的变量【Path】\"></a>3.1 进入环境变量，编辑【系统变量】下的变量【Path】</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d128a4fe1ce34016b08a2842cde77166.png\" alt=\"选择Path变量\"></p>\n<h3 id=\"3-2-添加Node-js的安装路径（此处为E-devTools-nodejs-）\"><a href=\"#3-2-添加Node-js的安装路径（此处为E-devTools-nodejs-）\" class=\"headerlink\" title=\"3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）\"></a>3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/4609bccc18d8419ea764fb0153454ca9.png\" alt=\"写入Node.js安装路径\"></p>\n<h1 id=\"二、验证是否安装成功\"><a href=\"#二、验证是否安装成功\" class=\"headerlink\" title=\"二、验证是否安装成功\"></a>二、验证是否安装成功</h1><p>进入cmd命令行窗口，输入node -v查看nodejs版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n\n<p>输入npm -v查看npm版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n\n\n<p>如下图所示，即为安装成功：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ff513962ea164d019d3a9d542d26f0ba.png\" alt=\"验证是否安装成功\"></p>\n<h1 id=\"三、修改模块下载位置\"><a href=\"#三、修改模块下载位置\" class=\"headerlink\" title=\"三、修改模块下载位置\"></a>三、修改模块下载位置</h1><p><span style=\"color:yellow;background:red\"><strong>此步骤修改以后npm全局下载模块的保存位置，可根据自身情况选择是否更改。</strong></span></p>\n<h2 id=\"1-查看npm默认存放位置\"><a href=\"#1-查看npm默认存放位置\" class=\"headerlink\" title=\"1.查看npm默认存放位置\"></a>1.查看npm默认存放位置</h2><p>使用npm get prefix查看npm全局模块的存放路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm get prefix</span><br></pre></td></tr></table></figure>\n\n\n<p>使用npm get cache查看npm缓存默认存放路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm get cache</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21684575b404a7f87f83572f8df3d4c.png\" alt=\"在这里插入图片描述\"></p>\n<p>如上图所示，npm 全局模块存放位置以及cache的存放位置，默认是在 C 盘 “C:\\Users\\用户\\AppData” 下。</p>\n<h2 id=\"2-在-nodejs-安装目录下，创建-“node-global”-和-“node-cache”-两个文件夹\"><a href=\"#2-在-nodejs-安装目录下，创建-“node-global”-和-“node-cache”-两个文件夹\" class=\"headerlink\" title=\"2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹\"></a>2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹</h2><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e9847471a84c45ddb1fc416a223cdb55.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-修改默认文件夹\"><a href=\"#3-修改默认文件夹\" class=\"headerlink\" title=\"3.修改默认文件夹\"></a>3.修改默认文件夹</h2><p>设置全局模块的安装路径到 “node_global” 文件夹，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set prefix &quot;E:\\devTools\\nodejs\\node_global&quot;</span><br></pre></td></tr></table></figure>\n\n<p>设置缓存到 “node_cache” 文件夹</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set cache &quot;E:\\devTools\\nodejs\\node_cache&quot;</span><br></pre></td></tr></table></figure>\n\n\n<p>如下图所示：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6e67a30770ff40c49f640007f96703d1.png\" alt=\"在这里插入图片描述\"></p>\n<p><span style =\"color:red\"><strong>注意：</strong></span>由于 node 全局模块大多数都是可以通过命令行访问的，还要把【node_global】的路径“E:\\devTools\\nodejs\\node_global”加入到【系统变量 】下的【PATH】 变量中，方便直接使用命令行运行，如下图所示：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bb96741ac93447aba9e65f0a184e3d11.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"4-测试默认位置是否更改成功\"><a href=\"#4-测试默认位置是否更改成功\" class=\"headerlink\" title=\"4.测试默认位置是否更改成功\"></a>4.测试默认位置是否更改成功</h2><p>经过上面的步骤，nodejs下载的模块就会自动下载到我们自定义的目录，接下来我们测试一下是否更改成功。输入下面的命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express -g</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express --global</span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color:red\"><strong>注意：</strong></span>“-g”等同于“–global”，“-g” 是全局安装，不加“-g”就是默认下载到当前目录。“-g” 表示安装到之前设置的【node_global】目录下，同时nodejs会自动地在node_global文件夹下创建【node_modules】子文件夹， 即自动下载到“E:\\devTools\\nodejs\\node_global\\node_modules” 路径下。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e05642e304a443ec85794f2ac3bad6a8.png\" alt=\"在这里插入图片描述\">如上图所示，下载express模块成功，然后在文件管理器中查看是否保存到上面自定义的路径下。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d460d0cd30884a83bb175a6e6127aeca.png\" alt=\"在这里插入图片描述\">可以看到，express模块已经成功地下载到【E:\\devTools\\nodejs\\node_global\\node_modules】下。</p>\n<p><span style=\"color:red\"><strong>注意：</strong></span>若执行命令npm install express -g出现如下报错：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6caaa64529e0401aa2d467a8a5ceec22.png\" alt=\"在这里插入图片描述\"></p>\n<p>是由于对文件夹操作的权限不够，右击Nodejs文件夹-&gt;属性-&gt;安全，点击编辑，将所有权限都✔即可。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d1a6f84379d3443bad6af4c734e169d7.png\" alt=\"在这里插入图片描述\"></p>\n<p>※执行npm install express -g仍然出错的话继续将nodejs下【node_cache】、【node_global】、【node_modules】这三个文件夹的所有权限勾选，再次执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express -g</span><br><span class=\"line\">即可下载成功。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、设置淘宝镜像\"><a href=\"#四、设置淘宝镜像\" class=\"headerlink\" title=\"四、设置淘宝镜像\"></a>四、设置淘宝镜像</h1><h2 id=\"1-将npm默认的registry修改为淘宝registry\"><a href=\"#1-将npm默认的registry修改为淘宝registry\" class=\"headerlink\" title=\"1.将npm默认的registry修改为淘宝registry\"></a>1.将npm默认的registry修改为淘宝registry</h2><p>说明：npm 默认的 registry ,也就是下载 npm 包时会从国外的服务器下载，国内下载会很慢，一般更换为淘宝镜像：<a href=\"https://registry.npm.taobao.org./\">https://registry.npm.taobao.org。</a></p>\n<h3 id=\"1-1-查看当前使用的镜像路径\"><a href=\"#1-1-查看当前使用的镜像路径\" class=\"headerlink\" title=\"1.1 查看当前使用的镜像路径\"></a>1.1 查看当前使用的镜像路径</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ef81e85548b74e06bc325a27a9914258.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"1-2-更换npm为淘宝镜像\"><a href=\"#1-2-更换npm为淘宝镜像\" class=\"headerlink\" title=\"1.2 更换npm为淘宝镜像\"></a>1.2 更换npm为淘宝镜像</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-检查镜像是否配置成功\"><a href=\"#1-3-检查镜像是否配置成功\" class=\"headerlink\" title=\"1.3 检查镜像是否配置成功\"></a>1.3 检查镜像是否配置成功</h3><p>再次执行npm config get registry，检查当前的镜像路径：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/5e6a5bd3b935462fb2521db2d9ea2577.png\" alt=\"在这里插入图片描述\"></p>\n<p>如上图所示，npm默认的registry已修改为淘宝registry。</p>\n<h2 id=\"2-全局安装基于淘宝源的cnpm\"><a href=\"#2-全局安装基于淘宝源的cnpm\" class=\"headerlink\" title=\"2.全局安装基于淘宝源的cnpm\"></a>2.全局安装基于淘宝源的cnpm</h2><p>说明：由于npm的服务器在海外，所以访问速度比较慢，访问不稳定 ，cnpm的服务器是由淘宝团队提供，服务器在国内，cnpm是npm镜像，一般会同步更新，相差在10分钟，所以cnpm在安装一些软件时候会比较有优势。但是cnpm一般只用于模块安装，在项目创建与卸载等相关操作时仍使用npm。</p>\n<h3 id=\"2-1-全局安装基于淘宝源的cnpm\"><a href=\"#2-1-全局安装基于淘宝源的cnpm\" class=\"headerlink\" title=\"2.1 全局安装基于淘宝源的cnpm\"></a>2.1 全局安装基于淘宝源的cnpm</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/b1247b4bd75d4e128914eba35e2ed91f.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-2-本地查看cnpm模块\"><a href=\"#2-2-本地查看cnpm模块\" class=\"headerlink\" title=\"2.2 本地查看cnpm模块\"></a>2.2 本地查看cnpm模块</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d9dddf1705e84f5990b2062db823cde4.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-3-执行命令查看cnpm是否安装成功\"><a href=\"#2-3-执行命令查看cnpm是否安装成功\" class=\"headerlink\" title=\"2.3 执行命令查看cnpm是否安装成功\"></a>2.3 执行命令查看cnpm是否安装成功</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm -v</span><br></pre></td></tr></table></figure>\n\n<p>如下图所示，即代表cnpm配置成功。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/a73fe1fb625b45ef9a04765a1e46fbae.png\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"一、安装Node-js\"><a href=\"#一、安装Node-js\" class=\"headerlink\" title=\"一、安装Node.js\"></a>一、安装Node.js</h1><h2 id=\"1-下载\"><a href=\"#1-下载\" class=\"headerlink\" title=\"1.下载\"></a>1.下载</h2><p><a href=\"http://nodejs.cn/download/\">Node.js官网下载</a><br>根据自身系统下载对应的安装包（我这里为Windows11 64位，故选择下载第一个安装包）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/914dfb1bae004d71bab1d7cc2c01a671.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-安装\"><a href=\"#2-安装\" class=\"headerlink\" title=\"2.安装\"></a>2.安装</h2><p>双击安装包，点击Next，勾选使用许可协议，点击Next，选择安装位置（可根据个人情况更换路径，我这里选择安装在E:\\devTools\\nodejs）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/493dfc78735841f395c4a116898f5c6f.png\" alt=\"在这里插入图片描述\"></p>\n<p>继续点击Next，点击Next，点击Install，点击Finish完成安装。</p>\n<h2 id=\"3-添加环境变量\"><a href=\"#3-添加环境变量\" class=\"headerlink\" title=\"3.添加环境变量\"></a>3.添加环境变量</h2><h3 id=\"3-1-进入环境变量，编辑【系统变量】下的变量【Path】\"><a href=\"#3-1-进入环境变量，编辑【系统变量】下的变量【Path】\" class=\"headerlink\" title=\"3.1 进入环境变量，编辑【系统变量】下的变量【Path】\"></a>3.1 进入环境变量，编辑【系统变量】下的变量【Path】</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d128a4fe1ce34016b08a2842cde77166.png\" alt=\"选择Path变量\"></p>\n<h3 id=\"3-2-添加Node-js的安装路径（此处为E-devTools-nodejs-）\"><a href=\"#3-2-添加Node-js的安装路径（此处为E-devTools-nodejs-）\" class=\"headerlink\" title=\"3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）\"></a>3.2 添加Node.js的安装路径（此处为E:\\devTools\\nodejs\\）</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/4609bccc18d8419ea764fb0153454ca9.png\" alt=\"写入Node.js安装路径\"></p>\n<h1 id=\"二、验证是否安装成功\"><a href=\"#二、验证是否安装成功\" class=\"headerlink\" title=\"二、验证是否安装成功\"></a>二、验证是否安装成功</h1><p>进入cmd命令行窗口，输入node -v查看nodejs版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br></pre></td></tr></table></figure>\n\n<p>输入npm -v查看npm版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n\n\n<p>如下图所示，即为安装成功：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ff513962ea164d019d3a9d542d26f0ba.png\" alt=\"验证是否安装成功\"></p>\n<h1 id=\"三、修改模块下载位置\"><a href=\"#三、修改模块下载位置\" class=\"headerlink\" title=\"三、修改模块下载位置\"></a>三、修改模块下载位置</h1><p><span style=\"color:yellow;background:red\"><strong>此步骤修改以后npm全局下载模块的保存位置，可根据自身情况选择是否更改。</strong></span></p>\n<h2 id=\"1-查看npm默认存放位置\"><a href=\"#1-查看npm默认存放位置\" class=\"headerlink\" title=\"1.查看npm默认存放位置\"></a>1.查看npm默认存放位置</h2><p>使用npm get prefix查看npm全局模块的存放路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm get prefix</span><br></pre></td></tr></table></figure>\n\n\n<p>使用npm get cache查看npm缓存默认存放路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm get cache</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21684575b404a7f87f83572f8df3d4c.png\" alt=\"在这里插入图片描述\"></p>\n<p>如上图所示，npm 全局模块存放位置以及cache的存放位置，默认是在 C 盘 “C:\\Users\\用户\\AppData” 下。</p>\n<h2 id=\"2-在-nodejs-安装目录下，创建-“node-global”-和-“node-cache”-两个文件夹\"><a href=\"#2-在-nodejs-安装目录下，创建-“node-global”-和-“node-cache”-两个文件夹\" class=\"headerlink\" title=\"2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹\"></a>2.在 nodejs 安装目录下，创建 “node_global” 和 “node_cache” 两个文件夹</h2><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e9847471a84c45ddb1fc416a223cdb55.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"3-修改默认文件夹\"><a href=\"#3-修改默认文件夹\" class=\"headerlink\" title=\"3.修改默认文件夹\"></a>3.修改默认文件夹</h2><p>设置全局模块的安装路径到 “node_global” 文件夹，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set prefix &quot;E:\\devTools\\nodejs\\node_global&quot;</span><br></pre></td></tr></table></figure>\n\n<p>设置缓存到 “node_cache” 文件夹</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set cache &quot;E:\\devTools\\nodejs\\node_cache&quot;</span><br></pre></td></tr></table></figure>\n\n\n<p>如下图所示：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6e67a30770ff40c49f640007f96703d1.png\" alt=\"在这里插入图片描述\"></p>\n<p><span style =\"color:red\"><strong>注意：</strong></span>由于 node 全局模块大多数都是可以通过命令行访问的，还要把【node_global】的路径“E:\\devTools\\nodejs\\node_global”加入到【系统变量 】下的【PATH】 变量中，方便直接使用命令行运行，如下图所示：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bb96741ac93447aba9e65f0a184e3d11.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"4-测试默认位置是否更改成功\"><a href=\"#4-测试默认位置是否更改成功\" class=\"headerlink\" title=\"4.测试默认位置是否更改成功\"></a>4.测试默认位置是否更改成功</h2><p>经过上面的步骤，nodejs下载的模块就会自动下载到我们自定义的目录，接下来我们测试一下是否更改成功。输入下面的命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express -g</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express --global</span><br></pre></td></tr></table></figure>\n\n<p><span style=\"color:red\"><strong>注意：</strong></span>“-g”等同于“–global”，“-g” 是全局安装，不加“-g”就是默认下载到当前目录。“-g” 表示安装到之前设置的【node_global】目录下，同时nodejs会自动地在node_global文件夹下创建【node_modules】子文件夹， 即自动下载到“E:\\devTools\\nodejs\\node_global\\node_modules” 路径下。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e05642e304a443ec85794f2ac3bad6a8.png\" alt=\"在这里插入图片描述\">如上图所示，下载express模块成功，然后在文件管理器中查看是否保存到上面自定义的路径下。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d460d0cd30884a83bb175a6e6127aeca.png\" alt=\"在这里插入图片描述\">可以看到，express模块已经成功地下载到【E:\\devTools\\nodejs\\node_global\\node_modules】下。</p>\n<p><span style=\"color:red\"><strong>注意：</strong></span>若执行命令npm install express -g出现如下报错：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/6caaa64529e0401aa2d467a8a5ceec22.png\" alt=\"在这里插入图片描述\"></p>\n<p>是由于对文件夹操作的权限不够，右击Nodejs文件夹-&gt;属性-&gt;安全，点击编辑，将所有权限都✔即可。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d1a6f84379d3443bad6af4c734e169d7.png\" alt=\"在这里插入图片描述\"></p>\n<p>※执行npm install express -g仍然出错的话继续将nodejs下【node_cache】、【node_global】、【node_modules】这三个文件夹的所有权限勾选，再次执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express -g</span><br><span class=\"line\">即可下载成功。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、设置淘宝镜像\"><a href=\"#四、设置淘宝镜像\" class=\"headerlink\" title=\"四、设置淘宝镜像\"></a>四、设置淘宝镜像</h1><h2 id=\"1-将npm默认的registry修改为淘宝registry\"><a href=\"#1-将npm默认的registry修改为淘宝registry\" class=\"headerlink\" title=\"1.将npm默认的registry修改为淘宝registry\"></a>1.将npm默认的registry修改为淘宝registry</h2><p>说明：npm 默认的 registry ,也就是下载 npm 包时会从国外的服务器下载，国内下载会很慢，一般更换为淘宝镜像：<a href=\"https://registry.npm.taobao.org./\">https://registry.npm.taobao.org。</a></p>\n<h3 id=\"1-1-查看当前使用的镜像路径\"><a href=\"#1-1-查看当前使用的镜像路径\" class=\"headerlink\" title=\"1.1 查看当前使用的镜像路径\"></a>1.1 查看当前使用的镜像路径</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/ef81e85548b74e06bc325a27a9914258.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"1-2-更换npm为淘宝镜像\"><a href=\"#1-2-更换npm为淘宝镜像\" class=\"headerlink\" title=\"1.2 更换npm为淘宝镜像\"></a>1.2 更换npm为淘宝镜像</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-检查镜像是否配置成功\"><a href=\"#1-3-检查镜像是否配置成功\" class=\"headerlink\" title=\"1.3 检查镜像是否配置成功\"></a>1.3 检查镜像是否配置成功</h3><p>再次执行npm config get registry，检查当前的镜像路径：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/5e6a5bd3b935462fb2521db2d9ea2577.png\" alt=\"在这里插入图片描述\"></p>\n<p>如上图所示，npm默认的registry已修改为淘宝registry。</p>\n<h2 id=\"2-全局安装基于淘宝源的cnpm\"><a href=\"#2-全局安装基于淘宝源的cnpm\" class=\"headerlink\" title=\"2.全局安装基于淘宝源的cnpm\"></a>2.全局安装基于淘宝源的cnpm</h2><p>说明：由于npm的服务器在海外，所以访问速度比较慢，访问不稳定 ，cnpm的服务器是由淘宝团队提供，服务器在国内，cnpm是npm镜像，一般会同步更新，相差在10分钟，所以cnpm在安装一些软件时候会比较有优势。但是cnpm一般只用于模块安装，在项目创建与卸载等相关操作时仍使用npm。</p>\n<h3 id=\"2-1-全局安装基于淘宝源的cnpm\"><a href=\"#2-1-全局安装基于淘宝源的cnpm\" class=\"headerlink\" title=\"2.1 全局安装基于淘宝源的cnpm\"></a>2.1 全局安装基于淘宝源的cnpm</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/b1247b4bd75d4e128914eba35e2ed91f.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-2-本地查看cnpm模块\"><a href=\"#2-2-本地查看cnpm模块\" class=\"headerlink\" title=\"2.2 本地查看cnpm模块\"></a>2.2 本地查看cnpm模块</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d9dddf1705e84f5990b2062db823cde4.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-3-执行命令查看cnpm是否安装成功\"><a href=\"#2-3-执行命令查看cnpm是否安装成功\" class=\"headerlink\" title=\"2.3 执行命令查看cnpm是否安装成功\"></a>2.3 执行命令查看cnpm是否安装成功</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cnpm -v</span><br></pre></td></tr></table></figure>\n\n<p>如下图所示，即代表cnpm配置成功。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/a73fe1fb625b45ef9a04765a1e46fbae.png\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-10-13T03:15:14.282Z","updated":"2022-10-13T03:15:14.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl9qmes7f0001iorfdmb9btab","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"hexo+github搭建博客","date":"2022-09-24T13:52:45.000Z","cover":"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png","comments":1,"toc":true,"pic":null,"_content":"\n[TOC]\n\n\n\n# 环境准备\n\n## 1、安装nodejs\n\n直接到官网上下载安装即可https://nodejs.org/en/download/\n\n- [Node.js](http://nodejs.org/) (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- Node自带npm\n\n详细安装配置\n\nnodejs配置\n\n\n\n## 2、安装git\n\nWindows：下载并安装 git.\nMac：使用 Homebrew, MacPorts 或者下载 安装程序。\nLinux (Ubuntu, Debian)：sudo apt-get install git-core\nLinux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n\n![img](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png)\n\nnpm下载慢的话也可以下载淘宝下载源cnpm\n\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n![img](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21b605afbc75a0e08824e062dae3ea4.png)\n\n# 开始安装Hexo\n\n## 1.安装hexo\n\n```\nnpm install -g hexo-cli\n或者\ncnpm install -g hexo-cli\n123\n```\n\n安装完成可输入hexo -v查看版本\n\n![image-20211203164700035](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bba538484708b3e30f14af8557501c3c.png)\n\n## 2、初始化hexo，新建存储博客的文件夹\n\n```\nhexo init myblog（本地文件夹名称：可自定义）\n```\n\n![image-20211203165005655](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d01a6881209137448e5385dd3534097d.png)\n\n## 3、进入文件夹，安装一下npm\n\n```\ncd myblog\nnpm install\n```\n\n可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了\n\n![iShot2021-12-03 16.55.54](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bcf516435e0c18ccdd4bb12f2fe04e2a.png)\n\n## 4、启动服务站点\n\n```\nhexo g \nhexo server\n```\n\n![image-20211203165829687](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/af32bf9e9c204c69d873df7c3437c3a4.png)\n\n访问http://localhost:4000/ 至此hero就搭建好了。可以在本地访问了\n\n![20211203170208](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/3a611caeb2993779a773aaad9864d493.png)\n\n# 将hexo博客站点上传到github上\n\n## 1、新建guthub仓库\n\n仓库名称限制了为你的：用户名+.github.io\n\n![image-20211203213307819](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d2560d7f2d59f5f9b587a34cd2819307.png)\n\n## 2、安装hexo上传插件\n\n这里需要安装一个hexo的上传插件deploy-git\n\n```\nnpm install hexo-deployer-git --save\n```\n\n![image-20211203171157254](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/49d71ebd13729dd4acb6f52cb5b07b70.png)\n\n## 3、修改hexo配置文件指定仓库路径\n\n可在文件夹中直接打开文件，也可通过vim直接编辑\n\n![image-20211203213606004](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/57b7452a5399f57b0e3ef2ef1a5d8271.png)\n\n## 4、推送站点到github\n\n```\n推送命令\nhexo d\n```\n\n\n\n# 注意事项\n\n推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现下图：鉴权失败（用户名密码错误）\n\n\n\n# hexo文件夹详解：\n\n* node_modules：是依赖包\n*  public：存放的是生成的页面\n*  scaffolds：命令生成文章等的模板\n*  source：用命令创建的各种文章\n*  themes：主题\n*  _config.yml：整个博客的配置\n*  db.json：source解析所得到的\n*  package.json：项目所需模块项目的配置信息\n\n","source":"_posts/hexo+github搭建博客.md","raw":"---\ntitle: hexo+github搭建博客\ndate: 2022-09-24 21:52:45\ncover: https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png\ntags: 安装\ncomments: true\ntoc: true\ncategories:\n - 安装文档\n - 博客相关\npic:\n---\n\n[TOC]\n\n\n\n# 环境准备\n\n## 1、安装nodejs\n\n直接到官网上下载安装即可https://nodejs.org/en/download/\n\n- [Node.js](http://nodejs.org/) (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- Node自带npm\n\n详细安装配置\n\nnodejs配置\n\n\n\n## 2、安装git\n\nWindows：下载并安装 git.\nMac：使用 Homebrew, MacPorts 或者下载 安装程序。\nLinux (Ubuntu, Debian)：sudo apt-get install git-core\nLinux (Fedora, Red Hat, CentOS)：sudo yum install git-core\n\n![img](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png)\n\nnpm下载慢的话也可以下载淘宝下载源cnpm\n\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n\n![img](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21b605afbc75a0e08824e062dae3ea4.png)\n\n# 开始安装Hexo\n\n## 1.安装hexo\n\n```\nnpm install -g hexo-cli\n或者\ncnpm install -g hexo-cli\n123\n```\n\n安装完成可输入hexo -v查看版本\n\n![image-20211203164700035](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bba538484708b3e30f14af8557501c3c.png)\n\n## 2、初始化hexo，新建存储博客的文件夹\n\n```\nhexo init myblog（本地文件夹名称：可自定义）\n```\n\n![image-20211203165005655](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d01a6881209137448e5385dd3534097d.png)\n\n## 3、进入文件夹，安装一下npm\n\n```\ncd myblog\nnpm install\n```\n\n可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了\n\n![iShot2021-12-03 16.55.54](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bcf516435e0c18ccdd4bb12f2fe04e2a.png)\n\n## 4、启动服务站点\n\n```\nhexo g \nhexo server\n```\n\n![image-20211203165829687](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/af32bf9e9c204c69d873df7c3437c3a4.png)\n\n访问http://localhost:4000/ 至此hero就搭建好了。可以在本地访问了\n\n![20211203170208](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/3a611caeb2993779a773aaad9864d493.png)\n\n# 将hexo博客站点上传到github上\n\n## 1、新建guthub仓库\n\n仓库名称限制了为你的：用户名+.github.io\n\n![image-20211203213307819](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d2560d7f2d59f5f9b587a34cd2819307.png)\n\n## 2、安装hexo上传插件\n\n这里需要安装一个hexo的上传插件deploy-git\n\n```\nnpm install hexo-deployer-git --save\n```\n\n![image-20211203171157254](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/49d71ebd13729dd4acb6f52cb5b07b70.png)\n\n## 3、修改hexo配置文件指定仓库路径\n\n可在文件夹中直接打开文件，也可通过vim直接编辑\n\n![image-20211203213606004](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/57b7452a5399f57b0e3ef2ef1a5d8271.png)\n\n## 4、推送站点到github\n\n```\n推送命令\nhexo d\n```\n\n\n\n# 注意事项\n\n推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现下图：鉴权失败（用户名密码错误）\n\n\n\n# hexo文件夹详解：\n\n* node_modules：是依赖包\n*  public：存放的是生成的页面\n*  scaffolds：命令生成文章等的模板\n*  source：用命令创建的各种文章\n*  themes：主题\n*  _config.yml：整个博客的配置\n*  db.json：source解析所得到的\n*  package.json：项目所需模块项目的配置信息\n\n","slug":"hexo+github搭建博客","published":1,"updated":"2022-10-13T03:15:14.283Z","layout":"post","photos":[],"link":"","_id":"cl9qmes7j0004iorf71th1l8o","content":"<p>[TOC]</p>\n<h1 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h1><h2 id=\"1、安装nodejs\"><a href=\"#1、安装nodejs\" class=\"headerlink\" title=\"1、安装nodejs\"></a>1、安装nodejs</h2><p>直接到官网上下载安装即可<a href=\"https://nodejs.org/en/download/\">https://nodejs.org/en/download/</a></p>\n<ul>\n<li><a href=\"http://nodejs.org/\">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>\n<li>Node自带npm</li>\n</ul>\n<p>详细安装配置</p>\n<p>nodejs配置</p>\n<h2 id=\"2、安装git\"><a href=\"#2、安装git\" class=\"headerlink\" title=\"2、安装git\"></a>2、安装git</h2><p>Windows：下载并安装 git.<br>Mac：使用 Homebrew, MacPorts 或者下载 安装程序。<br>Linux (Ubuntu, Debian)：sudo apt-get install git-core<br>Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png\" alt=\"img\"></p>\n<p>npm下载慢的话也可以下载淘宝下载源cnpm</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21b605afbc75a0e08824e062dae3ea4.png\" alt=\"img\"></p>\n<h1 id=\"开始安装Hexo\"><a href=\"#开始安装Hexo\" class=\"headerlink\" title=\"开始安装Hexo\"></a>开始安装Hexo</h1><h2 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1.安装hexo\"></a>1.安装hexo</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\">或者</span><br><span class=\"line\">cnpm install -g hexo-cli</span><br><span class=\"line\">123</span><br></pre></td></tr></table></figure>\n\n<p>安装完成可输入hexo -v查看版本</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bba538484708b3e30f14af8557501c3c.png\" alt=\"image-20211203164700035\"></p>\n<h2 id=\"2、初始化hexo，新建存储博客的文件夹\"><a href=\"#2、初始化hexo，新建存储博客的文件夹\" class=\"headerlink\" title=\"2、初始化hexo，新建存储博客的文件夹\"></a>2、初始化hexo，新建存储博客的文件夹</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init myblog（本地文件夹名称：可自定义）</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d01a6881209137448e5385dd3534097d.png\" alt=\"image-20211203165005655\"></p>\n<h2 id=\"3、进入文件夹，安装一下npm\"><a href=\"#3、进入文件夹，安装一下npm\" class=\"headerlink\" title=\"3、进入文件夹，安装一下npm\"></a>3、进入文件夹，安装一下npm</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myblog</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bcf516435e0c18ccdd4bb12f2fe04e2a.png\" alt=\"iShot2021-12-03 16.55.54\"></p>\n<h2 id=\"4、启动服务站点\"><a href=\"#4、启动服务站点\" class=\"headerlink\" title=\"4、启动服务站点\"></a>4、启动服务站点</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g </span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/af32bf9e9c204c69d873df7c3437c3a4.png\" alt=\"image-20211203165829687\"></p>\n<p>访问<a href=\"http://localhost:4000/\">http://localhost:4000/</a> 至此hero就搭建好了。可以在本地访问了</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/3a611caeb2993779a773aaad9864d493.png\" alt=\"20211203170208\"></p>\n<h1 id=\"将hexo博客站点上传到github上\"><a href=\"#将hexo博客站点上传到github上\" class=\"headerlink\" title=\"将hexo博客站点上传到github上\"></a>将hexo博客站点上传到github上</h1><h2 id=\"1、新建guthub仓库\"><a href=\"#1、新建guthub仓库\" class=\"headerlink\" title=\"1、新建guthub仓库\"></a>1、新建guthub仓库</h2><p>仓库名称限制了为你的：用户名+.github.io</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d2560d7f2d59f5f9b587a34cd2819307.png\" alt=\"image-20211203213307819\"></p>\n<h2 id=\"2、安装hexo上传插件\"><a href=\"#2、安装hexo上传插件\" class=\"headerlink\" title=\"2、安装hexo上传插件\"></a>2、安装hexo上传插件</h2><p>这里需要安装一个hexo的上传插件deploy-git</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/49d71ebd13729dd4acb6f52cb5b07b70.png\" alt=\"image-20211203171157254\"></p>\n<h2 id=\"3、修改hexo配置文件指定仓库路径\"><a href=\"#3、修改hexo配置文件指定仓库路径\" class=\"headerlink\" title=\"3、修改hexo配置文件指定仓库路径\"></a>3、修改hexo配置文件指定仓库路径</h2><p>可在文件夹中直接打开文件，也可通过vim直接编辑</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/57b7452a5399f57b0e3ef2ef1a5d8271.png\" alt=\"image-20211203213606004\"></p>\n<h2 id=\"4、推送站点到github\"><a href=\"#4、推送站点到github\" class=\"headerlink\" title=\"4、推送站点到github\"></a>4、推送站点到github</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推送命令</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p>推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现下图：鉴权失败（用户名密码错误）</p>\n<h1 id=\"hexo文件夹详解：\"><a href=\"#hexo文件夹详解：\" class=\"headerlink\" title=\"hexo文件夹详解：\"></a>hexo文件夹详解：</h1><ul>\n<li>node_modules：是依赖包</li>\n<li>public：存放的是生成的页面</li>\n<li>scaffolds：命令生成文章等的模板</li>\n<li>source：用命令创建的各种文章</li>\n<li>themes：主题</li>\n<li>_config.yml：整个博客的配置</li>\n<li>db.json：source解析所得到的</li>\n<li>package.json：项目所需模块项目的配置信息</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h1><h2 id=\"1、安装nodejs\"><a href=\"#1、安装nodejs\" class=\"headerlink\" title=\"1、安装nodejs\"></a>1、安装nodejs</h2><p>直接到官网上下载安装即可<a href=\"https://nodejs.org/en/download/\">https://nodejs.org/en/download/</a></p>\n<ul>\n<li><a href=\"http://nodejs.org/\">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>\n<li>Node自带npm</li>\n</ul>\n<p>详细安装配置</p>\n<p>nodejs配置</p>\n<h2 id=\"2、安装git\"><a href=\"#2、安装git\" class=\"headerlink\" title=\"2、安装git\"></a>2、安装git</h2><p>Windows：下载并安装 git.<br>Mac：使用 Homebrew, MacPorts 或者下载 安装程序。<br>Linux (Ubuntu, Debian)：sudo apt-get install git-core<br>Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/343d28b9c9178b0b857abee140a668b1.png\" alt=\"img\"></p>\n<p>npm下载慢的话也可以下载淘宝下载源cnpm</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/e21b605afbc75a0e08824e062dae3ea4.png\" alt=\"img\"></p>\n<h1 id=\"开始安装Hexo\"><a href=\"#开始安装Hexo\" class=\"headerlink\" title=\"开始安装Hexo\"></a>开始安装Hexo</h1><h2 id=\"1-安装hexo\"><a href=\"#1-安装hexo\" class=\"headerlink\" title=\"1.安装hexo\"></a>1.安装hexo</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\">或者</span><br><span class=\"line\">cnpm install -g hexo-cli</span><br><span class=\"line\">123</span><br></pre></td></tr></table></figure>\n\n<p>安装完成可输入hexo -v查看版本</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bba538484708b3e30f14af8557501c3c.png\" alt=\"image-20211203164700035\"></p>\n<h2 id=\"2、初始化hexo，新建存储博客的文件夹\"><a href=\"#2、初始化hexo，新建存储博客的文件夹\" class=\"headerlink\" title=\"2、初始化hexo，新建存储博客的文件夹\"></a>2、初始化hexo，新建存储博客的文件夹</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init myblog（本地文件夹名称：可自定义）</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d01a6881209137448e5385dd3534097d.png\" alt=\"image-20211203165005655\"></p>\n<h2 id=\"3、进入文件夹，安装一下npm\"><a href=\"#3、进入文件夹，安装一下npm\" class=\"headerlink\" title=\"3、进入文件夹，安装一下npm\"></a>3、进入文件夹，安装一下npm</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd myblog</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/bcf516435e0c18ccdd4bb12f2fe04e2a.png\" alt=\"iShot2021-12-03 16.55.54\"></p>\n<h2 id=\"4、启动服务站点\"><a href=\"#4、启动服务站点\" class=\"headerlink\" title=\"4、启动服务站点\"></a>4、启动服务站点</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g </span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/af32bf9e9c204c69d873df7c3437c3a4.png\" alt=\"image-20211203165829687\"></p>\n<p>访问<a href=\"http://localhost:4000/\">http://localhost:4000/</a> 至此hero就搭建好了。可以在本地访问了</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/3a611caeb2993779a773aaad9864d493.png\" alt=\"20211203170208\"></p>\n<h1 id=\"将hexo博客站点上传到github上\"><a href=\"#将hexo博客站点上传到github上\" class=\"headerlink\" title=\"将hexo博客站点上传到github上\"></a>将hexo博客站点上传到github上</h1><h2 id=\"1、新建guthub仓库\"><a href=\"#1、新建guthub仓库\" class=\"headerlink\" title=\"1、新建guthub仓库\"></a>1、新建guthub仓库</h2><p>仓库名称限制了为你的：用户名+.github.io</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/d2560d7f2d59f5f9b587a34cd2819307.png\" alt=\"image-20211203213307819\"></p>\n<h2 id=\"2、安装hexo上传插件\"><a href=\"#2、安装hexo上传插件\" class=\"headerlink\" title=\"2、安装hexo上传插件\"></a>2、安装hexo上传插件</h2><p>这里需要安装一个hexo的上传插件deploy-git</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/49d71ebd13729dd4acb6f52cb5b07b70.png\" alt=\"image-20211203171157254\"></p>\n<h2 id=\"3、修改hexo配置文件指定仓库路径\"><a href=\"#3、修改hexo配置文件指定仓库路径\" class=\"headerlink\" title=\"3、修改hexo配置文件指定仓库路径\"></a>3、修改hexo配置文件指定仓库路径</h2><p>可在文件夹中直接打开文件，也可通过vim直接编辑</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/57b7452a5399f57b0e3ef2ef1a5d8271.png\" alt=\"image-20211203213606004\"></p>\n<h2 id=\"4、推送站点到github\"><a href=\"#4、推送站点到github\" class=\"headerlink\" title=\"4、推送站点到github\"></a>4、推送站点到github</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">推送命令</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><p>推送过程中需要输入你的github用户名和密码。但是在2021年8月14日开始github官方就加强安全访问。不能通过原有账号密码git访问，密码需要用官方的token或者采用ssh公私钥访问。否则会出现下图：鉴权失败（用户名密码错误）</p>\n<h1 id=\"hexo文件夹详解：\"><a href=\"#hexo文件夹详解：\" class=\"headerlink\" title=\"hexo文件夹详解：\"></a>hexo文件夹详解：</h1><ul>\n<li>node_modules：是依赖包</li>\n<li>public：存放的是生成的页面</li>\n<li>scaffolds：命令生成文章等的模板</li>\n<li>source：用命令创建的各种文章</li>\n<li>themes：主题</li>\n<li>_config.yml：整个博客的配置</li>\n<li>db.json：source解析所得到的</li>\n<li>package.json：项目所需模块项目的配置信息</li>\n</ul>\n"},{"title":"java基础笔记","comments":1,"toc":true,"date":"2022-10-27T04:40:00.000Z","pic":null,"_content":"\n[TOC]\n\n\n\n#   java基础\n\n这是快速复习java基础的笔记\n\n## 重要编程思想\n\n**化繁为简**：现将复杂的功能转变成简单的需求。\n\n先死后活：有限考虑固定的值，再考虑变量。\n\n\n\n\n\n\n\n# java概述\n\n知识点：\n\n## [快速练习](##快速入门部分)\n\n1. 使用黑窗口编译.java文件时，注意要把需要编译的java文件编码设置与cmd黑窗口编码相同\n\n2. ```java\n   javac hello.java //编译指令\t\t\t\n   ```\n\n3. ```java\n   java hello //运行指令\t\n   //注意不要带文件后缀，否则报错\n   ```\n\n4. java执行流程分析\n\n   1. ![image-20220204113338135](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204113338135.png)\n\n## [制表符](##制表符部分)\n\n1. ```\n   \\t 一个制表位，实现对其功能\n   \\n 换行符，\n   \\\\ 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠\n   \\\t\\将\"\"：号输出显示出来，在前面添加\\\" \\\" 也可转义其他符号例如'\n   // \\r 表示一个回车 例如：System.out.println(\"韩顺平教育\\r北京\");\n   \t\t// 执行步骤：\n   \t\t// \t1. 先输出韩顺平教育\n   \t\t//  2. 执行回车后，相当于光标来到了最开头\n   \t\t//  3. 再输出北京\n   \t\t//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了\n           可以加个\\n换行防止覆盖\n   \n   ```\n\n2. ````java\n   class ChangeChar{\n   \tpublic static void main(String[] args){\n   \t\t// \\t 一个制表位，实现对其功能\n   \t\tSystem.out.println(\"beijing\\tshanghai\\tguangzhou\");\n   \t\t// \\n换行\n   \t\tSystem.out.println(\"jack\\nlisa\\nnino\");\n   \t\t// \\\\ 输出一个斜杠\\ \n   \t\t// 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠\n   \t\tSystem.out.println(\"c\\\\a\\\\v\\\\b.exe\");\n   \t\t// \\将\"\"：号输出显示出来，在前面添加\\\" \\\"\n   \t\tSystem.out.println(\"老王说：\\\"hello\\\"\");\n   \t\t// \\r 表示一个回车 System.out.println(\"韩顺平教育\\r北京\");\n   \t\t// 执行步骤：\n   \t\t// \t1. 先输出韩顺平教育\n   \t\t//  2. 执行回车后，相当于光标来到了最开头\n   \t\t//  3. 再输出北京\n   \t\t//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了\n   \t\tSystem.out.println(\"韩顺平教育\\r\\n北京\");\n   \n   \t}\n   }\n   ````\n\n# 注释\n\n1. 文档注释\n\n   1. ```\n      javadoc -d 路径文件 -xx -yy xxx.java\n      生成文档命令\n      xx yy 分别代码javadoc标签命令 例如-auther -version等\n      ```\n\n   2. ```java\n      @author 标明开发该类模块的作者 \n      @version 标明该类模块的版本 \n      @see 参考转向，也就是相关主题 \n      @param 对方法中某参数的说明 \n      @return 对方法返回值的说明 \n      @exception 对方法可能抛出的异常进行说明 \n      \n      @author 作者名 \n      @version 版本号\n      其中，@author 可以多次使用，以指明多个作者，生成的文档中每个作者之间使用逗号 (,) 隔开。@version 也可以使用多次，只有第一次有效 \n      \n      使用 @param、@return 和 @exception 说明方法 \n      这三个标记都是只用于方法的。@param 描述方法的参数，@return 描述方法的返回值，@exception 描述方法可能抛出的异常。它们的句法如下： \n      @param 参数名 参数说明 \n      @return 返回值说明 \n      @exception 异常类名 说明 \n      \n      ```\n\n# 变量\n\n## 数据类型\n\n### 变量\n\n1. 变量本质就是一个变化的值。\n\n2. 变量有三个基本要素\n\n   1. 类型\n   2. 名称\n   3. 值\n\n3. ```java\n   public static void main(String[] args){\n   \tint a=1;\n   \t//定义了一个变量，类型为int，名称为a，值为1\n   \ta=89;\n       //把89这个值赋给了a变量\n   }\n   ```\n\n4. 注意事项：\n\n   * 变量表示内存中的一个储存区域，[不同的变量，类型不同，占用的空间大小不同，比如：int 4个字节，double 8个字节]\n   * 该区域有自己的名称[变量名]和类型[数据类型]\n   * 变量必须先声明，后使用，有着自身的顺序\n   * 该区域的数据可以在同一类型范围内不断变化\n   * 变量在同一个作用域内不能重名\n   * 变量=变量名+值+数据类型，变量三要素\n\n### 运算符\n\n1. +号的使用\n   * 当左右两边为数值类型的时候，做加法运算\n   * 当左右两边有一方为字符串类型时，做拼接运算\n\n### 数据类型\n\njava数据类型\n\n1. 基本数据类型\n\n   * 数值型\n     * 整数类型，存放整数（byte[1],short[2],int[4],long[8])\n     * 浮点（小数）类型（float[4]，double[8])\n   * 字符型（char[2]），存放单个字符'a'\n   * 布尔型（Boolean[1]），存放true，false\n\n2. 引用数据类型（面向对象部分讲解）\n\n   * 类（class）\n   * 接口（interface）\n   * 数组（[]）\n\n3. 八大基本数据类型\n\n   【byte，short，int，long，float，double】，char，Boolean\n\n4. 浮点数据类型\n\n   1. 默认情况下输入的字符默认是double类型的\n\n   2. 如果想改成float类型需要在数值后面加上f或F\n\n   3. ```java\n      float a = 1.1 //错误\n      float a = 1.1F //正确\n      double b = 1.1\t//正确\n      double b = 1.1F\t//正确\n      ```\n\n   4. 平时使用默认的double类型就行，因为更为精确\n\n   5. 浮点数使用陷阱\n\n      * ```java\n        //例如\n        //2.7和8.1/3 比较\n        double a = 2.7 ;\n        double b = 8.1/3 ;//理论上数学得数是2.7\n        System.out.println(a);//2.7\n        System.out.println(b);//得数是一个接近2.7的一个小数，而不是2.7\n        //因为计算机计算机制的问题，不是数学的问题。\n        所以在做相等判断时需要小新\n        ```\n\n      * ```java\n        //类似问题的解决方法\n        double a = 2.7 ;\n        double b = 8.1/3 ;//理论上数学得数是2.7\n        System.out.println(a);//2.7\n        System.out.println(b);\n        \n        if(a == b){\n        //这样的写法会出问题\n        \tSystem.out.println(\"相等\");\n        }\n        \n        //可以使用计算其差值\n        if(Math.abs(a-b)<0.001){\n        \tSystem.out.println(\"差值非常小，到我规定的精度内，认为相等\");\n            \n           // Math方法调用java API\n           \n        }\n        ```\n\n5. 字符类型\n\n   1. char的本质就是一个整数，默认用的是Unicode编码\n   2. 字符常量用单引号引出来，\n      * 例：char a = 'a';\n      * char b = '/n';\n   3. 不能输入双引号，否则会认成字符串，会报错。\n   4. char类型时可以运算的。\n\n   字符型的本质\n\n   * 字符型储存到计算机中，需要将对应的码值（整数）找出来\n\n   * 字符和码值的对应关系是通过字符编码表决定的（是规定死的）\n\n   * ![image-20220205221255475](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220205221255475.png)\n\n6. 布尔类型\n\n   1. 只占一个字节，只允许true和false\n   2. 用于判断操作\n   3. 不可用0或非0 来代替true或false，c语言可以\n\n## 数据类型转换\n\n### 1、自动类型转换\n\n* 精度小的类型自动转换为精度大的数据类型，反之就会报错。\n\n* char < int < long < float < double \n\n* byte < short < int < long < float < double\n\n* ```java\n  //例：\n  int num = 'a';\n  ```\n\n1. 注意事项\n\n   1. 多重类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的哪种数据类型，然后再进行计算\n\n    ```java\n     //例\n     int n1 = 10;\n     float d1 = n1+1.1;\n     //这是错误的，因为转换成最大单位，1.1默认的类型是double类型的，如果是n1＋1.1f 的话就是正确的\n     double d1 = n1+1.1;\n     // 这是正确的；\n    ```\n\n   2. （ byte , short ) 和 char之间不会相互转换，当把一个具体的数赋给byte时。\n\n      1. 先判断该数是否在byte范围内，如果是就可以\n\n   3. byte，short，char 三者可以进行计算，在计算时都会先转换成int类型\n\n      * ```java\n        byte b1 = 1;\n        byte a1 = 1;\n        short b2 = 1;\n        short s2 = b1 + b2//错误\n        //因为计算时会转换成int类型，int不能再赋给比它小的类型short\n        int s2 = b1 + b2 //正确\n        byte s3 = a1 + b1//错误\n        //byte，short，char,只要涉及计算都会转换为int类型，所以错误\n        ```\n\n   4. 布尔类型 ( boolean ) 不参与类型转换\n\n   5. 自动提升原则：表达式结果的类型自动提升为 操作数中最大的类型。\n\n### 2、强制类型转换\n\n1. 简介\n\n   1. 大的数据类型转换为小的数据类型\n   2. 使用时要加上强制转换字符（类型）\n   3. 可能会出现精度降低和溢出问题\n\n2. 注意细节\n\n   1. 将数据从大到小转换，需要强制转换\n\n   2. ```java\n      //强制转换符只对最近的操作数有效，也就是只对下边的10数字有效，转换后再进行计算又会转换成double类型。\n      int x = (int)10*3.5+6*1.5;//提示编译错误，类型是double ->\n      \n      int x = (int)(10*3.5+6*1.5);//用小括号括起来即可完美解决上述问题\n      ```\n\n3、基本数据类型和String类型的转换\n\n1. 介绍\n\n   1. 在程序开发中，我们经常需要吧基本数据类型转换成String类型，或String转基本数据类型\n\n2. 方式\n\n   * 基本转String\n\n     * 基本数据类型的值+\" \" \n\n     * ```java\n       //例\n       int n1 = 123;\n       float f = 2.3f;\n       double b = 4.5;\n       String str1 = n1 +\" \";\n       String str2 = f +\"\";\n       String str3 = b +\"\";\n       \n       ```\n\n   * String 转基本\n\n     * 调用基本类型的包装类方法parseXXX 方法即可\n\n     * ```java\n       String s5= \"123\";\n       integer.parseInt(s5);\n       Double.parseDouble(s5);\n       Float.parseFloat(s5);\n       //怎么吧字符串转成字符char，含义是指吧字符串的第一个字符得到\n       system.out.println(s5.charAt(0));//获取字符串的第一个字符\n       //所以这个输出的值为1\n       ```\n\n3. 注意事项\n\n   1. string转换基本类型时，要确保string类型能够转成有效数据，可以吧'123'转换成一个整数，但不能吧\"hello\"转换成一个整数\n\n# 运算符\n\n## 运算符\n\n### 1.简介\n\n1. 是一种特殊符号，表示数据的运算、赋值和比较等\n2. 种类\n   * 算数运算符\n   * 赋值运算符\n   * 关系运算符(比较运算符)\n   * 逻辑运算符\n   * 位运算符 [ 需要二进制基础 ]\n   * 三元运算符\n\n### 2.算数运算符\n\n1. 对数值类型的变量进行运算的\n2. 预览：![image-20220211161920431](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220211161920431.png)\n3. 注意事项\n   * 取模\n   * <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">再%的本质，看一个公式 a % b = a-a / b * b</span>\n4. 面试题\n   1. ![image-20220213151013682](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213151013682.png)\n      1. 答案为 1\n         * 运行步骤为\n         * (1)先把 i 的值赋给一个临时变量tmp\n         * (2)再进行计算i++，结果为i=2\n         * (3)tmp的值重新赋给i，此时i =1\n      2. 答案为2\n         * 运行步骤为\n         * (1)再进行计算i++，结果为i=2\n         * (2)再将2移到临时变量tmp\n         * (3)tmp赋给 i\n\n### 3.关系运算符（比较运算符）\n\n1. 介绍\n   * 关系运算符的结果都是boolean型，\n   * 通常用在if条件语句结构条件中\n   * 关系运算符组成的表达式成为关系表达式\n2. 预览图\n\n![image-20220213162614379](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213162614379.png)\n\n\n\n### 4.逻辑运算符\n\n预览：\n\n1. ![image-20220213170452994](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170452994.png)\n\n2. ![image-20220213170753311](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170753311.png)\n\n3. ![image-20220213170926798](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170926798.png)\n\n4. ```\n   &&（短路与）\t只有两个条件都为true ，才为true\t//如果第一个条件为false，则后面的条件不执行，直接输出flase，效率高\n   \n   &\t（逻辑与）\t只有两个条件都为true ，才为true\t//两个条件都执行，效率低\n   ```\n\n5. ![image-20220214140501385](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220214140501385.png)\n\n6. ```java\n   取反\n   真变假，假变真\n   //a^b :叫逻辑异或，当a和b不同时，结果为true，否侧为false\n   例：\n   \tboolean b = (10>1) ^ (3<5);\n   \tSystem.out.println(\"b=\"+b);//f\n   ```\n\n### 5.赋值运算符（=）、\n\n分类：\n\n* 基本赋值运算符 = \tint a = 10；\n\n* 复合赋值运算符\n\n  ```\n  +=，-=，*=，/=，%=等等，\n  例：a += b;[等价 a=a+b;]\n  \ta -=b;[等价 a = a-b;]\n  一般情况加复合赋值运算符，前边都有基本赋值运算符\n  ```\n\n* 复合运算符会进行类型转换\n\n  ```java\n  byte a =3;\n  a += 2; //此时计算结果为int类型\n  //不会报错，因为会自动进行类型转换\n  \n  //不能直接写成\n  a=a+2; //会报错\n  \n  // 像a++，++a这种会都进行自动的类型转换\n  ```\n\n### 6.三元运算符\n\n* 语法：条件表达式？ 表达式1: 表达式2；\n\n* 运算规则：\n\n  1. 如果条件表达式为true，运算后的结果是表达式1；\n\n  2. 如果条件表达式为false，运算后的结果是表达式2；\n\n     口诀：【一灯大师：一真大师（如果为真，返回1）】\n\n  3. 例：\n\n     ```java\n     int a = 10 ;\n     int b = 99 ;\n     // 1.如果 结果为false\n     // 2.返回b--，先返回b，再进行b-1。依旧按照之前的a++,++a的计算形式\n     // 3.结果为99\n     int result = a > b ? a++; b--;\n     //如果a>b 为真，返回a++，如果为false返回b--;\n     \n     ```\n\n  4. 本质就是if，else语句\n\n### 7.运算符优先级\n\n* ![image-20220215150928654](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220215150928654.png)\n* 小结：优先级排名\n  1. () ，{}等优先级最高\n  2. 单目运算==a ，--a等；\n  3. 算术运算符+-\n  4. 位移运算符\n  5. 比较运算符\n  6. 逻辑运算符\n  7. 三元运算符\n  8. 赋值运算符\n\n## 标识符\n\n**标识符的规则和规范**\n\n1. java中对各种变量、方法和类的命名使用的字符成为标识符。\n\n* ```java\n  int num =1;\n  // num就是标识符\n  ```\n\n2. 标识符的命名规则必须遵守\n   * 标识符由26个字母的大小写，0-9，_或$符组成。\n   * 不可以用数字开头\n   * 不可以使用关键字和保留至，但能包含关键字和保留字\n   * 标识符不能包含空格\n3. 标识符命名规范\n   * 包名：多单词组成时，所有字母都小写。例：aaa.bbb.ccc\n   * 类名、接口名：多单词组成是，所有单词首字母大写，驼峰命名法\n   * 变量名、方法名：多单词组成时，第一个单词首字母小写，后面单词的首字母大写。例：aaBbCc\n   * 常量名：所有字母都大写。多单词时用下划线隔开。例：A_B_C\n\n##   键盘输入语句\n\n### 1.介绍\n\n在编程过程中需要接受用户的输入数据，可以使用键盘输入语句来获取。input.java，需要一个扫描器（对象），就是Scanner\n\n### 2.步骤\n\n1）导入该类所在的包，java.utill.*\n\n2）创建该类对象（声明变量）\n\n3）调用里面的功能\n\n### 3.案例\n\n```java\npublic class KeyboardInput {\n    public static void main(String[] args) {\n//        创建Scanner对象\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.println(\"请输入文本1\");\n//        z字符串类型\n        scanner.next();\n        System.out.println(\"请输入age\");\n//        nextint 代表接收一个int类型的输入\n        scanner.nextInt();\n//        接收double类型的\n        scanner.nextDouble();\n\n    }\n\n```\n\n\n\n\n\n## 进制\n\n### 介绍\n\n对于整数，有四种表达方式\n\n* 二进制（Bin/B）：0,1，满2进1，以0b或0B开头\n\n* 八进制（OCT/O）：0-7，满8进1。以数字0开头表示\n\n* 十进制（DEC/D）：0-9，满10进1\n\n* 十六进制（HEX/H）：0-9及A(10)-F(15)，满16进1.以0x或0X开头表示。此处的A-F不区分大小写\n\n* ```java\n  int n1 = 0b1010;\n  int n2 = 01010;\n  int n3 = 1010;\n  int n4 = 0x10101;\n  ```\n\n  \n\n### 进制转换（基本功）*\n\n第一组\n\n1. 二进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和\n\n   * ```\n     例\n     0b 1011  =1*2^0+1*2^1+0*2^2+1*2^\n     = 1+2+0+8\n     =11\n     \n     ```\n\n2. 八进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和。\n\n   * ```\n     例：0234转成十进制\n     0 234\n     =4*8^0 + 3*8^1 + 2*8^2 \n     =4+24+128\n     =156\n     ```\n\n3. 十六进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和\n\n   * ```\n     例：0x 23A转成十六进制\n     =10*16^0 + 3*16^1 + 2*16^2\n     =10 + 48 + 512\n     =570\n     A(10),B(11),C(12),D(13),E(14),F(15)\n     ```\n\n[第一部分练习](###进制部分)\n\n第二组\n\n1. 十进制转二进制\n\n   * 规则：将该数不断除2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制\n\n   * ```\n     将34转换成二进制\n     34%2\t余0\n     17%2  余1\n     8%2\t\t余0\n     4%2\t\t余0\n     2%2\t\t余0\n     1%2\t\t余1\n     反着读\n     结果：0b100010 //前缀0b的意思为二进制\n     正确答案为：0b00100010\n     因为一个字节二进制的是八位，34的出的结果是六位所以前面需要多加两个0\n     ```\n\n2. 十进制转八进制\n\n   * 规则：将该数不断除8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的八进制\n\n   * ```\n     例：将131转为八进制\n     131%8\t\t余3\n     16%8\t\t余0\n     2%8\t\t\t2\n     结果为0203前面的0代表的意思是八进制\n     ```\n\n3. 十进制转十六进制\n\n   * 规则：将该数不断除16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的十六进制\n\n   * ```\n     例：237\n     答案为 ED\n     ```\n\n   * ![image-20220216221217568](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220216221217568.png)\n\n第三组\n\n1. 二进制转八进制\n\n   * 规则：从低位开始，将二进制数的每三位一组，转成对应的八进制数即可\n\n   * ```\n     例：0b 11010101 每三个转成十进制再拼起来\n     =325\n     11100101\n     =345\n     ```\n\n2. 二进制转十六进制\n\n   * 从低位开始，将二进制数的每四位一组，转成对应的十六进制即可\n\n   * ```\n     11010101\n     =0xD5\n     1110010110\n     =0x396\t每四个转成十进制再拼起来\n     ```\n\n第四组\n\n1. 八进制转二进制\n\n   * 规则：将八进制数每一位，转成对应的3位的二进制数\n\n   * ```\n     237  每位以十进制转二进制转成对应的3位二进制数再连起来\n     2（010）3（011）7（111）\n     =010011111\n     \n     1230\n     =1(001)2(010)3(011)0(000)\n     =001010011000\n     ```\n\n2. 十六进制转二进制\n\n   * 规则：将八进制数每一位，转成对应的4位的二进制数\n\n   * ```\n     23B\n     =2(0010)3(0011)B(1011)\n     =001000111011\n     AB29\n     =A(1010)B(1011)2(0010)9(1001)\n     =1010101100101001\n     ```\n\n源码，反码，补码（重点）\n\n对于有符号的数而言（八个规则）：\n\n1. 二进制的最高位是符号位：0表示正数，1表示负数（口诀：0 - >0   1-> -）\n2. 正数的原码，反码，补码都一样（三码合一）\n3. 负数的反码 = 它的原码符号位不变，其他位取反（0->1,1->0）0变1,1变0.\n4. 负数的补码 = 它的反码+1，负数的反码 = 负数的补码-1\n5. 0的反码，补码都是0\n6. java没有无符号的数，换而言之，java中的数都是有符号的\n7. 计算机运算的时候，都是以 <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">补码的方式来运算的</span>\n8. <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">当我们看运算结果的时候，要看它的原码（！！！）</span>\n\n\n\n## 位运算\n\n* java中有七个位运算符（&，|，^，~，>>，<<和>>>）\n\n* 分别是：\n\n  * &：按位与\n\n    * 规则：两位全为1，结果为1，否则为0\n\n    * ```\n      例：\n         10011010\n        &11011101\n      -------------\n        =10011000// 两个都1结果才为1\n      ```\n\n  * |：按位或\n\n    * 规则：两位有一个为1，结果为1，否则为0\n\n    * ```\n          10011010\n        &11011101\n      -------------\n        =11011111// 两个有一个1结果才为1\n      ```\n\n  * ^：按位异或\n\n    * 规则：两位一个为0，一个为1，结果为1，否则为0\n\n    * ```\n      10011010\n      &11011101\n      ```\n\n    -------------\n\n        =01000111// 两位一个为0，一个为1，结果为1，否则为0\n\n      ```\n    \n      ```\n\n  * ~：按位取反\n\n    * 规则：0为1,1为0\n\n```\n//位移运算\nint a = 1>>2; // 1 向右位移2位\nint b = -1>>2;\nint c = 1<<2; //左移 2位\nint d = -1<<2;\nint e = 3>>>2;//无符号右移\n\n\n```\n\n[练习部分](##位运算练习)\n\n```\n2&3计算机计算流程（计算机是按照补码进行计算的）\n因为一个字节是八位，一个int类型有4个字节\n1.先得到2的补码 ===>* 源码00000000 00000000 00000000 00000010 //得到原码\n* 转成补码（正数的三码都一样）\n00000000 00000000 00000000 00000010\n2. 得到3的补码 ====>先获得原码00000000 00000000 00000000 00000011\n得到3的补码\n00000000 00000000 00000000 00000011\n\n3.计算2&3\n补码结果为：00000000 00000000 00000000 00000010\n原码也为：00000000 00000000 00000000 00000010\n最终结果为：2\n```\n\n````\n~-2计算过程\n1. 得到-2的原码10000000 00000000 00000000 00000010\n2. 算出-2的反码11111111 11111111 11111111 11111101（原符号位保持不变，其他取反）\n3. 算出-2的补码11111111 11111111 11111111 11111110\n4.再进行~-2操作00000000 00000000 00000000 00000001//运算后的补码\n5.转为原码00000000 00000000 00000000 00000001\n6.结果为1\n````\n\n```\n~2的计算过程\n1.得到2的原码00000000 00000000 00000000 00000010\n2.获取补码：00000000 00000000 00000000 00000010\n3.计算~2:11111111 11111111 11111111 11111101\n3.转为反码（）负数的反码=补码-1\n11111111 11111111 11111111 11111100\n4.转为原码：10000000 00000000 00000000 00000011\n5.结果为-3\n```\n\n* 运算符>>，<<和>>>运算规则\n\n  * 算数右移>>；低位溢出，符号位不变，并用符号位补溢出的高位\n\n    * ```\n      int a = 1>>2;\n      1:00000000 00000000 00000000 00000001\n      1 >>2 //相当于把最后边的01去掉用符号位补上\n      结果：00000000 00000000 00000000 00000000\n      最后结果为0\n      \n      简便的方法\n      1>>2 = 1/2/2= 0\n      15>>2 = 15/2/2=3  //取整\n      ```\n\n  * 算数左移<<; 符号位不变，低位补0\n\n    * ```\n      int a =1<<2;\n      1:00000000 00000000 00000000 00000001\n      1<<2\n      00000000 00000000 00000000 00000100\n      结果为4\n      \n      简便的方法\n      1<<2 =1*2*2 = 4\n      4<<3 = 4*2*2*2 = 32\n      \n      ```\n\n  * 3.>>>逻辑右移，也叫无符号右移，运算规则是：低位溢出，高位补0\n\n# 程序控制结构\n\n## 顺序控制（if,else,switch）\n\n### 介绍\n\n程序从上到下逐行执行，中间没有任何判断和跳转\n\n### 分支控制\n\n### **1）单分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块;\n}\n```\n\n说明：当条件表达式为true时，则执行{}内的代码。false就不执行。如果只有一条执行语句，可以省略{}。但不建议省略\n\n### **2）双分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块1;\n}else{\n\t执行代码块2;\n}\n```\n\n\n\n### **3）多分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块1;\n}else if(条件表达式){\n\t执行代码块2;\n}else{\n\t执行代码块....;\n}.....\n```\n\n流程图：\n\nelse只能有一个执行入口\n\n![image-20220222162201564](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220222162201564.png)\n\n特别说明：\n\n1. 多分支可以没有else，如果所有条件都不成立，则一个执行入口都没有\n2. 如果有else，如果所有的条件表达式都不成立，则默认执行else代码块。\n\n练习：\n\n```java\npublic class ifChapter {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入0-100的数字\");\n        int num = scanner.nextInt();\n        if (num<1 && num>100){\n            if (num==100){\n                System.out.println(\"信用极好\");\n            }else if (num>80 && num <= 99){\n                System.out.println(\"信用优秀\");\n            }else if (num >= 60 && num <= 80){\n                System.out.println(\"信用一般\");\n            }else if (num <60){//或直接不写这个条件语句，但这个会有bug\n                System.out.println(\"不及格\");\n            }else{\n                System.out.println(\"请输入合法数字\");\n            }\n        }else{\n            System.out.println(\"输入不合法\");\n        }\n    }\n}\n```\n\n### **4）嵌套分支**\n\n介绍：\n\n一个分支完整的嵌套了另一个分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支。\n\n规范：不建议超过三层（可读性不好）\n\n基本语法：\n\n```java\nif(){\n\tif(){\n\t\n\t}else{\n\t\tif.....\n\t}\n}\n```\n\n### 5）switch分支\n\n基本语法：\n\n```java\nswitch(表达式){ //表达式为具体的一个值\n    case 常量1:\n语句块1;\nbreak;\n    case 常量2:\n语句块2;\nbreak;\n    case ······:\nbreak;\n ...........\n       \ndefault :\ndefault语句块\nbreak;\n}\n```\n\n1. switch 关键字,表示swtich分支\n2. 表达式   对应一个值\n3. case常量1：当表达式的值等于常量1，就执行语句块1\n4. break：表示退出switch\n5. 如果case 常量1 匹配，就执行语句块1，如果没有则继续case 常量2；\n6. 如果一个都没有匹配上，就执行default\n\nSwitch流程图：\n\n![image-20220224155515378](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220224155515378.png)\n\n 注意：\n\n* 穿透\n  1. 如果case1 没有break\n  2. 则case不进行判断直接执行case2 的语句块\n\n```java\npublic static void main(String[] args) {\n        char week;\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入字母\");\n        week = scanner.next().charAt(0);\n        switch (week){\n            case 'a':\n                System.out.println(\"Monday\");\n                break;\n            case 'b':\n                System.out.println(\"Tuesday\");\n                break;\n            case 'c':\n                System.out.println(\"Wednesday\");\n            case 'd':\n                System.out.println(\"Thursday\");\n                break;\n            case 'e':\n                System.out.println(\"Friday\");\n                break;\n            case 'f':\n                System.out.println(\"Saturday\");\n                break;\n            case 'g':\n                System.out.println(\"sunday\");\n                break;\n            default:\n                System.out.println(\"输入有误，请输入a-g的字母\");\n        }\n    }\n```\n\n注意事项和细节\n\n1. 表达式数据类型，应和case后的常量类型一致，或者是可以自动转换成可以相互比较的类型，比如输入的是字符，而常量是int\n\n2. Switch(表达式)中表达式的返回值必须是：（byte，short，int，char，enum，String）\n\n   ```java\n   //比如下列例子，是不可以的\n   double a = 1.1;\n   switch(a){//错误\n   \tcase 1.1://case后面不可以有变量\n   \t\tSystem.out.println(\"···\");\n   \t\tbreak;\n   }\n   ```\n\n3. case子句中的值必须是常量，不能是变量\n\n4. default子句是可选的，当没有匹配的case时，执行default。default语句是可选的，当没有匹配的任何常量，则没有任何输出。\n\n5. break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有则会出现穿透现象，使程序执行后面所有的case语句块，除非遇到break；\n\n6. [练习](##switch练习)\n\n**switch 和if的比较**\n\n1. 如果判断的具体数值不多，而且符合byte，short，int，char，enum，string类型虽然这两个语句都可以用，建议用switch\n2. 其他情况，对区间判断，对结果为boolean配型判断，使用if，if的使用范围更广\n\n## 循环控制（for,while,dowhile,多重循环[重点]）\n\n### 1）for循环\n\n1. 基本语法\n\n   ```java\n   for(循环变量初始化；循环条件；循环变量迭代){\n   \t循环操作；(可多条语句)\n   }\n   \n   ```\n\n   \n\n2. 说明\n\n   1. for关键字，表示循环控制\n   2. for有四要素，1）循环变量初始化，2）循环条件，3）循环操作，4）循环变量迭代\n   3. 循环操作，这里可以有很多条语句，也就是我们要执行的代码块\n   4. 如果 循环操作(语句)只有一条语句，可以省略{}，建议不要省略\n\n例子：\n\n```java\npublic static void main(String[] args) {\n\n        //练习： 打印100句“韩顺平教育”\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"韩顺平教育\" +i);\n        }\n\n\n    }\n```\n\n* for循环流程图\n  * ![image-20220227123857620](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227123857620.png)\n\n#### 注意事项：\n\n* 循环条件返回一个布尔值(Boolean)\n\n* for（；循环条件；）中的初始化和变量迭代可以写到其他地方，但两边的分号不能省略\n\n  * ```java\n    //演示\n    int i = 0;\n    for (i; i < 10;) {\n                System.out.println(\"韩顺平教育\" +i);\n                 i++;\n            }\n    \n    //补充\n    for(;;){//表示一个无限循环\n       System.out.println(\"韩顺平教育\" +i);\n    }\n    ```\n\n* 循环初始值，可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开\n\n  * ```java\n    //例\n    int count =3;\n    for (i =0 ,j = 0 ;i<count; i++, j+=2){\n    \tSystem.out.println(\"i=\"+i \"j=\" +j);\n    }\n    输出 ：00 12 24\n    ```\n\n  * 00 12 24 \n\n#### **编程技巧**\n\n* 化繁为简：将复杂的需求拆解成简单的需求\n* 先死后活：先考虑固定的值，然后转成可以灵活变化的值\n\n**练习**\n\n1. 打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]\n\n   * ```\n     \n     ```\n\n   * ```java\n     //打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]\n           //1、先输出1-100循环\n           //2、在输出的过程中过滤9的倍数\n           //3、定义一个变量来累计计算个数\n           //4、定义一个变量来累计计算总和\n     public static void main(String[] args) {\n             int count= 0;\n             int sum =0;\n             for (int i = 1; i <=100 ; i++) {\n                 if (i%9==0){\n                     System.out.println(\"i=\"+i);\n                     count++;\n                     System.out.println(\"数量\"+count);\n                     sum+=i;// = sum + i\n                     System.out.println(\"sum=\"+sum);\n                 }\n     \n             }\n     ```\n\n### 2）while循环\n\n基础语法：\n\n```java\nwhile（循环条件）{\n\t循环体（语句）；\n\t循环变量迭代；\n}\n```\n\n说明：\n\n1. while循环也有四要素\n2. 只是四要素放的位置，和for不一样\n\n**流程图**\n\n![image-20220227143009846](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227143009846.png)\n\n#### 注意事项：\n\n1. 循环条件是返回布尔值\n2. while循环是先判断再执行语句\n\n\n\n### 3）do...while循环控制\n\n基础语法：\n\n```java\ndo{\n\t循环体(语句);\n\t循环变量迭代;\n}while(循环条件);\n\n```\n\n 说明:\n\n1. do  while 是关键字\n\n2. 也有循环四要素，只是位置不一样\n\n3. 先执行，在判断，也就是说，一定会执行一次\n\n4. 最后有一个分号\n\n5. while和do... while区别\n\n   * while是先判断再执行\n\n   * do .. while是先执行再判断\n\n```java\npublic static void main(String[] args) {\n\n       int i = 1;\n        do {\n            System.out.println(\"阿巴阿巴\");\n            i++;//不要忘记加上，否则容易死循环\n        }while (i<=10);\n\n        System.out.println(\"exit dowhile\");\n    }\n```\n\n\n\n流程图：\n\n![image-20220227163555197](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227163555197.png)\n\n#### 注意事项：\n\n1. 循环条件是返回一个布尔值的表达式\n2. do...while 循环是先执行后判断，因此它至少执行一次\n\n\n\n### 4）多重循环\n\n#### 介绍\n\n1. 讲一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do ...while均可以作为外层循环和内层循环 。【建议一般使用两层，最多不超过三层，否则代码可读性很差】\n\n2. 实质上，嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环\n\n3. 例：设外层循环次数为m次，内层为n次。则内层循环体实际上需要执行m*n次\n\n   ```java\n   for (int i = 0; i < 2; i++) {\n               for (int j = 0; j < 3; j++) {\n                   System.out.println(\"i = \"+i+ \",\"+\"j = \"+j);\n               }\n           }\n   \n   ------------------------输出------------------------\n   i = 0 , j =0\n   i = 0 , j =1\n   i = 0 , j =2\n   i = 1 , j =0\n   i = 1 , j =1\n   i = 1 , j =2\n   ```\n\n   \n\n#### 练习\n\n1. 统计3个班成绩情况，每个班有5名同学，求出各个班的平均成绩和所有班级的平均分【学生的成绩从键盘输入】\n\n   * ```java\n     Scanner scanner = new Scanner(System.in);\n     //        int clss = 1;\n                 int stu =0;\n                 double sum = 0;\n             for (int i = 1; i <=3 ; i++) {\n                 for ( int j = 1;j<=5;j++){\n     \n                     System.out.println(\"请输入\"+i+\"班\"+j+\"成绩\");\n                     int s = scanner.nextInt();\n                     sum = sum + s;\n                 }\n                 System.out.println(i+\"班的平均分为：\"+(sum / 5));\n                 sum =0;\n             }\n     ```\n\n     \n\n2. 打印99乘法表\n\n   * ```java\n     for (int i = 1; i <=9 ; i++) {\n        \n                 for (int j = 1; j <=i ; j++) {\n                     System.out.print(i+\"*\"+j+\"=\"+(i*j)+\"  \");\n     \n     \n                 }\n                 System.out.println(\"\");\n             }\n     ```\n\n3. 打印空心金字塔\n\n   * ```java\n     //        实心金字塔\n             for (int i = 1; i <=5 ; i++) {\n                 for (int k = 1; k <=5-i ; k++) {\n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n     \n                     System.out.print(\"*\");\n                 }\n                 System.out.println(\" \");\n             }\n     ```\n\n   * ```java\n     空心金字塔 【难点】\n             for (int i = 1; i <=5 ; i++) {\n                 for (int k = 1; k <=5-i ; k++) {\n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n                 \n                 \n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n                 \n                 \n     \t\t\t\t//1.空心金字塔的第一层和最后一层的*全部输出\n     \t\t\t\t//2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示\n     \t\t\t\t//3.再加一个条件 i == 5\n     \t\t\t\tif(j == 1 || j == 2*i-1 || i==5 ){\n     \t\t\t\t\t System.out.print(\"*\");\n     \t\t\t\t}else{\n     \t\t\t\t\t System.out.print(\" \");\n     \t\t\t\t}\n     \n     //可以将其中的5 提出来换成变量，实时控制金字塔的层数\n     \n                    \n                 }\n                 System.out.println(\" \");\n             }\n     ```\n\n     \n\n   * ```java\n     //可手动修改的\n     \n           Scanner scanner = new Scanner(System.in);\n           System.out.println(\"请输入层数\");\n           int layer = scanner.nextInt();\n     ```\n\n\n             for (int i = 1; i <=layer ; i++) {\n                 for (int k = 1; k <=layer-i ; k++) {\n    \n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n    \n                     //1.空心金字塔的第一层和最后一层的*全部输出\n                     //2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示\n                     //3.再加一个条件 i == 5\n                     if(j == 1 || j == 2*i-1 || i==layer ){\n                         System.out.print(\"*\");\n                     }else{\n                         System.out.print(\" \");\n                     }\n                 }\n                 System.out.println(\" \");\n             }\n    \n     ```\n   * 改为菱形\n     ```\n\n\n\n## break\n\n介绍\n\n1. 跳转控制语句----->break\n2. 当某个条件满足时，终止循环\n3. break语句用于终止某个语句块的执行，一般用于switch或者循环中\n\n基本语法：\n\n```java\n{\n......\nbreak;\n......\n```\n\n以while循环为例流程图：\n\n![image-20220228111326348](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228111326348.png)\n\n#### 注意事项\n\n1. break语句出现在多层嵌套语句块时，可以通过标签指明要终止的是哪一层语句块\n\n2. 标签的基本使用\n\n   ```java\n   label1:{.....\n   label2:\t\t{.....\n   label3:\t\t\t{.....\n   \t\t\t\tbreak label2;\n   \t\t\n   }\n   \t\n   }\n   \n   }\n   ```\n\n   1. break语句可以指定退出哪层\n   2. label1是标签，由程序员决定\n   3. break后指定到哪个label就退出到哪里\n   4. 在实际开发中，尽量不要使用标签\n   5. 如果没有指定break，默认退出最近的循环体\n\n## continue-跳转控制语句\n\n介绍：\n\n1. <u>**continue语句用于结束本次循环，继续执行下次循环**。</u>\n2. continue语句多出现在多层嵌套的循环语句中时，可以用过标签指明要跳过的是哪一环，这个和前面的标签使用一样\n\n基本语法\n\n```java\n{\n....\ncontinue;\n....\n}\n```\n\n流程图：\n\n![image-20220228153036178](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228153036178.png)\n\n\n\n## return-跳转控制语句\n\n介绍：\n\nreturn使用在方法，表示跳出所在的方法\n\n注意：\n\n1. 如果吧return放在main方法中会退出程序\n\n# 数组【重点】\n\n## 数组\n\n**介绍**\n\n数组可以存放 <u>多个</u>*<u>同一类型</u>* 的数据。数组也是一种数据类型，是引用数据类型。\n\n即：数（数据）组（一组）就是一组数据\n\n<span id = \"数组案例01\">案例</span>（快速入门）：\n\n```java\npublic static void main(String[] args) {\n   \t\t\tdouble totalWeght =0;\n        double[] hen = {1,2,3,4,5,6};\n  //可以通过 for循环访问数组的元素\n        for (int i = 0; i <hen.length ; i++) {\n          //可以通过下标来访问数组的元素 hen[下标]\n          //下标是从0开始的，比如【0，1，2，3】\n          //第二个元素是hen[1]\n    \n            System.out.println(\"第\"+(i+1)+\"个元素的值为\"+hen[i]);\n          totalWeght+=hen[i];\n        }\n  \t\tSystem.out.println(\"总体重为\"+totalWeght+\"平均体重为=\"+(totalWeght/hen.length));\n    }\n```\n\n### 动态初始化\n\n#### 使用方式1\n\n先new出一个数组，再动态的给它赋值。\n\n数组的定义：\n\n数据类型\t数组名[] = new 数据类型[大小]\n\n数据类型[]\t数组名 = new 数据类型[大小]\n\n以上两种写法的效果都是等价的\n\n例：\n\n```java\nint a[] = new int[5];\n\n//创建一个数组，名字为a，长度为5个int\n```\n\n内存图：\n\n![image-20220302092916369](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302092916369.png)\n\n例：\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class chapterArray01 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        //new数组类型时，记得加上数组的长度\n        double[] doubles = new double[5];\n        for (int i = 0; i < doubles.length; i++) {\n            System.out.println(\"请输入第\"+(i+1)+\"个数\");\n            doubles[i] = scanner.nextDouble();\n        }\n        System.out.println(\"========================================\");\n        for (int i = 0; i <doubles.length ; i++) {\n            System.out.println(\"输入的数为\"+doubles[i]);\n\n        }\n    }\n}\n\n```\n\n#### 使用方式2\n\n1. ***<u>先声明数组</u>***\n\n语法：\n\n* 数据类型 数组名[];\t或\t\t数据类型[] \t数组名;\n\n* int a[]  / int[]  a;\n\n2. ***<u>创建数组</u>***\n\n语法：\n\n* 数组名 = new 数据类型 [ 大小 ];\n* a = new int[5];\n\n```java\n//        double[] doubles = new double[5];\n//相当于吧使用方法1给拆分成两个\n//\t1.先声明\n        double doubles[];\n        //2.再创建\n        doubles = new double[5];\n```\n\n解释：1.先声明，在内存中相当于创建了一个空的变量，这时没有任何左右\n\n2.再创建，才使得这个数组有意义。不写的话会报空指针异常\n\n### 静态初始化\n\n语法：\n\n数据类型\t数组名[] = {元素值，元素值，元素值，......}\n\n[案例](#数组案例01)跳转\n\n### 注意事项和细节\n\n1. 数组是多核相同的数据类型的组合，实现对这些数据的统一管理\n2. 数组中的元素可以使任何数据类型，包括基本数据类型和引用数据类型，但不能混用\n3. 数组创建后，如果没有赋值，会有默认值：int 0 , short 0 , byte 0 ,long 0, float 0 ,double 0.0 , char \\u0000, boolean false , String null;\n4. 使用数组的步骤：\n   1. 声明数组并开辟空间\n   2. 给数组各个元素赋值\n   3. 使用数组\n5. 数组的下表是从0开始的 \n6. 数组下表必须在指定范围内使用，否则报：下标越界异常，比如: int[] arr = new int [5] ; 则有效下标为0-4\n7. 数组属于引用数据类型，数组行数据是对象（object）\n8. boolean 类型没有赋值的情况下默认false\n\n### 数组赋值机制\n\n1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响\n\n   ```java\n   //基本数据类型赋值，复制方式为值拷贝\n   int n1 = 2 ; \n   int n2 = n1 ;\n   \n   n2的变化不会影响n1\n       \n   ```\n\n2. 数组再默认情况下是引用传递，赋的值是地址。赋值方式为引用传递\n\n   ```java\n   int[] array1 = {1,2,3}\n   int[] array2 = array1; \n   \n   array2[0] = 10;\n   //此时运行的结果 array1的第0个元素会变成10\n   \n   ```\n\n   \n\n ![image-20220302141207302](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302141207302.png)\n\n### 数组拷贝\n\n案例：\n\n```java\nint[] arr1 = {1,2,3}\n//1. 创建一个新的数组arr2,开辟一个新的数据空间\n//2. 大小 = arr1.length\nint arr2[] = new int[arr1.length];\n\n//遍历arr1到对应的位置\nfor( i = 0; i < arr1.length; i++){\n    arr2[i] = arr1[i];\n}\n\n```\n\njvm内存图分析:\n\n![image-20220302142048498](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142048498.png)\n\n![image-20220302142253236](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142253236.png)\n\n### 数组翻转\n\n案例：\n\n要求：需要把数组的元素内容反转。\n\narr { 1 , 2 , 3 , 4 , 5 }-->{5 , 4 , 3 , 2 , 1}\n\n方式1：\n\n```java\nint[] arr = {11 , 22 , 33 , 44 , 55 , 66};\n\n//1. 把 arr[0] 和 arr[5] 进行交换\n//2. 把 arr[1] 和 arr[4] 进行交换\n//3. 把 arr[2] 和 arr[3] 进行交换\n//4. 一共要交换 3 次 = arr.length\n//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]\n  int temp = 0;\n        int len = arr.length;\n        for (int i = 0; i <len/2 ; i++) {\n            temp = arr[len-1-i];\n            arr[len-1-i] = arr[i];\n            arr[i] = temp;\n        }\n     \n     \n }\n```\n\n方式2\n\n```java\nint[] arr = {11 , 22 , 33 , 44 , 55 , 66};\n//1. 先创建一个arr2\n        //2. 逆序遍历arr，再将每个元素赋给arr2的元素中\n        //3. 增加一个循环变量j\n        int[] arr2 = new int[arr.length];\n\n        for (int i = 0,j=arr.length-1 ; j>=0; i++,j--) {\n            arr2[j] =arr[i];\n\n        }\n//4.当for循环结束，arr2就是一个逆序数组，{66 , 55 , 44 , 33 , 22 , 11}\n//5. 让arr指向arr2数据空间,此时arr原来的数据空间就没有变量引用\n//会被当做垃圾处理\narr = arr2\n    //6. 遍历输出\n  \n        for (int i = 0; i <arr.length ; i++) {\n            System.out.println(arr[i]);\n        }\n```\n\n\n\n### 数组扩容\n\n数组缩减同理\n\n数组添加\n\n要求：实现动态的给数组添加元素效果，实现对数组扩容\n\n1）原始数组使用静态分配int[] arr = {1,2,3}\n\n2）增加的元素4，直接放在数组的最后 arr = {1,2,3,4}\n\n3）用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class chapterArrayAdd {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        char key ;\n        int[] arr1 = {1,2,3};\n\n\n        do {\n            int[] arr2 = new int[arr1.length+1];\n                for (int i = 0; i < arr1.length; i++) {\n                    arr2[i] = arr1[i];\n                }\n                System.out.println(\"请输入一个要添加的值\");\n                arr2[arr2.length - 1] = scanner.nextInt();\n\n            arr1 = arr2;\n\n            System.out.println(\"是否继续添加？请输入y/n\");\n            key = scanner.next().charAt(0);\n\n            if (key=='y'){\n                System.out.println(\"继续增加\");\n            }else if (key== 'n'){\n                System.out.println(\"跳出\");\n                break ;\n            }else {\n                System.out.println(\"输入不合法\");\n            }\n//            将arry1的地址指定到arry2的地址，此时原arry1的地址被没有变量引用，所以被jvm销毁\n\n        }while (true);\n\n        for (int i = 0; i < arr1.length ; i++) {\n            System.out.println(\"arr1 = \"+arr1[i]);\n        }\n\n    }\n\n}\n\n```\n\n\n\n\n\n\n\n## 排序\n\n介绍\n\n排序的分类：\n\n1. 内部排序：\n\n* 指将需要处理的所有数据都加载到内部存储中进行排序。包括（交换式排序法，选择时排序法和插入式排序法）\n\n2. 外部排序法：\n   * 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。\n\n### 冒泡排序\n\n基本思想：通过对待排序序列从后向前（从下标较大的元素开始），一次比较相邻元素的值若发现逆序则交换，使值较大的元素从前移向后部。像水下的气泡一样逐渐向上冒。\n\n![image-20220303105607719](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220303105607719.png)\n\n特点：\n\n1. 一共有五个元素\n\n2. 一共进行了四轮排序，可以看成外层循环\n\n3. 每1轮排序可以确定一个数的位置，比如第一轮排序确最大数，第二轮确定第二大的数 的位置，依次类推\n\n4. 当进行比较时，如果前面的数大于后面的数，就交换\n\n   \n\n案例说明:\n\n将五个无序：24,69,80,57,13使用冒泡排序，从小到大排序\n\n```java\npackage com.smms.demo;\n\npublic class chapterBall {\n    public static void main(String[] args) {\n        int tmp = 0;\n        int[] a  = {24,69,80,57,13};\n       \n        for (int i = 0; i < a.length-1; i++) {\n            for (int j = 0; j < a.length; j++) {\n                if (j>=a.length-1){\n                    break;\n                } else if (a[j]<a[j+1]){\n                    System.out.println(\"不做交换\");\n                }else {\n\n                    tmp = a[j];\n                    a[j]  = a[j+1];\n                    a[j+1] = tmp;\n                    System.out.println(\"交换第\"+j+\"个数为\"+a[j]);\n                }\n            }\n        }\n        for (int i = 0; i <a.length ; i++) {\n            System.out.println(a[i]);\n        }\n\n    }\n}\n\n```\n\n\n\n## 查找\n\n### 1）顺序查找：\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class exercisesSequence {\n    public static void main(String[] args) {\n        /*有一个数列：\n        * 白眉鹰王，金毛狮王，紫衫龙王，青翼蝠王猜数游戏\n        * 从键盘任意输入一个名称，判断数列中是否包含此名称（顺序查找）\n        * 要求：如果找到了，就提示找到，并给出下标\n        */\n        String[] a ={\"白眉鹰王\",\"金毛狮王\",\"紫衫龙王\",\"青翼蝠王\"};\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入\");\n        String next = scanner.next();\n        //用于判断是否没找到\n        int nub =-1;\n        for (int i = 0; i <a.length ; i++) {\n            if (next.equals(a[i])){\n                System.out.println(\"找到了\");\n                //如果找到了就把i的值赋给sub\n                nub = i;\n                break;\n                //如果nub==-1就代表没找到\n            }else if (nub == -1){\n                System.out.println(\"没找到\");\n            }\n        }\n    }\n}\n\n```\n\n\n\n### 2）二分查找：\n\n\n\n算法部分讲解补充\n\n\n\n## 二维数组\n\n介绍：一个数组内，还有数组\n\n要理解的点：\n\n1. 看到定义形式就可知道是不是二维数组\n2. 二维数组的每一个元素都是一维数组\n3. 二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历\n4. \n\n```java\n如果需要访问第（i+1)个一维数组，第（j+1)个值。arr2d[i][j]\n 或需要访问第i个一维数组，第j个值。arr2d[i-1][j-1]   \n```\n\n\n\n案例：\n\n```java\npublic static void main(String[] args) {\n        /*\n        * 请用二维数组输入如下图形\n         0 0 0 0 0 0\n         0 0 1 0 0 0\n         0 2 0 3 0 0\n         0 0 0 0 0 0\n         */\n\n//        1. 定义形式 int[][]\n//        2.可以理解为一个数组内的每个元素都是一个数组\n        int[][] arr2d= {{0,0,0,0,0,0},{0,0,1,0,0,0},\n                        {0,2,0,3,0,0},{0,0,0,0,0,0}};\n   System.out.println(\"二维数组的元素个数\"+arr2d.length);\n//\t二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历\n    \n    \n    \n//        获取多个少个一维数组\n        for (int i = 0; i < arr2d.length; i++) {\n//            遍历二维数组的每一个元素（数组）,\n//            arr2d[i].length  获取二维数组内对应的每一个一维数组的长度\n            for (int j = 0; j < arr2d[i].length; j++) {\n                System.out.print(arr2d[i][j]+\"\\t\");\n\n            }\n            System.out.println();\n        }\n    }\n```\n\n### 二维数组内存原理图：\n\n![image-20220304165024843](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165024843.png)\n\n\n\n### 二维数组的使用方式\n\n方式1：动态初始化\n\n```\n1.语法：类型[][] 数组名 = new 类型[大小][大小];\n例如： int[][] = new int[2][3];\n\n```\n\n方式2：动态初始化\n\n```\n1. 先声明：类型 数组名[][];\n2. 再定义（开辟空间）： 数组名 = new 类型[大小][大小];\n3. 赋值（有默认值，比如int 类型默认值就是0）\n```\n\n方式3：动态初始化\n\n1. 列数不确定\n2. java不强制每个数组的长度都一样\n3. 例：![image-20220304165929272](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165929272.png)\n\n```java\npublic static void main(String[] args) {\n        /*\n            动态创建下面二维数组，并输出\n            i = 0 : 1\n            i = 1 : 2 2\n            i = 2 : 3 3 3\n         */\n        //1. 创建一个二维数组，因为数组内的每一堆数组的元素都是不确定的，所以不填。\n        // 填了的话相当于固定了长度\n        int[][] arr= new int[3][];\n        for (int i = 0; i <arr.length ; i++) {\n//            给数组内的一维数组开辟空间\n//            如果没有给一堆数组开辟空间，那么这个空间的就是null\n            arr[i] = new int[i+1];\n//            遍历一维数组，给一堆数组的每个元素赋值\n            for (int j = 0; j < arr[i].length ; j++) {\n                arr[i][j]= i+1;\n            }\n        }\n\n//        遍历出这个二维数组\n        for (int i = 0; i <arr.length ; i++) {\n            for (int j = 0; j <arr[i].length ; j++) {\n                System.out.print(arr[i][j]);\n            }\n            System.out.println();\n        }\n    }\n```\n\n杨辉三角形\n\n![image-20220305143151743](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220305143151743.png)\n\n提示：\n\n1. 第一行有一个元素，第n行有n个元素\n\n2. 第一行的第一个元素和最后一个元素都是1\n\n3. 从第三行开始，对于非第一个元素和最后一个元素的元素的值，arr[i],[j]\n\n4. ```java\n   中间的数为：\n   arr[i][j]  = arr[i-1][j]+ arr[i-1][j-1]\n     \n     \n     \n   ```\n\n   ```java\n   package basics.chapterArray;\n   \n   public class exerciseArrayYangHuiTriangle {\n       public static void main(String[] args) {\n           int[][] arr =  new int[10][];\n           for (int i = 0; i <10 ; i++) {\n               arr[i] = new int[i+1];\n               for (int j = 0; j < arr[i].length; j++) {\n                   if (j==0 || j == arr[i].length-1){\n                       arr[i][j] = 1;\n                   }else {\n                       arr[i][j] = arr[i-1][j]+arr[i-1][j-1];\n                   }\n   \n               }\n   \n           }\n           for (int i = 0; i <arr.length ; i++) {\n               for (int j = 0; j <arr[i].length ; j++) {\n                   System.out.print(arr[i][j]);\n               }\n               System.out.println();\n           }\n       }\n   }\n   \n   \n   ```\n\n\n# 面向对象\n\n## 类与对象\n\n1）类是抽象的，概念的。代表一类事物，比如人类，猫类，狗类。。。。，即它是实例\n\n```java\n例：\nclass cat{\n    //属性/也叫成员变量\n   // 成员变量 =属性 = field(字段)\n\tString name;\n\tint age;\n}\n//实例\ncat c = new ca();\n```\n\n2） 对象是具体的，实际的，代表一个具体事务，即是实例\n\n3） 类是对象的模板，对象是类的一个个体，对应一个实例\n\n属性可以使基本数据类型，也可以是引用数据类型(对象，数组)\n\n### 对象在内存中存在的形式（重要）\n\njava内存的结构分析：\n\n1. 栈：一般存放基本数据类型（局部变量）\n2. 堆：存放对象（Cat cat ，数组等）\n3. 方法区：常量池（常量，比如字符串），类加载信息\n4. 示意图：[Cat(name,age,price)]\n\n```java\nPerson p = new Person();\np.name = \"jack\";\np.age = 12;\n\n1.先加载Person类信息（属性和方法信息，只会加载一次）\n2.在堆中分配空间，进行默认初始化（看规则），\n3.把堆中的地址返回给p，p就指向对象\n4.进行指定初始化，比如：p.name = \"jack\",p.age = 12;\n\n    \n```\n\n\n\n\n\n对象和数组都是引用类型\n\n![image-20220307112129768](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307112129768.png)\n\n如果存放的数据，类型是基本数据类型则存放在堆中，引用的数据类型则存放在方法区\n\n###  注意事项\n\n1） 属性的定义语法同变量，示例：<span style=\"color:blue\">访问修饰符</span><span style= \"color:red\" > 属性类型  属性名;</span>\n\n2） 属性的定义类型可以为任意类型，包含基本类型或引用类型\n\n3） 属性如果不赋值，有默认值，规则和数组一致\n\n### 创建对象\n\n1. 先声明在创建\n\n   ```java\n   CAT cat;\n   cat  = new CAT();\n   ```\n\n2. 直接创建\n\n   ```java\n   CAT cat  = new CAT();\n   ```\n\n   \n\n访问属性\n\n```\n对象名.属性名；\ncat.xxx;\n```\n\n### 类对象的内存分配机制\n\n![image-20220307145803905](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307145803905.png)\n\n## 成员方法\n\n介绍：\n\n用于描述对象的行为，成为方法\n\n案例：\n\n![image-20220307161842380](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307161842380.png)\n\n```java\npackage com.smms.demo.method;\n\npublic class exercisesMethod01 {\n    public static void main(String[] args) {\n        Person person = new Person();\n        person.speal();\n        person.cal01();\n        person.cal02(3);\n//        调用getSum方法，并给了1,3的值\n//        用returnsum接收getSum返回的值\n        double returnsum = person.getSum(1,3);\n\n        System.out.println(\"returnsum=\"+returnsum);\n\n    }\n}\nclass Person{\n    public  void speal(){\n        System.out.println(\"我是一个好人\");\n    }\n\n    public  void cal01(){\n        int sum = 0;\n        for (int i = 0; i <= 1000; i++) {\n            sum+=i;\n        }\n        System.out.println(\"1+~+1000=\"+sum);\n    }\n    public  void cal02(int n){\n        int sum =0;\n        for (int i = 1; i <=n ; i++) {\n            sum = sum+i;\n        }\n        System.out.println(\"1+n=\"+sum);\n    }\n\n    public double getSum(double a, double b){\n        double sum=0;\n        sum = a+b;\n        System.out.println(\"a+b=\"+sum);\n//        表示返回sum\n        return sum;\n    }\n}\n```\n\n### 内存分析流程图\n\n![image-20220308162432089](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220308162432089.png)\n\n方法的优点：\n\n1. 提高了代码的复用性\n2. 可将实现的细节封装起来，然后提供其他用户来调用\n\n\n\n### 成员方法的定义\n\n```java\npublic 返回数据类型\\void（表示没有返回值）\t方法名(形参列表...){//方法体\n语句;\nreturn；//返回值\n}\n```\n\n1. 参数列表：表示成员方法输入cal(int n)\n2. 数据类型(返回类型)：表示成员方法输出，void表示没有返回值\n3. 方法主体:表示为了实现某一功能代码块\n4. return语句不是必须的\n\n\n\n### 注意事项\n\n1. 访问修饰符\n\n2. ``` java\n   访问修饰符 返回数据类型\\void（表示没有返回值）\t方法名(形参列表...){//方法体\n   语句;\n   return；//返回值\n   }\n   \n   1. 访问修饰符（作用是控制 方法的适用范围）\n       如果不写默认访问，[有四种：public protected 默认]\n   \n   ```\n\n   \n\n3. 返回数据类型\n\n```\n1. 一个方法最多有一个返回值\n\t返回多个结果，返回数组\n2. 返回类型可以为任意类型，包含基本类型和引用类型(数组，对象)\n3. 如果方法要求有返回数据类型，则方法体中最后执行的语句必须为return值；而且要求返回值类型必须和return的值的类型一致或兼容\n4. 如果方法是void，则方法体照片那个可以没有return语句，或者 只写 return；\n\n\n方法命名；使用驼峰命名法，最好见名知意\n```\n\n4. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开。例：getSum(int a,int b)\n\n5. 参数类型可以为任意类型，包含基本类型或引用类型。\n\n6. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数\n\n7. 方法定义时的参数成为形式参数（形参）；方法调用时的参数成为实际参数，简称实参。实参和形参的类型要一致或兼容、个数、顺序必须一致\n\n   * ```java\n     public static void main(){\n     \tMethod a = new Method();\n     \ta.input(123,345//这里成为实参);\n     }\n     \n     class Method{\n     \tpublic int input(int a,int b//这里成为形参){\n     \tsystem.out.print(\"xxx\");\n     \treturn xxx;\n     \t}\n     }\n     ```\n\n方法体\n\n​\t里面写完成功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义\n\n调用细节\n\n1. 同一类中的方法调用：直接调用即可\n\n   * 直接输入：方法名（参数）即可\n\n2. 跨类中的方法A类调用B类方法：需要通过对象名调用。比如：对象名.方法名(参数)\n\n\n## 成员方法传参（重要）\n\n基本数据类型\n\n1. ![image-20220310134944831](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310134944831.png)\n2. <span style = \"color:red\">基本数据类型</span>，传递的值（拷贝），形参的任何改变不影响实参！\n\n引用数据类型\n\n1. ![image-20220310140041330](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310140041330.png)\n2. 引用类型传递的是地址（传递也是值，但值是地址），可以通过形参影响实参。\n\n## 递归机制（recursion）\n\n递归调用的本质，是方法的调用\n\n1. ![image-20220310164428690](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310164428690.png)\n2. 栈是先进后出，先出后进（所以图中的test栈2先输出，然后是3，4）\n3. 每次这个栈内的方法执行完成后，外边的方法（图中test方法）都会执行一边\n4. 哪里调用就返回给哪里\n\n### 阶乘（factorial）\n\n![image-20220310203253490](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310203253490.png)\n\n###   递归调用的规则\n\n1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）\n2. 方法的局部变量是独立的，不会相互影响，比如n变量\n3. 如果方法中使用的是引用类型变量（比如数组，或者对象），就会共享该引用类型的数据。\n4. 递归必须像退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:)\n5. 当一个方法执行完毕，或者遇到return，就会执行完毕或者返回时，该方法也就执行\n\n### 斐波拉契数练习\n\n```java\npackage basics;\n\npublic class exerciseRecursion {\n    public static void main(String[] args) {\n        T t = new T();\n        int i = t.racursionNum(4);\n        System.out.println(i);\n\n    }\n\n}\n\nclass T{\n    public int racursionNum(int n1) {\n        if (n1 == 1 || n1 == 2) {\n            return 1;\n        } else {\n            return racursionNum(n1 - 1) + racursionNum(n1 - 2);\n        }\n    }\n}\n\n```\n\n解析图\n\n![image-20220310225335626](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310225335626.png)\n\n\n\n\n\n## 重载（overload）\n\n介绍：java允许同一个类中，多个同名方法的存在，但要求形参列表不一致！！！\n\n好处：\n\n1. 减轻了起名的麻烦\n2. 减轻了记名的麻烦\n\n注意细节：\n\n1. 方法名：必须相同\n2. 形参参列表：必须不同（参数类型或个数或顺序，至少有一样不同）\n3. 返回类型：无要求\n\n## 可变参数\n\n介绍：\n\njava允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法。\n\n基本语法：\n\n```java\n访问修饰符\t 返回类型\t方法名（数据类型 .... 参数名）{\n}\n```\n\n案例\n\n```java\nclass hasMestod{\n/*\n    public int sum(int a,int b){\n        return a+b;\n    }\n    public int sum(int a,int b,int c){\n        return a+b+c;\n    }\n    public int sum(int a,int b,int c,int d){\n        return a+b+c+d;\n    }\n//    ........以此类推\n*/\n\n//    可变参数优化\n//    上面三个方法名称相同，功能相同，只是参数个数不同---->使用可变参数优化\n//    1.int...表示接收的是可变参数，类型时int，即可以接收多个int（0-多）\n//    2.使用可变参数时，可以当做数组；来使用，即nums 可以当做数组使用\n    public  int sum1(int... nums){\n        System.out.println(\"接收的个数为\"+nums.length);\n        int sum = 0;\n        for (int i = 0; i < nums.length ; i++) {\n            sum=sum+nums[i];\n        }\n        return sum;\n    }\n\n}\n```\n\n注意事项：\n\n1. 可变参数的实参可以为0或任意多个\n\n2. 可变参数的实参可以为数组\n\n3. 可变参数的本质就是数组\n\n   \n\n4. 可变参数可以和普通类型的参数<u>*一起放在形参列表*</u>，但必须保证可变参数在最后\n\n5. 一个形参列表中只能出现一个可变参数\n\n\n\n## 作用域\n\n1. 在java中，主要的变量就是属性（成员变量）和局部变量\n2. 我们说的局部变量一般是指在成员方法中定义的变量\n3. 作用域的分类\n   1. 全局变量：也就是属性，作用域为整个整体\n   2. 局部变量：也就是除了属性以外的其他变量，作用域为定义它的代码块中\n4. 全局变量可以不赋值，直接使用，因为有默认值（也可指定值），局部变量必须赋值后，才能使用，因为没有默认值。    、   \n\n注意事项和细节\n\n1. 属性和局部变量可以重名，访问时遵循就近原则\n2. 在一个作用域中，比如在同一个成员方法中，两个局部变量，不能重\n3. 属性生命周期较长，伴随对象的创建而创建，伴随对象的死亡而死亡。局部变量，生命周期较短，伴随它的代码块的执行而创建，伴随代码块的结束而死亡\n4. 作用域范围不同：\n   1. 全集变量/属性：可以被本类使用，或其他类使用（通过对象调用）\n   2. 局部变量：智能在本类中对应的方法中使用\n5. 修饰符不同\n   1. 全局变量/属性可以加修饰符\n   2. 局部变量不可以加修饰符\n\n## 构造器(constructor)\n\n基本介绍：构造方法又称构造器(constructor)，是类的一种特殊方法，它的主要作用是完成对<span style = \"color:red\">新的对象初始化。</span>\n\n\n\n特点：\n\n1. 方法和类名相同\n2. 没有返回值\n3. 在创建对象时，系统会自动调用该类的构造器完成对对象的初始化\n\n\n\n需求案例：\n\n案例1:创建一个人类的对象，显示把一个对象创建好后，再给他的年龄姓名等属性赋值，如果现在我要求，在创建人类对象的时候，就直接指定这个对象的年龄和姓名。 此时可以使用构造器\n\n基本语法：\n\n```java\n[修饰符] 方法名(形参列){\n\n\t方法体;\n\n}\n```\n\n1. 构造器的修饰符可以默认，也可是public，protected，private\n2. 构造器没有返回值,也不能写void\n3. 方法名和类名必须一样\n4. 参数列表和成员方法一样的规则\n5. 构造器的调用<span style = \"color:red\">系统完成</span>\n\n\n\n细节：\n\n1. 一个类可以定义多个不同的构造器，即构造器的重载\n   * 比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄\n   * ![image-20220314163037454](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314163037454.png)\n2. 构造器是完成对象的初始化，并不是创建对象\n3. 如果程序员没有定义构造器，系统会自动生成一个默认的无参构造器(也叫默认构造方法),比如Person(){ }\n4. 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的午餐构造器，除非显示的定义一下，即自己再手写一边Person(){ }\n\n\n\n\n\n\n\n对象创建流程\n\n```java\nclass Person{\n\tint age =90;\n\tString name;\n\tPerson(String n , int a){\n\tname = n;\n\tage = a;\n\t}\n}\n\n\nPerson p = new Person(\"zhangsan\" , 20);\n```\n\n![image-20220314215432778](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png)\n\n```\n1. 先在方法区加载Person类\n2. 在堆中开辟一个空间，内部存放形参\n   1. 先初始化默认值，0和null，然后再将值赋进去\n   2. 当执行到构造器的时候，值才会赋进去\n   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值\n3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)\n```\n\n1. 加载Person.class，只会加载一次。\n\n2. 在堆中分配空间(地址)\n\n3. 完成对象初始化\n\n   3.1 默认初始化 age=0\tname = null\t\n\n   3.2 显示初始化 age=90,name=null,\n\n   3.3 构造器的初始化 age=20，name=zhangsan\n\n4. 在对象堆中的地址，返回给p(也可理解成对象的引用)\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n## this\n\n案例：\n\n```java\nclass Person{\n\tString name;\n\tint age;\n/*\n\t旧方法：\n\t\tint age =90;\n\t\tString name;\n\t\tPerson(String n , int a){ //此时形参的起名不能与属性名一致\n\t\tname = n;\n\t\tage = a;\n     1.如果可以将构造器的形参，直接写成属性名就好了\n     2.但是会出现一个问题，根据变量的作用域原则\n     3.构造器的name 是局部变量，而不是属性。相当于自己赋给自己\n     4.构造器的age 是局部变量，而不是属性、\n     5.==>此时使用this关键字\t\n*/\n    public Person(String name,int age){\n        this.name/*表示当前对象的属性*/ = name;/*表示当前构造器的局部变量*/\n        this.age = age;\n    }\n\t \n}\n```\n\n介绍：\n\njava虚拟机会给每个对象分配this，代表当前对象。\n\n分析图：\n\n每一个对象都有一个隐藏的属性this\n\n这个this它指向自己\n\n![image-20220314222909415](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314222909415.png)\n\n简单说，哪个对象调用this就指向哪个对象\n\n\n\n\n\n注意事项：\n\n1. this关键字可以用来访问本类的属性，方法，构造器\n\n2. this用于区分当前类的属性和局部变量\n\n3. 访问成员方法的语法：this.方法名(参数列表)；\n\n4. 访问构造器语法：this(参数列表);//注意，只能在构造器中访问另外一个构造器(当有访问构造器的语法this时，必须放在构造器语句里的第一行 )\n\n   * ```java\n     class T{\n         String name;\n         int age;\n     \t//无参构造器\n     \tpublic T(){\n             //当执行无参构造器时，我们想去访问有参构造器\n             this(\"zhangsan\",12);//这样访问有参构造器\n            //当有访问构造器的语法this时，必须放在构造器语句里的第一行 \n            \n     \t\tSystem.out.println(\"T() 构造器\");\n             \n             \n             \n     \t}\n     \t\n     \t//有参构造器\n     \tpublic T(String name,int age){\n             System.out.println(\"T(String name,int age) 构造器\");\n         }\n     }\n     ```\n\n5. this不能再类定义的外部使用，只能在类定义的范围中使用\n\n```java\npackage chapterObject;\n/*\n* 创建一个employee类\n* 属性有（名字，性别，年龄，职位，薪水）\n* 提供三个构造器\n* 1.名字，性别，年龄，职位，薪水\n* 2.名字，性别，年龄\n* 3.职位，薪水*/\npublic class ObjectHomeWork06 {\n}\nclass Employee{\n    String name;\n    char sex;\n    int age;\n    String post;\n    double salary;\n\n    public Employee(String name,char sex,int age){\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n    public Employee(String post,double salary){\n\n        this.post = post;\n        this.salary = salary;\n    }\n    public Employee(String name,char sex,int age,String post,double salary){\n        this(name, sex, age);\n//        因为构造器调用只能放在第一行，所以最多只能调用一个构造器\n        this.post = post;\n        this.salary = salary;\n    }\n\n//    public Employee(String name,char sex,int age,String post,double salary){\n//        this.name = name;\n//        this.sex = sex;\n//        this.age = age;\n//        this.post = post;\n//        this.salary = salary;\n//\n//    }\n}\n\n\n```\n\n\n\n# 面向对象（中级）\n\n## idea\n\n### 快捷键\n\n```\n自定义快捷键\nsettings - - > Keymap\n删除当前行 ctrl+y  自定义 alt+D\n复制当前行 ctrl+d\n\n快速格式化代码 ctrl + alt + L\n快速运行程序  自定义alt + R\n\n查看类的层级关系 ctrl + H\n将光标放在一个方法上，输入ctrl+b，可以定位到该方法的上\n自动分配变量名   在后面添加.var\n例：new Scanner(System.in).var+回车\n会生成Scanner scanner = new Scanner(System.in);\n```\n\n### 模板\n\n 设置路径\n\nfile -> settings -> editor -> live templates->\n\n可以自己自定义，也可查看预设的模板\n\n\n\n\n\n\n\n\n\n## 包\n\n三大作用：\n\n1. 区分相同名字的类\n2. 当类不同的时候，可以很好的管理\n3. 控制访问范围\n\n基本语法：\n\npackage com.xxx;\n\n1. package 关键字，表示打包\n2. com.xxx:表示包名\n\n包的本质\n\n就是创建不同的文件/目录保存文件\n\n\n\n### 包的命名\n\n规则：\n\n智能包含数字，字母，下划线，小圆点，但不能用数字开头，不能是关键字或保留字\n\n```java\ndemo.class.exec1 //falsee不允许有关键字class\ndemo.12\t\t//false,不能数字开头\ndemo.ad12.oa //true\n```\n\n规范\n\n一般是小写字母+小圆点\n\ncom.公司名.项目名.业务模块名\n\n例：com.alibaba.taobao.login\n\n```java\ncom.sina.crm.user\n等等\n```\n\n### java常用的包\n\n```java\njava.lang // lang包是基础包，默认引入，不用手动输入\n\njava.util //系统提供的工具包，工具类，例如Scanner类\n\njava.net // 网络包，网络开发\n\njava.awt  // 是做java的界面开发，GUI\n```\n\n\n\n包的引入\n\n建议需要什么类就引入什么类，不建议(java.util.* )全部引入\n\n\n\n\n\n\n\n## 访问修饰符\n\n介绍\n\njava提供了四种访问控制修饰符号控制方法和属性(成员变量)的访问权限(范围)\n\n1. 公开级别：public 修饰，对外公开\n2. 受保护级别：用protected修饰，对子类和统一包中的类公开\n3. 默认级别：没有修饰符号，向同一包的内公开\n4. 私有级别：用private修饰，只有类本身可以访问，不对外公开\n\n![image-20220317140746725](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220317140746725.png)\n\n注意事项：\n\n1. 修饰符可以用修饰类中的属性，成员方法以及类\n2. 只有默认的和public才能修饰类，并且遵循上述访问权限的特点\n3. 成员方法访问规则和属性完全一样\n\n\n\n\n\n\n\n\n\n\n\n\n\n## <u>*封装*</u>（重要）\n\n封装（encapsulation）就是把抽象出来的数据[**属性**]和对数据的操作[**方法**]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[**方法**]，才能对数据进行操作。\n\n**封装的好处**\n\n1. 隐藏实现细节  方法(连接数据库)<----调用(传入参数)\n2. 可对数据进行验证，保证安全合理\n\n\n\n封装的实现步骤 ( 三 步 ) \n\n1. 将属性进行私有化，private\n\n2. 提供一个公共的set方法，对属性进行判断并赋值\n\n   ```java\n   public void setXXX(类型\t参数名){\n   //加入数据验证的业务逻辑\n   属性 = 参数名；\n   }\n   ```\n\n3. 提供一个公共的get方法，用于获取属性的值\n\n   ```java\n   public void getXXX(类型\t参数名){\n   \treturn xx;\n   }\n   ```\n\n   \n\n\n\n## <u>*继承*</u>（重要）extends\n\n### 继承作用：\n\n解决代码复用性\n\n### 介绍：\n\n相当多个类存在相同的属性（变量）  和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些属性和方法，只需通过extend来声明继承父类即可\n\n###  基本语法\n\n```java\nclass 子类 extends 父类{\n\n}\n1. 子类会自动拥有父类定义的方法\n2. 父类又叫超类，基类\n3. 子类又叫派生类\n\n```\n\n示意图\n\n![image-20220318104942566](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318104942566.png)\n\n\n\n### 注意事项\n\n1. 子类继承了所有的属性和方法，但是私有属性不能再子类直接访问，需要通过公共方法访问\n\n2. 子类必须调用父类的构造器，完成父类的初始化\n\n3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中调用super去指定使用父类的那个构造器完成对父类的初始化工作，否则编译不通过\n\n4. 如果希望指定去调用父类的某个构造器，则显式的调用一下{super ( 参数 ) }\n\n5. super在使用时，需要放在第一行。super只能在构造器中使用\n\n6. super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器\n\n7. java所有类都是Object的子类，是所有类的基类   Ctrl+H可以看到类的继承关系\n\n   ![image-20220318165601997](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318165601997.png)\n\n8. 父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类)\n\n9. 子类对多只能继承一个父类(指直接传承)，即java中是单继承机制。\n\n10. 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系\n\n    1. person is a music\n    2. person music\n    3. music extends  person \n\n\n\n### 继承的本质（分析）\n\n当子类创建号对象以后，建立查找关系\n\n```java\n//案例：\nclass Grandpa{\n\tString name = \"爷爷\";\n\tString hobby = \"旅游\";\n}\n\nclass Father extends GrandPa{\n\tString name = \"大头爸爸\";\n\tint age = 30;\n}\n class Son extends Father{\n \tString name = \"儿子\";\n }\n \n \n Son son = new Son();\n son.name=?      //儿子\n son.age = ?\t //30\t\n son.hobby = ?\t // 旅游\n //\t\t1. 此时请注意，要按照查找关系返回信息\n /*     2. 首先看子类是否有该属性\n \t\t3. 如果子类有这个属性，并且可以访问，则返回信息\n \t\t4. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回)\n \t\t5. 如果父类没有4的规则，继续找上级，直到object\n   */  \n```\n\n### 内存原理图：\n\n ![image-20220320170828664](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320170828664.png)\n\n## Super\n\n### 基本介绍\n\nsuper代表父类的构造器，用于访问父类的属性，方法，构造器\n\n### 基本语法\n\n1. 访问父类的属性，但不能访问父类的private属性[案例]\n   * super.属性名；\n2. 访问父类的方法名，不能访问父类的private方法\n   * super.方法名(参数列表);\n3. 访问父类的构造器(这点前面用过);\n   * super(参数列表);\n   * 只能放在构造器的第一句并只能出现一句\n\n### 细节和注意事项\n\n1. 调用父类的构造器的好处（分工明确，弗雷属性由父类初始化，子类的属性由子类初始化）\n\n2. 当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果\n\n   * ```java\n     案例\n     class A{\n     \tpublic void cal(){\n     \t\tSystem.out.println(\"a类的cal方法\");\n     \t}\n     }\n     class B{\n     \tpublic void sum(){\n     \t\tSystem.out.println(\"b类的sum方法\");\n     \t/*\t\n     \t\t此时有三种方法调用cal\n     \t\t1. 找cal方法时，顺序是：先找本类，如果有，开始调用。\n     \t\t2. 如果没有。则找父类（如果有则调用）\n     \t\t3. 如果父类没有则继续找父类的父类。以此类推。直到Object类‘\n     \t\t\n     \t\t提示：如果查找的过程中找到了，但不能访问，则报错\n     \t\t\t 如果查找的过程中没找到。则提示没找到\n     \t*/\n         \tcal();\n             \n            \n             this.cal();//等价cal（）；\n             \n              /*\n             跳过本类直接查找父类\n             其他规则一样\n             */\n             super.cal();\n             \n     \t}\n     }\n     ```\n\n3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。（相当于跳过本类，从父类开始按规则找。父类找不到找爷爷类·····）\n\n### super和this的比较\n\n![image-20220320190806497](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190806497.png)\n\n![image-20220320190935663](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190935663.png)\n\n## 重写（overwrite）\n\n### 基本介绍\n\n简单地说：方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这方法覆盖了父类的方法。\n\n### 案例\n\n```java\nclass Animal{\n\tpublic void cry(){\n\t\tSystem.out.println(\"叫\");\n\t}\n}\n/*\n\t1. 因为dog是Animal的子类\n    2. Dog的cry方法和Animal的cry方法定义形式一样(名称，返回类型，参数)\n    3. 这时我们就说Dog的cry方法，重写了Animal的cry方法\n  */      \nclass dog extends Animal{\n\tpublic void cry(){\n\t\tSystem.out.println(\"汪汪汪\");\n\t}\n}\n```\n\n### 注意事项和使用细节\n\n1. 子类的方法的形参列表，方法名称，要和父类的方法的参数，方法名称完全一样。\n\n2. 子类方法的返回类型和父类方法返回类型一样，或者父类返回类型的子类\n\n   比如 父类返回类型是Object，子类方法返回类型是String\n\n   ```java\n   public Object getInfo(){}\n   ```\n\n   ```java\n   public String getInfo(){}\n   ```\n\n3. 子类方法不能缩小父类方法的访问权限public > protected > 默认(default ) > private \n\n   ```java\n   void sayOk(){}\n   ```\n\n   ```java\n   public void sayOk(){}//这样是可以的，但不能缩小\n   ```\n\n### 重写与重载的区别\n\n![image-20220320211941817](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320211941817.png)\n\n练习\n\n```java\npackage seatWork;\n\npublic class override {\n    /*\n    * 1. 编写一个Person类，包括属性/private（name,age），\n    * 构造器，方法say（返回组我介绍的字符串）\n    * 2. 编写一个student类，继承Person类，增加id，score属性/private，\n    * 以及构造器，定义say方法（返回自我介绍信息）\n    * 3. 在main方法中，分别创建Person和Student对象，调用say方法输出自我介绍*/\n\n    public static void main(String[] args) {\n        Person person = new Person(\"lisi\", 123);\n        String say1 = person.say();\n        System.out.println(say1);\n\n        Student student = new Student(\"zhangsan\",12,12345,100);\n        String say = student.say();\n        System.out.println(say);\n    }\n}\nclass Person{\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String say(){\n        System.out.println(\"我是父类\");\n//        System.out.println(\"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\");\n        return \"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\";\n    }\n}\n\nclass Student extends Person{\n    private int id;\n    private double score;\n\n    public Student(String name, int age, int id, double score) {\n        super(name, age);\n        this.id = id;\n        this.score = score;\n    }\n    public int getId() {\n        return id;\n    }\n    public void setId(int id) {\n        this.id = id;\n    }\n    public double getScore() {\n        return score;\n    }\n    public void setScore(double score) {\n        this.score = score;\n    }\n\n    public String say(){\n        return super.say()+\"id\"+getId()+\"\\t\"+\"score\"+getScore()+\"\\t\";\n//        System.out.println(\"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\"\n//        +\"id\"+getId()+\"\\t\"+\"score\"+getScore()+\"\\t\");\n    }\n}\n```\n\n## <u>*多态*</u>（重要）\n\n 多态可以提高代码的复用性\n\n### 基本介绍\n\n多态(多种)（状态）\n\n1. 方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础之上的额\n\n### 多态的具体体现\n\n#### 方法上体现\n\n1. 方法的多态\n\n   重写和重载就体现多态\n\n2. 案例说明\n\n3. 重载上体现\n\n   1. 对某一方法，传入不同的参数，调用不同的方法\n   2. ![image-20220320215939959](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320215939959.png)\n\n\n\n\n\n### 对象的多态（核心，难点，重点）\n\n要记住几点：\n\n1. 一个对象的编译类型和运行类型可以不一致\n\n   * ```\n     例如：\n     Animal animal = new Dog();【animal编译类型时Animal，运行类型是Dog】\n     animal  = new Cat(); \t【animal的运行类型变成了Cat，编译类型仍然是Animal】\n     ```\n\n2. 编译类型在定义对象时，就确定了，不能改变\n\n   * ```\n     Animal animal = new Dog()   编译类型在定以后就不能改变，所以可以直接用引用接收其他的运行类型\n     animal  = new Cat();\n     animal  = new PIG();`````\n     ```\n\n3. 运行类型是可以变化的\n\n4. 编译类型看定义时 = 号的左边，运行类型看 = 号的右边\n\n   * ```\n     Animal animal = new Dog()  animal就是变异类型，dog就是运行类型\n     ```\n\n```java\n//编译类型和运行类型的体现\nclass Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"动物在叫\");\n\t}\n}\nclass Cat extends Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"猫在叫\");\n\t}\n}\n\nclass Dog extends Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"狗在叫\");\n\t}\n}\n\nclass test{\n\tpublic static void main(String[] args){\n\t\t//animal编译类型就是Animal，运行类型Dog\n\t\tAnimal animal = new Dog();\n\t\tanimal.say();//因为运行类型是dog，animal的运行类型是dog，所以输出dog类的say方法。\n\t\t\n        animal = new Cat();\n        animal.say();//此时animal的运行类型是cat，所以输出cat类的say方法；\n    }\n}\n```\n\n\n\n### 注意事项和细节\n\n多态的前提是：两个对象(类)存在继承关系\n\n#### 多态的向上转型\n\n1. 本质：父类的引用指向了子类的对象\n\n2. 语法：父类类型    引用名 = new    子类类型()；\n\n   ```java\n   Father father = new Son();\n   //此时可称为向上转型\n   ```\n\n3. 特点：编译类型看左边，运行类型看右边\n\n   <span style=\"color:red;\">可以调用父类中的所有成员(需要遵循访问权限),</span>\n\n   <span style=\"color:red;\">不能调用子类中特有成员</span>\n\n   （<span style=\"color:red;\">因为在编译阶段，不能调用那些成员，是由编译类型来决定的。</span>）\n\n   最终运行效果按子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法\n\n   然后调用，与前面的方法调用规则一致\n\n#### 多态的向下转型\n\n语法：子类类型   引用名 = (子类类型) 父类引用;\n\n1. 只能强转父类的引用，不能强转父类的对象\n\n   ```java\n   //此时的向上转型\n   Animal animal = new Cat();\n   adimal.a();\n   //等等方法，这些方法只能调用父类子类的共同拥有的方法，不能调用子类的特殊方法\n   \n   //此时这样写\n   //强转一下，上述父类的引用\n   Cat cat =  (Cat)animal；\n       cat.catchMouse();\n   ```\n\n   \n\n2. 要求父类的引用必须指向的是当前目标类型的对象\n\n   ```java\n   //也就是说animal必须是指向对应的子类\n   Animal animal = new Cat();//必须有这句话\n   Cat cat =  (Cat)animal；//才能强转成cat类型\n   \n   ```\n\n   \n\n3. 可以调用子类类型中所有的成员\n\n\n\n#### 属性没有重写之说\n\n属性的值看编译类型\n\n```java\n例:\nclass A{\n\tint count = 1;\n}\nclass B extends A{\n\tint count = 2;\n}\n\npublic class test{\n\tpublic static void main(String[] atgs){\n\t\tA a = new B();\n\t\tpublic.out.print(a.count);\n            \n        //此时输入的值为1\n        //因为属性的值是看编译类型\n            \n        B b = new B();\n        public.out.print(a.count);\n        //此时输出2\n\t}\n}\n```\n\n\n\n#### instanceOf比较操作符，\n\n用于判断对象的类型是否为xx类型或xx类型的子类型\n\n判断对象的运行类型是否为xx类型，或这个xx类型的子类型\n\n```java\nclass A{\n\tint count = 1;\n}\nclass B extends A{\n\t count = 2;\n}\npublic class test{\n\tpublic static void main(String[] atgs){\n\tBB bb = new BB();\n\tpublic.out.print(bb instanceof BB);//true\n\tpublic.out.print(bb instanceof AA);//true\n       \n        \n        //编译类型AA ，运行类型BB\n     AA aa = new AA();\n        public.out.print(aa instanceof AA);//true\n       public.out.print(aa instanceof BB);//true \n        \t\n     Object obj   = new Object();\n        public.out.print(obj instanceof AA);//false,因为obj不是AA类，也不是AA的子类\n        \n}}\t\n```\n\n#### java动态绑定机制(重要) \n\n1. 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定\n2. 当调用对象属性时，没有动态绑定机制，哪里声明，那里使用\n\n```java\nclass A{\n\tpublic int i =10;\n\t//2\n\tpublic int sum(){\n        //3  \n\t\treturn geti()+10;//5\n\t}\n\t\n\tpublic int sum1(){\n\treturn i+10;\n\t}\n\tpublic int geti(){\n\treturn i;\n\t}\n}\n\nclass B{\n\tpublic int i =10;\n\t\n\tpublic int sum1(){\n\treturn i+10;\n\t}\n    //4\n\tpublic int geti(){\n\treturn i;\n\t}\n}\n\n\nA a  = new B()\n   //1\na.sum //40\n    \n   \n//因为执行到sum方法，开始准备执行geti方法时，因为有java动态绑定的机制，会跳到b类的geti方法执行\n    //再根据继承跳回去\n```\n\n\n\n####  多态的应用\n\n1）多态数组\n\n数组的定义类型为父类类型，里面保存的实际元素类型为子类型\n\n```java\npackage seatWork;\nimport java.security.PrivateKey;\n\npublic class polySeatwork {\n    public static void main(String[] args) {\n        /*\n        * 要求创建一个person对象name ，age\n        * 两个student 对象和2个teacher对象，统一放在数组中，\n        * 并调用每个对象的say方法\n        * */\n        Person1[] person1s = new Person1[5];\n        person1s[0] = new Person1(\"human\",00);\n        person1s[1] = new Student1(\"tom1\",12,150);\n        person1s[2] = new Student1(\"tom2\",13,143);\n        person1s[3] = new teacher(\"zhangsan\",30,4000);\n        person1s[4] = new teacher(\"lisi\",28,5000);\n\n        //循环遍历多态数组，调用say方法\n        for (int i = 0; i < person1s.length ; i++) {\n            //老韩提示， person1s[i]的编译类型是Person，\n            // 运行类型是根据实际情况而变化\n            System.out.println(person1s[i].say());\n        }\n    }\n}\nclass Person1{\n    private String name;\n    private int age;\n\n    public Person1(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String say(){\n        return \"name = \"+name+\"age = \"+age;\n    }\n}\n\nclass Student1 extends Person1{\n\n    private double score;\n\n    public Student1(String name, int age, double score) {\n        super(name, age);\n        this.score = score;\n    }\n    public double getScore() {\n        return score;\n    }\n    public void setScore(double score) {\n        this.score = score;\n    }\n\n    @Override\n    public String say() {\n        return super.say()+\"score = \"+score;\n    }\n    public void study(){\n        System.out.println(getName()+\"学习······\");\n    }\n}\n\nclass teacher extends Person1{\n    private double salary;\n\n    public teacher(String name, int age, double salary) {\n        super(name, age);\n        this.salary = salary;\n    }\n    public double getSalary() {\n        return salary;\n    }\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n\n    @Override\n    public String say() {\n        return super.say()+\"salary = \"+salary;\n    }\n    public void teach(){\n        System.out.println(getName()+\"教书·············\");\n    }\n}\n```\n\n案例升级：如何调用子类的特有方法，比如Teacher 有一个teach，Student有一个study方法。如何调用?\n\n```java\n//循环遍历多态数组，调用say方法\n        for (int i = 0; i < person1s.length ; i++) {\n            //老韩提示， person1s[i]的编译类型是Person，\n            // 运行类型是根据实际情况而变化\n\n            //判断person1s[i]的运行类型\n            if ( person1s[i] instanceof Student1){\n               Student1 student1 =  (Student1)person1s[i];\n               student1.say();\n               //也可以写成一条语句\n               ((Student1)person1s[i]).study();\n            }else if (person1s[i] instanceof teacher){\n                ((teacher)person1s[i]).teach();\n            }else{\n                System.out.println(\"============类型有误==============\");\n            }\n            System.out.println(person1s[i].say());\n        }\n```\n\n#### 多态参数\n\n方法定义的形参类型为父类型，实参类型允许为子类类型\n\n* polyParameter.java\n\n* ```java\n  package seatWork;\n  \n  public class polyParameter {\n      /*\n      * 定义员工类Employee，包含姓名和月工资[private]，以及计算年工资getAnnual的方法。\n      * 普通员工和经理继承了员工，经理类多了奖金bonus属性和管理manage方法，\n      * 普通员工类多了work方法，普通员工和经理类要求分别重写getAnnual方法\n      *\n      *\n      * 测试类中添加一个方法showEmployAnnual（Employee e ),\n      * 实现获取任何员工对象的年工资，\n      * 并在main方法中调用该方法[e.getAnnual()]\n      *\n      * 测试类中添加一个方法，testWork，如果是普通员工，\n      * 则调用work方法，如果是经理，则调用manage方法\n  */\n      public static void main(String[] args) {\n          GeneralStaff staff = new GeneralStaff(\"zhangsan\", 5000);\n          Manager manager = new Manager(\"lisi\", 5000, 10000);\n          polyParameter polyParameter = new polyParameter();\n          polyParameter.showEmployAnnual(staff);\n          polyParameter.showEmployAnnual(manager);\n  \n          polyParameter.testWork(staff);\n          polyParameter.testWork(manager);\n  \n      }\n      public void showEmployAnnual(Emplyee e){\n  \n          System.out.println(e.getAnnual());\n      }\n      /*\n      * 添加一个方法，testwork\n      * 如果是普通员工，则调用work方法\n      * 如果是经理则调用manage方法\n      * */\n      public void testWork(Emplyee e){\n          if (e instanceof GeneralStaff){\n              ((GeneralStaff) e).work();//向下转型\n          }else if (e instanceof Manager){\n              ((Manager) e).manage();//向下转型\n          }\n      }\n  \n  \n  }\n  class Emplyee {\n      private String name;\n      private double salary;\n  \n      public Emplyee(String name, double salary) {\n          this.name = name;\n          this.salary = salary;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public double getSalary() {\n          return salary;\n      }\n  \n      public void setSalary(double salary) {\n          this.salary = salary;\n      }\n  \n      public double getAnnual(){\n          double tmp = 12*salary;\n  \n          return tmp;\n      }\n  }\n  \n  class GeneralStaff extends Emplyee{\n  \n      public GeneralStaff(String name, double salary) {\n          super(name, salary);\n      }\n  \n      @Override\n      public double getAnnual() {\n          return super.getAnnual();\n      }\n  \n      public void work(){\n          System.out.println(\"work method\");\n      }\n  }\n  class Manager extends Emplyee{\n      private double bonus;\n  \n      public Manager(String name, double salary,double bonus) {\n          super(name, salary);\n          this.bonus = bonus;\n      }\n  \n      public void manage(){\n          System.out.println(\"manage method\");\n      }\n  \n      @Override\n      public double getAnnual() {\n          return super.getAnnual()+bonus;\n      }\n  }\n  \n  ```\n\n\n## Obeject类详解\n\n类Object是类的层次结构的根类，每个类都使用Object作为超类，所有对象(包括数组)都实现了这个类的方法\n\n#### equals\n\n==和equals的对比\n\n==是一个比较运算符\n\n1. 既可以判断基本类型，又可以判断引用类型\n2. 如果判断基本类型，判断值是否相等。例如：int i = 10; double b = 10.0;\n3. 如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象\n\n\n\n \n\nequals：是Object类中的方法，只能判断引用类型，\n\n判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等\n\n案例：\n\n```java\npackage seatWork;\n\npublic class equalsExercise {\n    public static void main(String[] args) {\n        Person02 person02 = new Person02(\"zhangsan\", 123, '男');\n        Person02 person03 = new Person02(\"zhangsan\", 123, '男');\n        //在没有重写equals方法时是不相等，此时的方法时比对是否指向同一对象\n        System.out.println(person02.equals(person03));\n    }\n}\nclass Person02{\n//    判断两个Person是否相等\n    private String name;\n    private int age;\n    private char gender;\n\n    public Person02(String name, int age, char gender) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public char getGender() {\n        return gender;\n    }\n\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    public boolean equals(Object obj) {\n//        1. 先判断两个是否指向同一对象\n        if (this == obj){\n            return true;\n        }\n//        2.进行类型判断\n        if (obj instanceof Person02) {\n//            3.向下转型，得到所有的属性信息进行比对\n            Person02 person02 = (Person02) obj;\n            return this.name.equals(person02.name)&&this.age== person02.age&&this.gender==person02.gender;\n        }\n//        如果不是Person类型，则直接返回false\n        return false;\n    }\n\n}\n\n```\n\n#### hashCode\n\n介绍：\n\n返回对象的哈希码值，支持此方法是为了提高哈希表的性能\n\n实际上，由object类定义的hashCode方法确定会针对不同的对象返回不同的证书，(这一般是通过将该对象的内部地址转移换成一个整数来实现的，但是java编程语言不需要这种实现技巧)\n\n老韩六小结：\n\n1. 提高具有哈希结构容器的效率\n\n2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的\n\n3. 两个引用，如果指向的是不同的对象，则哈希值是不一样的（极大概率不一样）\n\n4. 哈希值主要根据地址号来的！，不能完全将哈希值等价于地址\n\n5. 案例演示obj.hashCode() [测试 A obj1 = new A(); A obj2 = new A(); A obj3 = obj1]\n\n   ```java\n   package seatWork;\n   \n   public class hashCodeExcise {\n       public static void main(String[] args) {\n           A a = new A();\n           A a1 = new A();\n           A a3 = a;\n           System.out.println(\"a.hashCode() = \"+a.hashCode());       System.out.println(\"a1.hashCode() = \"+a1.hashCode());       System.out.println(\"a3.hashCode() = \"+a3.hashCode());\n       }\n   }\n   class A{\n   }\n   \n   ```\n\n   ![image-20220323164744164](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220323164744164.png)\n\n6. 后面在集合，中hashCode如果需要的话，也会重写\n\n#### toString\n\n介绍：\n\n默认返回：全类名+@+哈希值的十六进制，[查看object的tostring方法]\n\n子类往往会重写toString方法，用于<span style=\"color:red;background:yellow\">返回对象的属性信息</span>\n\n重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。\n\n\n\n当直接输出一个对象时，toString方法会被默认的调用\n\n```\nSystem.out.print(xxx);\n等价于System.out.print(xxx.toString);\n```\n\n\n\n#### finalize()\n\n介绍：\n\n当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法\n\n1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作\n2. 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制销毁该对象，在销毁该对象前，会先调用finalize方法\n3. 垃圾回收机制的调用，是由系统来决定的(即有自己的GC算法 )，也可以通过System.gc()主动触犯垃圾回收机制\n\n## 断点调试（debug）\n\n#### 提示：\n\n在断点调试的过程中，是运行状态，是以对象运行类型来执行的\n\n#### 介绍：\n\n​\t断点调试是指程序在的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步一步往下调，调试过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug。\n\n#### 快捷键\n\n* F7（跳入）\n  * 跳入方法内\n* F8（跳过）\n  * 逐行执行代码\n* shift+F8（跳出）\n  * 跳出方法\n* F9（resume，执行到下一个断点）\n\n![image-20220324141333874](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220324141333874.png)\n\n\n\n# 面向对象（高级）\n\n## 类变量和类方法\n\n### 一、类变量\n\n案例理解：\n\n```java\npublic Child{\nprivate String name;\n\n    \n//定义一个变量count，是一个类变量（静态变量）static静态\n    //该变量最大的特点就是会被Child类的所有的对象实例共享\npublic static int count = 0;\n\npublic Child （String name）{\n     this.name = name;\n}\n    public void join(){\n        System.out.println(name+\"加入了游戏····\")\n    }\n}\n\n\n\nmain(){\n    //定义一个变量count，统计多少小孩加入了游戏\n    //传统方法，定义一个count然后统计\n    //int count  = 0;\n    \n    Child child0 = new Child(\"xiaoming\")；\n        child0.join();\n    \t//count++;\n    \n    //改进后\n    \tchild0.count++;\n    \n    Child child1 = new Child(\"xiaoming\")；\n        child1.join();\n    \tchild1.count++;\n    \n    Child child2 = new Child(\"xiaoming\")；\n        child2.join();\n    \tchild2.count++;\n    \n    //类变量可以通过类名来访问\n    System.out.println(\"共有\"+child.count+\"小孩加入了游戏\")\n}\n```\n\nstatic变量会开辟一个独立的空间，所以new的对象空间不会再单独创建一个static变量的空间。所以这个static变量空间对于这个类的所有实例是共享的\n\n#### 内存分析\n\n![image-20220402161426676](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220402161426676.png)\n\n1. static变量是对象共享的\n2. 不管static变量在哪\n   1. static变量是同一个类，所有对象共享\n   2. static类变量，在类加载的时候就生成了\n\n#### 定义语法\n\n访问修饰符\tstatic\t数据类型\t变量名；【推荐】\n\nstatic\t访问修饰符\t数据类型\t变量名；\n\n#### 类变量访问\n\n类名.类变量名【推荐】\n\n或者\t\n\n对象名.类变量名 [静态变量的访问修饰符的访问权限和范围和普通属性是一样的]\n\n推荐使用第一种\n\n\n\n#### 使用细节\n\n1. 什么时候使用类变量？\n   * 当我们需要让某个类的所有对象都共享一个变量时，就可以使用类变量（静态变量）：比如上述的统计人数的案例\n2. 类变量与实际变量的区别\n   * 变量是该类的所有对象共享的\n   * 实例变量是每个对象独享的\n3. 加上static成为类变量或静态变量，否则称为实例变量/普通变量/非静态变量\n4. 类变量可以通过<span style=\"color:red\">类名.类变量名</span>或者<span style=\"color:red\">对象名.类变量名</span>来访问。推荐第一种方式访问（前提是得满足访问权限）\n5. 实例变量不能通过<span style=\"color:red\">类名.类变量名</span>方式访问\n6. 类变量是在类加载时就初始化了，也就是说，及时没有创建对象，只要加载类了，就可使用类变量了\n7. 类变量的声明周期是随类的加载开始，随着类的消亡而销毁\n\n### 二、类方法\n\n#### 介绍\n\n类方法也称静态方法\n\n### 格式\n\n````java\n访问修饰符\tstatic\t数据源返回类型\t方法名(){}\t【推荐】\nstatic\t访问修饰符\t数据返回类型\t方法名(){}\n````\n\n\n\n#### 类方法调用\n\n使用方式：\n\n<span style=\"color:red\">类名.类方法名</span>\n\n或\n\n<span style=\"color:red\">对象名.类方法名</span>\n\n#### 使用场景\n\n当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。\n\n比如：工具类中的方法utils\n\nMath类、Arrays类、Collections集合类\n\n#### 使用细节\n\n1. 类方法和普通方法都是随着类的加载而加载，将结构信息储存在方法区：\n   * 类方法中无this的参数\n   * 普通方法中隐含this参数\n2. 类方法可以通过类名调用，也可以通过对象名调用\n3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用\n4. 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以\n5. 类方法(静态方法)中，只能访问 静态变量和静态方法\n6. 普通成员方法，既可以访问静态的成员，非静态的方法。可以访问静态成员和非静态成员\n\n#### 总结：\n\n静态方法，只能访问静态的成员，\n\n非静态方法，可以访问静态的 成员和非静态的成员\n\n（前提是必须遵守访问权限规则）\n\n## 理解main方法语法\n\n#### 深入理解main方法\n\n解释main方法的形式：public static void main(String[] args){}\n\nmain方法是java虚拟机调用的\n\n1. java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public\n\n2. java虚拟机在执行main()方法是不必创建对象，所有该方法必须是static\n\n3. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数\n\n4. java执行的程序 参数1 参数2  参数3\n\n   ![image-20220403184106869](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220403184106869.png)\n\n#### 提示\n\n1. 在main（）方法中我们可以直接调用main方法所在类的静态方法或静态属性\n\n2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，再能通过这个对象去访问类中的非静态成员\n\n3. 例：\n\n   * ```java\n     class A{\n     \tprivate int a;\n     \tprivate static int b;\n     \t\n     \tprivate void a(){\n     \t\tSystem.out.println(\"非静态方法a\");\n     \t}\n     \tprivate static void b(){\n     \t\tSystem.out.println(\"静态方法a\");\n     \t}\n     \t\n     \t\n     \t\n     \tpublic static void main(String[] args){\n     \t\tSystem.out.println(\"id = \" +a);//错误 a是非静态变量，得实例一个对象才能调用\n             System.out.println(\"id = \" +new A().a);//这样是正确的，创建了个匿名对象调用\n             System.out.println(\"id = \" +b);//正确， 因为b是静态变量，可以直接调用\n             System.out.println(\"id = \" +a());//错误，和上述a的非静态变量的原因相同\n             System.out.println(\"id = \" +new A().a());//改成这样就是正确的，因为a()是非静态的方法\n             \n             A a = new A();\n             System.out.println(\"id = \" +a.a());//同理\n     \t}\n     }\n     ```\n\n   * \n\n\n\n## 代码块\n\n#### 介绍\n\n代码块又称初始化块，属于类中的成员【即 是类的一部分】。类似于方法，将罗技语句封装在方法体中，通过{}包围起来\n\n和方法不同，没有方法名，没有返回，没有参数，只有方法体。而且不用通过对象或类显式调用，而是在家类是，或创建对象时隐式调用。\n\n#### 基本语法\n\n```java\n[修饰符]{\n\t代码\n};\n```\n\n#### 注意：\n\n1. 修饰符 可选，要写的话，也只能写static\n2. 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块\n3. 逻辑语句可以为任何罗技语句（输入，输出，方法调用，循环，判断等）\n4. ; 号可以写上，也可以省略。\n\n#### 优点\n\n1. 相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作\n2. 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性\n\n#### 案例\n\n```java\nclass Movie{\n\tprivate String name;\n\tprivate double price;\n\tpricate String director;\n    /*\n    使用场景\n    1. 下面三个构造器都有相同的语句\n    2. 这样重写大量的代码\n    3. 可以吧相同语句提取出来，放到一个代码块中\n    4. 我们不管调用哪个构造器，创建对象，都会先执行代码块\n    5. 代码块调用的顺序都是优先于构造器\n    \n    */\n\t\n\t{\n\t\tSystem.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n\t\n\t}\n    \n    public Movie(String name){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n    }\n    public Movie(String name,double price){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n        this.price = price;\n    }\n    public Movie(String name,double price,String director){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n        this.price = price;\n        this.director = director;\n    }\n}\n```\n\n#### 使用细节\n\n1. static代码块也叫静态代码块，作用就是对类进行初始化，\n\n   而且它随着类的加载而执行\n\n   并且只会执行一次。\n\n   如果是普通代码块，每创建一个对象，就执行\n\n   ```java\n   //静态代码块\n   static{\n   \txxxx;\n   }\n   \n   //普通代码块\n   {\n   \txxxx;\n   }\n   ```\n\n2. 类什么时候被加载？[重要]\n\n   1. 创建对象实例时（new xxx)\n   2. 创建子类对象实例，父类也会被加载\n      1. 先在家父类的代码块，再执行子类的\n   3. 使用类的静态成员时（静态属性，静态方法）\n\n   案例：A类 extends B类的静态块\n\n   ​\t\t\t先执行a的静态块，然后再执行b的\n\n   ![image-20220404151232983](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220404151232983.png)\n\n3. 普通代码块，在创建对象实例时，会被隐式调用。\n\n   被创建一次，就会调用一次\n\n   如果只是使用类的静态成员时，普通代码块并不会执行\n\n   \n\n4. 创建一个对象时，在一个类 调用顺序是（重点，难点）\n\n   1. 调用静态代码块和静态属性初始化\n\n      （注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用\n\n      ```java\n      案例理解\n          \n          因为static的优先级一样，\n          所以哪个写在前面，哪个就先执行\n      class A{\n          \n          private static  int n1 = getn1();\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n      }\n      \n      ============================================\n      输出结果：\n      ============================================\n      use getn1\n      A's static codeBlock\n          \n          \n      =========================分割线=========================\n      //如果更换顺序\n      class A{\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          \n          private static  int n1 = getn1();\n          \n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n      }   \n      ============================================\n      输出结果：\n      ============================================\n       A's static codeBlock\n      use getn1\n         \n      ```\n\n      \n\n   2. 调用普通代码块和普通属性的初始化\n\n      （注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义的顺序调用） \n\n      ```java\n      //先执行静态的，和上述的一样，\n      //然后再执行非静态的，规则也是和上述一样，谁写前面先执行谁\n      class A{\n          private int b = getn2();\n      \n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }\n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      getn2 被调用\n      普通代码块被执行\n          \n          \n      =========================分割线=========================\n      class A{\n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          private int b = getn2();\n      \n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }    \n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      普通代码块被执行\n      getn2 被调用\n      ```\n\n        \n\n   3. 调用构造器\n\n      构造器优先级最低，上述的两个规则执行完成后\n      才会执行构造器\n\n      ```java\n      class A{\n          public A() {\n              System.out.println(\"构造器被执行\");\n          }\n      \n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          private int b = getn2();\n      \n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }\n      \n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      普通代码块被执行\n      getn2 被调用\n      构造器被执行\n      \n      ```\n\n5. 构造器 的最前面其实隐含了super() 和调用普通代码块\n\n   静态相关的代码块，属性初始化，在类加载时，就执行完毕。因此是优先于 构造器和普通代码块执行的\n\n   演示：\n\n   ```java\n   class A{\n   \tpublic A(){\n   \t\t//这里存在隐藏的调用\n   \t\t\t//(1) super();\n   \t\t\t//(2) 调用普通代码块\n   \t\t\t\n   \t\t System.out.println(\"xxxx\");\t\n   \t}\n   }\n   ```\n\n   ```java\n   class AAA{\n       public AAA() {\n           //这里存在隐藏的调用\n           //(1) super();\n           //(2) 调用普通代码块\n           //因为Object的代码块没有输出\n           \n           //1.先输出\n           System.out.println(\"AAA的构造器被调用\");\n       }\n   }\n   class BBB extends AAA{\n       {\n   //        根据规则父类的输出完毕后，再调用方法区\n   //        2. 再执行普通代码块\n           System.out.println(\"bbb的普通代码块执行\");\n       }\n   \n       public BBB() {\n           //这里存在隐藏的调用\n           //(1) super();\n           //(2) 调用普通代码块\n   //        等上述执行完毕后，最后执行该语句\n           System.out.println(\"BBB的无参构造被执行\");\n       }\n   }\n   ```\n\n6. 创建一个子类对象时(继承关系),他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：\n\n   1. 父类的静态代码块和静态属性（优先级一样，按定义的顺序执行）\n   2. 子类的静态代码块和静态属性（优先级一样，按定义的顺序执行）\n   3. 父类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）\n   4. 父类的构造器\n   5. 子类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）\n   6. 子类的构造器\n\n7. 静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任何成员\n\n\n\n## 单例设计模式\n\n#### 介绍\n\n1. 所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且只提供一个取得对象实例的方法\n2. 单例模式有两种方式：1）饿汉式 2）懒汉式\n   1. 二者最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例,而懒汉式在使用时才创建\n   2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题\n   3. 饿汉式存在浪费资源的可能。（因为如果程序员一个对象实例都没使用，那么饿汉式创建的对象就是浪费了，懒汉式是使用时才创建，就不存在这个问题\n   4. 在javaSE标准类中，java.lang.Runtim就是经典的单例设计模式\n\n演示：\n\n1. 恶汉式\n\n   类加载的时候，对象就被创建实例对象，可能会出现创建了，但是没有使用\n\n   步骤：\n\n   1. 构造器私有化 => 防止直接new\n\n   2. 类的内部创建对象\n\n   3. 向外露出一个静态的公共方法。\n\n   4. 代码实现\n\n   5. ```java\n      public class singleDesign {\n          public static void main(String[] args) {\n              System.out.println(GirlFriend.info());\n          }\n      \n      }\n      //有一个女朋友类\n      //只能有一个女朋友\n      class GirlFriend{\n          private String name;\n      \n      \n      //    2.创建一个对象\n      //    3.为了能够接收静态方法，需要修饰为static\n          private static GirlFriend girl = new GirlFriend(info());\n      \n      \n      \n      //    如何保证只能有一个对象实例\n      //    public girlFriend(String name) {\n      //        this.name = name;\n      //    }\n      //    1. 改成私有的构造器\n          private GirlFriend(String name) {\n              this.name = name;\n          }\n      //    4.创建一个静态方法，用于接收实例对象\n          public static String info(){\n              return \"g\";\n          }\n      \n      ```\n\n2. 懒汉式\n\n   使用时才创建实例\n\n   1. 构造器私有化=> 防止直接new\n\n   2. 类的内部创建对象\n\n   3. 向外暴露一个静态的公共方法\n\n   4. ```java\n      public class SingleDesign01 {\n          public static void main(String[] args) {\n              System.out.println(Cat.i);\n      //        此时只是初始化了cat ，但没有创建对象，其他的静态参数可以直接调用\n              System.out.println(Cat.getCat());\n      //        当只有调用了这个方法时，才会创建对象(通过判断发现没有cat类，此时创建后返回)\n          }\n      }\n      //懒汉式\n      //希望在程序运行中，只创建一个cat\n      \n      class Cat{\n          private String name;\n          public static int i =1;\n      //    2.定义一个静态属性static\n          private  static Cat cat;\n      \n      //    3.提供一个公共的static方法 可以返回一个Cat对象\n          public  static  Cat getCat(){\n              if (cat == null){ //如果还没创建对象\n                  cat = new Cat(\"little cute\");\n              }\n              return cat;\n          }\n      \n      //    1.创建私有构造器\n          private Cat(String name){\n              this.name = name;\n          }\n      }\n      ```\n\n      \n\n## final关键字\n\n#### 介绍\n\nfinal / 最后的，最终的\n\nfianl 可以修饰类、属性、方法和局部变量\n\n某些情况下，程序员可能有以下需求，就会使用到final：\n\n1. 当不希望类被继承时，可以用final修饰\n2. 当不希望父类的某个方法可以被子类覆盖/重写（override）时，可以用final关键字修饰\n3. 当不希望类的某个属性的值被修改，可以使用final修饰\n4. 当不希望某个局部变量被修改，可以使用final修饰\n\n\n\n#### 使用细节\n\n1. final修饰的属性又叫常量，一般用XX_XX_XX来命名\n\n2. final修饰的属性在定义时，必须赋初始值，并且以后都不能修改，赋值可以在如下位置之一（选择一个位置赋初始值即可）\n\n   1. 定义时：例如  public final double TAX_PATE=0.09;\n\n   2. 在构造器中\n\n   3. 在代码块中\n\n   4. ```java\n      class A{\n      //定义时赋值\n      \tpublic final double ATX_A = 0.9;\n      \t//在构造器中赋值\n      \tpublic final double ATX_B；\n      \tpublic A{\n      \t\tATX_B=0.8；\n      \t}\n      \t//在代码块中赋值\n      \tpublic final double ATX_C；\n      \t{\n      \t\tATX_C=0.2；\n      \t}\n      }\n      ```\n\n3. 如果final修饰的属性是静态的，则初始化的位置只能是\n\n   1. 定义时\n   2. 在静态代码块 \n   3. 不能再构造器中赋值\n\n4. final类不能被继承，但是可以实例化对象\n\n5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承\n\n6. 一般来说，如果一个类已经是final类，就没有必要再将方法修饰成final方法。\n\n7. final不能修饰构造方法（即构造器）\n\n8. final和static 往往搭配使用，效率更高，不会导致类的加载。底层编译器做了优化处理\n\n9. 包装类(integer,Double,Float,Boolean等等都是final),String 也是final类\n\n\n\n## 抽象类\n\n```java\n编写一个父类\n//class Animal{\nabstract Animal{\n\tString name;\n\tpublic Animal(String name){\n\t this.name = name;\n\t}\n\t/*\n\t这里的eat方法 实现了，没有什么意义\n\t即父类中的方法不确定性的问题\n\t\n\t1.考虑将该方法设计为抽象(abstract)方法\n\t2.所谓抽象方法就是没有实现的方法\n\t3.所谓的没有实现就是没有方法体\n\t4.当一个类存在抽象方法时，就需要将该类声明为abstract类\n\t\n\t一般来说，抽象类会被继承，有其子类来实现抽象方法\n\t*/\n    \n\t//public void eat(){\n\t//\tSystem.out.println(\"这个是一个吃方法，但不知道吃啥\");\n\t//}\n    \n\tpublic abstract void eat();\n}\n```\n\n\n\n#### 介绍\n\n1. 用abstract 关键字修饰的类时，这个类就是抽象类\n\n   1. ```java\n      访问修饰符 abstract 类名{\n      }\n      ```\n\n2. 用abstract 关键字来修饰一个方法时，这个方法就是抽象方法\n\n   1. ```java\n      访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体\n      ```\n\n3. 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()\n\n#### 细节\n\n1. 抽象类不能被实例化\n2. 抽象类不一定包含abstract方法。也就是说，抽象类可以没有abstract方法\n3. 一旦包含了abstract方法，则这个类必须声明为abstract \n4. abstract 只能修饰类和方法，不能修饰属性和其他的\n5. 抽象类可以有任意成员【抽象类的本质还是类】，比如：非抽象方法、构造器、静态属性等等\n6. 抽象方法不能有主体，即不能实现。例如：abstract void method()；不能有{}\n7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract 类（所谓实现就是有那个{}就可，具体内容不管）\n8. 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的\n\n#### 抽象类实践-模板设计模式\n\n现有个需求\n\n1. 有多个类，完成不同的任务job\n2. 要求能得到各自完成任务的时间\n\n```java\npackage seatWork;\n\npublic class Template {\n    public static void main(String[] args) {\n        son1 son1 = new son1();\n        son1.getCurrentTime();\n        son2 son2 = new son2();\n        son2.getCurrentTime();\n    }\n\n}\n\nabstract class Father{\n//在抽象类中定义一个抽象方法，这个方法后期会填入不同子类的不同不同方法\n    public abstract void job();\n//创建一个子类中的公共部分，在其中添加 不同的部分抽象类(方法)，\n// 由于动态绑定机制，当调用该方法时，根据实例不同的子类实现不同的输出结果\n//    也就是说相当于创建了个模板，不同的类用填不同的内容\n    public void getCurrentTime(){\n        long start = System.currentTimeMillis();\n        job();\n        long end = System.currentTimeMillis();\n        System.out.println(\"用时：\"+(end-start));\n    }\n}\nclass son1 extends Father{\n    @Override\n    public void job() {\n        int sum=0;\n        for (int i = 0; i < 10000; i++) {\n            sum+=i;\n        }\n    }\n}\nclass son2 extends Father{\n\n    @Override\n    public void job() {\n        int sum=0;\n        for (int i = 0; i < 60000; i++) {\n            sum+=i;\n        }\n    }\n} \n```\n\n## 接口（重要）\n\n#### 介绍\n\n接口就是给出一些没有实现的方法，封装到一起，起到某个类要使用的时候，在根据具体情况吧这些方法写出来\n\n#### 语法\n\n```java\ninterface 类名 implements 接口{\n 自己的属性；\n 自己的方法；\n 必须实现的接口的抽象方法；\n}\n```\n\n小结:\n\n1. jdk7之前，接口中所有方法否是抽象方法\n2. jdk8之后，接口中可以有实现方法，但需要使用default关键字修饰\n3. jdk8之后可以有静态方法\n4. abstract关键字可以省略\n\n#### 注意事项\n\n1. 接口不能被实例化\n\n2. 接口中所有的方法是public方法，接口中抽象方法，可以不用填写abstract，因为默认修饰的就是public abstract xxx。\n\n3. 一个普通类实现接口，就必须将该接口的所有方法都实现\n\n4. 抽象类实现接口，可以不用实现接口的方法\n\n5. 一个类同时可以实现多个接口\n\n6. 接口的属性，只能是final的，而且public static final 修饰符，比如：int a =1; 实际上是public static final int a =1；（必须）初始化\n\n7. 接口中属性的访问形式：接口名.属性名\n\n8. 一个接口不能继承其他的类，但是可以继承多个别的接口\n\n   ```java\n   interface A extend B,c,d...{}\n   ```\n\n9. 接口的修饰符只能是public和默认，这点和类的修饰符是一样的。\n\n小结：\n\n继承vs接口\n\n1. 当子类继承了父类，就自动拥有了父类的功能\n2. 如果子类需要拓展功能，可以通过实现接口的方式扩展\n3. 可以理解，接口是对java单继承机制的一个补充\n\n继承的价值：解决代码的复用性和可维护性\n\n接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。更加的灵活\n\n## 内部类（重点）\n\n#### 介绍：\n\n一个类的内部又完整的嵌套了另一个类结构。被嵌套的类成为内部类（inner class)，嵌套其他类的类成为外部类(out class)。是我们类的第五大成员\n\n类的五大成员：\n\n1. 属性\n2. 方法\n3. 构造器\n4. 代码块\n5. 内部类\n\n#### 基本语法\n\n```java\nclass Outer{//外部类\n\tclass inner{//内部类\n\t}\n}\n\nclass other{//外部其他类\n}\n```\n\n \n\n#### 内部类的分类\n\n定义在外部类局部位置上（比如方法内）\n\n##### 1）局部内部类（有类名）\n\n​\t\t说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名\n\n```java\n//例\nclass outclass{\n  private int n = 100;\n  //局部内部类师是定义在外部类的局部位置，通常在方法内\n // 1.第一种在局部位置\n \tclass innerClass{}\n  //2. 在方法内，（局部内部类）\n  public void mehtod(){//局部内部类（本质仍然是一个类）\n    \tclass innerClass{\n        System.out.print(\"n=\"+n);\n      }    \n  }\n}\n```\n\n1. 可以直接访问外部类的所有成员，包括私有的\n\n2. 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但可以使用final修饰，因为局部变量也可以使用final修饰符的\n\n3. 作用域：仅仅在定义它的方法或代码块中\n\n4. 局部内部类---访问---->外部类的成员【访问方式：直接访问】\n\n5. 外部类----访问---->局部内部类的成员\n\n   访问方式：创建对象，再访问（注意：必须在作用域内）\n\n6. 外部其它类---->不能访问---->局部内部类（因为 局部内部类地位是一个局部变量）\n\n7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问\n\n8. ```java\n   class Outer{\n   \tprivate int n1 = 10;\n   \tprivate static String name = \"张三\";\n   \tpublic void say(){\n   \t\tint n3 = 30;\n         //局部内部类是定义在外部类的局部位置，通常在方法  \n           //不能添加访问修饰符，可以使用final修饰\n     class localInner{//局部内部类（本质仍然是一个类）\n       int n1 = 100;\n      int n2 = 40;\n           //可以直接访问外部类的所有成员，包括私有的    \n         public void show(){\n         //默认输入内部类的n1的值 100\n   \t    System.out.print(\"n1=\"+n1);\n         //输入outer.this.n1 输出的才是外部类的n1\n         System.out.print(\"n1=\"+outer.this.n1);\n           \n         }\n   \t}\n   }\n     //外部类使用内部类\n     localInner inner = new localInner();\n     inner.show();\n    }\n   \n   \n   \n   //外部其他类\n   \n   ```\n\n9. \n\n##### 2）匿名内部类（没有类名，重点！！！！）\n\n###### 介绍：\n\n1. 本质是类\n2. 是一个内部类\n3. 该类没有名字\n4. 同时还是一个对象\n\n匿名内部类是定义在外部类的局部位置\n\n比如在方法中，并且没有类名\n\n###### 基本语法\n\n```java\nnew 类 或 接口（参数列表）{\n\t类体\n};\n\nanonymous\n```\n\n###### 演示 \n\n```java\npackage chapterObjectHeightLevel;\n\npublic class AnonymousClass {\n    public static void main(String[] args) {\n        outer outer = new outer();\n        outer.method();\n    }\n}\n\nclass outer{//外部类\n    private  int n1 =10;\n    public  void method(){\n        //现有一个需求，使用IA接口，并创建对象\n\n//        传统方法：新建一个类tiger 实现IA接口，并new tiger调用\n//        IA tiger = new Tiger();\n//        tiger.cry();\n//        当此时的需求是只需要这个Tiger类使用一次，并且以后再也不使用\n//        如果再用传统方法的话，会造成资源浪费，而且没有必要再去新建一个类\n//        此时就需要匿名内部类来简化开发，如下\n        IA tiger = new IA(){\n            /**\n             *此时底层是这样的\n             * class xxx(该类名是系统自动创建的) implements IA{\n             *     @Override\n             *     public void cry() {\n             *         System.out.println(\"老虎叫`````\");\n             *     }\n             * }\n             *\n             * 之后在让tiger指向xxx的地址\n             */\n            @Override\n            public void cry() {\n                System.out.println(\"老虎叫`````\");\n            }\n        };\n        tiger.cry();\n\n\n\n        //演示基于类的匿名内部类\n//        1. father的编译类型 Father(不加{}号)\n//        2. father的编译类型 xxx$2(加{}号）\n//        2.1 底层会创建匿名内部类\n        Father father = new Father(\"tiger\"){\n            @Override\n            public void test() {\n                System.out.println(\"override test method\");\n            }\n            /**\n            * 相当于创建了哥匿名内部类重写了test方法\n            * class xxx implement test{\n             *      @Override\n             *      public void test() {\n             *          System.out.println(\"override test method\");\n             *       }\n             * }\n             * 然后再将father指向xxx的地址\n            * */\n        };\n        father.test();\n\n    }\n\n}\n\ninterface IA{\n    public void cry();\n}\n\n//class Tiger implements IA{\n//\n//    @Override\n//    public void cry() {\n//        System.out.println(\"老虎叫`````\");\n//    }\n//}\n\nclass Father{\n    public Father(String name) {\n\n    }\n    public void test(){\n\n    }\n}\n\n```\n\n\n\n###### 注意细节\n\n1. 匿名内部类既是一个类的定义，同事它也是一个对象，因此从语法上来看，它既有定义类的特征，也有创建对象的特征，对前面的代码分析可以看出这个特点，因此调用匿名内部类方法有两种\n\n   ```java\n   //1.第一种方式\n   new A{\n   @override\n   \tpublic void cry(){\n   \tSystem.out.print(\"hello\");\n   \t}\n   }.cry();\n   \n   //2.第二种方式\n   A a=new A{\n   @override\n   \tpublic void cry(){\n   \tSystem.out.print(\"hello\");\n   \t}\n   }\n   a.cry();\n   ```\n\n2. 可以访问外部类的所有成员，包括私有的\n\n3. 不能添加访问修饰符，因为它的地位就是一个局部变量\n\n4. 作用域：方法或代码块中\n\n5. 匿名内部类--->范围跟--->外部类成员\n\n6. 外部其他类--->不能访问--->匿名内部类（因为 匿名内部类地位是一个局部变量）\n\n7. 如果外部类和内部类的成员变量重名时，内部类访问的话，默认就是就近原则，如果想访问外部，可以使用（外部类名.this.成员）去访问\n\n\n\n\n\n定义在外部类的成员位置上\n\n##### 1）成员内部类（没用static修饰）\n\n介绍：\n\n1. 成员内部类是定义在外部类的成员位置，并且没有static修饰\n\n   ```java\n   class outer{\n   \tprivate int n1 =10;\n   \tpublic String name = \"zhangsan\";\n   \t\n   \tclass inner{\n   \t\tpublic void say(){\n   \t\t\tSystem.out.print(\"outer n1 = \"+n1+\"outer name = \"+name);\n   \t\t}\n   \t}\n   }\n   ```\n\n2. 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位是一个成员\n\n3. 作用域\n\n   和外部类的其他成员一样，为整个类体比如前面的案例，在外部类的成员方法中创建成员内部类对象，再调用方法\n\n4. 成员内部类-->访问--->外部类成员\n\n   (比如属性)【访问方式：直接访问】\n\n5. 外部类 ---访问---内部类\n\n   访问方式：创建对象，再访问\n\n6. 外部其他类-----访问-----成员内部类\n\n   ```java\n   //三种方式:\n   //1\n   outer.inner class = new outer.new inner;\n   \n   // 第二种方式\n    1.定义一个方法，用于创建内部类并返回内部类的实例\n      public inner getInner(){\n      Inner inner  = new Inner();\n      return inner;\n    }\n   2. 在需要的地方new一个外部类.这个方法\n     Outer.Inner inner = new Outer.getInner();\n   \n   //3这个方法不建议使用\n     \n     new Outer().new Inner();\n   \n   ```\n\n7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问\n\n   ![image-20220409142725630](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409142725630.png)\n\n##### 2）静态内部类（使用static修饰）\n\n###### 介绍\n\n静态内部类定义在外部类的成员位置，并且有static修饰\n\n1. 可以直接访问外部的所有静态成员，包含私有的，但不能直接访问非静态成员\n2. 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员\n3. 作用域：同其他的成员，为整个类体\n\n```java\nclass outer{\nprivate int n1=10;\nprivate static String name = \"zhangsan\";\n\n//inner就是静态内部类\n  //1. 放在外部类的成员位置\n  //2. 使用static修饰\n  //3. 不能直接访问非静态成员\n  //4. 可以添加修饰符\n\tstatic class Inner{\n\t\tpublic void say(){\n      \tSystem.out.println(name);\n    }\n\t}\n}\n```\n\n4. 静态内部类---访问----外部类\n\n   （比如：静态属性）[访问方式：直接访问所有静态成员]\n\n5. 外部类--访问---静态内部类 \n\n   访问方式：创建对象，再访问\n\n6. 外部其他类 --访问 --内部类\n\n   访问方式：\n\n   ```java\n   //访问方式1\n   //因为静态内部类，是可以通过类名直接访问（前提是满足访问权限）\n   Outer.Inner inner = new Outer.Inner();\n   inner.xxx();\n   //访问方式2\n   //写一个方法，返回静态内部类的实例\n   public Inner getInner(){\n     return new Inner();\n   }\n   Outer.Inner inner = Outer.getInner();\n   \n   inner.xxx();\n   \n   //或者将方法换成静态\n   public static Inner getInner(){\n     return new Inner();\n   }\n   \n   \n   \n   ```\n\n7. 如果外部类和静态内部类的成员重名时，静态内部访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问\n\n\n\n# 枚举和注解\n\n## 枚举（enum）\n\n### 介绍\n\n1）枚举对应的英文（enumeration,简写enum）\n\n2）枚举是一组常量的集合\n\n3）可以理解：枚举属于一种特殊的类，里面只包含一组有限的特定对象（比如一年只有四个季节，建一个季节类的话只能有四个，而且有被添加其他季节的风险）\n\n\n\n### 实现方式\n\n#### 1）自定义枚举\n\n1. 不需要提供set方法，因为枚举对象通常为只读\n2. 对枚举对象/属性使用final +static共同修饰，实现底层优化\n3. 枚举对象通常使用大写，常量的命名规范\n4. 枚举对象根据需要，也可以有多个属性\n\n```java\npackage chapterEnum;\n\npublic class understandForEnum {\n    public static void main(String[] args) {\n        season autumn = season.AUTUMN;\n        System.out.println(autumn.getSeasonName()+autumn.getSeasonDescription());\n\n    }\n}\n//定义一个季节类\nclass season{\n    private String seasonName;//季节名称\n    private String seasonDescription;//季节描述\n  //1.将构造器私有化\n  //2.去掉setxx方法，防止属性被修改\n  //3.在season内部，直接创建固定的对象\n  //4.优化，添加final\n\n    public String getSeasonName() {\n        return seasonName;\n    }\n\n    public String getSeasonDescription() {\n        return seasonDescription;\n    }\n\n    private season(String seasonName, String seasonDescription) {\n        this.seasonName = seasonName;\n        this.seasonDescription = seasonDescription;\n    }\n//定义了四个对象\n    public final static season SPRING = new season(\"春天\",\"温暖\");\n    public final static season SUMMER = new season(\"夏天\",\"炎热\");\n    public final static season AUTUMN = new season(\"秋天\",\"凉爽\");\n    public final static season WINTER = new season(\"冬天\",\"寒冷\");\n}\n\n```\n\n总结：定义枚举类型有一下几个特点\n\n1. 构造器私有化\n2. 本类内部创建一组对象\n3. 对外暴露对象（添加public final static 修饰）\n4. 可以提供get方法，但不需要提供set方法\n\n#### 2）使用enum关键字实现\n\n```java\npackage chapterEnum;\n\npublic class understandForEnum02 {\n    public static void main(String[] args) {\n        System.out.println(season02.SPRING);\n    }\n}\nenum season02{\n    /**\n     * 实现步骤\n     * 1.使用enum代替class\n     * 2.直接使用 常量名(实参列表)\n     *   SPRING(\"春天\",\"温暖\"),\n     *   如果有多个常量则用,号隔开\n     *\n     * enum修饰必须将常量对象写在第一行\n     *  必须写在定义的变量和方法前面\n     *\n     * 3.编写常量，私有构造器和get方法\n     * */\n\n    SPRING(\"春天\",\"温暖\"),\n    SUMMER(\"夏天\",\"炎热\"),\n    AUTUMN(\"秋天\",\"凉爽\"),\n    WINTER(\"冬天\",\"寒冷\");\n\n\n    private String seasonName;//季节名称\n    private String seasonDescription;//季节描述\n\n    public String getSeasonName() {\n        return seasonName;\n    }\n\n    public String getSeasonDescription() {\n        return seasonDescription;\n    }\n\n    private season02(String seasonName, String seasonDescription) {\n        this.seasonName = seasonName;\n        this.seasonDescription = seasonDescription;\n    }\n\n    @Override\n    public String toString() {\n        return \"season02{\" +\n                \"seasonName='\" + seasonName + '\\'' +\n                \", seasonDescription='\" + seasonDescription + '\\'' +\n                '}';\n    }\n    //定义四个固定对象\n    /*\n    public final static season02 SPRING = new season02(\"春天\",\"温暖\");\n    public final static season02 SUMMER = new season02(\"夏天\",\"炎热\");\n    public final static season02 AUTUMN = new season02(\"秋天\",\"凉爽\");\n    public final static season02 WINTER = new season02(\"冬天\",\"寒冷\");\n*/\n\n\n}\n```\n\n##### 注意事项\n\n1. 当我们使用enum关键字开发一个枚举类时，默认会继承Enum类\n2. 传统的public static final SPRING = new season(\"春天\",\"温暖\");简化成SPRING(\"春天\",\"温暖\"),这里必须知道，它调用的是哪个构造器\n3. 如果使用无参构造器 创建枚举对象，则实参列表和小括号都可以省略\n4. 当有多个枚举对象时，使用，号间隔，最后一个分号结尾\n5. 枚举对象必须放在枚举的行首\n\n\n\n### enum常用方法说明\n\n使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类的相关方法\n\n![image-20220409204654918](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409204654918.png)\n\n```java\n    public static void main(String[] args) {\n//        使用season02 枚举类，演示各个方法\n        season02 summer = season02.SUMMER;\n//        输出枚举对象的名字\n//        summer.name();\n        System.out.println(summer.name());\n\n//        ordinal()输出的是该枚举对象的次序/编号，按枚举的顺序从0开始编号\n//        summer枚举对象时第二个，因此返回 1\n        System.out.println(summer.ordinal());\n\n//        从反编译可以看出values方法，返货season02[]\n//        含有定义所有的枚举对象\n        season02[] values = season02.values();\n        for (int i = 0; i <values.length ; i++) {\n            System.out.println(values[i].name());\n        }\n//        增强for循环演示\n//        每执行一次values就会扔一个对象给season、\n//        简单来说就是依次取出数组赋给season\n        System.out.println(\"==========增强for=========\");\n        for(season02 season:values){\n            System.out.println(season.name());\n        }\n\n//        valueOf:将字符串转换成枚举对象，要求字符串必须VT为己有的常量名，否则会报错\n//        1.根据输入的\"xia\"到season02中的枚举对象去查找\n//        2.如果找到了，就返回，如果没有找到就报错，如下这个例子\n        /*season02 vaof = chapterEnum.season02.valueOf(\"xia\");\n        System.out.println(\"vaof = \"+ vaof);*/\n//        3.只要valueOf()中的参数和枚举对象一致才能正常返回，如下\n        season02 xia = chapterEnum.season02.valueOf(\"SUMMER\");\n        System.out.println(\"xia = \" +xia);\n\n//        compareTo:比较两个枚举常量，比较的是编号\n//        就是把season02.SPRING和season02.SUMMER的编号进行比较\n//        底层是第一个的编号减去第二的编号，\n//        如果=0则是相等的，\n//        如果大于1，则代表前面那个编号大于后面一个编号\n//        如果小于1，则反之\n        System.out.println(season02.SPRING.compareTo(season02.SUMMER));//= -1\n        System.out.println(season02.SPRING.compareTo(season02.WINTER));//= -3\n\n    }\n```\n\n### 使用细节\n\n1. enum修饰的类不能在继承其他父类，因为enum会隐式继承一个Enum类\n2. enum实现的类，仍然是一个类，所以还是可以实现接口的\n\n\n\n### Switch中使用枚举\n\n案例\n\n1. ![image-20220410224921752](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410224921752.png)\n\n2. ```java\n   package homeWork.Annotation;\n   \n   public class AnnotationHomeWork08 {\n       public static void main(String[] args) {\n   //        Color.BLACK.show();\n   //        Color.RED.show();\n       Color red = Color.RED;\n   //    在小（）内放入枚举对象\n   //        在每个case后，直接写上枚举类，定义枚举对象即可\n           switch (red){\n               case RED:\n                   System.out.println(\"红色\");\n                   break;\n               case BLUE:\n                   System.out.println(\"蓝色\");\n                   break;\n               case BLACK:\n                   System.out.println(\"黑色\");\n                   break;\n               case YELLOW:\n                   System.out.println(\"黄色\");\n                   break;\n               case GREEN:\n                   System.out.println(\"绿色\");\n                   break;\n               default:\n                   System.out.println(\"没匹配到\");\n   \n           }\n       }\n   }\n   interface Tint{\n       public void show();\n   }\n   enum Color implements Tint{\n       RED(255,0,0),\n       BLUE(0,0,255),\n       BLACK(0,0,0),\n       YELLOW(255,255,0),\n       GREEN(0,255,0);\n   \n       private int redValue;\n       private int greenValue;\n       private int blueValue;\n   \n       Color(int redValue, int greenValue, int blueValue) {\n           this.redValue = redValue;\n           this.greenValue = greenValue;\n           this.blueValue = blueValue;\n       }\n   \n       @Override\n       public void show() {\n           System.out.println(redValue+\"\\t\"+greenValue+\"\\t\"+blueValue);\n       }\n   }\n   \n   ```\n\n\n\n## 注解\n\n#### 介绍\n\n1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息\n2. 和注解一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息\n3. 在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等，在javase中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替javaee旧版中所遗留 的繁冗代码和xml配置等\n\n使用Annotation时，前面要加@符号，并把Annotation当成一个修饰符使用。用于修饰它支持的程序元素\n\n1. @Override：限定某个方法，是重写父类方法，该注解只能用于方法\n\n   ```java\n   class son extends father{\n   //1.@Override注解方法fly方法上，表示子类fly方法重写了父类的fly\n   //2.如果这里没有写@Override ，还是重写了fly\n   //3.如果写了@Override注解，编译器就会去检查该方法是否真的重写了fly方法，\n   \t如果的确重写了，则编译通过。如果没有构成重写，则编译错误\n   @Override\n   public void fly(){\n    System.out.println(\"son fly...\");\n   }\n   }\n   ```\n\n   @Override只能修饰方法，不能修饰其他类\n\n2. @Deprecated：用于表示某个程序元素(类、方法等)已过时\n\n3. @SuppressWarnings：抑制编译器警告\n\n   1. 当写一些方法时，会出现一些无关不影响运行的警告。\n\n      可以使用@SuppressWarnings来抑制警告信息\n\n   2. 可以在@SuppressWarnings{\"\"}中写入希望抑制的警告信息\n\n   3. ![image-20220410190809537](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410190809537.png)\n\n   4. 位置在哪就屏蔽哪里 \n\n\n\n### 元注解（了解）\n\n@Target是修饰注解的注解，称为元注解  （了解）\n\n元注解的种类（使用不多，要求看到直到是干啥的）\n\n#### 1）Retention //指定注解的作用范围，三种SOURCE,CLASS,RUNTIME\n\n说明：\n\n只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，\n\n@Rentention包含一个RententionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值\n\n@Rentention的三种值：\n\nRententionPolicy.SOURCE //编译器使用后，直接丢弃这种策略的注释\n\nRententionPolicy.CLASS // 编译器将把注释记录在class文件中，当运行java程序时，JVM不会保留注释，这是默认值\n\nRententionPolicy.RUNTIME  //编译器将把注解记录在class文件中，当运行java程序时，JVM会保留注释，程序可以通过反射获取该注释\n\n示意图：\n\n![image-20220410203107921](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410203107921.png)\n\n#### 2）Target     //指定注解可以在哪些地方使用\n\n用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素\n\n简单来说就是在哪些元素上使用\n\n@Target   也包含一个名为value的成员变量\t\n\nTarget(value = CONSTRUCTOR（构造器）, FIELD（field） , LOACL_VARIABLE（局部变量）, METHOD（方法）,PACKAGE（包）,PARAMETER ,TYPE )\n\n#### 3）Documented    //指定该注解是否会在javadoc中体现\n\n@Documented   用于指定该元注解修饰的Annotation类将被Javadoc 工具提取成文档，即在生成文档时，可以看到注解\n\n定义Documented  注解必须设置Retention 值为RUNTIME\n\n#### 4）Inherited    //子类会继承父类注解\n\n\n\n# 异常\n\n## 异常的概念\n\n### 介绍\n\njava语言中，将程序执行中发生的不正常情况成为“异常”。（开发过程中的语法错误和逻辑错误不属于异常）\n\n执行过程中所发生的异常事件可分为两类\n\n1. Error（错误）：java虚拟机无法解决的严重问题。例如：JVM系统内部错误，资源耗尽等严重情况。例：StackOverflowError[栈溢出]和OOM（out of memory),Error是严重错误，程序会崩溃。\n2. Exception：因为，其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对想的代码进行处理，例如空指针访问，视图读取不存在的文件，网络连接中断等等，Exception分为两大类，运行时异常[程序运行发生的异常]和编译时异常[编译时，编译器查出的异常]\n\n\n\n## 异常体系图（重要）\n\n![image-20220411214601035](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411214601035.png)\n\n![image-20220411215335526](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411215335526.png)\n\n小结：\n\n1. 异常分为两大类，运行时异常和编译时异常\n\n2. 运行时异常，编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该避免出现的异常。java.lang.RuntimeException类及它的子类都是运行程序\n\n3. 对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影像\n\n4. 编译时异常，是编译器要求必须处置的异常\n\n    \n\n## 常见的异常\n\n### 常见的运行异常\n\n#### 1）NullPoniterException 空指针异常\n\n1. 当程序试图在需要对象的地方使用 null时，抛出该异常\n\n#### 2 ) ArithmeticException\t数字运算异常\n\n1. 当出现异常的运行条件时，抛出此异常\n2. 例如 一个整数\"除以零\"时，抛出此类的一个实例\n\n#### 3）ArrayIndexOutOfBoundsException\t数组下标异常\n\n1. 用非法索引访问数组时抛出的异常，如果索引为负或者大于等于数组大小，则该索引为非法索引\n\n#### 4）ClassCastException\t类型转换异常\n\n1. 当试图将对象强制转换为不是实例的子类时，抛出该异常\n\n#### 5）NumberFormatException\t数字格式不正确异常[]\n\n1. 当应用程序试图将字符串转换成一种数值类型，但该字符不能转换为适当格式时，抛出该异常\n2. 使用该异常我们可以确保输入的是满足条件的数字\n\n### 常见的编译异常\n\n#### 介绍\n\n编译异常是指在编译期间。就必须处理的异常，否则代码不能通过编译\n\n#### 常见的编译异常\n\n1. SQLException\t//操作数据库时，查询表可能发生的异常\n2. IOException\t\t//操作文件时，发生的异常\n3. FileNotFoundException\t//当操作一个不存在的文件时，发生异常\n4. ClassNotFoundException\t//加载类，该类不存在时，异常\n5. EOFException\t\t//操作文件，到文件末尾，发生异常\n6. IIIegalArguementException\t//参数异常\n\n\n\n## 异常处理概念\n\n### 基本介绍\n\n异常处理就是当异常发生时，对异常处理的方式\n\n### 异常处理方式\n\n#### 1）try-catch-finally\n\n程序员在代码中捕获发生的异常，自行处理\n\n```java\ntry{\n\t代码/可能有异常\n}catch(Exception e){\n//捕获的异常，传给e\n//1.当异常发生时\n//2.系统将异常封装成Exception对象e，传递给catch\n//3.得到异常对象后，程序员自己处理\n//4.如果没有发生异常，则catch代码块不执行\n}finally{\n    //不管try代码块是否有异常发生，始终都要执行finally\n    //通常将释放资源的代码方法finally代码块中\n}\n```\n\n\n\n#### 2）throws\n\n将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM\n\n##### 处理机制图\n\n![image-20220411224543192](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411224543192.png)\n\n\n\nthrows处理机制\n\n1. try-catch-finally和throws二选一\n2. 如果程序员，没有显示是处理异常，默认throws\n\n## 异常处理分类\n\n### try-catch方式处理异常说明\n\n#### 1）java提供try和catch块来处理异常。\n\ntry块用于包含可能出错的代码块。catch用于处理try块中发生的异常，可以根据需要在程序中有多个数量的try...catch块\n\n#### 2）基本语法\n\n```java\ntry{\n//可疑代码\n//将异常生成对应的异常对象，传递给catch块\n}catch(异常){\n//对异常的处理\n}\n//没有finally是可以通过的\n```\n\n```java\n//使用案例\ntry{\nString str = \"糖\";\nint a  = Integer.parseInt(str);\nSystem.out.println(\"数字=\"+a);\n}catch(Exception e){\nSystem.out.println(\"异常信息=\"+e.getMessage());\n}\n```\n\n#### 注意事项\n\n1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块\n\n2. 如果异常没有发生，则顺序执行try代码块，不会进入到catch块\n\n3. 如果希望不管是否能发生异常，都执行某段代码块（比如关闭链接，释放资源等）、\n\n4. 可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求是父类异异常在后，子类异常在前，比如（Exception 在后，NullPointerException 在前）如果发生异常，只会匹配一个catch\n\n   1. ```java\n      例:\n      try{\n      \n      }catch(NullPointerException e){\n      \n      }catch(Exception e){\n      \n      }finally{\n      \n      }\n      \n      ```\n\n5. 可以记性try-finally配合使用，这种方法相当于没有捕获异常，因此程序会直接崩掉\n\n   1. 应用场景：就是执行一段代码，不论是否发生异常，都必须执行某个业务逻辑\n\n#### 小结\n\n1. 如果没有出现异常，则执行try块中所有语句，不执行catch块中的语句，如果有finally，最后还要执行finally语句\n2. 如果出现异常，则try块异常发生后，剩下的语句不在执行，将执行catch块中的语句，如果有finally，最后还要执行finally里面的语句\n\n\n\n### throws异常处理\n\n#### 介绍：\n\n1）如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理异常，则此方法应显示的声明抛出异常，表明该方法将不对这些异常进行处理，而且由该方法的调用者负责处理\n\n2）在方法声明throws语句可以声明排除异常的列表，throws后面的异常类型可以是方法产生的异常类型，也可以是它的父类\n\n#### 注意事项\n\n1. 对于编译异常，程 序必须处理，比如try-catch或者throws\n2. 对于运行时异常，程序中如果没有处理，默认就是throws的方式处理\n3. 子类重写父类的方法是，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一直，要么为父类抛出的异常的类型和子类型\n4. 在throws过程中，如果有try-catch，就相当于处理异常，就可以不必throws\n5. ![image-20220412135104986](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412135104986.png)\n6. \n\n## 自定义异常  \n\n### 介绍：\n\n当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述错误信息。\n\n### 自定义异常的步骤\n\n1. 定义类：自定义异常类名（程序员自己写）继承Exceotion或RuntimeException\n2. 如果继承Ecxeption，属于编译异常\n3. 如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）\n\n```java\n//当我们接受Person对象年龄时，要求范围在18-120之间，否则抛出一个自定义异常（要求继承RuntimeException），并提示\npublic class CustomException {\n    public static void main(String[] args) {\n        int age =30;\n//        结果取反\n        if (!(age>=18&&age<=120)){\n//            通过构造器设置输出信息\n            throw new AgeException(\"年龄需要在18-120之间\");\n        }\n        System.out.println(\"你的年龄为\"+age);\n    }\n}\n//定义一个异常类继承RuntimeException\n//一般情况下，我们自定义异常都继承RuntimeException\n//也就是说大都是定义为运行时异常，好处是我们可以使用默认处理机制\n//即比较方便\nclass AgeException extends RuntimeException{\n//    定义一个构造器\n    public AgeException(String message) {\n        super(message);\n    }\n}\n```\n\n\n\n## throw和throws的对比\n\n|        | 意义                     | 位置       | 后面跟的东西 |\n| ------ | ------------------------ | ---------- | :----------: |\n| throws | 异常处理的一种方式       | 方法声明处 |   异常类型   |\n| throw  | 手动生成异常对象的关键字 | 方法体中   |   异常对象   |\n\nthrows\n\n```java\npublic void xxx() throws Exception{\n    //throws通常放在定义方法的末尾\n} \n```\n\nthrow\n\n```java\n//throw后面跟的是异常对象\nthrow new AgeException(\"年龄需要在18-120之间\");\n```\n\n\n\n# 常用类\n\n## 包装类\n\n### 包装类的分类   Wrapper\n\n1、针对八种基本数据类型相应类型的引用类型---包装类\n\n2、有了类的特点，就可以调用类中的方法\n\n| 基本数据类型 |  包装类   |\n| :----------: | :-------: |\n|   boolean    |  Boolean  |\n|     char     | Character |\n|     byte     |  `Byte`   |\n|    short     |  `Short`  |\n|     int      | `Integer` |\n|     long     |  `Long`   |\n|    float     |  `Float`  |\n|    double    |  `Doble`  |\n\n上述标出来的6个数据类型父类均为Number\n\n![image-20220412164154544](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412164154544.png)\n\n### 包装类和基本数据的转换\n\n#### 案例\n\n演示包装类和基本数据类型的相互转换，以int和integer演示\n\n1）jdk5前的手动装箱和拆箱方式，装箱：基本类型->包装类型,反之拆箱\n\n2）jdk5以后（包括jdk5）的自动装箱和拆箱方式\n\n3）自动装箱底层调用的是valueOf方法，比如integer.valueOf();\n\n4）其他类型同理\n\n```java\n//基本类型——————>包装类型[手动装箱]\nint i =10;\ninteger i1 = new Integer(i);\ninteger i2 = Integer.value(i);\n\n//包装类型————————>基本类型[手动拆箱]\nInteger j = new Integer(99);\nint j1 = j.intValue();\n```\n\n```java\n//jdk5.0之后的方式\nint m =10;\nInteger m2 =m;\nInteger n = new Integer(99);\nint n2 = n;\nSystem.out.println(\"n+100\");\nSystem.out.println(\"n*2\");\nif(n>10){\n\n}\n```\n\n### 包装类型和String类型的相互转换\n\n#### 案例\n\n以integer和String转为例\n\n```java\n//包装类型---->String类型\ninteger i =10;\n//方式1\nString s1 = i.toString();\n//方式2\nString s2 = String.valueOf(i);\n//方式3\nString s3 = i+\"\"; \nSystem.out.println(s3);\n\n//String --->包装类\n//方式1\nInteger j =new Integer(s1);\n//方式2\nInteger j2 = Integer.valueOf(s2);\n//\nInteger.parseInt(s3);\n```\n\n### Integer类和Character类常方法\n\n```java\nInteger.MIN_VALUE //返回最小值\nInteger.MAX_VALUE //返回最大值\n\nCharacter.isDigit('a');//判断是不是数字\nCharacter.isLetter('a');//判断是不是字母\nCharacter.isUpperCase('a');//判断是不是大写\nCharacter.inLowerCase('a');//判断是不是小写\n\nCharacter.isWhitespace('a')；//判断是不是空格\nCharacter.toUpperCase('a');//转成大写\nCharacter.toLowerCase('a');//转成小写\n\n```\n\n### Integer面试题\n\n1.看代码输出什么，为啥\n\n1. ![image-20220413164815801](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164815801.png)\n\n2. 因为integer的原码定义好了从-128-127之间不返回一个对象\n\n   ![image-20220413164729185](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164729185.png)\n\n   2.integer面试题总结\n\n   看下列代码输出什么结果\n\n   <span style=\"color:red;background:yellow \" >只要有基本数据类型会自动拆箱，比对的是数值。判断的是值是否相等</span>\n\n   如下的示例六和七，比对的是\n\n   ![image-20220413205739995](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413205739995.png)\n\n   \n\n   \n\n## String(重要)\n\n![image-20220413213320195](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413213320195.png)\n\nString实现了三个接口并继承了Object类\n\n* Serializable接口：说明String可以串行化。（可以在网络传输）\n* Comparable接口：说明String对象可以相互比较\n* CharSequence接口：字符序列\n\n<span style=\"color:blue;background:pink\">String类是final类，String类不能被其他类继承</span>\n\n<span style=\"color:blue;background:pink\">String 有属性，private final char value[];用于存放字符串内容（字符串的本质就是char数组）</span>\n\n<span style=\"color:red;background:pink\">(注意：value是一个final类型，不可修改（即：value不能指向新的地址，但是单个字符内容时可以变化的）)</span>\n\n\n\n\n\n### 理解\n\n1）String对象用于保存字符串，也就是一组字符序列\n\n2）字符串常量对象时用双引号括起来的字符序列。例如：\"你好\"，\"21.213\"，\"boy\"等等\n\n3）字符串的字符使用Unicode字符编码，一个字符（不区分字幕还是汉字）占两个字节\n\n4）String类较常用的构造方法（其他手册）\n\n* String s1 = new String();\n* String s2 = new String(String original);\n* String s3 = new String(char[] a);\n* String s4 = new String(char[] a,int startIndex, int count)\n\n### 创建方式\n\n#### 1）方式一：直接赋值String s = \"xxx\";\n\n创建流程：\n\n先从常量池查看是否有\"xxx\"数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址\n\n#### 2）方式二：调用构造器 String s = new String(\"xxx\")；\n\n流程：现在堆中创建空间，里面维护了value属性，指向常量池的xxx空间。如果常量池没有\"xxx\"，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址\n\n![image-20220414101904944](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414101904944.png)\n\n### String字符串的特性\n\n1）String是一个final类，代表不可变的字符序列\n\n2）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的 \n\n\n\n#### 面试题、\n\n1）String a = \"hello\"+\"abc\";创建了几个对象\n\n```java\n编译器会在后台会进行优化，判断创建的常量池对象，是否有引用指向\n优化等价于String a = \"helloabc\"；\n\n所以答案是创建了一个对象\n不是创建了三个\n```\n\n2）String a = \"hello\";\n\nString b = \"abc\";\n\nString c = a+b;\n\n总共创建了几个对象\n\n所以只创建了一个\n\n```java\n执行流程\n1. 先创建了一个StringBuilder sb = StringBuilder();\n2.执行sb.append(\"hello\");\n3.sb.append(\"abc\");\n4.String c = sb.toString();\n最后其实是c指向了堆中的对象（String）value[],堆中的对象指向了池中的“helloabc”\n```\n\n![image-20220414140922725](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414140922725.png)\n\n小结:底层是StringBuilder sb = new StringBuilder();sb.append(a);sb.append(b);sb是在堆中，并append是在原来的字符串的基础上追加的。\n\n重要规则：String c1 = \"sb\"+\"cd\";常量相加，看的是池。String c1 = a+b;变量相加，是在堆中\n\n### String类的常见方法\n\n#### 说明：\n\n​\tString类是保存字符串常量的。每次更新都需要重新开辟空间，效率低，因此java设计者还提供StringBuilder和StringBuffer来增强String的功能，并提高效率。\n\n#### Strng常见的方法\n\n![image-20220414145929644](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414145929644.png)\n\n* equals\t\t//区分大小写，判断是否相等\n\n* equalsIgnoreCase   //忽略大小写，判断内容是否相等\n\n* length  //获取字符的个数，字符窜长度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n\n* indexOf  //获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到返回-1\n\n* lastIndexOf   //获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，返回-1\n\n* substring //截取指定范围字符串\n\n* trim  //去前后空格\n\n* charAt //获取某索引处的字符，之一不能使用Str[index]这种方式\n\n* toUpperCase  //字符串转换成大写\n\n* toLowerCase  //字符串转换成小写\n\n* concat  //拼接字符串\n\n* replace  替换字符串中字符\n\n* split 分割字符串，罪域某些分割字符，我们需要转义\n\n  案例：\n\n  ```java\n  String poem =\"锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦\";\n  String[] split = poem.split(\",\");\n  //以，号为标准，分割上述整个字符串\n  //上述字符串被分割为4个部分用数组接收\n  \n  //在堆字符串进行分割时，如f\n  poem = \"E:\\\\aaa\\\\bbb\";\n  split  = poem.split(\"\\\\\\\\\");\n  ```\n\n  和 文件路径\n\n* compareTo //比较两个字符串的大小，如果前者大则返回正数，如果后者大则返回负数，\n\n  如果相等（\n\n  1.如果长度相同，并且字符串也相同返回0。\n\n  2.如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回if(c1 != c2）{\n\n  ​\t\treturn c1 - c2;\n\n  }\n\n  3.如果前面的部分都相同，就返回str1.len - str2.len）\n\n* toCharArray //字符串转成字符数组\n\n* format//格式化字符串，%s字符串，%c字符，%d 整型，%.2f 浮点型\n\n  ```java\n  //  %s%d%.2f%c成为占位符\n  //  这些占位符由后面的变量来替换\n  //  %s表示后面由字符串替换\n  //  %d表示整数替换\n  //  %.2f表示使用小数来替换，替换后，只会保留小数两位，并且会进行四舍五入的处理\n  //  %c是char类型替换\n      \n  String name =\"jack\";\n  int age = 10;\n  double score = 98.3 /3;\n  char gender ='男';\n  \n  //传统方法拼接\n  String info = \"名字是\"+name+\"年龄是\"+age+\"成绩是\"+score+\"性别：\"+gender\";\n  \n  \n  //使用format拼接\n  String info2 =String.format(\"姓名是%s年龄是%d成绩是%d性别时%c\",name,age,score,gender);\n  \n  //可以做成一个模板后面直接调用\n  String formatstr = \"姓名是%s年龄是%d成绩是%d性别时%c\";\n  \n  String info2 =String.format(formatstr,name,age,score,gender);\n  \n  System.out.println(\"info2 =\"+info2);\n  ```\n\n  \n\n## StringBuffer(重要)\n\n<span style=\"color:red;background:pink\">串行化（对象可以网络传输，可以保存到文件）</span>\n\n### 基本介绍\n\njava.lang.StringBuffer代表可变字符序列，可以对字符串内容进行增删\n\n很多方法与String相同，但StringBuffer是可变长度的\n\nStringBuffer是一个容器\n\n![image-20220415090614911](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415090614911.png)\n\n```java\nStringBuffer stringBuffer = new StringBuffer(\"hello\");\n//1.StringBuffer 的直接父类是 AbstractStringBuilder\n//2.StringBuffer 实现了Serializable，即StringBuffer的对象可以串行化\n//3.在父类中，AbstractStringBuilder 有属性 char[] value ，不是final\n\t该value 数组存放祖父穿内容，因数存放在堆中的\n//4.StringBuffer是一个final类， 不能被继承\n```\n\n### String 对比StringBuffer\n\n1）String保存的是字符串常量，里面的值不能更改，每次String类的更新实际是更改地址，效率较低//private final char value[]；\n\n2）StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用更新地址，效率较高//char[] value //这个放在堆\n\n\n\n### StringBuffer构造器\n\nStringBuffer()\n\n* 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符\n\n* ```java\n  //创建一个大小为16的char[]，用于存放字符串内容\n  StringBuffer stringBuffer = new StringBuffer();\n  ```\n\nStringBuffer(CharSequence seq)\n\n* public java.lang.StringBuffer(CharSequence seq)构造一个字符串缓冲区，它包含与指定的CharSequence 相同的字符\n\nStringBuffer(int capacity)//capacity[容量]\n\n* 构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对char[]大小进行指定\n\n* ```java\n  //通过构造器指定 char[]大小\n  StringBuffer stringBuffer = new StringBuffer(100);\n  ```\n\nStringBuffer(String str)\n\n* 构造一个字符串缓冲器，并将其内容初始化为指定的字符串内容\n\n* ```java\n  //通过给一个String 创建StringBuffer,char[] 大小就是str.length()+16\n  StringBuffer stringBuffer = new StringBuffer(\"hello\");\n  ```\n\n### String和StringBuffer\n\n#### String->StringBuffer\n\n```java\n//        String->StringBuffer\n//        方式一\n        String str =\"xxx\";\n//        注意：返回的是StringBuffer对象，对str本身是没有影响的\n        StringBuffer stringBuffer = new StringBuffer(str);\n\n\n//        方式二，使用append方法\n        StringBuffer stringBuffer1 = new StringBuffer();\n        stringBuffer1 = stringBuffer1.append(str);\n```\n\n#### StringBuffer->String\n\n```java\n\n//        StringBuffer->String\n        StringBuffer stringBuffer2 = new StringBuffer(\"xxxxxx\");\n//        方式一,使用StringBuffer提供的 toString方法;\n        String s = stringBuffer2.toString();\n\n//        方式二,使用构造器搞定\n        String s1 = new String(stringBuffer2);\n\n```\n\n\n\n### StirngBuffer类常见方法\n\n1. 增 append\n2. 删 delete(start,end)\n3. 改 replace(start,end,string)//将start---end间的内容替换掉，不含end\n4. 查 indexOf //查询字符串第1次出现的索引，如果找不回返回-1\n5. 插 insert\n6. 获取长度 length\n\n```java\n       StringBuffer stringBuffer = new StringBuffer(\"zhangsan\");\n\n        stringBuffer.append('x');\n        stringBuffer.append(\"张三\");\n        stringBuffer.append(\"wangwu\").append(true).append(10.2);\n        System.out.println(stringBuffer);\n\n//        删除\n        /*\n        * 删除索引为>=start && <end 处的字符\n        * 解读：删除11~14的字符[11,14)\n        * */\n        stringBuffer.delete(11,14);\n        System.out.println(stringBuffer);\n\n        //    改\n//        修改本质就是替换\n//        使用fff替换索引11-14的字符\n        stringBuffer.replace(11,14,\"fff\");\n        System.out.println(stringBuffer);\n\n//        查\n//        查找指定的子串在字符串出现的索引.如果找不到返回-1\n        int index = stringBuffer.indexOf(\"zhang\");\n        System.out.println(index);\n\n//        插入\n//        指定一个位置插入\n//        在索引为9的位置插入\"老王\"，原来索引为9的内容自动后移\n        stringBuffer.insert(9,\"老王\");\n        System.out.println(stringBuffer);\n\n//        获取长度\n        System.out.println(stringBuffer.length());\n    }\n\n```\n\n\n\n\n\n```java\n public static void main(String[] args) {\n        /**\n         * 输入商品名称和商品价格，要求打印效果示例，实用前面学习的方法完成\n         * 商品名  商品价格\n         * 手机123，456.56  //比如 价格价格1,456,786.5\n         * 要求：价格的小数点前面每三位用,号隔开，再输出\n        * */\n\n        String prices;\n        Scanner scanner = new Scanner(System.in);\n        String price = scanner.next();\n        StringBuffer stringBuffer = new StringBuffer(price);\n\n\n//        先完成最简单的实现21,312,412.32\n//        找到小数点的索引,然后再该位置的前三位插入,\n\n        for (int j = stringBuffer.lastIndexOf(\".\")-3; j >0 ; j-=3) {\n\n            stringBuffer = stringBuffer.insert(j, \",\");\n        }\n\n        System.out.println(stringBuffer);\n\n    }\n```\n\n\n\n\n\n## StringBuilder(重要)\n\n### 基本介绍\n\n1）一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder 不是线程安全)。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快（单线程的情况下，优先使用StringBuilder）\n\n2）在StringBuilder上主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据\n\n\n\n### StringBuilder常用方法\n\nStringBuilder和StringBuffer均代表可变字符序列，方法是一样的，所以使用和StringBuffer一样。\n\n1. StringBuilder是final类，不能被继承\n2. StringBuilder对象可以串行化\n3. 继承了AbstractStringBuilder属性 char[] value，内容存到value\n4. 实现了Serializable接口，序列化（所谓系列化既可以保存类型和数据本身）\n\n## String、StringBuffer、StringBuilder的比较☆\n\n1）StringBuilder和StringBuffer非常类似，均代表可变字符序列，而且方法也一样\n\n2）String：不可变字符序列，效率低，但是复用率高。\n\n3）StringBuffer：可变字符序列、效率较高（增删）、线程安全\n\n4）StringBuilder：可变字符序列、效率最高、线程不安全\n\n5）String使用注意事项：\n\n```java\nString s=\"a\"; //创建了一个字符串\ns+= \"b\";   //实际上原来的\"a\"字符串对象已经丢弃了，现在又产生了一个转字符串s+\"b\"（也就是\"ab\").如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=》\n//结论：如果我们对Stirng做大量修改，不要使用String\n```\n\n### 效率\n\nStringBuilder  > StringBuffer >String \n\n\n\n### 使用原则，结论\n\n1. 如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder\n2. 如果字符串存在大量的修改操作，并且在单线程的情况下使用StringBuilder\n3. 如果字符串存在大量的修改操作，并且在多线程的情况下使用StringBuffer\n4. 如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等\n\nStringBuffer和StringBuilder的方法使用一样\n\n## Math\n\n### 基本介绍\n\nMath类包含用于执行基本数学运算方法，如初等指数，对数，平方根和三角函数\n\n方法一览（均为静态方法）![image-20220415145338171](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415145338171.png)\n\n### Match常用的方法\n\n1. abs  绝对值\n\n2. pow  求幂\n\n3. ceil   向上取整  (返回>=该参数的最小整数)\n\n4. floor   向下取整  (返回<=该参数的最大整数)\n\n5. round   四舍五入\n\n6. sqrt  求开方\n\n7. random  求随机数\n\n   ```java\n   public static void main(String[] args) {\n           /*\n           random随机数\n           random默认返回 0<= x <1之间的一个随机小数\n           请写出a-b之间的一个随机整数，a,b均为整数比如a=2,b=7\n           即返回一个2 - 7 之间的随机数\n           * */\n           \n           /**\n           * random返回的是0<=x <1之间的一个随机小数\n            * Math.random()*(b-a)返回的就是0<= 数 <=b-a\n            * (1)(int)(a)<= x <(int)(a+Math.random() * (b-a +1))\n           * (2)集体使用解析\n            * (int)(a+Math.random() * (b-a +1))\n            *  = (int)(2+Math.random() * 6)\n            *  Math.random() * 6返回的就是0<= x <6小数\n            *  2+Math.random() * 6返回的就是2<= x <8小数\n            *  (int)(2+Math.random() * 6) = 2 <=x <=7\n           * */\n           \n   \n   \n   //      公式就是：(int)(a+Math.random() * (b-a +1))\n           for (int i = 0; i < 5; i++) {\n               System.out.println((int) (2 +Math.random()*(7-2+1)));\n           }\n       }\n   ```\n\n   \n\n8. max   求两个数的最大值\n\n9. min    求两个数的最小值\n\n\n\n\n\n## Date,Calender,LoaclDate.\n\n### Date[知道怎么查，怎么用即可]\n\n#### 第一代日期类\n\nDate：精确到毫秒，代表特定的瞬间\n\nSimpleDateFormat：格式和解析日期的类SimpleDateFormat 格式化和解析日期的具体类。它允许进行格式（日期->文本、解析（文本->日期）和规范化\n\n![image-20220420110144786](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420110144786.png)\n\n```java\n//获取当前时间\n//默认输出的格式是国外的格式\nDate d1 = new Date();、\n//因此需要对格式进行转换\nSimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 hh:mm:ss E\");\n//其他格式的字母意思，查看手册\nString foramt = d1.format(d1);\n\n//获取某个时间对应的毫秒数\nDate d2 = new Date(23123);\n\n//可以吧一个格式化的字符串转成对应的date\nString s = \"2000年7月五日 20:12:20 星期一\";\nDate pares = simpleDateFormat.parse(s);\n//接收的格式必须个定义的格式一样\n```\n\n### Calendar(日历)\n\n#### 第二代日期类\n\n主要就是Calendar类（日历）\n\n1）public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable<Calendar\n\n2)calendar类是一个抽象类，他为特定瞬间为一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等，日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。\n\n```java\n//创建日历对象，\nCalendar c =Calendar.getInstance();\nSystem.out.print(\"年\"+c.get(Calendar.YEAR))；\nSystem.out.print(\"月\"+c.get(Calendar.MONTH)+1)；\nSystem.out.print(\"日\"+c.get(Calendar.DAY_OF_MONTH))；\nSystem.out.print(\"小时\"+c.get(Calendar.HOUR))；\nSystem.out.print(\"分钟\"+c.get(Calendar.MINUTE))；\nSystem.out.print(\"秒\"+c.get(Calendar.SECOND))；\n//Calendar没有专门的格式化方法，所以程序员自己组合\nSystem.out.print(c.get(Calendar.SECOND)+\"年\"+(c.get(Calendar.MONTH)+1)+\"月\"+c.get(Calendar.DAY_OF_MONTH)+\"日\")；\n```\n\n### 第三代日期类\n\n前面两代的不足分析\n\n（jdk1.0中包含了一个java.Util.Date类，但是他的大多数方法已经存在JDK1.1引入Calendar类之后被弃用。Calendar也存在着很多问题\n\n1. 可变性：像日期和时间这样的类应该是不可变的。\n2. 偏移性：Date中年份是从1900开始的，而月份是从0开始的\n3. 格式化：格式化只对Date有用，Calendar则不行\n4. 此外，他们不是线程安全的，不能处理闰秒等（每隔两天多出1s）\n\n#### 第三代日期类\n\n1）LoaclDate（日期）、localTime（时间）、loacalDateTime（日期和时间内）\n\nJDK8\n\nLoaclDate：只包含日期，可以获取日期字段\n\nlocalTime：包含时间，可以获取时间字段\n\nloacalDateTime包含日期和时间，\n\n```java\nloacalDateTime ln = loacalDateTime.now();\nln.getYear();\nln.getMonth();\nln.getMonthValue();//输出数字版的月份\n```\n\n##### 2）DateTimeFormatter格式日期类\n\n类似于SimpleDateFormat\n\n```java\nDateTimeFormatter dtf = DateTimeFormatter.ofPattern(格式);//(yyyyMMdd....)\n\nString srt = dtf.format(日期对象);\n```\n\n#### Instant 时间戳\n\n类似于Date\n\n提供了一系列和Date类转换的方式\n\nInstant---->Date;\n\nDate date = Date.from(instant);\n\nDate --->Instant;\n\nInstant instant = date.toInstant();\n\n案例演示\n\n```java\nInstant now = Instant.now();\nSystem.out.print(now);\nDate date = Date.from(now);\nInstant instant = date.toInstant();\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## System\n\n### 常见方法\n\n1）exit 退出当前程序\n\n```\nSystem.exit(0);表示退出\n//0代表一个正常状态状态  。\n```\n\n2）Arraycopy：复制数组元素，比较合适底层调用，一般使用Arrays.copyOf完成数组复制。\n\n```java\nint[] src = {1,2,3};\nint[] dest = new int[3];\nSystem.arraycopy(src,0,dest,0,3)\n \tsrc:源数组\n    srcpos：从原数组的哪个索引位置开始开始拷贝\n    dest:目标数组，即吧原数组的数据拷贝到哪个数组\n    destpos：把原数组的数据拷贝到 目标数组的哪个索引\n    length:从原数组拷贝多少个数据到目标数组\n```\n\n3）currentTimeMillens：返回当前时间距离1970-1-1(1970年1月1日到现在) 的毫秒数\n\n4）gc：运行垃圾回收机制System.gc();\n\n## Arrays类\n\n### 介绍\n\nArrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）\n\n### 方法\n\n#### 1） toString返回数组的字符串形式，将数组拼接成字符串返回\n\n```java\nArrays.ToString(arr)\n```\n\n#### 2)sort排序（自然排序和定制排序）\t\n\n```java\nInteger arr[] = {1,-1,7,0,89};\n//可以直接使用该方法进行排序。不用再动手去敲方法\n//因为数组时引用类型，所以通过sort排序后，会影响到实参arr\nArrays.sort(arr);//正序排序\n//sort重载的，也可以通过传入一个接口Comparator实现定制排序\n\n1、调用定制排序时，传入两个参数\n    (1)排序数组的参数\n    (2)实现Comparator接口的匿名内部类。要求实现Compare方法\n\n    \n    \n//      这里体现了接口编程的方式\n//\n//        倒序排序\n        Arrays.sort(a, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                Integer i1 = (Integer) o1;\n                Integer i2 = (Integer) o2;\n//                return大于0 就是正序排序，小于0就是倒序\n                return i2 -i1;\n            }\n        });\n        System.out.println(Arrays.toString(a));\n\n    }\n```\n\n```java\n       bubble(a,new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                Integer i1 = (Integer) o1;\n                Integer i2 = (Integer) o2;\n                return i1 -i2 ;\n            }\n        });\n\n        System.out.println(\"定制类\"+Arrays.toString(a));\n\n    }\n\n\n//    定制排序\n    public static void bubble(Integer[] arr,Comparator c){\n        int temp;\n        for (int i = 0; i < arr.length-1 ; i++) {\n            for (int j = 0; j <arr.length-1-i; j++) {\n                if (c.compare(arr[j],arr[j+1])>0){\n                    temp =arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n```\n\n\n\n#### 3）binarySearch 二分搜索\n\nbinarySearch 通过二分搜索法进行查找，要求必须排好序\n\n```java\n //如果这个数组是有序的，可以通过该方法查找知否有这个数\n int[] arr = {1,23,45,65,78};\n//如果不存在该元素就返回，return -(low +1)//意思就是返回负的他该出现的位置的下标+1\n int index = Arrays.binarySearch(arr,3);//返回-2\n```\n\n#### 4）copyOf数组元素的复制\n\n```java\n//表示从arr数组中拷贝arr.length个长度的元素到新的arr数组中\nInteger[] newArr = Arrays.copyOf(arr,arr.length);\nInteger[] newArr = Arrays.copyOf(arr,arr.length-1);就是拷贝原数组长度-1\nInteger[] newArr = Arrays.copyOf(arr,arr.length+1);\n//如果长度超出原数组的长度，则多出来的部分元素为null   \n```\n\n#### 5)fill数组元素的填充\n\n```java\nInteger[] num = new Integer[]{9,2,1};\n//使用99去填充num数组\n//可以理解成替换原来的元素\nArrays.fill(num,99);\n\n==========运行结果======\n    [99,99,99]\n```\n\n#### 6)equals 比较两个数组元素内容是否完全一致\n\n```java\nboolean equals  = Arrays.equals(arr,arr2);\n//如果两个数组元素一样，则返回true。不一样返回false\n```\n\n#### 7)asList 将一组值，转换成list\n\n```java\nList<Integer> asList = Arrays.asList(2,3,4,5,6,1);\nSystem.out.println(\"asList\"+asList);\n```\n\n\n\n\n\n## Integer和BigDecimal类\n\n### 应用场景\n\n1）BigInteger适合保存比较大的整型(整数)\n\n```java\n//当编程中需要处理很大的整数。long不够用可以使用BigInteger类\n//使用\nBigInteger bigInteger = new BigInteger(\"2222222222222222222222222222222222222222\");\n\n//运算\n//在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）\n    \nBigInteger bigInteger 2=bigInteger.add(10)；//加\n    //也可再创建一个BigInteger相加\n```\n\n\n\n2）BigDecimal适合保存精度高的浮点型(小数)\n\n```java\n//当我们需要保存一个精度很高的值时，double不够用\n//可以使用BigDecimal\nBigDecimal bigDecimal = new BigDecimal(\"22.22222222222222222222222222\");\n//运算\n//在对BigDecimal进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）\n//需要创建一个需要操作的BigDecimal，然后调用即可\n\nBigDecimal bigDecimal=bigDecimal.add(2.3);\n    //使用删除方法时，可能会出现除不尽的情况，会抛出异常\n//解决办法：在调用divede(删除)方法是，指定精度即可\nbigDecimal.divide(1.11,BigDecimal.ROUND_CEILING)\n//如果有无限循环小数，就会保留到分子的精度\n\n```\n\n# 集合\n\n## 集合框架体系\n\n### 集合体系图\n\n背下来\n\n1）单例集合（在集合里面放单个的对象）\n\n![image-20220420163040446](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163040446.png)\n\n![image-20220420163624872](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163624872.png)\n\n2）双列集合（存放键值对形式的）\n\n![image-20220420163100945](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163100945.png)\n\n![image-20220420163609594](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163609594.png)\n\n```java\n//存放单个数据的成为单例\nArrayList  arrayList = new ArrayList();\narrayList.add(\"zhangsan\");\narrayList.add(\"lisi\");\n\n//存放双列数据的成为双例集合\nHashMap hashMap = new HashMap();\nhashMap.put(\"no1\",\"zhangsan\");\n//key,value\nhashMap.put(\"no2\",\"李四\");\n```\n\n## Collection\n\nCollection接口\n\n#### Collection接口实现类的特点\n\n```java\nPublic interface Collection<E> extends Iterable<E>\n```\n\n1. Collection实现子类可以存放多个元素，每个元素可以是 Object\n2. 有些Collection的实现类，可以存放重复的元素，有些不可以\n3. 有些Collection的实现类，有些是有序的（List），有些不是有序（Set）\n4. Collection接口没有直接实现子类，是通过它的子接口Set和List来实现的\n\n#### Collection接口和常用方法\n\n![image-20220420165341922](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420165341922.png)\n\n常用方法\n\n```java\n1)add :添加单个元素\n2)remove:删除指定元素\n3)contains:查找元素是否存在\n4）size：获取元素个数\n5）isEempty：判断是否为空\n6）clear：清空\n7）addAll：添加多个元素\n8）containsAll：查找多个元素是否都存在\n9）removeAll：删除多个元素\n说明：以ArrayList实现类演示\n```\n\n```java\npublic static void main(String[] args) {\n        ArrayList list = new ArrayList();\n//        1.添加单个元素\n        list.add(\"zhangsan\");\n        list.add(\"hahah\");\n        list.add(\"lisi\");\n        list.add(123);//等价于list.add(new Integer(123);\n        System.out.println(\"数组增加\"+list);\n//      remove：删除指定元素\n        list.remove(0);//删除第一个元素,下标从0开始\n        list.remove(\"123\");//删除指定元素\n        System.out.println(\"数组删除\"+list);\n\n//       contains 查找元素是否存在\n        System.out.println(list.contains(\"zhangsan\"));//F\n//        size,显示元素的个数\n        System.out.println(list.size());\n//      isEmpty判断是否为空\n        System.out.println(list.isEmpty());\n//        clear清空\n        list.clear();//清空集合\n        System.out.println(\"list清空=\"+list);\n\n        ArrayList list1 = new ArrayList();\n//        addAll:添加多个元素\n        list1.add(\"xxx\");\n        list1.add(\"xxxxxx\");\n\n        list.addAll(list1);\n        System.out.println(\"addAll\"+list);\n//        containsAll:查找多个元素知否存在\n        System.out.println(list.containsAll(list1));\n//        removeAll：删除多个元素\n        list.removeAll(list1);\n        System.out.println(list);\n\n    }\n```\n\n#### 使用Iterator（迭代器）\n\nCollection接口遍历元素的方式1-使用Iterator（迭代器）\n\n##### 基本介绍\n\n1）Iterator对象成为迭代器，主要用于遍历Collection集合中的元素\n\n2）所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可返回一个迭代器\n\n3）Iterator的结构![image-20220420231917444](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420231917444.png)\n\n4）Iterator仅用于遍历集合，Iterator本身并不存放对象\n\n###### 迭代器的运行原\n\n![image-20220421160914060](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220421160914060.png)\n\nhasNext用于判断\n\nnext（）；下移，并返回指向的元素\n\n```java\npublic class Iteraor {\n    public static void main(String[] args) {\n        Collection list = new ArrayList();\n        list.add(new HomeWork(\"zhansgan\",12313));\n        list.add(new HomeWork(\"haha\",231));\n\n//        使用迭代器遍历\n        Iterator iterator = list.iterator();\n//        while循环  快捷方式输入 itit\n//        ctrl+j提示所有快捷键\n     while (iterator.hasNext()) {\n//            返回下一个元素，是Object类型\n            Object next =  iterator.next();\n            System.out.println(next);\n        }\n//      当退出while循环后，这是iterator迭代器，指向最后一个元素\n//        iterator.next()  ，此时再让往下移指针会报异常：NuSuchElementException\n//        如果希望再次遍历，需要我们重置迭代器\n        iterator = list.iterator();//相当于指向了第一个元素\n\n    }\n}\n\nclass HomeWork{\n    String name;\n    Integer phoneNum;\n\n    public HomeWork() {\n    }\n\n    public HomeWork(String name, Integer phoneNum) {\n        this.name = name;\n        this.phoneNum = phoneNum;\n    }\n\n    @Override\n    public String toString() {\n        return \"HomeWork{\" +\n                \"name='\" + name + '\\'' +\n                \", phoneNum=\" + phoneNum +\n                '}';\n    }\n}\n```\n\n#### for循环增强\n\nCollection接口遍历元素的方式2-\n\n增强for循环，可以代替iterator迭代器\n\n特点：增强for就是简化版的iterator，本质一样。只能用于<span style=\"color:red\">遍历集合或数组</span>\n\n###### 基本语法\n\n```java\nfor(元素类型 元素名 : 集合名或数组){\n\t访问元素\n}\n```\n\n案例\n\n```java\n for (Object homeWork:list) {\n            System.out.println(homeWork);\n        }\n\n//        增强也可以在数组中使用\n        int[] a = {1,2,3,45,6};\n        for (int i: a){\n            System.out.println(i);\n        }\n```\n\n1. 增强for底层是迭代器\n2. 可以理解成增强for是简化版的迭代器\n\n## List\n\n基本介绍：\n\nList接口是Collection接口的子接口\n\n1）list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\n\n2）list集合中的每个元素都有其对应的顺序索引，即支持索引\n\n3）list容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素\n\n4）JDK API中的List接口实现类有：ArrayList、LinkedList和Vector\n\n```java\npublic static void main(String[] args) {\n//        list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\n        List list = new ArrayList();\n        list.add(\"jack\");\n        list.add(\"tom\");\n        list.add(\"zhangsan\");\n//        此时不会有冲突，相当于会认为有两个tom\n        list.add(\"tom\");\n//        此时输出的顺序就是存进去的顺序\n        System.out.println(\"list\"+list);\n\n//        2）list集合中的每个元素都有其对应的顺序索引，即支持索引\n//        索引从0开始\n        System.out.println(list.get(3));\n    }\n```\n\n##### List接口的常用方法\n\n1. void add（int index,Object ele）在index位置插入ele元素\n2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来\n3. Object get (int index)获取固定index位置的元素\n4. int indexOf(Object obj)  返回obj在几个中首次出现的位置\n5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置\n6. Object remove(int index) 移除指定index位置的元素，并返回此元素\n7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换\n8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合\n\n```java\npublic static void main(String[] args) {\n\n        List list = new ArrayList();\n        list.add(\"no1\");\n        list.add(\"no2\");\n//        1. void add（int index,Object ele）在index位置插入ele元素\n//        在index=1的位置插入一个对象\n        list.add(1,\"add(index,ele)\");\n        System.out.println(list);\n//        2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来\n        List list2 = new ArrayList();\n        list2.add(\"lno2\");\n        list2.add(\"lno3\");\n        list2.add(\"lno3\");\n//        在1的位置插入list2的集合\n        list.addAll(1,list2);\n        System.out.println(list);\n//        3. Object get (int index)获取固定index位置的元素\n//        4. int indexOf(Object obj)  返回obj在几个中首次出现的位置\n        System.out.println(list.indexOf(\"no1\"));\n//        5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置\n        System.out.println(list.lastIndexOf(\"lno3\"));\n//        6. Object remove(int index) 移除指定index位置的元素，并返回此元素\n        list.remove(1);\n        System.out.println( list);\n//        7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换\n//        将索引为1的改为尼诺\n        list.set(1,\"尼诺\");\n//        8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合\n        List result = list.subList(0, 2);//相当于选择了下标为0的和下标为2-1之间的元素\n        System.out.println(\"result\"+result);\n}\n```\n\n##### 注意事项\n\n1. permits all elements,including null , ArrayList 可以加入null，并且多个\n2. ArrayList 是由数组来实现数据存储的\n3. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）看源码，在多线程情况下，不建议使用ArrayList\n\n#### ArrayList\n\n#####  ArrayList底层机制和源码分析（重点）\n\n1）ArrayList中维护了一个Object类型的数组elementData\n\n​\t\ttransient Object[] elementData \n\n```\ntransient 表示瞬间，短暂的，表示该属性不会被序列化\n```\n\n\n\n2）当创建对象ArrayList时，如果使用的是无参构造器，则初始elementData容量为0\n\n3）当添加元素时，先判断是否需要扩容，则调用grow方法，否则直接添加元素到合适位置\n\n4）如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍\n\n5）如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity\n\n6）如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍\n\n\n\n#### Vector\n\n##### 介绍\n\nVevtor底层也是一个对象数组。protected Object[] elementData;\n\nVector是线程同步的，即线程安全，Vector类的操作方法带有synchronized\n\n在开发过程中，需要线程同步安全时，考虑使用Vector\n\n\n\n##### Vector 和ArrayList比较\n\n|           | 底层结构 | 版本   | 线程安全（同步）效率 | 扩容倍数                                                     |\n| --------- | -------- | ------ | -------------------- | ------------------------------------------------------------ |\n| ArrayList | 可变数组 | jdk1.2 | 不安全，效率高       | 如果有参构造1.5倍如果无参1.第一次是10，第二次按1.5扩         |\n| Vector    | 可变数组 | jdk1.0 | 安全，效率不高       | 如果是无参默认10，满后，就按两倍扩容。如果指定大小（创建）有参，则每次直接按2倍扩容 |\n\n#### LinkedList\n\n##### 说明\n\n1）LinkedList实现了双向链表和双端队列特点\n\n2）可以添加任意元素（元素可以重复），包括null\n\n3）线程不安全，没有实现同步\n\n##### LinkedList底层机制\n\n1. LinkedList底层维护了一个双向链表\n\n2. LinkedList中维护了两个属性first和last分别指向首节点和尾结点\n\n3. 每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表\n\n4. 所以LinkedList的元素的 添加和删除，不是通过该数组完成的，相对来说效率较高\n\n5. 模拟一个简单双向链表理解\n\n   ```java\n   public static void main(String[] args) {\n   //        模拟一个简单的双向链表\n           Node jack = new Node(\"jack\");\n           Node tom = new Node(\"tom\");\n           Node zhangshan = new Node(\"zhangshan\");\n   //        链接是三个结点，形成双向链表\n   //        jack->tom ->zhangsan\n           jack.next = tom;\n           tom.next =zhangshan;\n   //        zhangsan->tom->jack\n           zhangshan.pre = tom;\n           tom.pre = jack;\n   \n           Node first = jack;//让first引用指向jack，就是双向链表的头结点\n           Node last =zhangshan;//让last引用指向zhangshan，就是双向链表的尾结点\n   \n   \n   //        演示从头到尾进行遍历\n           while (true){\n               if (first == null){\n                   break;\n               }\n   //            输出first信息\n               System.out.println(first);\n               first = first.next;\n           }\n   \n   //        从未到头遍历\n           while (true){\n               if (last == null){\n                   break;\n               }\n               System.out.println(last);\n               last = last.pre;\n           }\n   \n       }\n   }\n   \n   //定义一个Node类，node对象 表示双向链表的一个结点\n   class Node{\n       public Object item;//真正存放数据\n       public Node next;//指向下一个结点\n       public Node pre;//指向前一个结点\n   \n       public Node(Object item) {\n           this.item = item;\n       }\n   \n       @Override\n       public String toString() {\n           return \"Node{\" +\n                   \"item=\" + item +\n                   '}';\n       }\n   }\n   ```\n\n   \n\n![image-20220429152321935](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429152321935.png)\n\n##### ArrayList 和LinkedList的比较\n\n|            | 底层结构 | 增删的效率         | 改查的效率 | 线程   |\n| ---------- | -------- | ------------------ | ---------- | ------ |\n| ArrayList  | 可变数组 | 较低；数组扩容     | 较高       | 不安全 |\n| LinkedList | 双向链表 | 较高，通过链表追加 | 较低       | 不安全 |\n\n何如选择\n\n1）如果我们改查的操作较多，选择ArrayList\n\n2）如果我们增删的操作多，选择LinkedList\n\n3）一般来说，在程序中80%-90%都是查询，因此大部分情况下会选择ArrayList\n\n4）在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说根据业务来进行合理选择\n\n## set\n\n介绍\n\n1）无序（添加和取出的顺序不一致），没有索引\n\n2）不允许重复元素，所以最多包含和一个null\n\n3）JDK API中Set接口的实现类有![image-20220429173926895](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429173926895.png)\n\n##### Set接口和常用方法\n\n和List接口一样，Set接口也是Collection的子接口，因此常用方法和Collection接口一样\n\n##### set接口遍历方式\n\n同Collection的遍历方式一样，因为Set接口是Collection接口的子接口\n\n* 使用迭代器\n* 增强for\n* 不能使用索引的方式获取\n\n##### 案例\n\n```java\npublic static void main(String[] args) {\n//        以set接口实现类HashSet来讲解Set接口的方法\n//        set接口的实现类的对象（set接口对象）\n//        重复添加的数据只会存进去一个，null值也是只能存放一个\n    //输出结果是无序的（存放的数据是无序的，即（添加的顺序和取出的顺序不一致））\n    //虽然取出的顺序和添加的顺序不一致，但取出的顺序是固定的，不会一直变化\n        Set set = new HashSet();\n        set.add(\"zhansgan\");\n        set.add(\"lisi\");\n        set.add(\"wa\");\n        set.add(\"zhansgan\");\n        set.add(null);\n        set.add(null);\n        System.out.println(set);\n    }\n\n//        遍历\n//        迭代器\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            Object next =  iterator.next();\n            System.out.println(next);\n        }\n//        增强for\n        for (Object o :set) {\n            System.out.println(o);\n        }\n----------------输出结果----------------------\n    [null, lisi, wa, zhansgan]\n```\n\n#### HashSet\n\n1)HashSet实现了Set接口\n\n2）HashSet实际上是HashMap，看源码\n\n![image-20220430145947382](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430145947382.png)\n\n3）可以存放null值，但是只能有一个null\n\n4）HashSet不保证元素时有序的，取决于hash之后，在确定索引的结果（即：不保证存放元素的顺序和取出的一致  ）\n\n5）不能有重复元素/对象。在前面Set接口使用已经标明\n\n```java\n//1.执行add方法后，会返回一个Boolean值\n//2.如果添加成功,返回true，否则返回false\n//3.可以通过remove指定删除哪个对象\n        HashSet set = new HashSet();\n        set.add(\"zhansgan\");\n        set.add(\"lisi\");\n        set.add(\"wa\");\n        set.add(\"zhansgan\");\n        set.add(null);\n        set.add(null);\n\n        set.remove(\"zhangsan\");\n\n        set.add(new HHHH(\"zzz\"));//添加成功\n        set.add(new HHHH(\"zzz\"));//添加成功\n    }\n}\nclass HHHH{\n    private String name;\n\n    public HHHH(String name) {\n        this.name = name;\n    }\n}\n```\n\n##### HashSet底层机制说明 \n\n1）HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树）\n\n\n\n1. HashSet底层是HashMap\n2. 添加一个元素时，先得到hash值 -会转成-索引值\n3. 找到储存数据表table，看这个索引位置是否已经存放的有元素\n4. 如果没有，直接加入\n5. 如果有调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后\n6. 在java8中，如果一条链表的元素个数到了TREEEIFY_THRESHOLD(默认是8)个，并且table的大小>=MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树）\n7. ![image-20220430160350549](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430160350549.png)\n\n源码分析\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    //定义了一个辅助变量\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //table就是HashMap的一个属性，类型是Node[]\n     //if语句表示如果当前table是null，或者大小=0\n    //就是第一次扩容，到16个空间\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n   //（1）根据key，得到hash值去计算key应该存放到table表的哪个索引位置\n    //并且把这个位置的对象赋给p\n    //（2）判断p是否为null\n    //（2.1）如果为null，表示还没有存放元素，就创建了一个Node\n    //（2.1）就放在该位置 tab[i] = newNode(hash, key, value, null); \n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n          //如果当前索引位置对应的链表的第一个元素和准备谈价的key的hash值一样\n            //并且满足下面条件之一\n            //1.准备加入的key和p指向的Node结点和key是同一个对象 \n            //2.p指向的Node结点的key的equals（）和准备加入的key比较后相同\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            //如果上述条件不满足，再判断p是不是一个红黑树\n            //如果是一颗红黑树，就调用putTreeVal，来进行添加判断\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            \n            else {\n                //依次比较链表内的内容\n                //如果table对应索引的额位置，已经是一个链表，就是用for循环比较\n                //(1)依次和链表的每一个元素比较后都不相同，则加入到该链表的最后\n                  //然后立即判断该链表是否已经达到8个结点，就调用   treeifyBin()对当前这个链表进行树化（转成红黑树）\n                //注意，在转成红黑树时，要进行判断，判断条件{if(tab == null ||(n = tab.length)<MIN_TREEIEY_CAPACITY)\n                //resize();   //table数组是否小于64，结点是否到达8个并不为空      }\n                //如果上面条件成立，先table扩容\n                //如果上面条件不成立，才进行树化\n                //(2)依次和该链表的每一个元素比较过程中，如果有相同的情况，就直接break；\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        \n                        p.next = newNode(hash, key, value, null);\n                \n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n##### HashSet的扩容和转成红黑树机制\n\n1. HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（localFactor）是0.75 =12\n2. 如果table数组实用到了临界值12，就会扩容到16*2=32，新的临界值就是32 * 0.75 = 24,依次类推\n3. 在java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8),并且table的大小>=MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树），否则仍然采用数组扩容机制\n\n\n\n### LinkedHashSet\n\n**说明**\n\n1）LinkedHashSet是HashSet的子类\n\n2）LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表\n\n3）LinkedHashSet根据元素的hashCode值来决定元素的储存位置，同时使用链表维护元素的次序（图），这使得元素看起来是以插入顺序保存的![image-20220501174705977](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220501174705977.png)\n\n4）LinkedHashSet不允许添加重复元素 \n\n![image-20220502111826275](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220502111826275.png)\n\n可以理解成不同索引的数，构成双向链表\n\n1. 在LinkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）\n\n2. 每一个结点有pre和next属性，这样可以形成双向链表\n\n3. 在添加一个元素时，先求hash值，在求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加[原则和hashset一样])\n\n   ```java\n   tail.next = newElement //简单指定\n   new Element.pre = tail\n   tail = newElement;\n   ```\n\n4. 这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致\n\n\n#### TreeSet\n\n1. 当使用无参构造器创建treeset的时候仍然是无序的\n\n2. 需求：希望添加的元素按字符串大小来排序?\n\n   1. 使用TreeSet提供的一个构造器,可以传入一个比较器（匿名内部类）\n\n   2. ```java\n      public class TreeSetDemo {\n          public static void main(String[] args) {\n      //        TreeSet treeSet = new TreeSet();\n              TreeSet treeSet = new TreeSet(new Comparator() {\n                  @Override\n                  public int compare(Object o1, Object o2) {\n      //                调用String的compareTo方法比较字符串大小\n                      return ((String)o1).compareTo((String) o2);\n                  }\n              });\n              treeSet.add(\"d\");\n              treeSet.add(\"b\");\n              treeSet.add(\"a\");\n              treeSet.add(\"c\");\n      \n              System.out.println(treeSet);\n          }}\n      ```\n\n   3. \n\n\n\n## Map\n\nMap**结构**\n\n<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220503163901620.png\" alt=\"image-20220503163901620\" style=\"zoom:50%;\" />\n\nMap接口的特点（JDK8之后的）\n\n1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）\n\n2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&Node对象中\n\n3）Map中的key不允许重复，原因和HashSet一样，前面分析过\n\n4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）\n\n5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个\n\n6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）\n\n7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n\n```java\n Map map = new HashMap();\n//        1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）\n//        2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&Node对象中\n//        3）Map中的key不允许重复，原因和HashSet一样，前面分析过\n//        4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(\"no1\",\"lisi\");\n//        5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个\n        map.put(null,null);\n        map.put(null,null);\n        map.put(\"no3\",null);\n        map.put(\"no4\",null);\n        //        6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）\n        map.put(new Object(),\"zhangsan\");\n//        7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n//        通过get方法传入key，会返回对应的value\n        System.out.println(map.get(\"no2\"));\n        System.out.println(map);\n=============输出==================\n  lisi\n{no2=lisi, null=null, no1=lisi, no4=null, no3=null, java.lang.Object@1540e19d=zhangsan}\n\n\n```\n\n8）Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，有因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry（如图）\n\n![image-20220504165516988](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220504165516988.png)\n\n数据存放在HashMap中，将set和collection作为一组对象放在Entry里面（其中不存放数据只是存放HashMap的引用）\n\n1. 将HashMap中的key和value数据 存放到一个entrySet集合（该集合不存放数据，存放的都是引用）\n\n```java\n Map map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");//k-v\n        map.put(\"no1\",\"lisi\");//k-v\n//        1.k-v最后是HashMap$Node node = newNode(hash ,key,value,null);\n//        2.k-v为了方便程序员遍历，还会创建EntrySet集合，该集合存放的元素类型（Entry），\n//        而一个Entry对象就有k-v，EntrySet<Entry<k,v>>，即：transient Set<Map.Entry<k,v>> entrySet;\n\n//        3.在entrySet中，定义的类型是Map.Entry，但是实际上存放的是HashMap$Node类型\n//        因为HashMap$Node implement Map.Entry 因为实现了Map.Entry接口，那么这个类的对象实例可以赋给这个接口类型\n//        4.当吧HashMap$Node存放到entrySet后就方便我们的遍历，因为Map.Entry提供了两个重要的方法，getKey()和getValue方法\n        Set set = map.entrySet();\n        System.out.println(set.getClass());\n//        输出：class java.util.HashMap$EntrySet\n        for (Object o :set) {\n            System.out.println(o.getClass());\n//            输出：class java.util.HashMap$Node\n//            从HashMap$Node取出k-v\n//            先做一个向下转型\n            Map.Entry entry = (Map.Entry) o;\n            System.out.println(entry.getKey() +\"\"+ entry.getValue());\n        }\n```\n\n\n\n#### map接口和常用方法\n\n1）put：添加\n\n2）remove：根据键删除映射关系\n\n3）get：根据键获取值\n\n4）size：获取元素个数\n\n5）isEmpty：判断个数是否为0\n\n6）clear；清楚\n\n7）containsKey：查找键值否存在\n\n```java\nMap map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(null,\"lisi\");\n        map.put(\"no3\",\"lisi\");\n        map.put(\"no4\",\"2\");\n\n        map.remove(null);\n        Object lisi = map.get(\"no2\");\n        System.out.println(\"lisi==\"+lisi);\n\n        System.out.println(map.size());\n\n        map.isEmpty();\n        System.out.println(map);\n        map.clear();\n        System.out.println(map);\n\n        System.out.println(map.containsKey(\"no3\"));\n\n```\n\n\n\n#### Map遍历方法\n\n1）containsKey：查找键是否存在\n\n2）KeySet：获取所有的键\n\n3）entrySet：获取所有关系\n\n4）values：获取所有的值\n\n```java\n  Map map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(null,\"sss\");\n        map.put(\"no3\",\"lisdsdsi\");\n        map.put(\"no4\",\"2\");\n\n//        第一粗：先取出所有的key，通过key取出对应的value\n        Set set = map.keySet();\n//        增强for\n        for (Object o :set) {\n            System.out.println(map.get(o));\n        }\n        System.out.println(\"迭代器\");\n//        （2） 使用迭代器\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            Object next =  iterator.next();\n            System.out.println(map.get(next));\n        }\n        System.out.println(\"=========第二中=========\");\n//      第二组：吧所有的values取出\n        Collection values = map.values();\n//        这里可以使用所有的collections使用的遍历方法\n        for (Object o :values) {\n            System.out.println(o);\n        }\n//        迭代器\n        System.out.println(\"迭代器\");\n        Iterator iterator1 = values.iterator();\n        while (iterator1.hasNext()) {\n            Object next =  iterator1.next();\n            System.out.println(next);\n        }\n\n        System.out.println(\"=========第三中=========\");\n//        通过entryset获取\n        Set set1 = map.entrySet();\n        for (Object entry :set1) {\n//            将entry转为map.entry\n            Map.Entry  entry1= (Map.Entry) entry;\n            System.out.println(entry1.getKey()+\" \"+entry1.getValue());\n        }\n        System.out.println(\"迭代器\");\n        Iterator iterator2 = set1.iterator();\n        while (iterator2.hasNext()) {\n            Object next =  iterator2.next();\n            Map.Entry m = (Map.Entry) next;\n            System.out.println(m.getKey()+\" itit \"+ m.getValue());\n        }\n```\n\n#### 小结\n\n1. Map接口的常用实现类：HashMap、Hashtable和Properties\n2. HashMap是Map接口使用频率最高的实现类\n3. HashMap是以key-value对的方式来存储数据（HashMap$Node类型）\n4. key不能重复，但值可以，允许使用null键和null值\n5. 如果添加相同的 key，则会覆盖原来的k-v，等同于修改，（key不会替换，val会替换）\n6. 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来储存的\n7. HashMap没有实现同步，因此线程不安全 的\n\n#### HashMap底层机制\n\n1）HashMap底层维护了Node类型的数组table，默认为null\n\n2）当创建对象时，将加载银子（loadfactor）初始化为0.75\n\n3）当添加key-value时，通过key的哈希值得到在table的索引，然后判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是连链表结构，做出相应处理。如果添加时发现容量不够则需扩容\n\n4）第一次添加，则需扩容table容量为16，临界值(threshold)为12\n\n5）以后再扩容，需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推\n\n6）在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小>=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化。\n\n#### HashTable\n\n**基本介绍**\n\n1）存放的元素时键值对：key-value\n\n2）hashTable的键和值都不能为null，否则会抛出空指针异常\n\n3）hashTable使用方法基本上和HashMap一样\n\n4）hashTable是线程安全的，HashMap是线程不安全的\n\n![image-20220506160740866](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220506160740866.png)\n\n#### Properties\n\n**基本介绍**\n\n1. properties类继承了Hashtable类并实现了Map接口，也是使用一种键值对(key-value)的形式来保存数据\n2. 它的使用特点和Hashtable类似\n3. properties还可用于从xxx.properties文件中，加载数据到properties类对象，并进行读取和修改\n4. 说明：工作后 xxx.properties文件常用作配置文件，io流部分(详细讲解)[www.cnblogs.com/xudong-bupt/p/3758136.html]\n\n## Collections\n\n### Collections工具类\n\n1）Collections是一个操作Set、List和Map等集合的工具类\n\n2）Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作\n\n### 排序操作（均为static方法）\n\n1. reverse（List）：反转List中元素的顺序\n\n2. shuffle（List）：对List集合元素进行随机排序\n\n3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序\n\n4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序\n\n5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换\n\n6. 案例：\n\n   ```java\n   public class Collectionsdemo {\n       public static void main(String[] args) {\n           ArrayList list = new ArrayList();\n           list.add(\"zhansgan\");\n           list.add(\"lisi\");\n           list.add(\"wngwu\");\n           list.add(\"laoliu\");\n           list.add(\"dasima\");\n           System.out.println(\"list=\"+list);\n   //        1. reverse（List）：反转List中元素的顺序\n           Collections.reverse(list);\n           System.out.println(\"reverse=\"+list);\n   //        2. shuffle（List）：对List集合元素进行随机排序\n           for (int i = 0; i < 5; i++) {\n               Collections.shuffle(list);\n               System.out.println(\"随机\"+list);\n           }\n   //        3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序\n           Collections.sort(list);\n           System.out.println(\"sort\"+list);\n   //        4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序\n           Collections.sort(list, new Comparator() {\n               @Override\n               public int compare(Object o1, Object o2) {\n                   return ((String)o1).length()-((String)o2).length();\n               }\n           });\n           System.out.println(\"字符串长度排序\"+list);\n   //        5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换\n   \n           Collections.swap(list,0,1);\n           System.out.println(\"位置交换\"+list);\n       }\n   }\n   ```\n\n\n\n### 查找、替换\n\n1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n\n2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素\n\n3. Object min（Collection)\n\n4. Object min (Collection，Comparator)\n\n5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数\n\n6. void copy（List dest，List src）：将src中的内容复制到dest中\n\n7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值\n\n8. ```java\n   public static void main(String[] args) {\n           ArrayList list = new ArrayList();\n           list.add(\"zhansgan\");\n           list.add(\"lisi\");\n           list.add(\"wngwu\");\n           list.add(\"laoliu\");\n           list.add(\"dasima\");\n           System.out.println(\"list=\"+list);\n   //        1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n           System.out.println(\"max num=\"+Collections.max(list));\n   //        2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素\n   //            获取最大长度的值\n           //        3. Object min（Collection)\n   //        4. Object min (Collection，Comparator)同理\n           Object max = Collections.max(list, new Comparator() {\n   \n               @Override\n               public int compare(Object o1, Object o2) {\n                   return ((String) o1).length() - ((String) o2).length();\n               }\n           });\n           System.out.println(\"字符串最大的值为=\"+max);\n   \n   \n   //        5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数\n   \n           System.out.println(\"lailiu=\"+ Collections.frequency(list,\"lailiu\"));\n   //        6. void copy（List dest，List src）：将src中的内容复制到dest中\n              ArrayList oldList =  new ArrayList();\n   //           为了完成一个拷贝，我们需要先给oldList赋值，大小和list一样,不然会报错\n           for (int i = 0; i < list.size(); i++) {\n               oldList.add(\"\");\n           }\n   //        拷贝\n           Collections.copy(oldList,list);\n           System.out.println(\"oldList=\"+oldList);\n   \n   //        7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值\n           Collections.replaceAll(list,\"laoliu\",\"老六\");\n           System.out.println(\"替换后=\"+list);\n       }\n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 总结\n\n在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择分析如下\n\n1）先判断储存类型（一组对象或一组键值对）\n\n2）一组对象[单列]：Collection接口\n\n* 允许重复：List\n  * 增删多：LinkedList（底层维护了一个双向链表）\n  * 改查多：ArrayList（底层维护了Object类型的可变数组）\n* 不允许重复：Set\n  * 无序：HashSet（底层是HashMap，维护了一个哈希表 即（数组+链表+红黑树））\n  * 排序：TreeSet\n  * 插入和取出顺序一直：LinkedHashSet，维护数组+双向链表\n\n3）一组键值对[双列]：Map\n\n* 键无序：HashMap（底层是：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树）\n* 键排序：TreeSet\n* 键插入和取出顺序一致：LinkedHashMap\n* 读取文件：Properties\n\n# 泛型\n\n## 泛型语法\n\n```java\npublic static void main(String[] args) {\n//        1.当我们ArrayList<Dog>表示放到ArrayList集合中的元素只能是Dog类型\n//        2.如果编译器发现添加的类型不满足，就会报错\n        ArrayList<Dog> dogs = new ArrayList<Dog>();\n        dogs.add(new Dog(\"laogou\",12));\n        dogs.add(new Dog(\"xiaogou\",1));\n    }\n//       方便遍历\n        for (Dog dog : dogs) {\n            System.out.println(dog);\n        }\n```\n\n好处：\n\n1. 编译时，检查添加元素的类型，提高了安全性\n2. 减少了类型转换的次数，提高效率\n3. 不再提示编译警告\n\n### 介绍\n\n理解：泛（广泛）型（类型）==> integer，String\n\n可以表示数据类型的数据类型![image-20220509171057972](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171057972.png)\n\n1）泛型又称参数化类型，时jdk5.0出现的新特性，解决数据类型的安全性问题\n\n2）在类声明或实例化时只要制定好需要的具体的类型即可\n\n3）java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮\n\n4）泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型\n\n![image-20220509171249826](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171249826.png)\n\n（此时E称为泛型，那么Dog->E（此时E为 ））\n\n```java\nCat<String> tianyuanmao = new Cat<>(\"tianyuanmao\");\n\nclass Cat<E> {\n    E e;//E表示 e的数据类型，改数据类型在定义Cat对象时指定的，即在编译期间，就确定是什么类型了\n\n    public Cat(E e) {//E也可在参数类型体现\n        this.e = e;\n    }\n    public E method(){//返回类型也可体现\n        return e;\n    }\n\n}\n```\n\n### 语法\n\n泛型的声明\n\n```java\ninterface 接口<T> {}\nclass类<K,V,...>{}(可以接收多个泛型等等)\n说明：\n    1.其中K,V,T不代表值，而是表示类型\n    2.任意字母都可以。常用T表示，是type的缩写\n```\n\n泛型的实例化\n\n```java\n要在类名后面指定类型参数的值（类型）。如\n//1\nList <String> strList = new ArrayList<String>();\n//2\nIterator <Customer> iterator = coustomers.iterator();\n\n```\n\n### 使用细节\n\n1. interface List<T>{},public class HashSet<E>{}....等等\n\n   1. 说明：T，E只能是引用类型\n   2. 不能是基本数据类型（八大基本数据类型,int,double 等等）\n\n2. 在指定泛型具体类型后，可以传入该类型或者其子类类型\n\n3. 泛型适用形式\n\n   1. ```java\n      List<integer> list1 =new ArrayList<Integer>{}\n      \n      List<Integer> list2 = new ArrayList<>();\n      ```\n\n4. 如果我们这样写List list3 = new ArrayList（）；默认给它的泛型是[<E> E就是Object 类型]\n\n   \n\n\n\n## 自定义泛型\n\n### 泛型类\n\n**基本语法**\n\n```java\nclass 类名<T,R....>{\n成员\n}\n```\n\n细节：\n\n1. 普通成员可以使用泛型（属性，方法）\n\n2. 使用泛型的数组，不能初始化\n\n3. 静态方法中不能使用类的泛型‘\n\n   1. 因为静态是和类相关的，在类加载时，对象还没创建\n   2. 所以，如果静态方法和静态属性使用泛型时 ，JVM就无法完成初始化\n\n4. 泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）\n\n5. 如果在创建对象时，没有指定类型，默认为object\n\n6. ```java\n   //1.demo后面有泛型，所以我们吧demo就称为自定义泛型类\n   //2.T,R,M泛型的标识符，一般是单个大写字母\n   //3.泛型标识符可以有多个\n   //4.普通成员可以使用泛型 （属性，方法）\n   //5.使用泛型的数组，不能初始化\n   \t//（因为数组在new的\n   \n   \n   class demo<T,R,M>{\n   String name;\n   T t;\n   R r;\n   M m;\n       T[] t1;//可以声明\n       \n       public demo11(String name, T t, R r, M m) {//构造器使用泛型\n           this.name = name;\n           this.t = t;\n           this.r = r;\n           this.m = m;\n       }\n       //方法使用泛型\n        public String getName() {\n           return name;\n       }\n   \n       public void setName(String name) {\n           this.name = name;\n       }\n   \n       public T getT() {\n           return t;\n       }\n   \n       public void setT(T t) {\n           this.t = t;\n       }\n   \n       public R getR() {\n           return r;\n       }\n   \n       public void setR(R r) {\n           this.r = r;\n       }\n   \n       public M getM() {\n           return m;\n       }\n   \n       public void setM(M m) {\n           this.m = m;\n       }\n   }\n   ```\n\n   \n\n\n\n\n\n### 泛型接口\n\n**基本语法**\n\n```java\ninterface  接口名 <T,R...>{\n\n}\n```\n\n细节：\n\n1. 接口中，静态成员也不能使用泛型\n\n2. 泛型接口的类型，在继承接口或者实现接口时确定\n\n3. 没有指定类型，默认为Object\n\n   \n\n### 泛型方法\n\n**基本语法**\n\n```java\n修饰符<T,R...>返回类型 方法名（番薯列表）{}\n```\n\n**注意细节**：\n\n1. 反省方法，可以定义在普通类中，也可以定义在泛型类中\n\n2. 当泛型方法被调用时，类型会确定\n\n3. public void eat（E e）{}，修饰符后没有<T,R..>eat方法不是泛型方法，而是使用了泛型\n\n4. ```java\n   //泛型方法，可以定义在普通类中，也可以定义在泛型类中\n   class Car{\n       public void run(){//普通方法\n   \n       }\n   //    1.T,R就是泛型标识符\n   //    2.提供给fly方法使用的\n       public <T,R> void  fly(T t, R r){//泛型方法\n   \n       }\n   \n   }\n   ```\n\n5. ```java\n   class Car2<T,R>{//泛型类\n       public <U,M> void  fly(U u, M m){//泛型方法\n       }\n       public void  fly2(T t){\n   //        1.该方法不是泛型方法\n   //        2.是fly2方法使用了类声明的泛型\n       }\n   ```\n\n6. ```java \n   Car car = new Car();\n           car.fly(\"baoma\",2000);\n           //在调用方法是，编译器会自动识别传入的参数的类型，就会确定型\n   ```\n\n7. 泛型方法可以使用类声明的泛型，也可使用自己声明的泛型\n\n## 泛型继承和通配符\n\n**介绍**\n\n1)泛型不具备继承性\n\n```java\nList<Object> list = new ArrayList<String>();\n//是错误的，因为泛型中没有继承性\n```\n\n2）<?>:支持任意泛型类型\n\n3）<? extend A>:支持A类以及 A类的子类，规定了泛型的上限\n\n![image-20220511142709072](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142709072.png)\n\n4）<? super A>:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限\n\n![image-20220511142730306](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142730306.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n  \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n# 知识点补充\n\n## JUnit\n\n1. 一个类有很多功能代码需要测试，为了测试，就需要写入main方法中\n2. 如果有很多个功能代码测试，就需要来回注销，切换很麻烦\n3. 如果可以直接运行一个方法，就会方便很多\n\n### 介绍：\n\n1. \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n# 练习部分\n\n## 快速入门部分\n\n1. 开发一个hello.java文件，输出：老王 is studying java！\n\n   1. ```java\n      public class hello{\n      \tpublic static void main(String[] args) {\n      \tSystem.out.println(\"lao wang is studying java\");\n      \t\n      \t}\n      }\n      ```\n\n   2. 需注意的事项：记得吧类部分带上public class 带上，不要只写个方法\n\n## 制表符部分\n\n1. ![image-20220204140604059](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204140604059.png)\n\n   1. ```java\n      public class ChangeChar {\n          public static void main(String[] args) {\n              System.out.println(\"书名\\t作者\\t价格\\t销量\\n三国\\t罗贯中\\t120\\t1000\");\n          }\n      }\n      ```\n\n## 进制部分\n\n* 第一部分\n\n  ```\n  1. 0b110001100\n     =0*2^0 + 0*2^1 + 1*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 0*2^6 + 1*2^7 + 1*2^8\n     =0+0+4+8+0+0+0+128+256\n     =396\n  02456\n  =6*8^0 + 5*8^1 + 4*8^2 + 2*8^3\n  =6+40+256+1024\n  =1326\n  \n  0xA45\n  =5*16^0 + 4*16^1 + 10*16^2\n  =5 + 64 + 2560\n  =2629\n  ```\n\n## 位运算练习\n\n```\n2|3\n1. 2的原码：00000000 00000000 00000000 00000010\n2. 2的补码：00000000 00000000 00000000 00000010\n3. 3的原码：00000000 00000000 00000000 00000011\n4. 3的补码：00000000 00000000 00000000 00000011\n5.2|3：00000000 00000000 00000000 00000010（都为1结果为1否则为0）\n6. 转为原码：00000000 00000000 00000000 00000010\n7.结果为：2\n\n2^3\n1. 2的原码：00000000 00000000 00000000 00000010\n2. 2的补码：00000000 00000000 00000000 00000010\n3. 3的原码：00000000 00000000 00000000 00000011\n4. 3的补码：00000000 00000000 00000000 00000011\n5.2^3:00000000 00000000 00000000 00000001(两位一个为0，一个为1，结果为1，否则为0)\n6.转为原码：00000000 00000000 00000000 00000001\n7.结果为1\n```\n\n## switch练习\n\n1. ![image-20220225162131420](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162131420.png)\n\n   * ![image-20220225162214945](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162214945.png)\n\n2. 3,4,5为春季。6，7，8，为夏季，9,10,11位秋季。12,1,2为冬季\n\n   * ```java\n     Scanner scanner = new Scanner(System.in);\n             System.out.println(\"请输入月份\");\n             int month = scanner.nextInt();\n             if (month>0 && month<=12){\n                 switch (month){\n                     case 3:\n                     case 4:\n                     case 5:\n                         System.out.println(\"春季\");\n                         break;\n                     case 6:\n                     case 7:\n                     case 8:\n                         System.out.println(\"夏季\");\n                         break;\n                     case 9:\n                     case 10:\n                     case 11:\n                         System.out.println(\"秋季\");\n                         break;\n                     case 12:\n                     case 1:\n                     case 2:\n                         System.out.println(\"冬季\");\n                         break;\n                 }\n             }else {\n                 System.out.println(\"输入不合法\");\n             }\n     ```\n\n## 数组部分\n\n* 已知数组{10,12,45,90}。添加一个数使该数组依然是升序的\n\n```java\n//方法1：数组扩容➕冒泡排序\n\npackage basics.chapterArray;\n\nimport java.time.OffsetDateTime;\nimport java.util.Scanner;\nimport java.util.concurrent.ForkJoinPool;\n\npublic class exercisesArryHomeWork {\n    /*\n    * 已知数组{10,12,45,90}\n    * 添加一个数使该数组依然是升序的\n    * */\n    public static void main(String[] args) {\n        int[] arr = {10,12,45,90};\n        char key;\n        Scanner scanner = new Scanner(System.in);\n        int inputnum;\n        int tmp;\n\n        do {\n            int[] arr2 = new int[arr.length+1];\n            for (int i = 0; i <arr.length ; i++) {\n                arr2[i] = arr[i];\n            }\n            System.out.println(\"请输入添加一个数\");\n            inputnum = scanner.nextInt();\n            arr2[arr2.length-1] = inputnum;\n            arr = arr2;\n            for (int i = 0; i <arr.length ; i++) {\n                System.out.print(arr[i]+\"\\t\");\n            }\n\n\n            System.out.println(\"是否继续输入? y/n\");\n            key = scanner.next().charAt(0);\n            if (key == 'y'){\n                System.out.println(\"continue\");\n            }else if (key == 'n'){\n                System.out.println(\"end\");\n                break;\n            }else {\n                System.out.println(\"input error\");\n            }\n        }while (true);\n        System.out.println(\"============数组排序==============\");\n        for (int i = 0; i < arr.length-1; i++) {\n            for (int j = 0; j <arr.length ; j++) {\n                if (j>=arr.length-1){\n                    break;\n                }else if (arr[j]<=arr[j+1]){\n                    System.out.println(\"no change\");\n                }else if (arr[j]>=arr[j+1]){\n                    tmp = arr[j+1];\n                    arr[j+1] = arr[j];\n                    arr[j] = tmp;\n                }\n\n            }\n        }\n\n\n        System.out.println(\"=============输出==============\");\n        for (int i = 0; i <arr.length ; i++) {\n            System.out.print(arr[i]+\"\\t\");\n        }\n\n\n\n\n\n    }\n}\n```\n\n方法二：定位➕扩容\n\n ```\n //1. 先定义原数组 \n //2. 遍历数组，如果发现insertnum < arr[i] ,说明i就是要插入的位置\n //3. 如果index 保留 index =i\n //4. 如果遍历完后，没有发现inserNum<=arr[i] ，说明index = arr.length\n 即：添加到arr的最后\n ```\n\n```java\npackage basics.chapterArray;\n\npublic class exercisesArrayHomeWorkmethod2 {\n    public static void main(String[] args) {\n        int[] arr = {10,12,45,90};\n        int insertNum = 23;\n        int index = -1;\n//          数组定位\n//        1.遍历数组\n        for (int i = 0; i <arr.length ; i++) {\n//            2. 如果arr[i]的这个数大于insertNum则表示这个数的位置是要添加的数的位置\n            if (insertNum<=arr[i]){\n//                3. 用index接受这个位置信息\n                index = i;\n                break;\n            }\n        }\n//        4. 数组扩容添加\n        int[] arr2 = new int[arr.length+1];\n//        创建一个j，当插入前半部分时，j指向arr的数组的数不变。\n        for (int i = 0,j=0; i <arr2.length; i++) {\n//            如果i不等于上面得到的i的位置\n            if ( i != index){\n//                则将arr的数赋给对应的新数组\n                arr2[i] = arr[j];\n                j++;\n            }else {\n\n                arr2[i] = insertNum;\n            }\n        }\n        arr = arr2;\n\n        for (int i = 0; i <arr.length ; i++) {\n            System.out.print(arr[i]+\"\\t\");\n        }\n    }\n}\n\n```\n\n\n\n### 二维数组部分\n\n1. ```java\n   //            int[][] arr = {{4,6},{1,4,5,7},{-2} };\n   //          遍历数组,求和\n   ```\n\n   * ```java\n     public static void main(String[] args) {\n      \n            int sum = 0;\n            int[][] arr = {{4,6},{1,4,5,7},{-2}};\n            for (int i = 0; i < arr.length; i++) {\n                for (int j = 0; j <arr[i].length ; j++) {\n                    sum = sum+ arr[i][j];\n                }\n            }\n            System.out.println(sum);\n        }\n     ```\n\n     \n\n## 面向对象部分\n\n```java\npackage basics.method;\n\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class chapterMethod01 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入一个整数\");\n        int num = scanner.nextInt();\n        AA aa = new AA();\n\n//        第一种写法\n//        boolean t = aa.odd(num);\n//        if (t==true){\n//            System.out.println(\"偶数\");\n//        }else {\n//            System.out.println(\"奇数\");\n//        }\n\n        /*\n        * 第二种写法，较为简洁 。后续较为常见\n        *\n        * */\n\n        if (aa.odd(1)){ //1 为true 2为false\n            System.out.println(\"偶数\");\n        }else {\n            System.out.println(\"奇数\");\n        }\n    }\n}\nclass AA{\n    public boolean odd(int a){\n\n//        if (a%2 ==0){\n//\n//            return true;\n//        }else {\n//\n//            return false;\n//        }\n    return a%2==0 ?  true : false;\n    }\n}\n```\n\n### 递归\n\n1、小球迷宫\n\n![image-20220311132440361](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220311132440361.png)\n\n1. 小球得到的路径和程序员设置的策略有关，即找到的上下左右的顺序相关\n2. 再得到小球路径时，可以先使用（下右上左），再改成（上右下左）\n\n```\n1. 先用二维数组创建迷宫 8行7列\nint[][] map =new int[8][7];\n2.先规定map数组，0表示可以走，1表示障碍物\n3. 将最上的一行，和最下面的一行。设置为1\nfor(int i=0;i<7;i++){\n\tmap[0][i]=1;\n\tmap[7][i]=1\n}\n```\n\n```java\npackage com.smms.demo.method;\n\npublic class homeworkForMaze {\n    public static void main(String[] args) {\n        //1. 先创建迷宫\n        int[][] map = new int[8][7];\n        //2. 定义数组\n        for (int i1 = 0; i1 <7 ; i1++) {\n            map[0][i1] = 1;\n            map[7][i1] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n        map[3][1]=1;\n        map[3][2]=1;\n\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[i].length; j++) {\n                System.out.print(map[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n        System.out.println(\"==================分割线======================\");\n\n        System.out.println(\"use findWay\");\n        T t = new T();\n        t.findWay(map,1,1);\n        System.out.println(\"out print\");\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j <map[i].length ; j++) {\n                System.out.print(map[i][j]+\"\\t\");\n\n            }\n            System.out.println();\n\n        }\n    }\n}\n\n// 使用递归回溯的思想解决该题\n/*\n1.创建findway方法\n2.如果找到，就返回true ，否则返回false\n3.map就是二维数组，即表示迷宫\n4.i,j 就是老鼠的位置，初始化的位置为(1,1)\n5.因为我们使用的是递归找路，所以先规定map内值的含义\n0 表示可以走，1表示障碍物，2表示可以走，3表示走过\n6.当map[6][5] =2就说明找到了通路，就可以结束，否则就继续\n\n7.定下找路的策略，下->右->上->左\n*\n* */\nclass T{\n    public boolean findWay(int[][] map,int i,int j){\n        if (map[6][5]==2){\n            return true;\n        }else {\n            if (map[i][j]==0){\n//                标记可以走通为2\n//                假定可以走通\n                map[i][j]=2;\n    //  找路策略,下->右->上->左\n                if (findWay(map,i+1,j)){\n                    return true;\n                }else if (findWay(map,i,j+1)){\n                    return true;\n                }else if (findWay(map,i-1,j)){\n                    return true;\n                }else if (findWay(map,i,j-1)){\n                    return true;\n                }else {\n                    map[i][j] =3;\n                    return false;\n                }\n            }\n            return false;\n        }\n    }\n}\n\n```\n\n2、汉诺塔\n\n```java\nclass A{\n    public void move(int num,char a,char b, char c){\n        if (num==1){\n            System.out.println(a+\"->\"+c);\n        }else {\n//            如果有多个盘num，可以直接看成2个，最下边的和最上边的\n//            1.先移动上面的盘子到b，借助c\n            move(num-1,a,c,b);\n//            2.吧下面的盘子移动到c\n            System.out.println(a+\"->\"+c);\n//            3.再把b塔的所有盘，移动到c，借助a\n            move(num-1,b,a,c);\n        }\n    }\n}\n```\n\n## 集合\n\n1）分析HashSet和TreeSet分别如何实现去重\n\n1. HashSet的去重机制：hahsCode()+equals()，底层先通过存入对象，进行运算得到一个hash值，通过hash得到对应的索引，如果发现table索引所在的位置没有数据直接存放，如果有数据，就进行equals比较（equals可由程序员重写），如果比较厚，不相同，就加入，相同就不加入\n2. TreeSet去重机制：如果传入了一个Comparator匿名对象，就使用实现Comparator去重，如果方法返回为0，就认为相同的元素/数据，就不添加。如果没有传入Comparator对象，则以添加的对象实现的Compareable的compareTo去重\n\n# 注意事项\n\n1. 一个java文件中只能有一个public类，其他类的个数不限\n   1. public的类名必须和文件名相同\n   2. 编译后每一个类都对应一个class文件\n2. equals方法两种书写方式\n   1. name.equals(\"xxx\");\n   2. \"xxx\".eqauls(name); //推荐这一种，可以避免空指针\n\n\n\n## \n\n\n\n# 面试题\n\n**相关可能问道的面试题目**\n\n1、 JDK、JRE、JVM的关系\n\n1. JDK = JRE + java开发工具\n2. JRE =  JVM ＋ 核心类库\n\n2、 环境变量path的作用\n\n1. 使dos界面能够使用java和javac 等命令\n2. 先配置JAVA_HOME 指向JDK主目录\n3. path根据JAVA_HOME 寻找其子目录\n\n3、 为什么计算机都是以补码的方式运行的\n\n* 因为它将正数负数都统一起来了\n\n4、 new一个对象时，此时内存里发生了什么？\n\n1. 先在方法区创建Person类\n2. 在堆中开辟一个空间，内部存放形参\n   1. 先初始化默认值，0和null，然后再将值赋进去\n   2. 当执行到构造器的时候，值才会赋进去\n   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值\n3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)\n4. ![image-20220314215432778](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png)\n\n\n\n","source":"_posts/java基础笔记.md","raw":"---\ntitle: java基础笔记\ncomments: true\ntoc: true\ndate: 2022-10-27 12:40:00\ncategories:\n  - 学习笔记\n  - java\ntags: java\npic:\n---\n\n[TOC]\n\n\n\n#   java基础\n\n这是快速复习java基础的笔记\n\n## 重要编程思想\n\n**化繁为简**：现将复杂的功能转变成简单的需求。\n\n先死后活：有限考虑固定的值，再考虑变量。\n\n\n\n\n\n\n\n# java概述\n\n知识点：\n\n## [快速练习](##快速入门部分)\n\n1. 使用黑窗口编译.java文件时，注意要把需要编译的java文件编码设置与cmd黑窗口编码相同\n\n2. ```java\n   javac hello.java //编译指令\t\t\t\n   ```\n\n3. ```java\n   java hello //运行指令\t\n   //注意不要带文件后缀，否则报错\n   ```\n\n4. java执行流程分析\n\n   1. ![image-20220204113338135](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204113338135.png)\n\n## [制表符](##制表符部分)\n\n1. ```\n   \\t 一个制表位，实现对其功能\n   \\n 换行符，\n   \\\\ 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠\n   \\\t\\将\"\"：号输出显示出来，在前面添加\\\" \\\" 也可转义其他符号例如'\n   // \\r 表示一个回车 例如：System.out.println(\"韩顺平教育\\r北京\");\n   \t\t// 执行步骤：\n   \t\t// \t1. 先输出韩顺平教育\n   \t\t//  2. 执行回车后，相当于光标来到了最开头\n   \t\t//  3. 再输出北京\n   \t\t//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了\n           可以加个\\n换行防止覆盖\n   \n   ```\n\n2. ````java\n   class ChangeChar{\n   \tpublic static void main(String[] args){\n   \t\t// \\t 一个制表位，实现对其功能\n   \t\tSystem.out.println(\"beijing\\tshanghai\\tguangzhou\");\n   \t\t// \\n换行\n   \t\tSystem.out.println(\"jack\\nlisa\\nnino\");\n   \t\t// \\\\ 输出一个斜杠\\ \n   \t\t// 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠\n   \t\tSystem.out.println(\"c\\\\a\\\\v\\\\b.exe\");\n   \t\t// \\将\"\"：号输出显示出来，在前面添加\\\" \\\"\n   \t\tSystem.out.println(\"老王说：\\\"hello\\\"\");\n   \t\t// \\r 表示一个回车 System.out.println(\"韩顺平教育\\r北京\");\n   \t\t// 执行步骤：\n   \t\t// \t1. 先输出韩顺平教育\n   \t\t//  2. 执行回车后，相当于光标来到了最开头\n   \t\t//  3. 再输出北京\n   \t\t//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了\n   \t\tSystem.out.println(\"韩顺平教育\\r\\n北京\");\n   \n   \t}\n   }\n   ````\n\n# 注释\n\n1. 文档注释\n\n   1. ```\n      javadoc -d 路径文件 -xx -yy xxx.java\n      生成文档命令\n      xx yy 分别代码javadoc标签命令 例如-auther -version等\n      ```\n\n   2. ```java\n      @author 标明开发该类模块的作者 \n      @version 标明该类模块的版本 \n      @see 参考转向，也就是相关主题 \n      @param 对方法中某参数的说明 \n      @return 对方法返回值的说明 \n      @exception 对方法可能抛出的异常进行说明 \n      \n      @author 作者名 \n      @version 版本号\n      其中，@author 可以多次使用，以指明多个作者，生成的文档中每个作者之间使用逗号 (,) 隔开。@version 也可以使用多次，只有第一次有效 \n      \n      使用 @param、@return 和 @exception 说明方法 \n      这三个标记都是只用于方法的。@param 描述方法的参数，@return 描述方法的返回值，@exception 描述方法可能抛出的异常。它们的句法如下： \n      @param 参数名 参数说明 \n      @return 返回值说明 \n      @exception 异常类名 说明 \n      \n      ```\n\n# 变量\n\n## 数据类型\n\n### 变量\n\n1. 变量本质就是一个变化的值。\n\n2. 变量有三个基本要素\n\n   1. 类型\n   2. 名称\n   3. 值\n\n3. ```java\n   public static void main(String[] args){\n   \tint a=1;\n   \t//定义了一个变量，类型为int，名称为a，值为1\n   \ta=89;\n       //把89这个值赋给了a变量\n   }\n   ```\n\n4. 注意事项：\n\n   * 变量表示内存中的一个储存区域，[不同的变量，类型不同，占用的空间大小不同，比如：int 4个字节，double 8个字节]\n   * 该区域有自己的名称[变量名]和类型[数据类型]\n   * 变量必须先声明，后使用，有着自身的顺序\n   * 该区域的数据可以在同一类型范围内不断变化\n   * 变量在同一个作用域内不能重名\n   * 变量=变量名+值+数据类型，变量三要素\n\n### 运算符\n\n1. +号的使用\n   * 当左右两边为数值类型的时候，做加法运算\n   * 当左右两边有一方为字符串类型时，做拼接运算\n\n### 数据类型\n\njava数据类型\n\n1. 基本数据类型\n\n   * 数值型\n     * 整数类型，存放整数（byte[1],short[2],int[4],long[8])\n     * 浮点（小数）类型（float[4]，double[8])\n   * 字符型（char[2]），存放单个字符'a'\n   * 布尔型（Boolean[1]），存放true，false\n\n2. 引用数据类型（面向对象部分讲解）\n\n   * 类（class）\n   * 接口（interface）\n   * 数组（[]）\n\n3. 八大基本数据类型\n\n   【byte，short，int，long，float，double】，char，Boolean\n\n4. 浮点数据类型\n\n   1. 默认情况下输入的字符默认是double类型的\n\n   2. 如果想改成float类型需要在数值后面加上f或F\n\n   3. ```java\n      float a = 1.1 //错误\n      float a = 1.1F //正确\n      double b = 1.1\t//正确\n      double b = 1.1F\t//正确\n      ```\n\n   4. 平时使用默认的double类型就行，因为更为精确\n\n   5. 浮点数使用陷阱\n\n      * ```java\n        //例如\n        //2.7和8.1/3 比较\n        double a = 2.7 ;\n        double b = 8.1/3 ;//理论上数学得数是2.7\n        System.out.println(a);//2.7\n        System.out.println(b);//得数是一个接近2.7的一个小数，而不是2.7\n        //因为计算机计算机制的问题，不是数学的问题。\n        所以在做相等判断时需要小新\n        ```\n\n      * ```java\n        //类似问题的解决方法\n        double a = 2.7 ;\n        double b = 8.1/3 ;//理论上数学得数是2.7\n        System.out.println(a);//2.7\n        System.out.println(b);\n        \n        if(a == b){\n        //这样的写法会出问题\n        \tSystem.out.println(\"相等\");\n        }\n        \n        //可以使用计算其差值\n        if(Math.abs(a-b)<0.001){\n        \tSystem.out.println(\"差值非常小，到我规定的精度内，认为相等\");\n            \n           // Math方法调用java API\n           \n        }\n        ```\n\n5. 字符类型\n\n   1. char的本质就是一个整数，默认用的是Unicode编码\n   2. 字符常量用单引号引出来，\n      * 例：char a = 'a';\n      * char b = '/n';\n   3. 不能输入双引号，否则会认成字符串，会报错。\n   4. char类型时可以运算的。\n\n   字符型的本质\n\n   * 字符型储存到计算机中，需要将对应的码值（整数）找出来\n\n   * 字符和码值的对应关系是通过字符编码表决定的（是规定死的）\n\n   * ![image-20220205221255475](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220205221255475.png)\n\n6. 布尔类型\n\n   1. 只占一个字节，只允许true和false\n   2. 用于判断操作\n   3. 不可用0或非0 来代替true或false，c语言可以\n\n## 数据类型转换\n\n### 1、自动类型转换\n\n* 精度小的类型自动转换为精度大的数据类型，反之就会报错。\n\n* char < int < long < float < double \n\n* byte < short < int < long < float < double\n\n* ```java\n  //例：\n  int num = 'a';\n  ```\n\n1. 注意事项\n\n   1. 多重类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的哪种数据类型，然后再进行计算\n\n    ```java\n     //例\n     int n1 = 10;\n     float d1 = n1+1.1;\n     //这是错误的，因为转换成最大单位，1.1默认的类型是double类型的，如果是n1＋1.1f 的话就是正确的\n     double d1 = n1+1.1;\n     // 这是正确的；\n    ```\n\n   2. （ byte , short ) 和 char之间不会相互转换，当把一个具体的数赋给byte时。\n\n      1. 先判断该数是否在byte范围内，如果是就可以\n\n   3. byte，short，char 三者可以进行计算，在计算时都会先转换成int类型\n\n      * ```java\n        byte b1 = 1;\n        byte a1 = 1;\n        short b2 = 1;\n        short s2 = b1 + b2//错误\n        //因为计算时会转换成int类型，int不能再赋给比它小的类型short\n        int s2 = b1 + b2 //正确\n        byte s3 = a1 + b1//错误\n        //byte，short，char,只要涉及计算都会转换为int类型，所以错误\n        ```\n\n   4. 布尔类型 ( boolean ) 不参与类型转换\n\n   5. 自动提升原则：表达式结果的类型自动提升为 操作数中最大的类型。\n\n### 2、强制类型转换\n\n1. 简介\n\n   1. 大的数据类型转换为小的数据类型\n   2. 使用时要加上强制转换字符（类型）\n   3. 可能会出现精度降低和溢出问题\n\n2. 注意细节\n\n   1. 将数据从大到小转换，需要强制转换\n\n   2. ```java\n      //强制转换符只对最近的操作数有效，也就是只对下边的10数字有效，转换后再进行计算又会转换成double类型。\n      int x = (int)10*3.5+6*1.5;//提示编译错误，类型是double ->\n      \n      int x = (int)(10*3.5+6*1.5);//用小括号括起来即可完美解决上述问题\n      ```\n\n3、基本数据类型和String类型的转换\n\n1. 介绍\n\n   1. 在程序开发中，我们经常需要吧基本数据类型转换成String类型，或String转基本数据类型\n\n2. 方式\n\n   * 基本转String\n\n     * 基本数据类型的值+\" \" \n\n     * ```java\n       //例\n       int n1 = 123;\n       float f = 2.3f;\n       double b = 4.5;\n       String str1 = n1 +\" \";\n       String str2 = f +\"\";\n       String str3 = b +\"\";\n       \n       ```\n\n   * String 转基本\n\n     * 调用基本类型的包装类方法parseXXX 方法即可\n\n     * ```java\n       String s5= \"123\";\n       integer.parseInt(s5);\n       Double.parseDouble(s5);\n       Float.parseFloat(s5);\n       //怎么吧字符串转成字符char，含义是指吧字符串的第一个字符得到\n       system.out.println(s5.charAt(0));//获取字符串的第一个字符\n       //所以这个输出的值为1\n       ```\n\n3. 注意事项\n\n   1. string转换基本类型时，要确保string类型能够转成有效数据，可以吧'123'转换成一个整数，但不能吧\"hello\"转换成一个整数\n\n# 运算符\n\n## 运算符\n\n### 1.简介\n\n1. 是一种特殊符号，表示数据的运算、赋值和比较等\n2. 种类\n   * 算数运算符\n   * 赋值运算符\n   * 关系运算符(比较运算符)\n   * 逻辑运算符\n   * 位运算符 [ 需要二进制基础 ]\n   * 三元运算符\n\n### 2.算数运算符\n\n1. 对数值类型的变量进行运算的\n2. 预览：![image-20220211161920431](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220211161920431.png)\n3. 注意事项\n   * 取模\n   * <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">再%的本质，看一个公式 a % b = a-a / b * b</span>\n4. 面试题\n   1. ![image-20220213151013682](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213151013682.png)\n      1. 答案为 1\n         * 运行步骤为\n         * (1)先把 i 的值赋给一个临时变量tmp\n         * (2)再进行计算i++，结果为i=2\n         * (3)tmp的值重新赋给i，此时i =1\n      2. 答案为2\n         * 运行步骤为\n         * (1)再进行计算i++，结果为i=2\n         * (2)再将2移到临时变量tmp\n         * (3)tmp赋给 i\n\n### 3.关系运算符（比较运算符）\n\n1. 介绍\n   * 关系运算符的结果都是boolean型，\n   * 通常用在if条件语句结构条件中\n   * 关系运算符组成的表达式成为关系表达式\n2. 预览图\n\n![image-20220213162614379](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213162614379.png)\n\n\n\n### 4.逻辑运算符\n\n预览：\n\n1. ![image-20220213170452994](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170452994.png)\n\n2. ![image-20220213170753311](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170753311.png)\n\n3. ![image-20220213170926798](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170926798.png)\n\n4. ```\n   &&（短路与）\t只有两个条件都为true ，才为true\t//如果第一个条件为false，则后面的条件不执行，直接输出flase，效率高\n   \n   &\t（逻辑与）\t只有两个条件都为true ，才为true\t//两个条件都执行，效率低\n   ```\n\n5. ![image-20220214140501385](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220214140501385.png)\n\n6. ```java\n   取反\n   真变假，假变真\n   //a^b :叫逻辑异或，当a和b不同时，结果为true，否侧为false\n   例：\n   \tboolean b = (10>1) ^ (3<5);\n   \tSystem.out.println(\"b=\"+b);//f\n   ```\n\n### 5.赋值运算符（=）、\n\n分类：\n\n* 基本赋值运算符 = \tint a = 10；\n\n* 复合赋值运算符\n\n  ```\n  +=，-=，*=，/=，%=等等，\n  例：a += b;[等价 a=a+b;]\n  \ta -=b;[等价 a = a-b;]\n  一般情况加复合赋值运算符，前边都有基本赋值运算符\n  ```\n\n* 复合运算符会进行类型转换\n\n  ```java\n  byte a =3;\n  a += 2; //此时计算结果为int类型\n  //不会报错，因为会自动进行类型转换\n  \n  //不能直接写成\n  a=a+2; //会报错\n  \n  // 像a++，++a这种会都进行自动的类型转换\n  ```\n\n### 6.三元运算符\n\n* 语法：条件表达式？ 表达式1: 表达式2；\n\n* 运算规则：\n\n  1. 如果条件表达式为true，运算后的结果是表达式1；\n\n  2. 如果条件表达式为false，运算后的结果是表达式2；\n\n     口诀：【一灯大师：一真大师（如果为真，返回1）】\n\n  3. 例：\n\n     ```java\n     int a = 10 ;\n     int b = 99 ;\n     // 1.如果 结果为false\n     // 2.返回b--，先返回b，再进行b-1。依旧按照之前的a++,++a的计算形式\n     // 3.结果为99\n     int result = a > b ? a++; b--;\n     //如果a>b 为真，返回a++，如果为false返回b--;\n     \n     ```\n\n  4. 本质就是if，else语句\n\n### 7.运算符优先级\n\n* ![image-20220215150928654](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220215150928654.png)\n* 小结：优先级排名\n  1. () ，{}等优先级最高\n  2. 单目运算==a ，--a等；\n  3. 算术运算符+-\n  4. 位移运算符\n  5. 比较运算符\n  6. 逻辑运算符\n  7. 三元运算符\n  8. 赋值运算符\n\n## 标识符\n\n**标识符的规则和规范**\n\n1. java中对各种变量、方法和类的命名使用的字符成为标识符。\n\n* ```java\n  int num =1;\n  // num就是标识符\n  ```\n\n2. 标识符的命名规则必须遵守\n   * 标识符由26个字母的大小写，0-9，_或$符组成。\n   * 不可以用数字开头\n   * 不可以使用关键字和保留至，但能包含关键字和保留字\n   * 标识符不能包含空格\n3. 标识符命名规范\n   * 包名：多单词组成时，所有字母都小写。例：aaa.bbb.ccc\n   * 类名、接口名：多单词组成是，所有单词首字母大写，驼峰命名法\n   * 变量名、方法名：多单词组成时，第一个单词首字母小写，后面单词的首字母大写。例：aaBbCc\n   * 常量名：所有字母都大写。多单词时用下划线隔开。例：A_B_C\n\n##   键盘输入语句\n\n### 1.介绍\n\n在编程过程中需要接受用户的输入数据，可以使用键盘输入语句来获取。input.java，需要一个扫描器（对象），就是Scanner\n\n### 2.步骤\n\n1）导入该类所在的包，java.utill.*\n\n2）创建该类对象（声明变量）\n\n3）调用里面的功能\n\n### 3.案例\n\n```java\npublic class KeyboardInput {\n    public static void main(String[] args) {\n//        创建Scanner对象\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.println(\"请输入文本1\");\n//        z字符串类型\n        scanner.next();\n        System.out.println(\"请输入age\");\n//        nextint 代表接收一个int类型的输入\n        scanner.nextInt();\n//        接收double类型的\n        scanner.nextDouble();\n\n    }\n\n```\n\n\n\n\n\n## 进制\n\n### 介绍\n\n对于整数，有四种表达方式\n\n* 二进制（Bin/B）：0,1，满2进1，以0b或0B开头\n\n* 八进制（OCT/O）：0-7，满8进1。以数字0开头表示\n\n* 十进制（DEC/D）：0-9，满10进1\n\n* 十六进制（HEX/H）：0-9及A(10)-F(15)，满16进1.以0x或0X开头表示。此处的A-F不区分大小写\n\n* ```java\n  int n1 = 0b1010;\n  int n2 = 01010;\n  int n3 = 1010;\n  int n4 = 0x10101;\n  ```\n\n  \n\n### 进制转换（基本功）*\n\n第一组\n\n1. 二进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和\n\n   * ```\n     例\n     0b 1011  =1*2^0+1*2^1+0*2^2+1*2^\n     = 1+2+0+8\n     =11\n     \n     ```\n\n2. 八进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和。\n\n   * ```\n     例：0234转成十进制\n     0 234\n     =4*8^0 + 3*8^1 + 2*8^2 \n     =4+24+128\n     =156\n     ```\n\n3. 十六进制转十进制\n\n   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和\n\n   * ```\n     例：0x 23A转成十六进制\n     =10*16^0 + 3*16^1 + 2*16^2\n     =10 + 48 + 512\n     =570\n     A(10),B(11),C(12),D(13),E(14),F(15)\n     ```\n\n[第一部分练习](###进制部分)\n\n第二组\n\n1. 十进制转二进制\n\n   * 规则：将该数不断除2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制\n\n   * ```\n     将34转换成二进制\n     34%2\t余0\n     17%2  余1\n     8%2\t\t余0\n     4%2\t\t余0\n     2%2\t\t余0\n     1%2\t\t余1\n     反着读\n     结果：0b100010 //前缀0b的意思为二进制\n     正确答案为：0b00100010\n     因为一个字节二进制的是八位，34的出的结果是六位所以前面需要多加两个0\n     ```\n\n2. 十进制转八进制\n\n   * 规则：将该数不断除8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的八进制\n\n   * ```\n     例：将131转为八进制\n     131%8\t\t余3\n     16%8\t\t余0\n     2%8\t\t\t2\n     结果为0203前面的0代表的意思是八进制\n     ```\n\n3. 十进制转十六进制\n\n   * 规则：将该数不断除16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的十六进制\n\n   * ```\n     例：237\n     答案为 ED\n     ```\n\n   * ![image-20220216221217568](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220216221217568.png)\n\n第三组\n\n1. 二进制转八进制\n\n   * 规则：从低位开始，将二进制数的每三位一组，转成对应的八进制数即可\n\n   * ```\n     例：0b 11010101 每三个转成十进制再拼起来\n     =325\n     11100101\n     =345\n     ```\n\n2. 二进制转十六进制\n\n   * 从低位开始，将二进制数的每四位一组，转成对应的十六进制即可\n\n   * ```\n     11010101\n     =0xD5\n     1110010110\n     =0x396\t每四个转成十进制再拼起来\n     ```\n\n第四组\n\n1. 八进制转二进制\n\n   * 规则：将八进制数每一位，转成对应的3位的二进制数\n\n   * ```\n     237  每位以十进制转二进制转成对应的3位二进制数再连起来\n     2（010）3（011）7（111）\n     =010011111\n     \n     1230\n     =1(001)2(010)3(011)0(000)\n     =001010011000\n     ```\n\n2. 十六进制转二进制\n\n   * 规则：将八进制数每一位，转成对应的4位的二进制数\n\n   * ```\n     23B\n     =2(0010)3(0011)B(1011)\n     =001000111011\n     AB29\n     =A(1010)B(1011)2(0010)9(1001)\n     =1010101100101001\n     ```\n\n源码，反码，补码（重点）\n\n对于有符号的数而言（八个规则）：\n\n1. 二进制的最高位是符号位：0表示正数，1表示负数（口诀：0 - >0   1-> -）\n2. 正数的原码，反码，补码都一样（三码合一）\n3. 负数的反码 = 它的原码符号位不变，其他位取反（0->1,1->0）0变1,1变0.\n4. 负数的补码 = 它的反码+1，负数的反码 = 负数的补码-1\n5. 0的反码，补码都是0\n6. java没有无符号的数，换而言之，java中的数都是有符号的\n7. 计算机运算的时候，都是以 <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">补码的方式来运算的</span>\n8. <span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">当我们看运算结果的时候，要看它的原码（！！！）</span>\n\n\n\n## 位运算\n\n* java中有七个位运算符（&，|，^，~，>>，<<和>>>）\n\n* 分别是：\n\n  * &：按位与\n\n    * 规则：两位全为1，结果为1，否则为0\n\n    * ```\n      例：\n         10011010\n        &11011101\n      -------------\n        =10011000// 两个都1结果才为1\n      ```\n\n  * |：按位或\n\n    * 规则：两位有一个为1，结果为1，否则为0\n\n    * ```\n          10011010\n        &11011101\n      -------------\n        =11011111// 两个有一个1结果才为1\n      ```\n\n  * ^：按位异或\n\n    * 规则：两位一个为0，一个为1，结果为1，否则为0\n\n    * ```\n      10011010\n      &11011101\n      ```\n\n    -------------\n\n        =01000111// 两位一个为0，一个为1，结果为1，否则为0\n\n      ```\n    \n      ```\n\n  * ~：按位取反\n\n    * 规则：0为1,1为0\n\n```\n//位移运算\nint a = 1>>2; // 1 向右位移2位\nint b = -1>>2;\nint c = 1<<2; //左移 2位\nint d = -1<<2;\nint e = 3>>>2;//无符号右移\n\n\n```\n\n[练习部分](##位运算练习)\n\n```\n2&3计算机计算流程（计算机是按照补码进行计算的）\n因为一个字节是八位，一个int类型有4个字节\n1.先得到2的补码 ===>* 源码00000000 00000000 00000000 00000010 //得到原码\n* 转成补码（正数的三码都一样）\n00000000 00000000 00000000 00000010\n2. 得到3的补码 ====>先获得原码00000000 00000000 00000000 00000011\n得到3的补码\n00000000 00000000 00000000 00000011\n\n3.计算2&3\n补码结果为：00000000 00000000 00000000 00000010\n原码也为：00000000 00000000 00000000 00000010\n最终结果为：2\n```\n\n````\n~-2计算过程\n1. 得到-2的原码10000000 00000000 00000000 00000010\n2. 算出-2的反码11111111 11111111 11111111 11111101（原符号位保持不变，其他取反）\n3. 算出-2的补码11111111 11111111 11111111 11111110\n4.再进行~-2操作00000000 00000000 00000000 00000001//运算后的补码\n5.转为原码00000000 00000000 00000000 00000001\n6.结果为1\n````\n\n```\n~2的计算过程\n1.得到2的原码00000000 00000000 00000000 00000010\n2.获取补码：00000000 00000000 00000000 00000010\n3.计算~2:11111111 11111111 11111111 11111101\n3.转为反码（）负数的反码=补码-1\n11111111 11111111 11111111 11111100\n4.转为原码：10000000 00000000 00000000 00000011\n5.结果为-3\n```\n\n* 运算符>>，<<和>>>运算规则\n\n  * 算数右移>>；低位溢出，符号位不变，并用符号位补溢出的高位\n\n    * ```\n      int a = 1>>2;\n      1:00000000 00000000 00000000 00000001\n      1 >>2 //相当于把最后边的01去掉用符号位补上\n      结果：00000000 00000000 00000000 00000000\n      最后结果为0\n      \n      简便的方法\n      1>>2 = 1/2/2= 0\n      15>>2 = 15/2/2=3  //取整\n      ```\n\n  * 算数左移<<; 符号位不变，低位补0\n\n    * ```\n      int a =1<<2;\n      1:00000000 00000000 00000000 00000001\n      1<<2\n      00000000 00000000 00000000 00000100\n      结果为4\n      \n      简便的方法\n      1<<2 =1*2*2 = 4\n      4<<3 = 4*2*2*2 = 32\n      \n      ```\n\n  * 3.>>>逻辑右移，也叫无符号右移，运算规则是：低位溢出，高位补0\n\n# 程序控制结构\n\n## 顺序控制（if,else,switch）\n\n### 介绍\n\n程序从上到下逐行执行，中间没有任何判断和跳转\n\n### 分支控制\n\n### **1）单分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块;\n}\n```\n\n说明：当条件表达式为true时，则执行{}内的代码。false就不执行。如果只有一条执行语句，可以省略{}。但不建议省略\n\n### **2）双分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块1;\n}else{\n\t执行代码块2;\n}\n```\n\n\n\n### **3）多分支**\n\n基本语法：\n\n```java\nif(条件表达式){\n\t执行代码块1;\n}else if(条件表达式){\n\t执行代码块2;\n}else{\n\t执行代码块....;\n}.....\n```\n\n流程图：\n\nelse只能有一个执行入口\n\n![image-20220222162201564](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220222162201564.png)\n\n特别说明：\n\n1. 多分支可以没有else，如果所有条件都不成立，则一个执行入口都没有\n2. 如果有else，如果所有的条件表达式都不成立，则默认执行else代码块。\n\n练习：\n\n```java\npublic class ifChapter {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入0-100的数字\");\n        int num = scanner.nextInt();\n        if (num<1 && num>100){\n            if (num==100){\n                System.out.println(\"信用极好\");\n            }else if (num>80 && num <= 99){\n                System.out.println(\"信用优秀\");\n            }else if (num >= 60 && num <= 80){\n                System.out.println(\"信用一般\");\n            }else if (num <60){//或直接不写这个条件语句，但这个会有bug\n                System.out.println(\"不及格\");\n            }else{\n                System.out.println(\"请输入合法数字\");\n            }\n        }else{\n            System.out.println(\"输入不合法\");\n        }\n    }\n}\n```\n\n### **4）嵌套分支**\n\n介绍：\n\n一个分支完整的嵌套了另一个分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支。\n\n规范：不建议超过三层（可读性不好）\n\n基本语法：\n\n```java\nif(){\n\tif(){\n\t\n\t}else{\n\t\tif.....\n\t}\n}\n```\n\n### 5）switch分支\n\n基本语法：\n\n```java\nswitch(表达式){ //表达式为具体的一个值\n    case 常量1:\n语句块1;\nbreak;\n    case 常量2:\n语句块2;\nbreak;\n    case ······:\nbreak;\n ...........\n       \ndefault :\ndefault语句块\nbreak;\n}\n```\n\n1. switch 关键字,表示swtich分支\n2. 表达式   对应一个值\n3. case常量1：当表达式的值等于常量1，就执行语句块1\n4. break：表示退出switch\n5. 如果case 常量1 匹配，就执行语句块1，如果没有则继续case 常量2；\n6. 如果一个都没有匹配上，就执行default\n\nSwitch流程图：\n\n![image-20220224155515378](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220224155515378.png)\n\n 注意：\n\n* 穿透\n  1. 如果case1 没有break\n  2. 则case不进行判断直接执行case2 的语句块\n\n```java\npublic static void main(String[] args) {\n        char week;\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入字母\");\n        week = scanner.next().charAt(0);\n        switch (week){\n            case 'a':\n                System.out.println(\"Monday\");\n                break;\n            case 'b':\n                System.out.println(\"Tuesday\");\n                break;\n            case 'c':\n                System.out.println(\"Wednesday\");\n            case 'd':\n                System.out.println(\"Thursday\");\n                break;\n            case 'e':\n                System.out.println(\"Friday\");\n                break;\n            case 'f':\n                System.out.println(\"Saturday\");\n                break;\n            case 'g':\n                System.out.println(\"sunday\");\n                break;\n            default:\n                System.out.println(\"输入有误，请输入a-g的字母\");\n        }\n    }\n```\n\n注意事项和细节\n\n1. 表达式数据类型，应和case后的常量类型一致，或者是可以自动转换成可以相互比较的类型，比如输入的是字符，而常量是int\n\n2. Switch(表达式)中表达式的返回值必须是：（byte，short，int，char，enum，String）\n\n   ```java\n   //比如下列例子，是不可以的\n   double a = 1.1;\n   switch(a){//错误\n   \tcase 1.1://case后面不可以有变量\n   \t\tSystem.out.println(\"···\");\n   \t\tbreak;\n   }\n   ```\n\n3. case子句中的值必须是常量，不能是变量\n\n4. default子句是可选的，当没有匹配的case时，执行default。default语句是可选的，当没有匹配的任何常量，则没有任何输出。\n\n5. break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有则会出现穿透现象，使程序执行后面所有的case语句块，除非遇到break；\n\n6. [练习](##switch练习)\n\n**switch 和if的比较**\n\n1. 如果判断的具体数值不多，而且符合byte，short，int，char，enum，string类型虽然这两个语句都可以用，建议用switch\n2. 其他情况，对区间判断，对结果为boolean配型判断，使用if，if的使用范围更广\n\n## 循环控制（for,while,dowhile,多重循环[重点]）\n\n### 1）for循环\n\n1. 基本语法\n\n   ```java\n   for(循环变量初始化；循环条件；循环变量迭代){\n   \t循环操作；(可多条语句)\n   }\n   \n   ```\n\n   \n\n2. 说明\n\n   1. for关键字，表示循环控制\n   2. for有四要素，1）循环变量初始化，2）循环条件，3）循环操作，4）循环变量迭代\n   3. 循环操作，这里可以有很多条语句，也就是我们要执行的代码块\n   4. 如果 循环操作(语句)只有一条语句，可以省略{}，建议不要省略\n\n例子：\n\n```java\npublic static void main(String[] args) {\n\n        //练习： 打印100句“韩顺平教育”\n        for (int i = 0; i < 10; i++) {\n            System.out.println(\"韩顺平教育\" +i);\n        }\n\n\n    }\n```\n\n* for循环流程图\n  * ![image-20220227123857620](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227123857620.png)\n\n#### 注意事项：\n\n* 循环条件返回一个布尔值(Boolean)\n\n* for（；循环条件；）中的初始化和变量迭代可以写到其他地方，但两边的分号不能省略\n\n  * ```java\n    //演示\n    int i = 0;\n    for (i; i < 10;) {\n                System.out.println(\"韩顺平教育\" +i);\n                 i++;\n            }\n    \n    //补充\n    for(;;){//表示一个无限循环\n       System.out.println(\"韩顺平教育\" +i);\n    }\n    ```\n\n* 循环初始值，可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开\n\n  * ```java\n    //例\n    int count =3;\n    for (i =0 ,j = 0 ;i<count; i++, j+=2){\n    \tSystem.out.println(\"i=\"+i \"j=\" +j);\n    }\n    输出 ：00 12 24\n    ```\n\n  * 00 12 24 \n\n#### **编程技巧**\n\n* 化繁为简：将复杂的需求拆解成简单的需求\n* 先死后活：先考虑固定的值，然后转成可以灵活变化的值\n\n**练习**\n\n1. 打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]\n\n   * ```\n     \n     ```\n\n   * ```java\n     //打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]\n           //1、先输出1-100循环\n           //2、在输出的过程中过滤9的倍数\n           //3、定义一个变量来累计计算个数\n           //4、定义一个变量来累计计算总和\n     public static void main(String[] args) {\n             int count= 0;\n             int sum =0;\n             for (int i = 1; i <=100 ; i++) {\n                 if (i%9==0){\n                     System.out.println(\"i=\"+i);\n                     count++;\n                     System.out.println(\"数量\"+count);\n                     sum+=i;// = sum + i\n                     System.out.println(\"sum=\"+sum);\n                 }\n     \n             }\n     ```\n\n### 2）while循环\n\n基础语法：\n\n```java\nwhile（循环条件）{\n\t循环体（语句）；\n\t循环变量迭代；\n}\n```\n\n说明：\n\n1. while循环也有四要素\n2. 只是四要素放的位置，和for不一样\n\n**流程图**\n\n![image-20220227143009846](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227143009846.png)\n\n#### 注意事项：\n\n1. 循环条件是返回布尔值\n2. while循环是先判断再执行语句\n\n\n\n### 3）do...while循环控制\n\n基础语法：\n\n```java\ndo{\n\t循环体(语句);\n\t循环变量迭代;\n}while(循环条件);\n\n```\n\n 说明:\n\n1. do  while 是关键字\n\n2. 也有循环四要素，只是位置不一样\n\n3. 先执行，在判断，也就是说，一定会执行一次\n\n4. 最后有一个分号\n\n5. while和do... while区别\n\n   * while是先判断再执行\n\n   * do .. while是先执行再判断\n\n```java\npublic static void main(String[] args) {\n\n       int i = 1;\n        do {\n            System.out.println(\"阿巴阿巴\");\n            i++;//不要忘记加上，否则容易死循环\n        }while (i<=10);\n\n        System.out.println(\"exit dowhile\");\n    }\n```\n\n\n\n流程图：\n\n![image-20220227163555197](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227163555197.png)\n\n#### 注意事项：\n\n1. 循环条件是返回一个布尔值的表达式\n2. do...while 循环是先执行后判断，因此它至少执行一次\n\n\n\n### 4）多重循环\n\n#### 介绍\n\n1. 讲一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do ...while均可以作为外层循环和内层循环 。【建议一般使用两层，最多不超过三层，否则代码可读性很差】\n\n2. 实质上，嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环\n\n3. 例：设外层循环次数为m次，内层为n次。则内层循环体实际上需要执行m*n次\n\n   ```java\n   for (int i = 0; i < 2; i++) {\n               for (int j = 0; j < 3; j++) {\n                   System.out.println(\"i = \"+i+ \",\"+\"j = \"+j);\n               }\n           }\n   \n   ------------------------输出------------------------\n   i = 0 , j =0\n   i = 0 , j =1\n   i = 0 , j =2\n   i = 1 , j =0\n   i = 1 , j =1\n   i = 1 , j =2\n   ```\n\n   \n\n#### 练习\n\n1. 统计3个班成绩情况，每个班有5名同学，求出各个班的平均成绩和所有班级的平均分【学生的成绩从键盘输入】\n\n   * ```java\n     Scanner scanner = new Scanner(System.in);\n     //        int clss = 1;\n                 int stu =0;\n                 double sum = 0;\n             for (int i = 1; i <=3 ; i++) {\n                 for ( int j = 1;j<=5;j++){\n     \n                     System.out.println(\"请输入\"+i+\"班\"+j+\"成绩\");\n                     int s = scanner.nextInt();\n                     sum = sum + s;\n                 }\n                 System.out.println(i+\"班的平均分为：\"+(sum / 5));\n                 sum =0;\n             }\n     ```\n\n     \n\n2. 打印99乘法表\n\n   * ```java\n     for (int i = 1; i <=9 ; i++) {\n        \n                 for (int j = 1; j <=i ; j++) {\n                     System.out.print(i+\"*\"+j+\"=\"+(i*j)+\"  \");\n     \n     \n                 }\n                 System.out.println(\"\");\n             }\n     ```\n\n3. 打印空心金字塔\n\n   * ```java\n     //        实心金字塔\n             for (int i = 1; i <=5 ; i++) {\n                 for (int k = 1; k <=5-i ; k++) {\n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n     \n                     System.out.print(\"*\");\n                 }\n                 System.out.println(\" \");\n             }\n     ```\n\n   * ```java\n     空心金字塔 【难点】\n             for (int i = 1; i <=5 ; i++) {\n                 for (int k = 1; k <=5-i ; k++) {\n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n                 \n                 \n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n                 \n                 \n     \t\t\t\t//1.空心金字塔的第一层和最后一层的*全部输出\n     \t\t\t\t//2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示\n     \t\t\t\t//3.再加一个条件 i == 5\n     \t\t\t\tif(j == 1 || j == 2*i-1 || i==5 ){\n     \t\t\t\t\t System.out.print(\"*\");\n     \t\t\t\t}else{\n     \t\t\t\t\t System.out.print(\" \");\n     \t\t\t\t}\n     \n     //可以将其中的5 提出来换成变量，实时控制金字塔的层数\n     \n                    \n                 }\n                 System.out.println(\" \");\n             }\n     ```\n\n     \n\n   * ```java\n     //可手动修改的\n     \n           Scanner scanner = new Scanner(System.in);\n           System.out.println(\"请输入层数\");\n           int layer = scanner.nextInt();\n     ```\n\n\n             for (int i = 1; i <=layer ; i++) {\n                 for (int k = 1; k <=layer-i ; k++) {\n    \n     //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                     System.out.print(\" \");\n                 }\n     //            控制每个打印的*的层数\n                 for (int j = 1; j <=2*i-1 ; j++) {\n    \n                     //1.空心金字塔的第一层和最后一层的*全部输出\n                     //2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示\n                     //3.再加一个条件 i == 5\n                     if(j == 1 || j == 2*i-1 || i==layer ){\n                         System.out.print(\"*\");\n                     }else{\n                         System.out.print(\" \");\n                     }\n                 }\n                 System.out.println(\" \");\n             }\n    \n     ```\n   * 改为菱形\n     ```\n\n\n\n## break\n\n介绍\n\n1. 跳转控制语句----->break\n2. 当某个条件满足时，终止循环\n3. break语句用于终止某个语句块的执行，一般用于switch或者循环中\n\n基本语法：\n\n```java\n{\n......\nbreak;\n......\n```\n\n以while循环为例流程图：\n\n![image-20220228111326348](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228111326348.png)\n\n#### 注意事项\n\n1. break语句出现在多层嵌套语句块时，可以通过标签指明要终止的是哪一层语句块\n\n2. 标签的基本使用\n\n   ```java\n   label1:{.....\n   label2:\t\t{.....\n   label3:\t\t\t{.....\n   \t\t\t\tbreak label2;\n   \t\t\n   }\n   \t\n   }\n   \n   }\n   ```\n\n   1. break语句可以指定退出哪层\n   2. label1是标签，由程序员决定\n   3. break后指定到哪个label就退出到哪里\n   4. 在实际开发中，尽量不要使用标签\n   5. 如果没有指定break，默认退出最近的循环体\n\n## continue-跳转控制语句\n\n介绍：\n\n1. <u>**continue语句用于结束本次循环，继续执行下次循环**。</u>\n2. continue语句多出现在多层嵌套的循环语句中时，可以用过标签指明要跳过的是哪一环，这个和前面的标签使用一样\n\n基本语法\n\n```java\n{\n....\ncontinue;\n....\n}\n```\n\n流程图：\n\n![image-20220228153036178](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228153036178.png)\n\n\n\n## return-跳转控制语句\n\n介绍：\n\nreturn使用在方法，表示跳出所在的方法\n\n注意：\n\n1. 如果吧return放在main方法中会退出程序\n\n# 数组【重点】\n\n## 数组\n\n**介绍**\n\n数组可以存放 <u>多个</u>*<u>同一类型</u>* 的数据。数组也是一种数据类型，是引用数据类型。\n\n即：数（数据）组（一组）就是一组数据\n\n<span id = \"数组案例01\">案例</span>（快速入门）：\n\n```java\npublic static void main(String[] args) {\n   \t\t\tdouble totalWeght =0;\n        double[] hen = {1,2,3,4,5,6};\n  //可以通过 for循环访问数组的元素\n        for (int i = 0; i <hen.length ; i++) {\n          //可以通过下标来访问数组的元素 hen[下标]\n          //下标是从0开始的，比如【0，1，2，3】\n          //第二个元素是hen[1]\n    \n            System.out.println(\"第\"+(i+1)+\"个元素的值为\"+hen[i]);\n          totalWeght+=hen[i];\n        }\n  \t\tSystem.out.println(\"总体重为\"+totalWeght+\"平均体重为=\"+(totalWeght/hen.length));\n    }\n```\n\n### 动态初始化\n\n#### 使用方式1\n\n先new出一个数组，再动态的给它赋值。\n\n数组的定义：\n\n数据类型\t数组名[] = new 数据类型[大小]\n\n数据类型[]\t数组名 = new 数据类型[大小]\n\n以上两种写法的效果都是等价的\n\n例：\n\n```java\nint a[] = new int[5];\n\n//创建一个数组，名字为a，长度为5个int\n```\n\n内存图：\n\n![image-20220302092916369](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302092916369.png)\n\n例：\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class chapterArray01 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        //new数组类型时，记得加上数组的长度\n        double[] doubles = new double[5];\n        for (int i = 0; i < doubles.length; i++) {\n            System.out.println(\"请输入第\"+(i+1)+\"个数\");\n            doubles[i] = scanner.nextDouble();\n        }\n        System.out.println(\"========================================\");\n        for (int i = 0; i <doubles.length ; i++) {\n            System.out.println(\"输入的数为\"+doubles[i]);\n\n        }\n    }\n}\n\n```\n\n#### 使用方式2\n\n1. ***<u>先声明数组</u>***\n\n语法：\n\n* 数据类型 数组名[];\t或\t\t数据类型[] \t数组名;\n\n* int a[]  / int[]  a;\n\n2. ***<u>创建数组</u>***\n\n语法：\n\n* 数组名 = new 数据类型 [ 大小 ];\n* a = new int[5];\n\n```java\n//        double[] doubles = new double[5];\n//相当于吧使用方法1给拆分成两个\n//\t1.先声明\n        double doubles[];\n        //2.再创建\n        doubles = new double[5];\n```\n\n解释：1.先声明，在内存中相当于创建了一个空的变量，这时没有任何左右\n\n2.再创建，才使得这个数组有意义。不写的话会报空指针异常\n\n### 静态初始化\n\n语法：\n\n数据类型\t数组名[] = {元素值，元素值，元素值，......}\n\n[案例](#数组案例01)跳转\n\n### 注意事项和细节\n\n1. 数组是多核相同的数据类型的组合，实现对这些数据的统一管理\n2. 数组中的元素可以使任何数据类型，包括基本数据类型和引用数据类型，但不能混用\n3. 数组创建后，如果没有赋值，会有默认值：int 0 , short 0 , byte 0 ,long 0, float 0 ,double 0.0 , char \\u0000, boolean false , String null;\n4. 使用数组的步骤：\n   1. 声明数组并开辟空间\n   2. 给数组各个元素赋值\n   3. 使用数组\n5. 数组的下表是从0开始的 \n6. 数组下表必须在指定范围内使用，否则报：下标越界异常，比如: int[] arr = new int [5] ; 则有效下标为0-4\n7. 数组属于引用数据类型，数组行数据是对象（object）\n8. boolean 类型没有赋值的情况下默认false\n\n### 数组赋值机制\n\n1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响\n\n   ```java\n   //基本数据类型赋值，复制方式为值拷贝\n   int n1 = 2 ; \n   int n2 = n1 ;\n   \n   n2的变化不会影响n1\n       \n   ```\n\n2. 数组再默认情况下是引用传递，赋的值是地址。赋值方式为引用传递\n\n   ```java\n   int[] array1 = {1,2,3}\n   int[] array2 = array1; \n   \n   array2[0] = 10;\n   //此时运行的结果 array1的第0个元素会变成10\n   \n   ```\n\n   \n\n ![image-20220302141207302](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302141207302.png)\n\n### 数组拷贝\n\n案例：\n\n```java\nint[] arr1 = {1,2,3}\n//1. 创建一个新的数组arr2,开辟一个新的数据空间\n//2. 大小 = arr1.length\nint arr2[] = new int[arr1.length];\n\n//遍历arr1到对应的位置\nfor( i = 0; i < arr1.length; i++){\n    arr2[i] = arr1[i];\n}\n\n```\n\njvm内存图分析:\n\n![image-20220302142048498](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142048498.png)\n\n![image-20220302142253236](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142253236.png)\n\n### 数组翻转\n\n案例：\n\n要求：需要把数组的元素内容反转。\n\narr { 1 , 2 , 3 , 4 , 5 }-->{5 , 4 , 3 , 2 , 1}\n\n方式1：\n\n```java\nint[] arr = {11 , 22 , 33 , 44 , 55 , 66};\n\n//1. 把 arr[0] 和 arr[5] 进行交换\n//2. 把 arr[1] 和 arr[4] 进行交换\n//3. 把 arr[2] 和 arr[3] 进行交换\n//4. 一共要交换 3 次 = arr.length\n//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]\n  int temp = 0;\n        int len = arr.length;\n        for (int i = 0; i <len/2 ; i++) {\n            temp = arr[len-1-i];\n            arr[len-1-i] = arr[i];\n            arr[i] = temp;\n        }\n     \n     \n }\n```\n\n方式2\n\n```java\nint[] arr = {11 , 22 , 33 , 44 , 55 , 66};\n//1. 先创建一个arr2\n        //2. 逆序遍历arr，再将每个元素赋给arr2的元素中\n        //3. 增加一个循环变量j\n        int[] arr2 = new int[arr.length];\n\n        for (int i = 0,j=arr.length-1 ; j>=0; i++,j--) {\n            arr2[j] =arr[i];\n\n        }\n//4.当for循环结束，arr2就是一个逆序数组，{66 , 55 , 44 , 33 , 22 , 11}\n//5. 让arr指向arr2数据空间,此时arr原来的数据空间就没有变量引用\n//会被当做垃圾处理\narr = arr2\n    //6. 遍历输出\n  \n        for (int i = 0; i <arr.length ; i++) {\n            System.out.println(arr[i]);\n        }\n```\n\n\n\n### 数组扩容\n\n数组缩减同理\n\n数组添加\n\n要求：实现动态的给数组添加元素效果，实现对数组扩容\n\n1）原始数组使用静态分配int[] arr = {1,2,3}\n\n2）增加的元素4，直接放在数组的最后 arr = {1,2,3,4}\n\n3）用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class chapterArrayAdd {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        char key ;\n        int[] arr1 = {1,2,3};\n\n\n        do {\n            int[] arr2 = new int[arr1.length+1];\n                for (int i = 0; i < arr1.length; i++) {\n                    arr2[i] = arr1[i];\n                }\n                System.out.println(\"请输入一个要添加的值\");\n                arr2[arr2.length - 1] = scanner.nextInt();\n\n            arr1 = arr2;\n\n            System.out.println(\"是否继续添加？请输入y/n\");\n            key = scanner.next().charAt(0);\n\n            if (key=='y'){\n                System.out.println(\"继续增加\");\n            }else if (key== 'n'){\n                System.out.println(\"跳出\");\n                break ;\n            }else {\n                System.out.println(\"输入不合法\");\n            }\n//            将arry1的地址指定到arry2的地址，此时原arry1的地址被没有变量引用，所以被jvm销毁\n\n        }while (true);\n\n        for (int i = 0; i < arr1.length ; i++) {\n            System.out.println(\"arr1 = \"+arr1[i]);\n        }\n\n    }\n\n}\n\n```\n\n\n\n\n\n\n\n## 排序\n\n介绍\n\n排序的分类：\n\n1. 内部排序：\n\n* 指将需要处理的所有数据都加载到内部存储中进行排序。包括（交换式排序法，选择时排序法和插入式排序法）\n\n2. 外部排序法：\n   * 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。\n\n### 冒泡排序\n\n基本思想：通过对待排序序列从后向前（从下标较大的元素开始），一次比较相邻元素的值若发现逆序则交换，使值较大的元素从前移向后部。像水下的气泡一样逐渐向上冒。\n\n![image-20220303105607719](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220303105607719.png)\n\n特点：\n\n1. 一共有五个元素\n\n2. 一共进行了四轮排序，可以看成外层循环\n\n3. 每1轮排序可以确定一个数的位置，比如第一轮排序确最大数，第二轮确定第二大的数 的位置，依次类推\n\n4. 当进行比较时，如果前面的数大于后面的数，就交换\n\n   \n\n案例说明:\n\n将五个无序：24,69,80,57,13使用冒泡排序，从小到大排序\n\n```java\npackage com.smms.demo;\n\npublic class chapterBall {\n    public static void main(String[] args) {\n        int tmp = 0;\n        int[] a  = {24,69,80,57,13};\n       \n        for (int i = 0; i < a.length-1; i++) {\n            for (int j = 0; j < a.length; j++) {\n                if (j>=a.length-1){\n                    break;\n                } else if (a[j]<a[j+1]){\n                    System.out.println(\"不做交换\");\n                }else {\n\n                    tmp = a[j];\n                    a[j]  = a[j+1];\n                    a[j+1] = tmp;\n                    System.out.println(\"交换第\"+j+\"个数为\"+a[j]);\n                }\n            }\n        }\n        for (int i = 0; i <a.length ; i++) {\n            System.out.println(a[i]);\n        }\n\n    }\n}\n\n```\n\n\n\n## 查找\n\n### 1）顺序查找：\n\n```java\npackage com.smms.demo;\n\nimport java.util.Scanner;\n\npublic class exercisesSequence {\n    public static void main(String[] args) {\n        /*有一个数列：\n        * 白眉鹰王，金毛狮王，紫衫龙王，青翼蝠王猜数游戏\n        * 从键盘任意输入一个名称，判断数列中是否包含此名称（顺序查找）\n        * 要求：如果找到了，就提示找到，并给出下标\n        */\n        String[] a ={\"白眉鹰王\",\"金毛狮王\",\"紫衫龙王\",\"青翼蝠王\"};\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入\");\n        String next = scanner.next();\n        //用于判断是否没找到\n        int nub =-1;\n        for (int i = 0; i <a.length ; i++) {\n            if (next.equals(a[i])){\n                System.out.println(\"找到了\");\n                //如果找到了就把i的值赋给sub\n                nub = i;\n                break;\n                //如果nub==-1就代表没找到\n            }else if (nub == -1){\n                System.out.println(\"没找到\");\n            }\n        }\n    }\n}\n\n```\n\n\n\n### 2）二分查找：\n\n\n\n算法部分讲解补充\n\n\n\n## 二维数组\n\n介绍：一个数组内，还有数组\n\n要理解的点：\n\n1. 看到定义形式就可知道是不是二维数组\n2. 二维数组的每一个元素都是一维数组\n3. 二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历\n4. \n\n```java\n如果需要访问第（i+1)个一维数组，第（j+1)个值。arr2d[i][j]\n 或需要访问第i个一维数组，第j个值。arr2d[i-1][j-1]   \n```\n\n\n\n案例：\n\n```java\npublic static void main(String[] args) {\n        /*\n        * 请用二维数组输入如下图形\n         0 0 0 0 0 0\n         0 0 1 0 0 0\n         0 2 0 3 0 0\n         0 0 0 0 0 0\n         */\n\n//        1. 定义形式 int[][]\n//        2.可以理解为一个数组内的每个元素都是一个数组\n        int[][] arr2d= {{0,0,0,0,0,0},{0,0,1,0,0,0},\n                        {0,2,0,3,0,0},{0,0,0,0,0,0}};\n   System.out.println(\"二维数组的元素个数\"+arr2d.length);\n//\t二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历\n    \n    \n    \n//        获取多个少个一维数组\n        for (int i = 0; i < arr2d.length; i++) {\n//            遍历二维数组的每一个元素（数组）,\n//            arr2d[i].length  获取二维数组内对应的每一个一维数组的长度\n            for (int j = 0; j < arr2d[i].length; j++) {\n                System.out.print(arr2d[i][j]+\"\\t\");\n\n            }\n            System.out.println();\n        }\n    }\n```\n\n### 二维数组内存原理图：\n\n![image-20220304165024843](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165024843.png)\n\n\n\n### 二维数组的使用方式\n\n方式1：动态初始化\n\n```\n1.语法：类型[][] 数组名 = new 类型[大小][大小];\n例如： int[][] = new int[2][3];\n\n```\n\n方式2：动态初始化\n\n```\n1. 先声明：类型 数组名[][];\n2. 再定义（开辟空间）： 数组名 = new 类型[大小][大小];\n3. 赋值（有默认值，比如int 类型默认值就是0）\n```\n\n方式3：动态初始化\n\n1. 列数不确定\n2. java不强制每个数组的长度都一样\n3. 例：![image-20220304165929272](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165929272.png)\n\n```java\npublic static void main(String[] args) {\n        /*\n            动态创建下面二维数组，并输出\n            i = 0 : 1\n            i = 1 : 2 2\n            i = 2 : 3 3 3\n         */\n        //1. 创建一个二维数组，因为数组内的每一堆数组的元素都是不确定的，所以不填。\n        // 填了的话相当于固定了长度\n        int[][] arr= new int[3][];\n        for (int i = 0; i <arr.length ; i++) {\n//            给数组内的一维数组开辟空间\n//            如果没有给一堆数组开辟空间，那么这个空间的就是null\n            arr[i] = new int[i+1];\n//            遍历一维数组，给一堆数组的每个元素赋值\n            for (int j = 0; j < arr[i].length ; j++) {\n                arr[i][j]= i+1;\n            }\n        }\n\n//        遍历出这个二维数组\n        for (int i = 0; i <arr.length ; i++) {\n            for (int j = 0; j <arr[i].length ; j++) {\n                System.out.print(arr[i][j]);\n            }\n            System.out.println();\n        }\n    }\n```\n\n杨辉三角形\n\n![image-20220305143151743](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220305143151743.png)\n\n提示：\n\n1. 第一行有一个元素，第n行有n个元素\n\n2. 第一行的第一个元素和最后一个元素都是1\n\n3. 从第三行开始，对于非第一个元素和最后一个元素的元素的值，arr[i],[j]\n\n4. ```java\n   中间的数为：\n   arr[i][j]  = arr[i-1][j]+ arr[i-1][j-1]\n     \n     \n     \n   ```\n\n   ```java\n   package basics.chapterArray;\n   \n   public class exerciseArrayYangHuiTriangle {\n       public static void main(String[] args) {\n           int[][] arr =  new int[10][];\n           for (int i = 0; i <10 ; i++) {\n               arr[i] = new int[i+1];\n               for (int j = 0; j < arr[i].length; j++) {\n                   if (j==0 || j == arr[i].length-1){\n                       arr[i][j] = 1;\n                   }else {\n                       arr[i][j] = arr[i-1][j]+arr[i-1][j-1];\n                   }\n   \n               }\n   \n           }\n           for (int i = 0; i <arr.length ; i++) {\n               for (int j = 0; j <arr[i].length ; j++) {\n                   System.out.print(arr[i][j]);\n               }\n               System.out.println();\n           }\n       }\n   }\n   \n   \n   ```\n\n\n# 面向对象\n\n## 类与对象\n\n1）类是抽象的，概念的。代表一类事物，比如人类，猫类，狗类。。。。，即它是实例\n\n```java\n例：\nclass cat{\n    //属性/也叫成员变量\n   // 成员变量 =属性 = field(字段)\n\tString name;\n\tint age;\n}\n//实例\ncat c = new ca();\n```\n\n2） 对象是具体的，实际的，代表一个具体事务，即是实例\n\n3） 类是对象的模板，对象是类的一个个体，对应一个实例\n\n属性可以使基本数据类型，也可以是引用数据类型(对象，数组)\n\n### 对象在内存中存在的形式（重要）\n\njava内存的结构分析：\n\n1. 栈：一般存放基本数据类型（局部变量）\n2. 堆：存放对象（Cat cat ，数组等）\n3. 方法区：常量池（常量，比如字符串），类加载信息\n4. 示意图：[Cat(name,age,price)]\n\n```java\nPerson p = new Person();\np.name = \"jack\";\np.age = 12;\n\n1.先加载Person类信息（属性和方法信息，只会加载一次）\n2.在堆中分配空间，进行默认初始化（看规则），\n3.把堆中的地址返回给p，p就指向对象\n4.进行指定初始化，比如：p.name = \"jack\",p.age = 12;\n\n    \n```\n\n\n\n\n\n对象和数组都是引用类型\n\n![image-20220307112129768](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307112129768.png)\n\n如果存放的数据，类型是基本数据类型则存放在堆中，引用的数据类型则存放在方法区\n\n###  注意事项\n\n1） 属性的定义语法同变量，示例：<span style=\"color:blue\">访问修饰符</span><span style= \"color:red\" > 属性类型  属性名;</span>\n\n2） 属性的定义类型可以为任意类型，包含基本类型或引用类型\n\n3） 属性如果不赋值，有默认值，规则和数组一致\n\n### 创建对象\n\n1. 先声明在创建\n\n   ```java\n   CAT cat;\n   cat  = new CAT();\n   ```\n\n2. 直接创建\n\n   ```java\n   CAT cat  = new CAT();\n   ```\n\n   \n\n访问属性\n\n```\n对象名.属性名；\ncat.xxx;\n```\n\n### 类对象的内存分配机制\n\n![image-20220307145803905](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307145803905.png)\n\n## 成员方法\n\n介绍：\n\n用于描述对象的行为，成为方法\n\n案例：\n\n![image-20220307161842380](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307161842380.png)\n\n```java\npackage com.smms.demo.method;\n\npublic class exercisesMethod01 {\n    public static void main(String[] args) {\n        Person person = new Person();\n        person.speal();\n        person.cal01();\n        person.cal02(3);\n//        调用getSum方法，并给了1,3的值\n//        用returnsum接收getSum返回的值\n        double returnsum = person.getSum(1,3);\n\n        System.out.println(\"returnsum=\"+returnsum);\n\n    }\n}\nclass Person{\n    public  void speal(){\n        System.out.println(\"我是一个好人\");\n    }\n\n    public  void cal01(){\n        int sum = 0;\n        for (int i = 0; i <= 1000; i++) {\n            sum+=i;\n        }\n        System.out.println(\"1+~+1000=\"+sum);\n    }\n    public  void cal02(int n){\n        int sum =0;\n        for (int i = 1; i <=n ; i++) {\n            sum = sum+i;\n        }\n        System.out.println(\"1+n=\"+sum);\n    }\n\n    public double getSum(double a, double b){\n        double sum=0;\n        sum = a+b;\n        System.out.println(\"a+b=\"+sum);\n//        表示返回sum\n        return sum;\n    }\n}\n```\n\n### 内存分析流程图\n\n![image-20220308162432089](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220308162432089.png)\n\n方法的优点：\n\n1. 提高了代码的复用性\n2. 可将实现的细节封装起来，然后提供其他用户来调用\n\n\n\n### 成员方法的定义\n\n```java\npublic 返回数据类型\\void（表示没有返回值）\t方法名(形参列表...){//方法体\n语句;\nreturn；//返回值\n}\n```\n\n1. 参数列表：表示成员方法输入cal(int n)\n2. 数据类型(返回类型)：表示成员方法输出，void表示没有返回值\n3. 方法主体:表示为了实现某一功能代码块\n4. return语句不是必须的\n\n\n\n### 注意事项\n\n1. 访问修饰符\n\n2. ``` java\n   访问修饰符 返回数据类型\\void（表示没有返回值）\t方法名(形参列表...){//方法体\n   语句;\n   return；//返回值\n   }\n   \n   1. 访问修饰符（作用是控制 方法的适用范围）\n       如果不写默认访问，[有四种：public protected 默认]\n   \n   ```\n\n   \n\n3. 返回数据类型\n\n```\n1. 一个方法最多有一个返回值\n\t返回多个结果，返回数组\n2. 返回类型可以为任意类型，包含基本类型和引用类型(数组，对象)\n3. 如果方法要求有返回数据类型，则方法体中最后执行的语句必须为return值；而且要求返回值类型必须和return的值的类型一致或兼容\n4. 如果方法是void，则方法体照片那个可以没有return语句，或者 只写 return；\n\n\n方法命名；使用驼峰命名法，最好见名知意\n```\n\n4. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开。例：getSum(int a,int b)\n\n5. 参数类型可以为任意类型，包含基本类型或引用类型。\n\n6. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数\n\n7. 方法定义时的参数成为形式参数（形参）；方法调用时的参数成为实际参数，简称实参。实参和形参的类型要一致或兼容、个数、顺序必须一致\n\n   * ```java\n     public static void main(){\n     \tMethod a = new Method();\n     \ta.input(123,345//这里成为实参);\n     }\n     \n     class Method{\n     \tpublic int input(int a,int b//这里成为形参){\n     \tsystem.out.print(\"xxx\");\n     \treturn xxx;\n     \t}\n     }\n     ```\n\n方法体\n\n​\t里面写完成功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义\n\n调用细节\n\n1. 同一类中的方法调用：直接调用即可\n\n   * 直接输入：方法名（参数）即可\n\n2. 跨类中的方法A类调用B类方法：需要通过对象名调用。比如：对象名.方法名(参数)\n\n\n## 成员方法传参（重要）\n\n基本数据类型\n\n1. ![image-20220310134944831](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310134944831.png)\n2. <span style = \"color:red\">基本数据类型</span>，传递的值（拷贝），形参的任何改变不影响实参！\n\n引用数据类型\n\n1. ![image-20220310140041330](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310140041330.png)\n2. 引用类型传递的是地址（传递也是值，但值是地址），可以通过形参影响实参。\n\n## 递归机制（recursion）\n\n递归调用的本质，是方法的调用\n\n1. ![image-20220310164428690](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310164428690.png)\n2. 栈是先进后出，先出后进（所以图中的test栈2先输出，然后是3，4）\n3. 每次这个栈内的方法执行完成后，外边的方法（图中test方法）都会执行一边\n4. 哪里调用就返回给哪里\n\n### 阶乘（factorial）\n\n![image-20220310203253490](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310203253490.png)\n\n###   递归调用的规则\n\n1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）\n2. 方法的局部变量是独立的，不会相互影响，比如n变量\n3. 如果方法中使用的是引用类型变量（比如数组，或者对象），就会共享该引用类型的数据。\n4. 递归必须像退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:)\n5. 当一个方法执行完毕，或者遇到return，就会执行完毕或者返回时，该方法也就执行\n\n### 斐波拉契数练习\n\n```java\npackage basics;\n\npublic class exerciseRecursion {\n    public static void main(String[] args) {\n        T t = new T();\n        int i = t.racursionNum(4);\n        System.out.println(i);\n\n    }\n\n}\n\nclass T{\n    public int racursionNum(int n1) {\n        if (n1 == 1 || n1 == 2) {\n            return 1;\n        } else {\n            return racursionNum(n1 - 1) + racursionNum(n1 - 2);\n        }\n    }\n}\n\n```\n\n解析图\n\n![image-20220310225335626](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310225335626.png)\n\n\n\n\n\n## 重载（overload）\n\n介绍：java允许同一个类中，多个同名方法的存在，但要求形参列表不一致！！！\n\n好处：\n\n1. 减轻了起名的麻烦\n2. 减轻了记名的麻烦\n\n注意细节：\n\n1. 方法名：必须相同\n2. 形参参列表：必须不同（参数类型或个数或顺序，至少有一样不同）\n3. 返回类型：无要求\n\n## 可变参数\n\n介绍：\n\njava允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法。\n\n基本语法：\n\n```java\n访问修饰符\t 返回类型\t方法名（数据类型 .... 参数名）{\n}\n```\n\n案例\n\n```java\nclass hasMestod{\n/*\n    public int sum(int a,int b){\n        return a+b;\n    }\n    public int sum(int a,int b,int c){\n        return a+b+c;\n    }\n    public int sum(int a,int b,int c,int d){\n        return a+b+c+d;\n    }\n//    ........以此类推\n*/\n\n//    可变参数优化\n//    上面三个方法名称相同，功能相同，只是参数个数不同---->使用可变参数优化\n//    1.int...表示接收的是可变参数，类型时int，即可以接收多个int（0-多）\n//    2.使用可变参数时，可以当做数组；来使用，即nums 可以当做数组使用\n    public  int sum1(int... nums){\n        System.out.println(\"接收的个数为\"+nums.length);\n        int sum = 0;\n        for (int i = 0; i < nums.length ; i++) {\n            sum=sum+nums[i];\n        }\n        return sum;\n    }\n\n}\n```\n\n注意事项：\n\n1. 可变参数的实参可以为0或任意多个\n\n2. 可变参数的实参可以为数组\n\n3. 可变参数的本质就是数组\n\n   \n\n4. 可变参数可以和普通类型的参数<u>*一起放在形参列表*</u>，但必须保证可变参数在最后\n\n5. 一个形参列表中只能出现一个可变参数\n\n\n\n## 作用域\n\n1. 在java中，主要的变量就是属性（成员变量）和局部变量\n2. 我们说的局部变量一般是指在成员方法中定义的变量\n3. 作用域的分类\n   1. 全局变量：也就是属性，作用域为整个整体\n   2. 局部变量：也就是除了属性以外的其他变量，作用域为定义它的代码块中\n4. 全局变量可以不赋值，直接使用，因为有默认值（也可指定值），局部变量必须赋值后，才能使用，因为没有默认值。    、   \n\n注意事项和细节\n\n1. 属性和局部变量可以重名，访问时遵循就近原则\n2. 在一个作用域中，比如在同一个成员方法中，两个局部变量，不能重\n3. 属性生命周期较长，伴随对象的创建而创建，伴随对象的死亡而死亡。局部变量，生命周期较短，伴随它的代码块的执行而创建，伴随代码块的结束而死亡\n4. 作用域范围不同：\n   1. 全集变量/属性：可以被本类使用，或其他类使用（通过对象调用）\n   2. 局部变量：智能在本类中对应的方法中使用\n5. 修饰符不同\n   1. 全局变量/属性可以加修饰符\n   2. 局部变量不可以加修饰符\n\n## 构造器(constructor)\n\n基本介绍：构造方法又称构造器(constructor)，是类的一种特殊方法，它的主要作用是完成对<span style = \"color:red\">新的对象初始化。</span>\n\n\n\n特点：\n\n1. 方法和类名相同\n2. 没有返回值\n3. 在创建对象时，系统会自动调用该类的构造器完成对对象的初始化\n\n\n\n需求案例：\n\n案例1:创建一个人类的对象，显示把一个对象创建好后，再给他的年龄姓名等属性赋值，如果现在我要求，在创建人类对象的时候，就直接指定这个对象的年龄和姓名。 此时可以使用构造器\n\n基本语法：\n\n```java\n[修饰符] 方法名(形参列){\n\n\t方法体;\n\n}\n```\n\n1. 构造器的修饰符可以默认，也可是public，protected，private\n2. 构造器没有返回值,也不能写void\n3. 方法名和类名必须一样\n4. 参数列表和成员方法一样的规则\n5. 构造器的调用<span style = \"color:red\">系统完成</span>\n\n\n\n细节：\n\n1. 一个类可以定义多个不同的构造器，即构造器的重载\n   * 比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄\n   * ![image-20220314163037454](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314163037454.png)\n2. 构造器是完成对象的初始化，并不是创建对象\n3. 如果程序员没有定义构造器，系统会自动生成一个默认的无参构造器(也叫默认构造方法),比如Person(){ }\n4. 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的午餐构造器，除非显示的定义一下，即自己再手写一边Person(){ }\n\n\n\n\n\n\n\n对象创建流程\n\n```java\nclass Person{\n\tint age =90;\n\tString name;\n\tPerson(String n , int a){\n\tname = n;\n\tage = a;\n\t}\n}\n\n\nPerson p = new Person(\"zhangsan\" , 20);\n```\n\n![image-20220314215432778](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png)\n\n```\n1. 先在方法区加载Person类\n2. 在堆中开辟一个空间，内部存放形参\n   1. 先初始化默认值，0和null，然后再将值赋进去\n   2. 当执行到构造器的时候，值才会赋进去\n   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值\n3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)\n```\n\n1. 加载Person.class，只会加载一次。\n\n2. 在堆中分配空间(地址)\n\n3. 完成对象初始化\n\n   3.1 默认初始化 age=0\tname = null\t\n\n   3.2 显示初始化 age=90,name=null,\n\n   3.3 构造器的初始化 age=20，name=zhangsan\n\n4. 在对象堆中的地址，返回给p(也可理解成对象的引用)\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n## this\n\n案例：\n\n```java\nclass Person{\n\tString name;\n\tint age;\n/*\n\t旧方法：\n\t\tint age =90;\n\t\tString name;\n\t\tPerson(String n , int a){ //此时形参的起名不能与属性名一致\n\t\tname = n;\n\t\tage = a;\n     1.如果可以将构造器的形参，直接写成属性名就好了\n     2.但是会出现一个问题，根据变量的作用域原则\n     3.构造器的name 是局部变量，而不是属性。相当于自己赋给自己\n     4.构造器的age 是局部变量，而不是属性、\n     5.==>此时使用this关键字\t\n*/\n    public Person(String name,int age){\n        this.name/*表示当前对象的属性*/ = name;/*表示当前构造器的局部变量*/\n        this.age = age;\n    }\n\t \n}\n```\n\n介绍：\n\njava虚拟机会给每个对象分配this，代表当前对象。\n\n分析图：\n\n每一个对象都有一个隐藏的属性this\n\n这个this它指向自己\n\n![image-20220314222909415](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314222909415.png)\n\n简单说，哪个对象调用this就指向哪个对象\n\n\n\n\n\n注意事项：\n\n1. this关键字可以用来访问本类的属性，方法，构造器\n\n2. this用于区分当前类的属性和局部变量\n\n3. 访问成员方法的语法：this.方法名(参数列表)；\n\n4. 访问构造器语法：this(参数列表);//注意，只能在构造器中访问另外一个构造器(当有访问构造器的语法this时，必须放在构造器语句里的第一行 )\n\n   * ```java\n     class T{\n         String name;\n         int age;\n     \t//无参构造器\n     \tpublic T(){\n             //当执行无参构造器时，我们想去访问有参构造器\n             this(\"zhangsan\",12);//这样访问有参构造器\n            //当有访问构造器的语法this时，必须放在构造器语句里的第一行 \n            \n     \t\tSystem.out.println(\"T() 构造器\");\n             \n             \n             \n     \t}\n     \t\n     \t//有参构造器\n     \tpublic T(String name,int age){\n             System.out.println(\"T(String name,int age) 构造器\");\n         }\n     }\n     ```\n\n5. this不能再类定义的外部使用，只能在类定义的范围中使用\n\n```java\npackage chapterObject;\n/*\n* 创建一个employee类\n* 属性有（名字，性别，年龄，职位，薪水）\n* 提供三个构造器\n* 1.名字，性别，年龄，职位，薪水\n* 2.名字，性别，年龄\n* 3.职位，薪水*/\npublic class ObjectHomeWork06 {\n}\nclass Employee{\n    String name;\n    char sex;\n    int age;\n    String post;\n    double salary;\n\n    public Employee(String name,char sex,int age){\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n    public Employee(String post,double salary){\n\n        this.post = post;\n        this.salary = salary;\n    }\n    public Employee(String name,char sex,int age,String post,double salary){\n        this(name, sex, age);\n//        因为构造器调用只能放在第一行，所以最多只能调用一个构造器\n        this.post = post;\n        this.salary = salary;\n    }\n\n//    public Employee(String name,char sex,int age,String post,double salary){\n//        this.name = name;\n//        this.sex = sex;\n//        this.age = age;\n//        this.post = post;\n//        this.salary = salary;\n//\n//    }\n}\n\n\n```\n\n\n\n# 面向对象（中级）\n\n## idea\n\n### 快捷键\n\n```\n自定义快捷键\nsettings - - > Keymap\n删除当前行 ctrl+y  自定义 alt+D\n复制当前行 ctrl+d\n\n快速格式化代码 ctrl + alt + L\n快速运行程序  自定义alt + R\n\n查看类的层级关系 ctrl + H\n将光标放在一个方法上，输入ctrl+b，可以定位到该方法的上\n自动分配变量名   在后面添加.var\n例：new Scanner(System.in).var+回车\n会生成Scanner scanner = new Scanner(System.in);\n```\n\n### 模板\n\n 设置路径\n\nfile -> settings -> editor -> live templates->\n\n可以自己自定义，也可查看预设的模板\n\n\n\n\n\n\n\n\n\n## 包\n\n三大作用：\n\n1. 区分相同名字的类\n2. 当类不同的时候，可以很好的管理\n3. 控制访问范围\n\n基本语法：\n\npackage com.xxx;\n\n1. package 关键字，表示打包\n2. com.xxx:表示包名\n\n包的本质\n\n就是创建不同的文件/目录保存文件\n\n\n\n### 包的命名\n\n规则：\n\n智能包含数字，字母，下划线，小圆点，但不能用数字开头，不能是关键字或保留字\n\n```java\ndemo.class.exec1 //falsee不允许有关键字class\ndemo.12\t\t//false,不能数字开头\ndemo.ad12.oa //true\n```\n\n规范\n\n一般是小写字母+小圆点\n\ncom.公司名.项目名.业务模块名\n\n例：com.alibaba.taobao.login\n\n```java\ncom.sina.crm.user\n等等\n```\n\n### java常用的包\n\n```java\njava.lang // lang包是基础包，默认引入，不用手动输入\n\njava.util //系统提供的工具包，工具类，例如Scanner类\n\njava.net // 网络包，网络开发\n\njava.awt  // 是做java的界面开发，GUI\n```\n\n\n\n包的引入\n\n建议需要什么类就引入什么类，不建议(java.util.* )全部引入\n\n\n\n\n\n\n\n## 访问修饰符\n\n介绍\n\njava提供了四种访问控制修饰符号控制方法和属性(成员变量)的访问权限(范围)\n\n1. 公开级别：public 修饰，对外公开\n2. 受保护级别：用protected修饰，对子类和统一包中的类公开\n3. 默认级别：没有修饰符号，向同一包的内公开\n4. 私有级别：用private修饰，只有类本身可以访问，不对外公开\n\n![image-20220317140746725](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220317140746725.png)\n\n注意事项：\n\n1. 修饰符可以用修饰类中的属性，成员方法以及类\n2. 只有默认的和public才能修饰类，并且遵循上述访问权限的特点\n3. 成员方法访问规则和属性完全一样\n\n\n\n\n\n\n\n\n\n\n\n\n\n## <u>*封装*</u>（重要）\n\n封装（encapsulation）就是把抽象出来的数据[**属性**]和对数据的操作[**方法**]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[**方法**]，才能对数据进行操作。\n\n**封装的好处**\n\n1. 隐藏实现细节  方法(连接数据库)<----调用(传入参数)\n2. 可对数据进行验证，保证安全合理\n\n\n\n封装的实现步骤 ( 三 步 ) \n\n1. 将属性进行私有化，private\n\n2. 提供一个公共的set方法，对属性进行判断并赋值\n\n   ```java\n   public void setXXX(类型\t参数名){\n   //加入数据验证的业务逻辑\n   属性 = 参数名；\n   }\n   ```\n\n3. 提供一个公共的get方法，用于获取属性的值\n\n   ```java\n   public void getXXX(类型\t参数名){\n   \treturn xx;\n   }\n   ```\n\n   \n\n\n\n## <u>*继承*</u>（重要）extends\n\n### 继承作用：\n\n解决代码复用性\n\n### 介绍：\n\n相当多个类存在相同的属性（变量）  和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些属性和方法，只需通过extend来声明继承父类即可\n\n###  基本语法\n\n```java\nclass 子类 extends 父类{\n\n}\n1. 子类会自动拥有父类定义的方法\n2. 父类又叫超类，基类\n3. 子类又叫派生类\n\n```\n\n示意图\n\n![image-20220318104942566](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318104942566.png)\n\n\n\n### 注意事项\n\n1. 子类继承了所有的属性和方法，但是私有属性不能再子类直接访问，需要通过公共方法访问\n\n2. 子类必须调用父类的构造器，完成父类的初始化\n\n3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中调用super去指定使用父类的那个构造器完成对父类的初始化工作，否则编译不通过\n\n4. 如果希望指定去调用父类的某个构造器，则显式的调用一下{super ( 参数 ) }\n\n5. super在使用时，需要放在第一行。super只能在构造器中使用\n\n6. super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器\n\n7. java所有类都是Object的子类，是所有类的基类   Ctrl+H可以看到类的继承关系\n\n   ![image-20220318165601997](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318165601997.png)\n\n8. 父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类)\n\n9. 子类对多只能继承一个父类(指直接传承)，即java中是单继承机制。\n\n10. 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系\n\n    1. person is a music\n    2. person music\n    3. music extends  person \n\n\n\n### 继承的本质（分析）\n\n当子类创建号对象以后，建立查找关系\n\n```java\n//案例：\nclass Grandpa{\n\tString name = \"爷爷\";\n\tString hobby = \"旅游\";\n}\n\nclass Father extends GrandPa{\n\tString name = \"大头爸爸\";\n\tint age = 30;\n}\n class Son extends Father{\n \tString name = \"儿子\";\n }\n \n \n Son son = new Son();\n son.name=?      //儿子\n son.age = ?\t //30\t\n son.hobby = ?\t // 旅游\n //\t\t1. 此时请注意，要按照查找关系返回信息\n /*     2. 首先看子类是否有该属性\n \t\t3. 如果子类有这个属性，并且可以访问，则返回信息\n \t\t4. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回)\n \t\t5. 如果父类没有4的规则，继续找上级，直到object\n   */  \n```\n\n### 内存原理图：\n\n ![image-20220320170828664](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320170828664.png)\n\n## Super\n\n### 基本介绍\n\nsuper代表父类的构造器，用于访问父类的属性，方法，构造器\n\n### 基本语法\n\n1. 访问父类的属性，但不能访问父类的private属性[案例]\n   * super.属性名；\n2. 访问父类的方法名，不能访问父类的private方法\n   * super.方法名(参数列表);\n3. 访问父类的构造器(这点前面用过);\n   * super(参数列表);\n   * 只能放在构造器的第一句并只能出现一句\n\n### 细节和注意事项\n\n1. 调用父类的构造器的好处（分工明确，弗雷属性由父类初始化，子类的属性由子类初始化）\n\n2. 当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果\n\n   * ```java\n     案例\n     class A{\n     \tpublic void cal(){\n     \t\tSystem.out.println(\"a类的cal方法\");\n     \t}\n     }\n     class B{\n     \tpublic void sum(){\n     \t\tSystem.out.println(\"b类的sum方法\");\n     \t/*\t\n     \t\t此时有三种方法调用cal\n     \t\t1. 找cal方法时，顺序是：先找本类，如果有，开始调用。\n     \t\t2. 如果没有。则找父类（如果有则调用）\n     \t\t3. 如果父类没有则继续找父类的父类。以此类推。直到Object类‘\n     \t\t\n     \t\t提示：如果查找的过程中找到了，但不能访问，则报错\n     \t\t\t 如果查找的过程中没找到。则提示没找到\n     \t*/\n         \tcal();\n             \n            \n             this.cal();//等价cal（）；\n             \n              /*\n             跳过本类直接查找父类\n             其他规则一样\n             */\n             super.cal();\n             \n     \t}\n     }\n     ```\n\n3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。（相当于跳过本类，从父类开始按规则找。父类找不到找爷爷类·····）\n\n### super和this的比较\n\n![image-20220320190806497](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190806497.png)\n\n![image-20220320190935663](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190935663.png)\n\n## 重写（overwrite）\n\n### 基本介绍\n\n简单地说：方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这方法覆盖了父类的方法。\n\n### 案例\n\n```java\nclass Animal{\n\tpublic void cry(){\n\t\tSystem.out.println(\"叫\");\n\t}\n}\n/*\n\t1. 因为dog是Animal的子类\n    2. Dog的cry方法和Animal的cry方法定义形式一样(名称，返回类型，参数)\n    3. 这时我们就说Dog的cry方法，重写了Animal的cry方法\n  */      \nclass dog extends Animal{\n\tpublic void cry(){\n\t\tSystem.out.println(\"汪汪汪\");\n\t}\n}\n```\n\n### 注意事项和使用细节\n\n1. 子类的方法的形参列表，方法名称，要和父类的方法的参数，方法名称完全一样。\n\n2. 子类方法的返回类型和父类方法返回类型一样，或者父类返回类型的子类\n\n   比如 父类返回类型是Object，子类方法返回类型是String\n\n   ```java\n   public Object getInfo(){}\n   ```\n\n   ```java\n   public String getInfo(){}\n   ```\n\n3. 子类方法不能缩小父类方法的访问权限public > protected > 默认(default ) > private \n\n   ```java\n   void sayOk(){}\n   ```\n\n   ```java\n   public void sayOk(){}//这样是可以的，但不能缩小\n   ```\n\n### 重写与重载的区别\n\n![image-20220320211941817](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320211941817.png)\n\n练习\n\n```java\npackage seatWork;\n\npublic class override {\n    /*\n    * 1. 编写一个Person类，包括属性/private（name,age），\n    * 构造器，方法say（返回组我介绍的字符串）\n    * 2. 编写一个student类，继承Person类，增加id，score属性/private，\n    * 以及构造器，定义say方法（返回自我介绍信息）\n    * 3. 在main方法中，分别创建Person和Student对象，调用say方法输出自我介绍*/\n\n    public static void main(String[] args) {\n        Person person = new Person(\"lisi\", 123);\n        String say1 = person.say();\n        System.out.println(say1);\n\n        Student student = new Student(\"zhangsan\",12,12345,100);\n        String say = student.say();\n        System.out.println(say);\n    }\n}\nclass Person{\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String say(){\n        System.out.println(\"我是父类\");\n//        System.out.println(\"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\");\n        return \"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\";\n    }\n}\n\nclass Student extends Person{\n    private int id;\n    private double score;\n\n    public Student(String name, int age, int id, double score) {\n        super(name, age);\n        this.id = id;\n        this.score = score;\n    }\n    public int getId() {\n        return id;\n    }\n    public void setId(int id) {\n        this.id = id;\n    }\n    public double getScore() {\n        return score;\n    }\n    public void setScore(double score) {\n        this.score = score;\n    }\n\n    public String say(){\n        return super.say()+\"id\"+getId()+\"\\t\"+\"score\"+getScore()+\"\\t\";\n//        System.out.println(\"name\"+getName()+\"\\t\"+\"age\"+getAge()+\"\\t\"\n//        +\"id\"+getId()+\"\\t\"+\"score\"+getScore()+\"\\t\");\n    }\n}\n```\n\n## <u>*多态*</u>（重要）\n\n 多态可以提高代码的复用性\n\n### 基本介绍\n\n多态(多种)（状态）\n\n1. 方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础之上的额\n\n### 多态的具体体现\n\n#### 方法上体现\n\n1. 方法的多态\n\n   重写和重载就体现多态\n\n2. 案例说明\n\n3. 重载上体现\n\n   1. 对某一方法，传入不同的参数，调用不同的方法\n   2. ![image-20220320215939959](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320215939959.png)\n\n\n\n\n\n### 对象的多态（核心，难点，重点）\n\n要记住几点：\n\n1. 一个对象的编译类型和运行类型可以不一致\n\n   * ```\n     例如：\n     Animal animal = new Dog();【animal编译类型时Animal，运行类型是Dog】\n     animal  = new Cat(); \t【animal的运行类型变成了Cat，编译类型仍然是Animal】\n     ```\n\n2. 编译类型在定义对象时，就确定了，不能改变\n\n   * ```\n     Animal animal = new Dog()   编译类型在定以后就不能改变，所以可以直接用引用接收其他的运行类型\n     animal  = new Cat();\n     animal  = new PIG();`````\n     ```\n\n3. 运行类型是可以变化的\n\n4. 编译类型看定义时 = 号的左边，运行类型看 = 号的右边\n\n   * ```\n     Animal animal = new Dog()  animal就是变异类型，dog就是运行类型\n     ```\n\n```java\n//编译类型和运行类型的体现\nclass Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"动物在叫\");\n\t}\n}\nclass Cat extends Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"猫在叫\");\n\t}\n}\n\nclass Dog extends Animal{\n\tpublic void say(){\n\t\tSystem.out.println(\"狗在叫\");\n\t}\n}\n\nclass test{\n\tpublic static void main(String[] args){\n\t\t//animal编译类型就是Animal，运行类型Dog\n\t\tAnimal animal = new Dog();\n\t\tanimal.say();//因为运行类型是dog，animal的运行类型是dog，所以输出dog类的say方法。\n\t\t\n        animal = new Cat();\n        animal.say();//此时animal的运行类型是cat，所以输出cat类的say方法；\n    }\n}\n```\n\n\n\n### 注意事项和细节\n\n多态的前提是：两个对象(类)存在继承关系\n\n#### 多态的向上转型\n\n1. 本质：父类的引用指向了子类的对象\n\n2. 语法：父类类型    引用名 = new    子类类型()；\n\n   ```java\n   Father father = new Son();\n   //此时可称为向上转型\n   ```\n\n3. 特点：编译类型看左边，运行类型看右边\n\n   <span style=\"color:red;\">可以调用父类中的所有成员(需要遵循访问权限),</span>\n\n   <span style=\"color:red;\">不能调用子类中特有成员</span>\n\n   （<span style=\"color:red;\">因为在编译阶段，不能调用那些成员，是由编译类型来决定的。</span>）\n\n   最终运行效果按子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法\n\n   然后调用，与前面的方法调用规则一致\n\n#### 多态的向下转型\n\n语法：子类类型   引用名 = (子类类型) 父类引用;\n\n1. 只能强转父类的引用，不能强转父类的对象\n\n   ```java\n   //此时的向上转型\n   Animal animal = new Cat();\n   adimal.a();\n   //等等方法，这些方法只能调用父类子类的共同拥有的方法，不能调用子类的特殊方法\n   \n   //此时这样写\n   //强转一下，上述父类的引用\n   Cat cat =  (Cat)animal；\n       cat.catchMouse();\n   ```\n\n   \n\n2. 要求父类的引用必须指向的是当前目标类型的对象\n\n   ```java\n   //也就是说animal必须是指向对应的子类\n   Animal animal = new Cat();//必须有这句话\n   Cat cat =  (Cat)animal；//才能强转成cat类型\n   \n   ```\n\n   \n\n3. 可以调用子类类型中所有的成员\n\n\n\n#### 属性没有重写之说\n\n属性的值看编译类型\n\n```java\n例:\nclass A{\n\tint count = 1;\n}\nclass B extends A{\n\tint count = 2;\n}\n\npublic class test{\n\tpublic static void main(String[] atgs){\n\t\tA a = new B();\n\t\tpublic.out.print(a.count);\n            \n        //此时输入的值为1\n        //因为属性的值是看编译类型\n            \n        B b = new B();\n        public.out.print(a.count);\n        //此时输出2\n\t}\n}\n```\n\n\n\n#### instanceOf比较操作符，\n\n用于判断对象的类型是否为xx类型或xx类型的子类型\n\n判断对象的运行类型是否为xx类型，或这个xx类型的子类型\n\n```java\nclass A{\n\tint count = 1;\n}\nclass B extends A{\n\t count = 2;\n}\npublic class test{\n\tpublic static void main(String[] atgs){\n\tBB bb = new BB();\n\tpublic.out.print(bb instanceof BB);//true\n\tpublic.out.print(bb instanceof AA);//true\n       \n        \n        //编译类型AA ，运行类型BB\n     AA aa = new AA();\n        public.out.print(aa instanceof AA);//true\n       public.out.print(aa instanceof BB);//true \n        \t\n     Object obj   = new Object();\n        public.out.print(obj instanceof AA);//false,因为obj不是AA类，也不是AA的子类\n        \n}}\t\n```\n\n#### java动态绑定机制(重要) \n\n1. 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定\n2. 当调用对象属性时，没有动态绑定机制，哪里声明，那里使用\n\n```java\nclass A{\n\tpublic int i =10;\n\t//2\n\tpublic int sum(){\n        //3  \n\t\treturn geti()+10;//5\n\t}\n\t\n\tpublic int sum1(){\n\treturn i+10;\n\t}\n\tpublic int geti(){\n\treturn i;\n\t}\n}\n\nclass B{\n\tpublic int i =10;\n\t\n\tpublic int sum1(){\n\treturn i+10;\n\t}\n    //4\n\tpublic int geti(){\n\treturn i;\n\t}\n}\n\n\nA a  = new B()\n   //1\na.sum //40\n    \n   \n//因为执行到sum方法，开始准备执行geti方法时，因为有java动态绑定的机制，会跳到b类的geti方法执行\n    //再根据继承跳回去\n```\n\n\n\n####  多态的应用\n\n1）多态数组\n\n数组的定义类型为父类类型，里面保存的实际元素类型为子类型\n\n```java\npackage seatWork;\nimport java.security.PrivateKey;\n\npublic class polySeatwork {\n    public static void main(String[] args) {\n        /*\n        * 要求创建一个person对象name ，age\n        * 两个student 对象和2个teacher对象，统一放在数组中，\n        * 并调用每个对象的say方法\n        * */\n        Person1[] person1s = new Person1[5];\n        person1s[0] = new Person1(\"human\",00);\n        person1s[1] = new Student1(\"tom1\",12,150);\n        person1s[2] = new Student1(\"tom2\",13,143);\n        person1s[3] = new teacher(\"zhangsan\",30,4000);\n        person1s[4] = new teacher(\"lisi\",28,5000);\n\n        //循环遍历多态数组，调用say方法\n        for (int i = 0; i < person1s.length ; i++) {\n            //老韩提示， person1s[i]的编译类型是Person，\n            // 运行类型是根据实际情况而变化\n            System.out.println(person1s[i].say());\n        }\n    }\n}\nclass Person1{\n    private String name;\n    private int age;\n\n    public Person1(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String say(){\n        return \"name = \"+name+\"age = \"+age;\n    }\n}\n\nclass Student1 extends Person1{\n\n    private double score;\n\n    public Student1(String name, int age, double score) {\n        super(name, age);\n        this.score = score;\n    }\n    public double getScore() {\n        return score;\n    }\n    public void setScore(double score) {\n        this.score = score;\n    }\n\n    @Override\n    public String say() {\n        return super.say()+\"score = \"+score;\n    }\n    public void study(){\n        System.out.println(getName()+\"学习······\");\n    }\n}\n\nclass teacher extends Person1{\n    private double salary;\n\n    public teacher(String name, int age, double salary) {\n        super(name, age);\n        this.salary = salary;\n    }\n    public double getSalary() {\n        return salary;\n    }\n    public void setSalary(double salary) {\n        this.salary = salary;\n    }\n\n    @Override\n    public String say() {\n        return super.say()+\"salary = \"+salary;\n    }\n    public void teach(){\n        System.out.println(getName()+\"教书·············\");\n    }\n}\n```\n\n案例升级：如何调用子类的特有方法，比如Teacher 有一个teach，Student有一个study方法。如何调用?\n\n```java\n//循环遍历多态数组，调用say方法\n        for (int i = 0; i < person1s.length ; i++) {\n            //老韩提示， person1s[i]的编译类型是Person，\n            // 运行类型是根据实际情况而变化\n\n            //判断person1s[i]的运行类型\n            if ( person1s[i] instanceof Student1){\n               Student1 student1 =  (Student1)person1s[i];\n               student1.say();\n               //也可以写成一条语句\n               ((Student1)person1s[i]).study();\n            }else if (person1s[i] instanceof teacher){\n                ((teacher)person1s[i]).teach();\n            }else{\n                System.out.println(\"============类型有误==============\");\n            }\n            System.out.println(person1s[i].say());\n        }\n```\n\n#### 多态参数\n\n方法定义的形参类型为父类型，实参类型允许为子类类型\n\n* polyParameter.java\n\n* ```java\n  package seatWork;\n  \n  public class polyParameter {\n      /*\n      * 定义员工类Employee，包含姓名和月工资[private]，以及计算年工资getAnnual的方法。\n      * 普通员工和经理继承了员工，经理类多了奖金bonus属性和管理manage方法，\n      * 普通员工类多了work方法，普通员工和经理类要求分别重写getAnnual方法\n      *\n      *\n      * 测试类中添加一个方法showEmployAnnual（Employee e ),\n      * 实现获取任何员工对象的年工资，\n      * 并在main方法中调用该方法[e.getAnnual()]\n      *\n      * 测试类中添加一个方法，testWork，如果是普通员工，\n      * 则调用work方法，如果是经理，则调用manage方法\n  */\n      public static void main(String[] args) {\n          GeneralStaff staff = new GeneralStaff(\"zhangsan\", 5000);\n          Manager manager = new Manager(\"lisi\", 5000, 10000);\n          polyParameter polyParameter = new polyParameter();\n          polyParameter.showEmployAnnual(staff);\n          polyParameter.showEmployAnnual(manager);\n  \n          polyParameter.testWork(staff);\n          polyParameter.testWork(manager);\n  \n      }\n      public void showEmployAnnual(Emplyee e){\n  \n          System.out.println(e.getAnnual());\n      }\n      /*\n      * 添加一个方法，testwork\n      * 如果是普通员工，则调用work方法\n      * 如果是经理则调用manage方法\n      * */\n      public void testWork(Emplyee e){\n          if (e instanceof GeneralStaff){\n              ((GeneralStaff) e).work();//向下转型\n          }else if (e instanceof Manager){\n              ((Manager) e).manage();//向下转型\n          }\n      }\n  \n  \n  }\n  class Emplyee {\n      private String name;\n      private double salary;\n  \n      public Emplyee(String name, double salary) {\n          this.name = name;\n          this.salary = salary;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  \n      public void setName(String name) {\n          this.name = name;\n      }\n  \n      public double getSalary() {\n          return salary;\n      }\n  \n      public void setSalary(double salary) {\n          this.salary = salary;\n      }\n  \n      public double getAnnual(){\n          double tmp = 12*salary;\n  \n          return tmp;\n      }\n  }\n  \n  class GeneralStaff extends Emplyee{\n  \n      public GeneralStaff(String name, double salary) {\n          super(name, salary);\n      }\n  \n      @Override\n      public double getAnnual() {\n          return super.getAnnual();\n      }\n  \n      public void work(){\n          System.out.println(\"work method\");\n      }\n  }\n  class Manager extends Emplyee{\n      private double bonus;\n  \n      public Manager(String name, double salary,double bonus) {\n          super(name, salary);\n          this.bonus = bonus;\n      }\n  \n      public void manage(){\n          System.out.println(\"manage method\");\n      }\n  \n      @Override\n      public double getAnnual() {\n          return super.getAnnual()+bonus;\n      }\n  }\n  \n  ```\n\n\n## Obeject类详解\n\n类Object是类的层次结构的根类，每个类都使用Object作为超类，所有对象(包括数组)都实现了这个类的方法\n\n#### equals\n\n==和equals的对比\n\n==是一个比较运算符\n\n1. 既可以判断基本类型，又可以判断引用类型\n2. 如果判断基本类型，判断值是否相等。例如：int i = 10; double b = 10.0;\n3. 如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象\n\n\n\n \n\nequals：是Object类中的方法，只能判断引用类型，\n\n判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等\n\n案例：\n\n```java\npackage seatWork;\n\npublic class equalsExercise {\n    public static void main(String[] args) {\n        Person02 person02 = new Person02(\"zhangsan\", 123, '男');\n        Person02 person03 = new Person02(\"zhangsan\", 123, '男');\n        //在没有重写equals方法时是不相等，此时的方法时比对是否指向同一对象\n        System.out.println(person02.equals(person03));\n    }\n}\nclass Person02{\n//    判断两个Person是否相等\n    private String name;\n    private int age;\n    private char gender;\n\n    public Person02(String name, int age, char gender) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public char getGender() {\n        return gender;\n    }\n\n    public void setGender(char gender) {\n        this.gender = gender;\n    }\n\n    public boolean equals(Object obj) {\n//        1. 先判断两个是否指向同一对象\n        if (this == obj){\n            return true;\n        }\n//        2.进行类型判断\n        if (obj instanceof Person02) {\n//            3.向下转型，得到所有的属性信息进行比对\n            Person02 person02 = (Person02) obj;\n            return this.name.equals(person02.name)&&this.age== person02.age&&this.gender==person02.gender;\n        }\n//        如果不是Person类型，则直接返回false\n        return false;\n    }\n\n}\n\n```\n\n#### hashCode\n\n介绍：\n\n返回对象的哈希码值，支持此方法是为了提高哈希表的性能\n\n实际上，由object类定义的hashCode方法确定会针对不同的对象返回不同的证书，(这一般是通过将该对象的内部地址转移换成一个整数来实现的，但是java编程语言不需要这种实现技巧)\n\n老韩六小结：\n\n1. 提高具有哈希结构容器的效率\n\n2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的\n\n3. 两个引用，如果指向的是不同的对象，则哈希值是不一样的（极大概率不一样）\n\n4. 哈希值主要根据地址号来的！，不能完全将哈希值等价于地址\n\n5. 案例演示obj.hashCode() [测试 A obj1 = new A(); A obj2 = new A(); A obj3 = obj1]\n\n   ```java\n   package seatWork;\n   \n   public class hashCodeExcise {\n       public static void main(String[] args) {\n           A a = new A();\n           A a1 = new A();\n           A a3 = a;\n           System.out.println(\"a.hashCode() = \"+a.hashCode());       System.out.println(\"a1.hashCode() = \"+a1.hashCode());       System.out.println(\"a3.hashCode() = \"+a3.hashCode());\n       }\n   }\n   class A{\n   }\n   \n   ```\n\n   ![image-20220323164744164](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220323164744164.png)\n\n6. 后面在集合，中hashCode如果需要的话，也会重写\n\n#### toString\n\n介绍：\n\n默认返回：全类名+@+哈希值的十六进制，[查看object的tostring方法]\n\n子类往往会重写toString方法，用于<span style=\"color:red;background:yellow\">返回对象的属性信息</span>\n\n重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。\n\n\n\n当直接输出一个对象时，toString方法会被默认的调用\n\n```\nSystem.out.print(xxx);\n等价于System.out.print(xxx.toString);\n```\n\n\n\n#### finalize()\n\n介绍：\n\n当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法\n\n1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作\n2. 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制销毁该对象，在销毁该对象前，会先调用finalize方法\n3. 垃圾回收机制的调用，是由系统来决定的(即有自己的GC算法 )，也可以通过System.gc()主动触犯垃圾回收机制\n\n## 断点调试（debug）\n\n#### 提示：\n\n在断点调试的过程中，是运行状态，是以对象运行类型来执行的\n\n#### 介绍：\n\n​\t断点调试是指程序在的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步一步往下调，调试过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug。\n\n#### 快捷键\n\n* F7（跳入）\n  * 跳入方法内\n* F8（跳过）\n  * 逐行执行代码\n* shift+F8（跳出）\n  * 跳出方法\n* F9（resume，执行到下一个断点）\n\n![image-20220324141333874](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220324141333874.png)\n\n\n\n# 面向对象（高级）\n\n## 类变量和类方法\n\n### 一、类变量\n\n案例理解：\n\n```java\npublic Child{\nprivate String name;\n\n    \n//定义一个变量count，是一个类变量（静态变量）static静态\n    //该变量最大的特点就是会被Child类的所有的对象实例共享\npublic static int count = 0;\n\npublic Child （String name）{\n     this.name = name;\n}\n    public void join(){\n        System.out.println(name+\"加入了游戏····\")\n    }\n}\n\n\n\nmain(){\n    //定义一个变量count，统计多少小孩加入了游戏\n    //传统方法，定义一个count然后统计\n    //int count  = 0;\n    \n    Child child0 = new Child(\"xiaoming\")；\n        child0.join();\n    \t//count++;\n    \n    //改进后\n    \tchild0.count++;\n    \n    Child child1 = new Child(\"xiaoming\")；\n        child1.join();\n    \tchild1.count++;\n    \n    Child child2 = new Child(\"xiaoming\")；\n        child2.join();\n    \tchild2.count++;\n    \n    //类变量可以通过类名来访问\n    System.out.println(\"共有\"+child.count+\"小孩加入了游戏\")\n}\n```\n\nstatic变量会开辟一个独立的空间，所以new的对象空间不会再单独创建一个static变量的空间。所以这个static变量空间对于这个类的所有实例是共享的\n\n#### 内存分析\n\n![image-20220402161426676](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220402161426676.png)\n\n1. static变量是对象共享的\n2. 不管static变量在哪\n   1. static变量是同一个类，所有对象共享\n   2. static类变量，在类加载的时候就生成了\n\n#### 定义语法\n\n访问修饰符\tstatic\t数据类型\t变量名；【推荐】\n\nstatic\t访问修饰符\t数据类型\t变量名；\n\n#### 类变量访问\n\n类名.类变量名【推荐】\n\n或者\t\n\n对象名.类变量名 [静态变量的访问修饰符的访问权限和范围和普通属性是一样的]\n\n推荐使用第一种\n\n\n\n#### 使用细节\n\n1. 什么时候使用类变量？\n   * 当我们需要让某个类的所有对象都共享一个变量时，就可以使用类变量（静态变量）：比如上述的统计人数的案例\n2. 类变量与实际变量的区别\n   * 变量是该类的所有对象共享的\n   * 实例变量是每个对象独享的\n3. 加上static成为类变量或静态变量，否则称为实例变量/普通变量/非静态变量\n4. 类变量可以通过<span style=\"color:red\">类名.类变量名</span>或者<span style=\"color:red\">对象名.类变量名</span>来访问。推荐第一种方式访问（前提是得满足访问权限）\n5. 实例变量不能通过<span style=\"color:red\">类名.类变量名</span>方式访问\n6. 类变量是在类加载时就初始化了，也就是说，及时没有创建对象，只要加载类了，就可使用类变量了\n7. 类变量的声明周期是随类的加载开始，随着类的消亡而销毁\n\n### 二、类方法\n\n#### 介绍\n\n类方法也称静态方法\n\n### 格式\n\n````java\n访问修饰符\tstatic\t数据源返回类型\t方法名(){}\t【推荐】\nstatic\t访问修饰符\t数据返回类型\t方法名(){}\n````\n\n\n\n#### 类方法调用\n\n使用方式：\n\n<span style=\"color:red\">类名.类方法名</span>\n\n或\n\n<span style=\"color:red\">对象名.类方法名</span>\n\n#### 使用场景\n\n当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。\n\n比如：工具类中的方法utils\n\nMath类、Arrays类、Collections集合类\n\n#### 使用细节\n\n1. 类方法和普通方法都是随着类的加载而加载，将结构信息储存在方法区：\n   * 类方法中无this的参数\n   * 普通方法中隐含this参数\n2. 类方法可以通过类名调用，也可以通过对象名调用\n3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用\n4. 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以\n5. 类方法(静态方法)中，只能访问 静态变量和静态方法\n6. 普通成员方法，既可以访问静态的成员，非静态的方法。可以访问静态成员和非静态成员\n\n#### 总结：\n\n静态方法，只能访问静态的成员，\n\n非静态方法，可以访问静态的 成员和非静态的成员\n\n（前提是必须遵守访问权限规则）\n\n## 理解main方法语法\n\n#### 深入理解main方法\n\n解释main方法的形式：public static void main(String[] args){}\n\nmain方法是java虚拟机调用的\n\n1. java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public\n\n2. java虚拟机在执行main()方法是不必创建对象，所有该方法必须是static\n\n3. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数\n\n4. java执行的程序 参数1 参数2  参数3\n\n   ![image-20220403184106869](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220403184106869.png)\n\n#### 提示\n\n1. 在main（）方法中我们可以直接调用main方法所在类的静态方法或静态属性\n\n2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，再能通过这个对象去访问类中的非静态成员\n\n3. 例：\n\n   * ```java\n     class A{\n     \tprivate int a;\n     \tprivate static int b;\n     \t\n     \tprivate void a(){\n     \t\tSystem.out.println(\"非静态方法a\");\n     \t}\n     \tprivate static void b(){\n     \t\tSystem.out.println(\"静态方法a\");\n     \t}\n     \t\n     \t\n     \t\n     \tpublic static void main(String[] args){\n     \t\tSystem.out.println(\"id = \" +a);//错误 a是非静态变量，得实例一个对象才能调用\n             System.out.println(\"id = \" +new A().a);//这样是正确的，创建了个匿名对象调用\n             System.out.println(\"id = \" +b);//正确， 因为b是静态变量，可以直接调用\n             System.out.println(\"id = \" +a());//错误，和上述a的非静态变量的原因相同\n             System.out.println(\"id = \" +new A().a());//改成这样就是正确的，因为a()是非静态的方法\n             \n             A a = new A();\n             System.out.println(\"id = \" +a.a());//同理\n     \t}\n     }\n     ```\n\n   * \n\n\n\n## 代码块\n\n#### 介绍\n\n代码块又称初始化块，属于类中的成员【即 是类的一部分】。类似于方法，将罗技语句封装在方法体中，通过{}包围起来\n\n和方法不同，没有方法名，没有返回，没有参数，只有方法体。而且不用通过对象或类显式调用，而是在家类是，或创建对象时隐式调用。\n\n#### 基本语法\n\n```java\n[修饰符]{\n\t代码\n};\n```\n\n#### 注意：\n\n1. 修饰符 可选，要写的话，也只能写static\n2. 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块\n3. 逻辑语句可以为任何罗技语句（输入，输出，方法调用，循环，判断等）\n4. ; 号可以写上，也可以省略。\n\n#### 优点\n\n1. 相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作\n2. 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性\n\n#### 案例\n\n```java\nclass Movie{\n\tprivate String name;\n\tprivate double price;\n\tpricate String director;\n    /*\n    使用场景\n    1. 下面三个构造器都有相同的语句\n    2. 这样重写大量的代码\n    3. 可以吧相同语句提取出来，放到一个代码块中\n    4. 我们不管调用哪个构造器，创建对象，都会先执行代码块\n    5. 代码块调用的顺序都是优先于构造器\n    \n    */\n\t\n\t{\n\t\tSystem.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n\t\n\t}\n    \n    public Movie(String name){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n    }\n    public Movie(String name,double price){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n        this.price = price;\n    }\n    public Movie(String name,double price,String director){\n       /* \n        System.out.println(\"电影屏幕打开···\");\n\t\tSystem.out.println(\"广告···\");\n\t\tSystem.out.println(\"开始播放电影···\");\n        */\n        this.name = name;\n        this.price = price;\n        this.director = director;\n    }\n}\n```\n\n#### 使用细节\n\n1. static代码块也叫静态代码块，作用就是对类进行初始化，\n\n   而且它随着类的加载而执行\n\n   并且只会执行一次。\n\n   如果是普通代码块，每创建一个对象，就执行\n\n   ```java\n   //静态代码块\n   static{\n   \txxxx;\n   }\n   \n   //普通代码块\n   {\n   \txxxx;\n   }\n   ```\n\n2. 类什么时候被加载？[重要]\n\n   1. 创建对象实例时（new xxx)\n   2. 创建子类对象实例，父类也会被加载\n      1. 先在家父类的代码块，再执行子类的\n   3. 使用类的静态成员时（静态属性，静态方法）\n\n   案例：A类 extends B类的静态块\n\n   ​\t\t\t先执行a的静态块，然后再执行b的\n\n   ![image-20220404151232983](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220404151232983.png)\n\n3. 普通代码块，在创建对象实例时，会被隐式调用。\n\n   被创建一次，就会调用一次\n\n   如果只是使用类的静态成员时，普通代码块并不会执行\n\n   \n\n4. 创建一个对象时，在一个类 调用顺序是（重点，难点）\n\n   1. 调用静态代码块和静态属性初始化\n\n      （注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用\n\n      ```java\n      案例理解\n          \n          因为static的优先级一样，\n          所以哪个写在前面，哪个就先执行\n      class A{\n          \n          private static  int n1 = getn1();\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n      }\n      \n      ============================================\n      输出结果：\n      ============================================\n      use getn1\n      A's static codeBlock\n          \n          \n      =========================分割线=========================\n      //如果更换顺序\n      class A{\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          \n          private static  int n1 = getn1();\n          \n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n      }   \n      ============================================\n      输出结果：\n      ============================================\n       A's static codeBlock\n      use getn1\n         \n      ```\n\n      \n\n   2. 调用普通代码块和普通属性的初始化\n\n      （注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义的顺序调用） \n\n      ```java\n      //先执行静态的，和上述的一样，\n      //然后再执行非静态的，规则也是和上述一样，谁写前面先执行谁\n      class A{\n          private int b = getn2();\n      \n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }\n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      getn2 被调用\n      普通代码块被执行\n          \n          \n      =========================分割线=========================\n      class A{\n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          private int b = getn2();\n      \n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }    \n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      普通代码块被执行\n      getn2 被调用\n      ```\n\n        \n\n   3. 调用构造器\n\n      构造器优先级最低，上述的两个规则执行完成后\n      才会执行构造器\n\n      ```java\n      class A{\n          public A() {\n              System.out.println(\"构造器被执行\");\n          }\n      \n          {\n              System.out.println(\"普通代码块被执行\");\n          }\n          private int b = getn2();\n      \n          static {\n              System.out.println(\"A's static codeBlock\");\n          }\n          private static  int n1 = getn1();\n      \n          public static int getn1(){\n              System.out.println(\"use getn1\");\n              return 100;\n          }\n          public int getn2(){\n              System.out.println(\"getn2 被调用\");\n              return 1;\n          }\n      }\n      \n      ============================================\n      输出结果：\n      ============================================\n      A's static codeBlock\n      use getn1\n      普通代码块被执行\n      getn2 被调用\n      构造器被执行\n      \n      ```\n\n5. 构造器 的最前面其实隐含了super() 和调用普通代码块\n\n   静态相关的代码块，属性初始化，在类加载时，就执行完毕。因此是优先于 构造器和普通代码块执行的\n\n   演示：\n\n   ```java\n   class A{\n   \tpublic A(){\n   \t\t//这里存在隐藏的调用\n   \t\t\t//(1) super();\n   \t\t\t//(2) 调用普通代码块\n   \t\t\t\n   \t\t System.out.println(\"xxxx\");\t\n   \t}\n   }\n   ```\n\n   ```java\n   class AAA{\n       public AAA() {\n           //这里存在隐藏的调用\n           //(1) super();\n           //(2) 调用普通代码块\n           //因为Object的代码块没有输出\n           \n           //1.先输出\n           System.out.println(\"AAA的构造器被调用\");\n       }\n   }\n   class BBB extends AAA{\n       {\n   //        根据规则父类的输出完毕后，再调用方法区\n   //        2. 再执行普通代码块\n           System.out.println(\"bbb的普通代码块执行\");\n       }\n   \n       public BBB() {\n           //这里存在隐藏的调用\n           //(1) super();\n           //(2) 调用普通代码块\n   //        等上述执行完毕后，最后执行该语句\n           System.out.println(\"BBB的无参构造被执行\");\n       }\n   }\n   ```\n\n6. 创建一个子类对象时(继承关系),他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：\n\n   1. 父类的静态代码块和静态属性（优先级一样，按定义的顺序执行）\n   2. 子类的静态代码块和静态属性（优先级一样，按定义的顺序执行）\n   3. 父类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）\n   4. 父类的构造器\n   5. 子类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）\n   6. 子类的构造器\n\n7. 静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任何成员\n\n\n\n## 单例设计模式\n\n#### 介绍\n\n1. 所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且只提供一个取得对象实例的方法\n2. 单例模式有两种方式：1）饿汉式 2）懒汉式\n   1. 二者最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例,而懒汉式在使用时才创建\n   2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题\n   3. 饿汉式存在浪费资源的可能。（因为如果程序员一个对象实例都没使用，那么饿汉式创建的对象就是浪费了，懒汉式是使用时才创建，就不存在这个问题\n   4. 在javaSE标准类中，java.lang.Runtim就是经典的单例设计模式\n\n演示：\n\n1. 恶汉式\n\n   类加载的时候，对象就被创建实例对象，可能会出现创建了，但是没有使用\n\n   步骤：\n\n   1. 构造器私有化 => 防止直接new\n\n   2. 类的内部创建对象\n\n   3. 向外露出一个静态的公共方法。\n\n   4. 代码实现\n\n   5. ```java\n      public class singleDesign {\n          public static void main(String[] args) {\n              System.out.println(GirlFriend.info());\n          }\n      \n      }\n      //有一个女朋友类\n      //只能有一个女朋友\n      class GirlFriend{\n          private String name;\n      \n      \n      //    2.创建一个对象\n      //    3.为了能够接收静态方法，需要修饰为static\n          private static GirlFriend girl = new GirlFriend(info());\n      \n      \n      \n      //    如何保证只能有一个对象实例\n      //    public girlFriend(String name) {\n      //        this.name = name;\n      //    }\n      //    1. 改成私有的构造器\n          private GirlFriend(String name) {\n              this.name = name;\n          }\n      //    4.创建一个静态方法，用于接收实例对象\n          public static String info(){\n              return \"g\";\n          }\n      \n      ```\n\n2. 懒汉式\n\n   使用时才创建实例\n\n   1. 构造器私有化=> 防止直接new\n\n   2. 类的内部创建对象\n\n   3. 向外暴露一个静态的公共方法\n\n   4. ```java\n      public class SingleDesign01 {\n          public static void main(String[] args) {\n              System.out.println(Cat.i);\n      //        此时只是初始化了cat ，但没有创建对象，其他的静态参数可以直接调用\n              System.out.println(Cat.getCat());\n      //        当只有调用了这个方法时，才会创建对象(通过判断发现没有cat类，此时创建后返回)\n          }\n      }\n      //懒汉式\n      //希望在程序运行中，只创建一个cat\n      \n      class Cat{\n          private String name;\n          public static int i =1;\n      //    2.定义一个静态属性static\n          private  static Cat cat;\n      \n      //    3.提供一个公共的static方法 可以返回一个Cat对象\n          public  static  Cat getCat(){\n              if (cat == null){ //如果还没创建对象\n                  cat = new Cat(\"little cute\");\n              }\n              return cat;\n          }\n      \n      //    1.创建私有构造器\n          private Cat(String name){\n              this.name = name;\n          }\n      }\n      ```\n\n      \n\n## final关键字\n\n#### 介绍\n\nfinal / 最后的，最终的\n\nfianl 可以修饰类、属性、方法和局部变量\n\n某些情况下，程序员可能有以下需求，就会使用到final：\n\n1. 当不希望类被继承时，可以用final修饰\n2. 当不希望父类的某个方法可以被子类覆盖/重写（override）时，可以用final关键字修饰\n3. 当不希望类的某个属性的值被修改，可以使用final修饰\n4. 当不希望某个局部变量被修改，可以使用final修饰\n\n\n\n#### 使用细节\n\n1. final修饰的属性又叫常量，一般用XX_XX_XX来命名\n\n2. final修饰的属性在定义时，必须赋初始值，并且以后都不能修改，赋值可以在如下位置之一（选择一个位置赋初始值即可）\n\n   1. 定义时：例如  public final double TAX_PATE=0.09;\n\n   2. 在构造器中\n\n   3. 在代码块中\n\n   4. ```java\n      class A{\n      //定义时赋值\n      \tpublic final double ATX_A = 0.9;\n      \t//在构造器中赋值\n      \tpublic final double ATX_B；\n      \tpublic A{\n      \t\tATX_B=0.8；\n      \t}\n      \t//在代码块中赋值\n      \tpublic final double ATX_C；\n      \t{\n      \t\tATX_C=0.2；\n      \t}\n      }\n      ```\n\n3. 如果final修饰的属性是静态的，则初始化的位置只能是\n\n   1. 定义时\n   2. 在静态代码块 \n   3. 不能再构造器中赋值\n\n4. final类不能被继承，但是可以实例化对象\n\n5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承\n\n6. 一般来说，如果一个类已经是final类，就没有必要再将方法修饰成final方法。\n\n7. final不能修饰构造方法（即构造器）\n\n8. final和static 往往搭配使用，效率更高，不会导致类的加载。底层编译器做了优化处理\n\n9. 包装类(integer,Double,Float,Boolean等等都是final),String 也是final类\n\n\n\n## 抽象类\n\n```java\n编写一个父类\n//class Animal{\nabstract Animal{\n\tString name;\n\tpublic Animal(String name){\n\t this.name = name;\n\t}\n\t/*\n\t这里的eat方法 实现了，没有什么意义\n\t即父类中的方法不确定性的问题\n\t\n\t1.考虑将该方法设计为抽象(abstract)方法\n\t2.所谓抽象方法就是没有实现的方法\n\t3.所谓的没有实现就是没有方法体\n\t4.当一个类存在抽象方法时，就需要将该类声明为abstract类\n\t\n\t一般来说，抽象类会被继承，有其子类来实现抽象方法\n\t*/\n    \n\t//public void eat(){\n\t//\tSystem.out.println(\"这个是一个吃方法，但不知道吃啥\");\n\t//}\n    \n\tpublic abstract void eat();\n}\n```\n\n\n\n#### 介绍\n\n1. 用abstract 关键字修饰的类时，这个类就是抽象类\n\n   1. ```java\n      访问修饰符 abstract 类名{\n      }\n      ```\n\n2. 用abstract 关键字来修饰一个方法时，这个方法就是抽象方法\n\n   1. ```java\n      访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体\n      ```\n\n3. 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()\n\n#### 细节\n\n1. 抽象类不能被实例化\n2. 抽象类不一定包含abstract方法。也就是说，抽象类可以没有abstract方法\n3. 一旦包含了abstract方法，则这个类必须声明为abstract \n4. abstract 只能修饰类和方法，不能修饰属性和其他的\n5. 抽象类可以有任意成员【抽象类的本质还是类】，比如：非抽象方法、构造器、静态属性等等\n6. 抽象方法不能有主体，即不能实现。例如：abstract void method()；不能有{}\n7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract 类（所谓实现就是有那个{}就可，具体内容不管）\n8. 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的\n\n#### 抽象类实践-模板设计模式\n\n现有个需求\n\n1. 有多个类，完成不同的任务job\n2. 要求能得到各自完成任务的时间\n\n```java\npackage seatWork;\n\npublic class Template {\n    public static void main(String[] args) {\n        son1 son1 = new son1();\n        son1.getCurrentTime();\n        son2 son2 = new son2();\n        son2.getCurrentTime();\n    }\n\n}\n\nabstract class Father{\n//在抽象类中定义一个抽象方法，这个方法后期会填入不同子类的不同不同方法\n    public abstract void job();\n//创建一个子类中的公共部分，在其中添加 不同的部分抽象类(方法)，\n// 由于动态绑定机制，当调用该方法时，根据实例不同的子类实现不同的输出结果\n//    也就是说相当于创建了个模板，不同的类用填不同的内容\n    public void getCurrentTime(){\n        long start = System.currentTimeMillis();\n        job();\n        long end = System.currentTimeMillis();\n        System.out.println(\"用时：\"+(end-start));\n    }\n}\nclass son1 extends Father{\n    @Override\n    public void job() {\n        int sum=0;\n        for (int i = 0; i < 10000; i++) {\n            sum+=i;\n        }\n    }\n}\nclass son2 extends Father{\n\n    @Override\n    public void job() {\n        int sum=0;\n        for (int i = 0; i < 60000; i++) {\n            sum+=i;\n        }\n    }\n} \n```\n\n## 接口（重要）\n\n#### 介绍\n\n接口就是给出一些没有实现的方法，封装到一起，起到某个类要使用的时候，在根据具体情况吧这些方法写出来\n\n#### 语法\n\n```java\ninterface 类名 implements 接口{\n 自己的属性；\n 自己的方法；\n 必须实现的接口的抽象方法；\n}\n```\n\n小结:\n\n1. jdk7之前，接口中所有方法否是抽象方法\n2. jdk8之后，接口中可以有实现方法，但需要使用default关键字修饰\n3. jdk8之后可以有静态方法\n4. abstract关键字可以省略\n\n#### 注意事项\n\n1. 接口不能被实例化\n\n2. 接口中所有的方法是public方法，接口中抽象方法，可以不用填写abstract，因为默认修饰的就是public abstract xxx。\n\n3. 一个普通类实现接口，就必须将该接口的所有方法都实现\n\n4. 抽象类实现接口，可以不用实现接口的方法\n\n5. 一个类同时可以实现多个接口\n\n6. 接口的属性，只能是final的，而且public static final 修饰符，比如：int a =1; 实际上是public static final int a =1；（必须）初始化\n\n7. 接口中属性的访问形式：接口名.属性名\n\n8. 一个接口不能继承其他的类，但是可以继承多个别的接口\n\n   ```java\n   interface A extend B,c,d...{}\n   ```\n\n9. 接口的修饰符只能是public和默认，这点和类的修饰符是一样的。\n\n小结：\n\n继承vs接口\n\n1. 当子类继承了父类，就自动拥有了父类的功能\n2. 如果子类需要拓展功能，可以通过实现接口的方式扩展\n3. 可以理解，接口是对java单继承机制的一个补充\n\n继承的价值：解决代码的复用性和可维护性\n\n接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。更加的灵活\n\n## 内部类（重点）\n\n#### 介绍：\n\n一个类的内部又完整的嵌套了另一个类结构。被嵌套的类成为内部类（inner class)，嵌套其他类的类成为外部类(out class)。是我们类的第五大成员\n\n类的五大成员：\n\n1. 属性\n2. 方法\n3. 构造器\n4. 代码块\n5. 内部类\n\n#### 基本语法\n\n```java\nclass Outer{//外部类\n\tclass inner{//内部类\n\t}\n}\n\nclass other{//外部其他类\n}\n```\n\n \n\n#### 内部类的分类\n\n定义在外部类局部位置上（比如方法内）\n\n##### 1）局部内部类（有类名）\n\n​\t\t说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名\n\n```java\n//例\nclass outclass{\n  private int n = 100;\n  //局部内部类师是定义在外部类的局部位置，通常在方法内\n // 1.第一种在局部位置\n \tclass innerClass{}\n  //2. 在方法内，（局部内部类）\n  public void mehtod(){//局部内部类（本质仍然是一个类）\n    \tclass innerClass{\n        System.out.print(\"n=\"+n);\n      }    \n  }\n}\n```\n\n1. 可以直接访问外部类的所有成员，包括私有的\n\n2. 不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但可以使用final修饰，因为局部变量也可以使用final修饰符的\n\n3. 作用域：仅仅在定义它的方法或代码块中\n\n4. 局部内部类---访问---->外部类的成员【访问方式：直接访问】\n\n5. 外部类----访问---->局部内部类的成员\n\n   访问方式：创建对象，再访问（注意：必须在作用域内）\n\n6. 外部其它类---->不能访问---->局部内部类（因为 局部内部类地位是一个局部变量）\n\n7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问\n\n8. ```java\n   class Outer{\n   \tprivate int n1 = 10;\n   \tprivate static String name = \"张三\";\n   \tpublic void say(){\n   \t\tint n3 = 30;\n         //局部内部类是定义在外部类的局部位置，通常在方法  \n           //不能添加访问修饰符，可以使用final修饰\n     class localInner{//局部内部类（本质仍然是一个类）\n       int n1 = 100;\n      int n2 = 40;\n           //可以直接访问外部类的所有成员，包括私有的    \n         public void show(){\n         //默认输入内部类的n1的值 100\n   \t    System.out.print(\"n1=\"+n1);\n         //输入outer.this.n1 输出的才是外部类的n1\n         System.out.print(\"n1=\"+outer.this.n1);\n           \n         }\n   \t}\n   }\n     //外部类使用内部类\n     localInner inner = new localInner();\n     inner.show();\n    }\n   \n   \n   \n   //外部其他类\n   \n   ```\n\n9. \n\n##### 2）匿名内部类（没有类名，重点！！！！）\n\n###### 介绍：\n\n1. 本质是类\n2. 是一个内部类\n3. 该类没有名字\n4. 同时还是一个对象\n\n匿名内部类是定义在外部类的局部位置\n\n比如在方法中，并且没有类名\n\n###### 基本语法\n\n```java\nnew 类 或 接口（参数列表）{\n\t类体\n};\n\nanonymous\n```\n\n###### 演示 \n\n```java\npackage chapterObjectHeightLevel;\n\npublic class AnonymousClass {\n    public static void main(String[] args) {\n        outer outer = new outer();\n        outer.method();\n    }\n}\n\nclass outer{//外部类\n    private  int n1 =10;\n    public  void method(){\n        //现有一个需求，使用IA接口，并创建对象\n\n//        传统方法：新建一个类tiger 实现IA接口，并new tiger调用\n//        IA tiger = new Tiger();\n//        tiger.cry();\n//        当此时的需求是只需要这个Tiger类使用一次，并且以后再也不使用\n//        如果再用传统方法的话，会造成资源浪费，而且没有必要再去新建一个类\n//        此时就需要匿名内部类来简化开发，如下\n        IA tiger = new IA(){\n            /**\n             *此时底层是这样的\n             * class xxx(该类名是系统自动创建的) implements IA{\n             *     @Override\n             *     public void cry() {\n             *         System.out.println(\"老虎叫`````\");\n             *     }\n             * }\n             *\n             * 之后在让tiger指向xxx的地址\n             */\n            @Override\n            public void cry() {\n                System.out.println(\"老虎叫`````\");\n            }\n        };\n        tiger.cry();\n\n\n\n        //演示基于类的匿名内部类\n//        1. father的编译类型 Father(不加{}号)\n//        2. father的编译类型 xxx$2(加{}号）\n//        2.1 底层会创建匿名内部类\n        Father father = new Father(\"tiger\"){\n            @Override\n            public void test() {\n                System.out.println(\"override test method\");\n            }\n            /**\n            * 相当于创建了哥匿名内部类重写了test方法\n            * class xxx implement test{\n             *      @Override\n             *      public void test() {\n             *          System.out.println(\"override test method\");\n             *       }\n             * }\n             * 然后再将father指向xxx的地址\n            * */\n        };\n        father.test();\n\n    }\n\n}\n\ninterface IA{\n    public void cry();\n}\n\n//class Tiger implements IA{\n//\n//    @Override\n//    public void cry() {\n//        System.out.println(\"老虎叫`````\");\n//    }\n//}\n\nclass Father{\n    public Father(String name) {\n\n    }\n    public void test(){\n\n    }\n}\n\n```\n\n\n\n###### 注意细节\n\n1. 匿名内部类既是一个类的定义，同事它也是一个对象，因此从语法上来看，它既有定义类的特征，也有创建对象的特征，对前面的代码分析可以看出这个特点，因此调用匿名内部类方法有两种\n\n   ```java\n   //1.第一种方式\n   new A{\n   @override\n   \tpublic void cry(){\n   \tSystem.out.print(\"hello\");\n   \t}\n   }.cry();\n   \n   //2.第二种方式\n   A a=new A{\n   @override\n   \tpublic void cry(){\n   \tSystem.out.print(\"hello\");\n   \t}\n   }\n   a.cry();\n   ```\n\n2. 可以访问外部类的所有成员，包括私有的\n\n3. 不能添加访问修饰符，因为它的地位就是一个局部变量\n\n4. 作用域：方法或代码块中\n\n5. 匿名内部类--->范围跟--->外部类成员\n\n6. 外部其他类--->不能访问--->匿名内部类（因为 匿名内部类地位是一个局部变量）\n\n7. 如果外部类和内部类的成员变量重名时，内部类访问的话，默认就是就近原则，如果想访问外部，可以使用（外部类名.this.成员）去访问\n\n\n\n\n\n定义在外部类的成员位置上\n\n##### 1）成员内部类（没用static修饰）\n\n介绍：\n\n1. 成员内部类是定义在外部类的成员位置，并且没有static修饰\n\n   ```java\n   class outer{\n   \tprivate int n1 =10;\n   \tpublic String name = \"zhangsan\";\n   \t\n   \tclass inner{\n   \t\tpublic void say(){\n   \t\t\tSystem.out.print(\"outer n1 = \"+n1+\"outer name = \"+name);\n   \t\t}\n   \t}\n   }\n   ```\n\n2. 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位是一个成员\n\n3. 作用域\n\n   和外部类的其他成员一样，为整个类体比如前面的案例，在外部类的成员方法中创建成员内部类对象，再调用方法\n\n4. 成员内部类-->访问--->外部类成员\n\n   (比如属性)【访问方式：直接访问】\n\n5. 外部类 ---访问---内部类\n\n   访问方式：创建对象，再访问\n\n6. 外部其他类-----访问-----成员内部类\n\n   ```java\n   //三种方式:\n   //1\n   outer.inner class = new outer.new inner;\n   \n   // 第二种方式\n    1.定义一个方法，用于创建内部类并返回内部类的实例\n      public inner getInner(){\n      Inner inner  = new Inner();\n      return inner;\n    }\n   2. 在需要的地方new一个外部类.这个方法\n     Outer.Inner inner = new Outer.getInner();\n   \n   //3这个方法不建议使用\n     \n     new Outer().new Inner();\n   \n   ```\n\n7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问\n\n   ![image-20220409142725630](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409142725630.png)\n\n##### 2）静态内部类（使用static修饰）\n\n###### 介绍\n\n静态内部类定义在外部类的成员位置，并且有static修饰\n\n1. 可以直接访问外部的所有静态成员，包含私有的，但不能直接访问非静态成员\n2. 可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员\n3. 作用域：同其他的成员，为整个类体\n\n```java\nclass outer{\nprivate int n1=10;\nprivate static String name = \"zhangsan\";\n\n//inner就是静态内部类\n  //1. 放在外部类的成员位置\n  //2. 使用static修饰\n  //3. 不能直接访问非静态成员\n  //4. 可以添加修饰符\n\tstatic class Inner{\n\t\tpublic void say(){\n      \tSystem.out.println(name);\n    }\n\t}\n}\n```\n\n4. 静态内部类---访问----外部类\n\n   （比如：静态属性）[访问方式：直接访问所有静态成员]\n\n5. 外部类--访问---静态内部类 \n\n   访问方式：创建对象，再访问\n\n6. 外部其他类 --访问 --内部类\n\n   访问方式：\n\n   ```java\n   //访问方式1\n   //因为静态内部类，是可以通过类名直接访问（前提是满足访问权限）\n   Outer.Inner inner = new Outer.Inner();\n   inner.xxx();\n   //访问方式2\n   //写一个方法，返回静态内部类的实例\n   public Inner getInner(){\n     return new Inner();\n   }\n   Outer.Inner inner = Outer.getInner();\n   \n   inner.xxx();\n   \n   //或者将方法换成静态\n   public static Inner getInner(){\n     return new Inner();\n   }\n   \n   \n   \n   ```\n\n7. 如果外部类和静态内部类的成员重名时，静态内部访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问\n\n\n\n# 枚举和注解\n\n## 枚举（enum）\n\n### 介绍\n\n1）枚举对应的英文（enumeration,简写enum）\n\n2）枚举是一组常量的集合\n\n3）可以理解：枚举属于一种特殊的类，里面只包含一组有限的特定对象（比如一年只有四个季节，建一个季节类的话只能有四个，而且有被添加其他季节的风险）\n\n\n\n### 实现方式\n\n#### 1）自定义枚举\n\n1. 不需要提供set方法，因为枚举对象通常为只读\n2. 对枚举对象/属性使用final +static共同修饰，实现底层优化\n3. 枚举对象通常使用大写，常量的命名规范\n4. 枚举对象根据需要，也可以有多个属性\n\n```java\npackage chapterEnum;\n\npublic class understandForEnum {\n    public static void main(String[] args) {\n        season autumn = season.AUTUMN;\n        System.out.println(autumn.getSeasonName()+autumn.getSeasonDescription());\n\n    }\n}\n//定义一个季节类\nclass season{\n    private String seasonName;//季节名称\n    private String seasonDescription;//季节描述\n  //1.将构造器私有化\n  //2.去掉setxx方法，防止属性被修改\n  //3.在season内部，直接创建固定的对象\n  //4.优化，添加final\n\n    public String getSeasonName() {\n        return seasonName;\n    }\n\n    public String getSeasonDescription() {\n        return seasonDescription;\n    }\n\n    private season(String seasonName, String seasonDescription) {\n        this.seasonName = seasonName;\n        this.seasonDescription = seasonDescription;\n    }\n//定义了四个对象\n    public final static season SPRING = new season(\"春天\",\"温暖\");\n    public final static season SUMMER = new season(\"夏天\",\"炎热\");\n    public final static season AUTUMN = new season(\"秋天\",\"凉爽\");\n    public final static season WINTER = new season(\"冬天\",\"寒冷\");\n}\n\n```\n\n总结：定义枚举类型有一下几个特点\n\n1. 构造器私有化\n2. 本类内部创建一组对象\n3. 对外暴露对象（添加public final static 修饰）\n4. 可以提供get方法，但不需要提供set方法\n\n#### 2）使用enum关键字实现\n\n```java\npackage chapterEnum;\n\npublic class understandForEnum02 {\n    public static void main(String[] args) {\n        System.out.println(season02.SPRING);\n    }\n}\nenum season02{\n    /**\n     * 实现步骤\n     * 1.使用enum代替class\n     * 2.直接使用 常量名(实参列表)\n     *   SPRING(\"春天\",\"温暖\"),\n     *   如果有多个常量则用,号隔开\n     *\n     * enum修饰必须将常量对象写在第一行\n     *  必须写在定义的变量和方法前面\n     *\n     * 3.编写常量，私有构造器和get方法\n     * */\n\n    SPRING(\"春天\",\"温暖\"),\n    SUMMER(\"夏天\",\"炎热\"),\n    AUTUMN(\"秋天\",\"凉爽\"),\n    WINTER(\"冬天\",\"寒冷\");\n\n\n    private String seasonName;//季节名称\n    private String seasonDescription;//季节描述\n\n    public String getSeasonName() {\n        return seasonName;\n    }\n\n    public String getSeasonDescription() {\n        return seasonDescription;\n    }\n\n    private season02(String seasonName, String seasonDescription) {\n        this.seasonName = seasonName;\n        this.seasonDescription = seasonDescription;\n    }\n\n    @Override\n    public String toString() {\n        return \"season02{\" +\n                \"seasonName='\" + seasonName + '\\'' +\n                \", seasonDescription='\" + seasonDescription + '\\'' +\n                '}';\n    }\n    //定义四个固定对象\n    /*\n    public final static season02 SPRING = new season02(\"春天\",\"温暖\");\n    public final static season02 SUMMER = new season02(\"夏天\",\"炎热\");\n    public final static season02 AUTUMN = new season02(\"秋天\",\"凉爽\");\n    public final static season02 WINTER = new season02(\"冬天\",\"寒冷\");\n*/\n\n\n}\n```\n\n##### 注意事项\n\n1. 当我们使用enum关键字开发一个枚举类时，默认会继承Enum类\n2. 传统的public static final SPRING = new season(\"春天\",\"温暖\");简化成SPRING(\"春天\",\"温暖\"),这里必须知道，它调用的是哪个构造器\n3. 如果使用无参构造器 创建枚举对象，则实参列表和小括号都可以省略\n4. 当有多个枚举对象时，使用，号间隔，最后一个分号结尾\n5. 枚举对象必须放在枚举的行首\n\n\n\n### enum常用方法说明\n\n使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类的相关方法\n\n![image-20220409204654918](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409204654918.png)\n\n```java\n    public static void main(String[] args) {\n//        使用season02 枚举类，演示各个方法\n        season02 summer = season02.SUMMER;\n//        输出枚举对象的名字\n//        summer.name();\n        System.out.println(summer.name());\n\n//        ordinal()输出的是该枚举对象的次序/编号，按枚举的顺序从0开始编号\n//        summer枚举对象时第二个，因此返回 1\n        System.out.println(summer.ordinal());\n\n//        从反编译可以看出values方法，返货season02[]\n//        含有定义所有的枚举对象\n        season02[] values = season02.values();\n        for (int i = 0; i <values.length ; i++) {\n            System.out.println(values[i].name());\n        }\n//        增强for循环演示\n//        每执行一次values就会扔一个对象给season、\n//        简单来说就是依次取出数组赋给season\n        System.out.println(\"==========增强for=========\");\n        for(season02 season:values){\n            System.out.println(season.name());\n        }\n\n//        valueOf:将字符串转换成枚举对象，要求字符串必须VT为己有的常量名，否则会报错\n//        1.根据输入的\"xia\"到season02中的枚举对象去查找\n//        2.如果找到了，就返回，如果没有找到就报错，如下这个例子\n        /*season02 vaof = chapterEnum.season02.valueOf(\"xia\");\n        System.out.println(\"vaof = \"+ vaof);*/\n//        3.只要valueOf()中的参数和枚举对象一致才能正常返回，如下\n        season02 xia = chapterEnum.season02.valueOf(\"SUMMER\");\n        System.out.println(\"xia = \" +xia);\n\n//        compareTo:比较两个枚举常量，比较的是编号\n//        就是把season02.SPRING和season02.SUMMER的编号进行比较\n//        底层是第一个的编号减去第二的编号，\n//        如果=0则是相等的，\n//        如果大于1，则代表前面那个编号大于后面一个编号\n//        如果小于1，则反之\n        System.out.println(season02.SPRING.compareTo(season02.SUMMER));//= -1\n        System.out.println(season02.SPRING.compareTo(season02.WINTER));//= -3\n\n    }\n```\n\n### 使用细节\n\n1. enum修饰的类不能在继承其他父类，因为enum会隐式继承一个Enum类\n2. enum实现的类，仍然是一个类，所以还是可以实现接口的\n\n\n\n### Switch中使用枚举\n\n案例\n\n1. ![image-20220410224921752](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410224921752.png)\n\n2. ```java\n   package homeWork.Annotation;\n   \n   public class AnnotationHomeWork08 {\n       public static void main(String[] args) {\n   //        Color.BLACK.show();\n   //        Color.RED.show();\n       Color red = Color.RED;\n   //    在小（）内放入枚举对象\n   //        在每个case后，直接写上枚举类，定义枚举对象即可\n           switch (red){\n               case RED:\n                   System.out.println(\"红色\");\n                   break;\n               case BLUE:\n                   System.out.println(\"蓝色\");\n                   break;\n               case BLACK:\n                   System.out.println(\"黑色\");\n                   break;\n               case YELLOW:\n                   System.out.println(\"黄色\");\n                   break;\n               case GREEN:\n                   System.out.println(\"绿色\");\n                   break;\n               default:\n                   System.out.println(\"没匹配到\");\n   \n           }\n       }\n   }\n   interface Tint{\n       public void show();\n   }\n   enum Color implements Tint{\n       RED(255,0,0),\n       BLUE(0,0,255),\n       BLACK(0,0,0),\n       YELLOW(255,255,0),\n       GREEN(0,255,0);\n   \n       private int redValue;\n       private int greenValue;\n       private int blueValue;\n   \n       Color(int redValue, int greenValue, int blueValue) {\n           this.redValue = redValue;\n           this.greenValue = greenValue;\n           this.blueValue = blueValue;\n       }\n   \n       @Override\n       public void show() {\n           System.out.println(redValue+\"\\t\"+greenValue+\"\\t\"+blueValue);\n       }\n   }\n   \n   ```\n\n\n\n## 注解\n\n#### 介绍\n\n1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息\n2. 和注解一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息\n3. 在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等，在javase中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替javaee旧版中所遗留 的繁冗代码和xml配置等\n\n使用Annotation时，前面要加@符号，并把Annotation当成一个修饰符使用。用于修饰它支持的程序元素\n\n1. @Override：限定某个方法，是重写父类方法，该注解只能用于方法\n\n   ```java\n   class son extends father{\n   //1.@Override注解方法fly方法上，表示子类fly方法重写了父类的fly\n   //2.如果这里没有写@Override ，还是重写了fly\n   //3.如果写了@Override注解，编译器就会去检查该方法是否真的重写了fly方法，\n   \t如果的确重写了，则编译通过。如果没有构成重写，则编译错误\n   @Override\n   public void fly(){\n    System.out.println(\"son fly...\");\n   }\n   }\n   ```\n\n   @Override只能修饰方法，不能修饰其他类\n\n2. @Deprecated：用于表示某个程序元素(类、方法等)已过时\n\n3. @SuppressWarnings：抑制编译器警告\n\n   1. 当写一些方法时，会出现一些无关不影响运行的警告。\n\n      可以使用@SuppressWarnings来抑制警告信息\n\n   2. 可以在@SuppressWarnings{\"\"}中写入希望抑制的警告信息\n\n   3. ![image-20220410190809537](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410190809537.png)\n\n   4. 位置在哪就屏蔽哪里 \n\n\n\n### 元注解（了解）\n\n@Target是修饰注解的注解，称为元注解  （了解）\n\n元注解的种类（使用不多，要求看到直到是干啥的）\n\n#### 1）Retention //指定注解的作用范围，三种SOURCE,CLASS,RUNTIME\n\n说明：\n\n只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，\n\n@Rentention包含一个RententionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值\n\n@Rentention的三种值：\n\nRententionPolicy.SOURCE //编译器使用后，直接丢弃这种策略的注释\n\nRententionPolicy.CLASS // 编译器将把注释记录在class文件中，当运行java程序时，JVM不会保留注释，这是默认值\n\nRententionPolicy.RUNTIME  //编译器将把注解记录在class文件中，当运行java程序时，JVM会保留注释，程序可以通过反射获取该注释\n\n示意图：\n\n![image-20220410203107921](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410203107921.png)\n\n#### 2）Target     //指定注解可以在哪些地方使用\n\n用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素\n\n简单来说就是在哪些元素上使用\n\n@Target   也包含一个名为value的成员变量\t\n\nTarget(value = CONSTRUCTOR（构造器）, FIELD（field） , LOACL_VARIABLE（局部变量）, METHOD（方法）,PACKAGE（包）,PARAMETER ,TYPE )\n\n#### 3）Documented    //指定该注解是否会在javadoc中体现\n\n@Documented   用于指定该元注解修饰的Annotation类将被Javadoc 工具提取成文档，即在生成文档时，可以看到注解\n\n定义Documented  注解必须设置Retention 值为RUNTIME\n\n#### 4）Inherited    //子类会继承父类注解\n\n\n\n# 异常\n\n## 异常的概念\n\n### 介绍\n\njava语言中，将程序执行中发生的不正常情况成为“异常”。（开发过程中的语法错误和逻辑错误不属于异常）\n\n执行过程中所发生的异常事件可分为两类\n\n1. Error（错误）：java虚拟机无法解决的严重问题。例如：JVM系统内部错误，资源耗尽等严重情况。例：StackOverflowError[栈溢出]和OOM（out of memory),Error是严重错误，程序会崩溃。\n2. Exception：因为，其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对想的代码进行处理，例如空指针访问，视图读取不存在的文件，网络连接中断等等，Exception分为两大类，运行时异常[程序运行发生的异常]和编译时异常[编译时，编译器查出的异常]\n\n\n\n## 异常体系图（重要）\n\n![image-20220411214601035](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411214601035.png)\n\n![image-20220411215335526](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411215335526.png)\n\n小结：\n\n1. 异常分为两大类，运行时异常和编译时异常\n\n2. 运行时异常，编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该避免出现的异常。java.lang.RuntimeException类及它的子类都是运行程序\n\n3. 对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影像\n\n4. 编译时异常，是编译器要求必须处置的异常\n\n    \n\n## 常见的异常\n\n### 常见的运行异常\n\n#### 1）NullPoniterException 空指针异常\n\n1. 当程序试图在需要对象的地方使用 null时，抛出该异常\n\n#### 2 ) ArithmeticException\t数字运算异常\n\n1. 当出现异常的运行条件时，抛出此异常\n2. 例如 一个整数\"除以零\"时，抛出此类的一个实例\n\n#### 3）ArrayIndexOutOfBoundsException\t数组下标异常\n\n1. 用非法索引访问数组时抛出的异常，如果索引为负或者大于等于数组大小，则该索引为非法索引\n\n#### 4）ClassCastException\t类型转换异常\n\n1. 当试图将对象强制转换为不是实例的子类时，抛出该异常\n\n#### 5）NumberFormatException\t数字格式不正确异常[]\n\n1. 当应用程序试图将字符串转换成一种数值类型，但该字符不能转换为适当格式时，抛出该异常\n2. 使用该异常我们可以确保输入的是满足条件的数字\n\n### 常见的编译异常\n\n#### 介绍\n\n编译异常是指在编译期间。就必须处理的异常，否则代码不能通过编译\n\n#### 常见的编译异常\n\n1. SQLException\t//操作数据库时，查询表可能发生的异常\n2. IOException\t\t//操作文件时，发生的异常\n3. FileNotFoundException\t//当操作一个不存在的文件时，发生异常\n4. ClassNotFoundException\t//加载类，该类不存在时，异常\n5. EOFException\t\t//操作文件，到文件末尾，发生异常\n6. IIIegalArguementException\t//参数异常\n\n\n\n## 异常处理概念\n\n### 基本介绍\n\n异常处理就是当异常发生时，对异常处理的方式\n\n### 异常处理方式\n\n#### 1）try-catch-finally\n\n程序员在代码中捕获发生的异常，自行处理\n\n```java\ntry{\n\t代码/可能有异常\n}catch(Exception e){\n//捕获的异常，传给e\n//1.当异常发生时\n//2.系统将异常封装成Exception对象e，传递给catch\n//3.得到异常对象后，程序员自己处理\n//4.如果没有发生异常，则catch代码块不执行\n}finally{\n    //不管try代码块是否有异常发生，始终都要执行finally\n    //通常将释放资源的代码方法finally代码块中\n}\n```\n\n\n\n#### 2）throws\n\n将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM\n\n##### 处理机制图\n\n![image-20220411224543192](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411224543192.png)\n\n\n\nthrows处理机制\n\n1. try-catch-finally和throws二选一\n2. 如果程序员，没有显示是处理异常，默认throws\n\n## 异常处理分类\n\n### try-catch方式处理异常说明\n\n#### 1）java提供try和catch块来处理异常。\n\ntry块用于包含可能出错的代码块。catch用于处理try块中发生的异常，可以根据需要在程序中有多个数量的try...catch块\n\n#### 2）基本语法\n\n```java\ntry{\n//可疑代码\n//将异常生成对应的异常对象，传递给catch块\n}catch(异常){\n//对异常的处理\n}\n//没有finally是可以通过的\n```\n\n```java\n//使用案例\ntry{\nString str = \"糖\";\nint a  = Integer.parseInt(str);\nSystem.out.println(\"数字=\"+a);\n}catch(Exception e){\nSystem.out.println(\"异常信息=\"+e.getMessage());\n}\n```\n\n#### 注意事项\n\n1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块\n\n2. 如果异常没有发生，则顺序执行try代码块，不会进入到catch块\n\n3. 如果希望不管是否能发生异常，都执行某段代码块（比如关闭链接，释放资源等）、\n\n4. 可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求是父类异异常在后，子类异常在前，比如（Exception 在后，NullPointerException 在前）如果发生异常，只会匹配一个catch\n\n   1. ```java\n      例:\n      try{\n      \n      }catch(NullPointerException e){\n      \n      }catch(Exception e){\n      \n      }finally{\n      \n      }\n      \n      ```\n\n5. 可以记性try-finally配合使用，这种方法相当于没有捕获异常，因此程序会直接崩掉\n\n   1. 应用场景：就是执行一段代码，不论是否发生异常，都必须执行某个业务逻辑\n\n#### 小结\n\n1. 如果没有出现异常，则执行try块中所有语句，不执行catch块中的语句，如果有finally，最后还要执行finally语句\n2. 如果出现异常，则try块异常发生后，剩下的语句不在执行，将执行catch块中的语句，如果有finally，最后还要执行finally里面的语句\n\n\n\n### throws异常处理\n\n#### 介绍：\n\n1）如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理异常，则此方法应显示的声明抛出异常，表明该方法将不对这些异常进行处理，而且由该方法的调用者负责处理\n\n2）在方法声明throws语句可以声明排除异常的列表，throws后面的异常类型可以是方法产生的异常类型，也可以是它的父类\n\n#### 注意事项\n\n1. 对于编译异常，程 序必须处理，比如try-catch或者throws\n2. 对于运行时异常，程序中如果没有处理，默认就是throws的方式处理\n3. 子类重写父类的方法是，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一直，要么为父类抛出的异常的类型和子类型\n4. 在throws过程中，如果有try-catch，就相当于处理异常，就可以不必throws\n5. ![image-20220412135104986](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412135104986.png)\n6. \n\n## 自定义异常  \n\n### 介绍：\n\n当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述错误信息。\n\n### 自定义异常的步骤\n\n1. 定义类：自定义异常类名（程序员自己写）继承Exceotion或RuntimeException\n2. 如果继承Ecxeption，属于编译异常\n3. 如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）\n\n```java\n//当我们接受Person对象年龄时，要求范围在18-120之间，否则抛出一个自定义异常（要求继承RuntimeException），并提示\npublic class CustomException {\n    public static void main(String[] args) {\n        int age =30;\n//        结果取反\n        if (!(age>=18&&age<=120)){\n//            通过构造器设置输出信息\n            throw new AgeException(\"年龄需要在18-120之间\");\n        }\n        System.out.println(\"你的年龄为\"+age);\n    }\n}\n//定义一个异常类继承RuntimeException\n//一般情况下，我们自定义异常都继承RuntimeException\n//也就是说大都是定义为运行时异常，好处是我们可以使用默认处理机制\n//即比较方便\nclass AgeException extends RuntimeException{\n//    定义一个构造器\n    public AgeException(String message) {\n        super(message);\n    }\n}\n```\n\n\n\n## throw和throws的对比\n\n|        | 意义                     | 位置       | 后面跟的东西 |\n| ------ | ------------------------ | ---------- | :----------: |\n| throws | 异常处理的一种方式       | 方法声明处 |   异常类型   |\n| throw  | 手动生成异常对象的关键字 | 方法体中   |   异常对象   |\n\nthrows\n\n```java\npublic void xxx() throws Exception{\n    //throws通常放在定义方法的末尾\n} \n```\n\nthrow\n\n```java\n//throw后面跟的是异常对象\nthrow new AgeException(\"年龄需要在18-120之间\");\n```\n\n\n\n# 常用类\n\n## 包装类\n\n### 包装类的分类   Wrapper\n\n1、针对八种基本数据类型相应类型的引用类型---包装类\n\n2、有了类的特点，就可以调用类中的方法\n\n| 基本数据类型 |  包装类   |\n| :----------: | :-------: |\n|   boolean    |  Boolean  |\n|     char     | Character |\n|     byte     |  `Byte`   |\n|    short     |  `Short`  |\n|     int      | `Integer` |\n|     long     |  `Long`   |\n|    float     |  `Float`  |\n|    double    |  `Doble`  |\n\n上述标出来的6个数据类型父类均为Number\n\n![image-20220412164154544](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412164154544.png)\n\n### 包装类和基本数据的转换\n\n#### 案例\n\n演示包装类和基本数据类型的相互转换，以int和integer演示\n\n1）jdk5前的手动装箱和拆箱方式，装箱：基本类型->包装类型,反之拆箱\n\n2）jdk5以后（包括jdk5）的自动装箱和拆箱方式\n\n3）自动装箱底层调用的是valueOf方法，比如integer.valueOf();\n\n4）其他类型同理\n\n```java\n//基本类型——————>包装类型[手动装箱]\nint i =10;\ninteger i1 = new Integer(i);\ninteger i2 = Integer.value(i);\n\n//包装类型————————>基本类型[手动拆箱]\nInteger j = new Integer(99);\nint j1 = j.intValue();\n```\n\n```java\n//jdk5.0之后的方式\nint m =10;\nInteger m2 =m;\nInteger n = new Integer(99);\nint n2 = n;\nSystem.out.println(\"n+100\");\nSystem.out.println(\"n*2\");\nif(n>10){\n\n}\n```\n\n### 包装类型和String类型的相互转换\n\n#### 案例\n\n以integer和String转为例\n\n```java\n//包装类型---->String类型\ninteger i =10;\n//方式1\nString s1 = i.toString();\n//方式2\nString s2 = String.valueOf(i);\n//方式3\nString s3 = i+\"\"; \nSystem.out.println(s3);\n\n//String --->包装类\n//方式1\nInteger j =new Integer(s1);\n//方式2\nInteger j2 = Integer.valueOf(s2);\n//\nInteger.parseInt(s3);\n```\n\n### Integer类和Character类常方法\n\n```java\nInteger.MIN_VALUE //返回最小值\nInteger.MAX_VALUE //返回最大值\n\nCharacter.isDigit('a');//判断是不是数字\nCharacter.isLetter('a');//判断是不是字母\nCharacter.isUpperCase('a');//判断是不是大写\nCharacter.inLowerCase('a');//判断是不是小写\n\nCharacter.isWhitespace('a')；//判断是不是空格\nCharacter.toUpperCase('a');//转成大写\nCharacter.toLowerCase('a');//转成小写\n\n```\n\n### Integer面试题\n\n1.看代码输出什么，为啥\n\n1. ![image-20220413164815801](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164815801.png)\n\n2. 因为integer的原码定义好了从-128-127之间不返回一个对象\n\n   ![image-20220413164729185](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164729185.png)\n\n   2.integer面试题总结\n\n   看下列代码输出什么结果\n\n   <span style=\"color:red;background:yellow \" >只要有基本数据类型会自动拆箱，比对的是数值。判断的是值是否相等</span>\n\n   如下的示例六和七，比对的是\n\n   ![image-20220413205739995](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413205739995.png)\n\n   \n\n   \n\n## String(重要)\n\n![image-20220413213320195](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413213320195.png)\n\nString实现了三个接口并继承了Object类\n\n* Serializable接口：说明String可以串行化。（可以在网络传输）\n* Comparable接口：说明String对象可以相互比较\n* CharSequence接口：字符序列\n\n<span style=\"color:blue;background:pink\">String类是final类，String类不能被其他类继承</span>\n\n<span style=\"color:blue;background:pink\">String 有属性，private final char value[];用于存放字符串内容（字符串的本质就是char数组）</span>\n\n<span style=\"color:red;background:pink\">(注意：value是一个final类型，不可修改（即：value不能指向新的地址，但是单个字符内容时可以变化的）)</span>\n\n\n\n\n\n### 理解\n\n1）String对象用于保存字符串，也就是一组字符序列\n\n2）字符串常量对象时用双引号括起来的字符序列。例如：\"你好\"，\"21.213\"，\"boy\"等等\n\n3）字符串的字符使用Unicode字符编码，一个字符（不区分字幕还是汉字）占两个字节\n\n4）String类较常用的构造方法（其他手册）\n\n* String s1 = new String();\n* String s2 = new String(String original);\n* String s3 = new String(char[] a);\n* String s4 = new String(char[] a,int startIndex, int count)\n\n### 创建方式\n\n#### 1）方式一：直接赋值String s = \"xxx\";\n\n创建流程：\n\n先从常量池查看是否有\"xxx\"数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址\n\n#### 2）方式二：调用构造器 String s = new String(\"xxx\")；\n\n流程：现在堆中创建空间，里面维护了value属性，指向常量池的xxx空间。如果常量池没有\"xxx\"，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址\n\n![image-20220414101904944](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414101904944.png)\n\n### String字符串的特性\n\n1）String是一个final类，代表不可变的字符序列\n\n2）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的 \n\n\n\n#### 面试题、\n\n1）String a = \"hello\"+\"abc\";创建了几个对象\n\n```java\n编译器会在后台会进行优化，判断创建的常量池对象，是否有引用指向\n优化等价于String a = \"helloabc\"；\n\n所以答案是创建了一个对象\n不是创建了三个\n```\n\n2）String a = \"hello\";\n\nString b = \"abc\";\n\nString c = a+b;\n\n总共创建了几个对象\n\n所以只创建了一个\n\n```java\n执行流程\n1. 先创建了一个StringBuilder sb = StringBuilder();\n2.执行sb.append(\"hello\");\n3.sb.append(\"abc\");\n4.String c = sb.toString();\n最后其实是c指向了堆中的对象（String）value[],堆中的对象指向了池中的“helloabc”\n```\n\n![image-20220414140922725](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414140922725.png)\n\n小结:底层是StringBuilder sb = new StringBuilder();sb.append(a);sb.append(b);sb是在堆中，并append是在原来的字符串的基础上追加的。\n\n重要规则：String c1 = \"sb\"+\"cd\";常量相加，看的是池。String c1 = a+b;变量相加，是在堆中\n\n### String类的常见方法\n\n#### 说明：\n\n​\tString类是保存字符串常量的。每次更新都需要重新开辟空间，效率低，因此java设计者还提供StringBuilder和StringBuffer来增强String的功能，并提高效率。\n\n#### Strng常见的方法\n\n![image-20220414145929644](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414145929644.png)\n\n* equals\t\t//区分大小写，判断是否相等\n\n* equalsIgnoreCase   //忽略大小写，判断内容是否相等\n\n* length  //获取字符的个数，字符窜长度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n\n* indexOf  //获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到返回-1\n\n* lastIndexOf   //获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，返回-1\n\n* substring //截取指定范围字符串\n\n* trim  //去前后空格\n\n* charAt //获取某索引处的字符，之一不能使用Str[index]这种方式\n\n* toUpperCase  //字符串转换成大写\n\n* toLowerCase  //字符串转换成小写\n\n* concat  //拼接字符串\n\n* replace  替换字符串中字符\n\n* split 分割字符串，罪域某些分割字符，我们需要转义\n\n  案例：\n\n  ```java\n  String poem =\"锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦\";\n  String[] split = poem.split(\",\");\n  //以，号为标准，分割上述整个字符串\n  //上述字符串被分割为4个部分用数组接收\n  \n  //在堆字符串进行分割时，如f\n  poem = \"E:\\\\aaa\\\\bbb\";\n  split  = poem.split(\"\\\\\\\\\");\n  ```\n\n  和 文件路径\n\n* compareTo //比较两个字符串的大小，如果前者大则返回正数，如果后者大则返回负数，\n\n  如果相等（\n\n  1.如果长度相同，并且字符串也相同返回0。\n\n  2.如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回if(c1 != c2）{\n\n  ​\t\treturn c1 - c2;\n\n  }\n\n  3.如果前面的部分都相同，就返回str1.len - str2.len）\n\n* toCharArray //字符串转成字符数组\n\n* format//格式化字符串，%s字符串，%c字符，%d 整型，%.2f 浮点型\n\n  ```java\n  //  %s%d%.2f%c成为占位符\n  //  这些占位符由后面的变量来替换\n  //  %s表示后面由字符串替换\n  //  %d表示整数替换\n  //  %.2f表示使用小数来替换，替换后，只会保留小数两位，并且会进行四舍五入的处理\n  //  %c是char类型替换\n      \n  String name =\"jack\";\n  int age = 10;\n  double score = 98.3 /3;\n  char gender ='男';\n  \n  //传统方法拼接\n  String info = \"名字是\"+name+\"年龄是\"+age+\"成绩是\"+score+\"性别：\"+gender\";\n  \n  \n  //使用format拼接\n  String info2 =String.format(\"姓名是%s年龄是%d成绩是%d性别时%c\",name,age,score,gender);\n  \n  //可以做成一个模板后面直接调用\n  String formatstr = \"姓名是%s年龄是%d成绩是%d性别时%c\";\n  \n  String info2 =String.format(formatstr,name,age,score,gender);\n  \n  System.out.println(\"info2 =\"+info2);\n  ```\n\n  \n\n## StringBuffer(重要)\n\n<span style=\"color:red;background:pink\">串行化（对象可以网络传输，可以保存到文件）</span>\n\n### 基本介绍\n\njava.lang.StringBuffer代表可变字符序列，可以对字符串内容进行增删\n\n很多方法与String相同，但StringBuffer是可变长度的\n\nStringBuffer是一个容器\n\n![image-20220415090614911](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415090614911.png)\n\n```java\nStringBuffer stringBuffer = new StringBuffer(\"hello\");\n//1.StringBuffer 的直接父类是 AbstractStringBuilder\n//2.StringBuffer 实现了Serializable，即StringBuffer的对象可以串行化\n//3.在父类中，AbstractStringBuilder 有属性 char[] value ，不是final\n\t该value 数组存放祖父穿内容，因数存放在堆中的\n//4.StringBuffer是一个final类， 不能被继承\n```\n\n### String 对比StringBuffer\n\n1）String保存的是字符串常量，里面的值不能更改，每次String类的更新实际是更改地址，效率较低//private final char value[]；\n\n2）StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用更新地址，效率较高//char[] value //这个放在堆\n\n\n\n### StringBuffer构造器\n\nStringBuffer()\n\n* 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符\n\n* ```java\n  //创建一个大小为16的char[]，用于存放字符串内容\n  StringBuffer stringBuffer = new StringBuffer();\n  ```\n\nStringBuffer(CharSequence seq)\n\n* public java.lang.StringBuffer(CharSequence seq)构造一个字符串缓冲区，它包含与指定的CharSequence 相同的字符\n\nStringBuffer(int capacity)//capacity[容量]\n\n* 构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对char[]大小进行指定\n\n* ```java\n  //通过构造器指定 char[]大小\n  StringBuffer stringBuffer = new StringBuffer(100);\n  ```\n\nStringBuffer(String str)\n\n* 构造一个字符串缓冲器，并将其内容初始化为指定的字符串内容\n\n* ```java\n  //通过给一个String 创建StringBuffer,char[] 大小就是str.length()+16\n  StringBuffer stringBuffer = new StringBuffer(\"hello\");\n  ```\n\n### String和StringBuffer\n\n#### String->StringBuffer\n\n```java\n//        String->StringBuffer\n//        方式一\n        String str =\"xxx\";\n//        注意：返回的是StringBuffer对象，对str本身是没有影响的\n        StringBuffer stringBuffer = new StringBuffer(str);\n\n\n//        方式二，使用append方法\n        StringBuffer stringBuffer1 = new StringBuffer();\n        stringBuffer1 = stringBuffer1.append(str);\n```\n\n#### StringBuffer->String\n\n```java\n\n//        StringBuffer->String\n        StringBuffer stringBuffer2 = new StringBuffer(\"xxxxxx\");\n//        方式一,使用StringBuffer提供的 toString方法;\n        String s = stringBuffer2.toString();\n\n//        方式二,使用构造器搞定\n        String s1 = new String(stringBuffer2);\n\n```\n\n\n\n### StirngBuffer类常见方法\n\n1. 增 append\n2. 删 delete(start,end)\n3. 改 replace(start,end,string)//将start---end间的内容替换掉，不含end\n4. 查 indexOf //查询字符串第1次出现的索引，如果找不回返回-1\n5. 插 insert\n6. 获取长度 length\n\n```java\n       StringBuffer stringBuffer = new StringBuffer(\"zhangsan\");\n\n        stringBuffer.append('x');\n        stringBuffer.append(\"张三\");\n        stringBuffer.append(\"wangwu\").append(true).append(10.2);\n        System.out.println(stringBuffer);\n\n//        删除\n        /*\n        * 删除索引为>=start && <end 处的字符\n        * 解读：删除11~14的字符[11,14)\n        * */\n        stringBuffer.delete(11,14);\n        System.out.println(stringBuffer);\n\n        //    改\n//        修改本质就是替换\n//        使用fff替换索引11-14的字符\n        stringBuffer.replace(11,14,\"fff\");\n        System.out.println(stringBuffer);\n\n//        查\n//        查找指定的子串在字符串出现的索引.如果找不到返回-1\n        int index = stringBuffer.indexOf(\"zhang\");\n        System.out.println(index);\n\n//        插入\n//        指定一个位置插入\n//        在索引为9的位置插入\"老王\"，原来索引为9的内容自动后移\n        stringBuffer.insert(9,\"老王\");\n        System.out.println(stringBuffer);\n\n//        获取长度\n        System.out.println(stringBuffer.length());\n    }\n\n```\n\n\n\n\n\n```java\n public static void main(String[] args) {\n        /**\n         * 输入商品名称和商品价格，要求打印效果示例，实用前面学习的方法完成\n         * 商品名  商品价格\n         * 手机123，456.56  //比如 价格价格1,456,786.5\n         * 要求：价格的小数点前面每三位用,号隔开，再输出\n        * */\n\n        String prices;\n        Scanner scanner = new Scanner(System.in);\n        String price = scanner.next();\n        StringBuffer stringBuffer = new StringBuffer(price);\n\n\n//        先完成最简单的实现21,312,412.32\n//        找到小数点的索引,然后再该位置的前三位插入,\n\n        for (int j = stringBuffer.lastIndexOf(\".\")-3; j >0 ; j-=3) {\n\n            stringBuffer = stringBuffer.insert(j, \",\");\n        }\n\n        System.out.println(stringBuffer);\n\n    }\n```\n\n\n\n\n\n## StringBuilder(重要)\n\n### 基本介绍\n\n1）一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder 不是线程安全)。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快（单线程的情况下，优先使用StringBuilder）\n\n2）在StringBuilder上主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据\n\n\n\n### StringBuilder常用方法\n\nStringBuilder和StringBuffer均代表可变字符序列，方法是一样的，所以使用和StringBuffer一样。\n\n1. StringBuilder是final类，不能被继承\n2. StringBuilder对象可以串行化\n3. 继承了AbstractStringBuilder属性 char[] value，内容存到value\n4. 实现了Serializable接口，序列化（所谓系列化既可以保存类型和数据本身）\n\n## String、StringBuffer、StringBuilder的比较☆\n\n1）StringBuilder和StringBuffer非常类似，均代表可变字符序列，而且方法也一样\n\n2）String：不可变字符序列，效率低，但是复用率高。\n\n3）StringBuffer：可变字符序列、效率较高（增删）、线程安全\n\n4）StringBuilder：可变字符序列、效率最高、线程不安全\n\n5）String使用注意事项：\n\n```java\nString s=\"a\"; //创建了一个字符串\ns+= \"b\";   //实际上原来的\"a\"字符串对象已经丢弃了，现在又产生了一个转字符串s+\"b\"（也就是\"ab\").如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=》\n//结论：如果我们对Stirng做大量修改，不要使用String\n```\n\n### 效率\n\nStringBuilder  > StringBuffer >String \n\n\n\n### 使用原则，结论\n\n1. 如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder\n2. 如果字符串存在大量的修改操作，并且在单线程的情况下使用StringBuilder\n3. 如果字符串存在大量的修改操作，并且在多线程的情况下使用StringBuffer\n4. 如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等\n\nStringBuffer和StringBuilder的方法使用一样\n\n## Math\n\n### 基本介绍\n\nMath类包含用于执行基本数学运算方法，如初等指数，对数，平方根和三角函数\n\n方法一览（均为静态方法）![image-20220415145338171](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415145338171.png)\n\n### Match常用的方法\n\n1. abs  绝对值\n\n2. pow  求幂\n\n3. ceil   向上取整  (返回>=该参数的最小整数)\n\n4. floor   向下取整  (返回<=该参数的最大整数)\n\n5. round   四舍五入\n\n6. sqrt  求开方\n\n7. random  求随机数\n\n   ```java\n   public static void main(String[] args) {\n           /*\n           random随机数\n           random默认返回 0<= x <1之间的一个随机小数\n           请写出a-b之间的一个随机整数，a,b均为整数比如a=2,b=7\n           即返回一个2 - 7 之间的随机数\n           * */\n           \n           /**\n           * random返回的是0<=x <1之间的一个随机小数\n            * Math.random()*(b-a)返回的就是0<= 数 <=b-a\n            * (1)(int)(a)<= x <(int)(a+Math.random() * (b-a +1))\n           * (2)集体使用解析\n            * (int)(a+Math.random() * (b-a +1))\n            *  = (int)(2+Math.random() * 6)\n            *  Math.random() * 6返回的就是0<= x <6小数\n            *  2+Math.random() * 6返回的就是2<= x <8小数\n            *  (int)(2+Math.random() * 6) = 2 <=x <=7\n           * */\n           \n   \n   \n   //      公式就是：(int)(a+Math.random() * (b-a +1))\n           for (int i = 0; i < 5; i++) {\n               System.out.println((int) (2 +Math.random()*(7-2+1)));\n           }\n       }\n   ```\n\n   \n\n8. max   求两个数的最大值\n\n9. min    求两个数的最小值\n\n\n\n\n\n## Date,Calender,LoaclDate.\n\n### Date[知道怎么查，怎么用即可]\n\n#### 第一代日期类\n\nDate：精确到毫秒，代表特定的瞬间\n\nSimpleDateFormat：格式和解析日期的类SimpleDateFormat 格式化和解析日期的具体类。它允许进行格式（日期->文本、解析（文本->日期）和规范化\n\n![image-20220420110144786](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420110144786.png)\n\n```java\n//获取当前时间\n//默认输出的格式是国外的格式\nDate d1 = new Date();、\n//因此需要对格式进行转换\nSimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 hh:mm:ss E\");\n//其他格式的字母意思，查看手册\nString foramt = d1.format(d1);\n\n//获取某个时间对应的毫秒数\nDate d2 = new Date(23123);\n\n//可以吧一个格式化的字符串转成对应的date\nString s = \"2000年7月五日 20:12:20 星期一\";\nDate pares = simpleDateFormat.parse(s);\n//接收的格式必须个定义的格式一样\n```\n\n### Calendar(日历)\n\n#### 第二代日期类\n\n主要就是Calendar类（日历）\n\n1）public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable<Calendar\n\n2)calendar类是一个抽象类，他为特定瞬间为一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等，日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。\n\n```java\n//创建日历对象，\nCalendar c =Calendar.getInstance();\nSystem.out.print(\"年\"+c.get(Calendar.YEAR))；\nSystem.out.print(\"月\"+c.get(Calendar.MONTH)+1)；\nSystem.out.print(\"日\"+c.get(Calendar.DAY_OF_MONTH))；\nSystem.out.print(\"小时\"+c.get(Calendar.HOUR))；\nSystem.out.print(\"分钟\"+c.get(Calendar.MINUTE))；\nSystem.out.print(\"秒\"+c.get(Calendar.SECOND))；\n//Calendar没有专门的格式化方法，所以程序员自己组合\nSystem.out.print(c.get(Calendar.SECOND)+\"年\"+(c.get(Calendar.MONTH)+1)+\"月\"+c.get(Calendar.DAY_OF_MONTH)+\"日\")；\n```\n\n### 第三代日期类\n\n前面两代的不足分析\n\n（jdk1.0中包含了一个java.Util.Date类，但是他的大多数方法已经存在JDK1.1引入Calendar类之后被弃用。Calendar也存在着很多问题\n\n1. 可变性：像日期和时间这样的类应该是不可变的。\n2. 偏移性：Date中年份是从1900开始的，而月份是从0开始的\n3. 格式化：格式化只对Date有用，Calendar则不行\n4. 此外，他们不是线程安全的，不能处理闰秒等（每隔两天多出1s）\n\n#### 第三代日期类\n\n1）LoaclDate（日期）、localTime（时间）、loacalDateTime（日期和时间内）\n\nJDK8\n\nLoaclDate：只包含日期，可以获取日期字段\n\nlocalTime：包含时间，可以获取时间字段\n\nloacalDateTime包含日期和时间，\n\n```java\nloacalDateTime ln = loacalDateTime.now();\nln.getYear();\nln.getMonth();\nln.getMonthValue();//输出数字版的月份\n```\n\n##### 2）DateTimeFormatter格式日期类\n\n类似于SimpleDateFormat\n\n```java\nDateTimeFormatter dtf = DateTimeFormatter.ofPattern(格式);//(yyyyMMdd....)\n\nString srt = dtf.format(日期对象);\n```\n\n#### Instant 时间戳\n\n类似于Date\n\n提供了一系列和Date类转换的方式\n\nInstant---->Date;\n\nDate date = Date.from(instant);\n\nDate --->Instant;\n\nInstant instant = date.toInstant();\n\n案例演示\n\n```java\nInstant now = Instant.now();\nSystem.out.print(now);\nDate date = Date.from(now);\nInstant instant = date.toInstant();\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## System\n\n### 常见方法\n\n1）exit 退出当前程序\n\n```\nSystem.exit(0);表示退出\n//0代表一个正常状态状态  。\n```\n\n2）Arraycopy：复制数组元素，比较合适底层调用，一般使用Arrays.copyOf完成数组复制。\n\n```java\nint[] src = {1,2,3};\nint[] dest = new int[3];\nSystem.arraycopy(src,0,dest,0,3)\n \tsrc:源数组\n    srcpos：从原数组的哪个索引位置开始开始拷贝\n    dest:目标数组，即吧原数组的数据拷贝到哪个数组\n    destpos：把原数组的数据拷贝到 目标数组的哪个索引\n    length:从原数组拷贝多少个数据到目标数组\n```\n\n3）currentTimeMillens：返回当前时间距离1970-1-1(1970年1月1日到现在) 的毫秒数\n\n4）gc：运行垃圾回收机制System.gc();\n\n## Arrays类\n\n### 介绍\n\nArrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）\n\n### 方法\n\n#### 1） toString返回数组的字符串形式，将数组拼接成字符串返回\n\n```java\nArrays.ToString(arr)\n```\n\n#### 2)sort排序（自然排序和定制排序）\t\n\n```java\nInteger arr[] = {1,-1,7,0,89};\n//可以直接使用该方法进行排序。不用再动手去敲方法\n//因为数组时引用类型，所以通过sort排序后，会影响到实参arr\nArrays.sort(arr);//正序排序\n//sort重载的，也可以通过传入一个接口Comparator实现定制排序\n\n1、调用定制排序时，传入两个参数\n    (1)排序数组的参数\n    (2)实现Comparator接口的匿名内部类。要求实现Compare方法\n\n    \n    \n//      这里体现了接口编程的方式\n//\n//        倒序排序\n        Arrays.sort(a, new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                Integer i1 = (Integer) o1;\n                Integer i2 = (Integer) o2;\n//                return大于0 就是正序排序，小于0就是倒序\n                return i2 -i1;\n            }\n        });\n        System.out.println(Arrays.toString(a));\n\n    }\n```\n\n```java\n       bubble(a,new Comparator() {\n            @Override\n            public int compare(Object o1, Object o2) {\n                Integer i1 = (Integer) o1;\n                Integer i2 = (Integer) o2;\n                return i1 -i2 ;\n            }\n        });\n\n        System.out.println(\"定制类\"+Arrays.toString(a));\n\n    }\n\n\n//    定制排序\n    public static void bubble(Integer[] arr,Comparator c){\n        int temp;\n        for (int i = 0; i < arr.length-1 ; i++) {\n            for (int j = 0; j <arr.length-1-i; j++) {\n                if (c.compare(arr[j],arr[j+1])>0){\n                    temp =arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n```\n\n\n\n#### 3）binarySearch 二分搜索\n\nbinarySearch 通过二分搜索法进行查找，要求必须排好序\n\n```java\n //如果这个数组是有序的，可以通过该方法查找知否有这个数\n int[] arr = {1,23,45,65,78};\n//如果不存在该元素就返回，return -(low +1)//意思就是返回负的他该出现的位置的下标+1\n int index = Arrays.binarySearch(arr,3);//返回-2\n```\n\n#### 4）copyOf数组元素的复制\n\n```java\n//表示从arr数组中拷贝arr.length个长度的元素到新的arr数组中\nInteger[] newArr = Arrays.copyOf(arr,arr.length);\nInteger[] newArr = Arrays.copyOf(arr,arr.length-1);就是拷贝原数组长度-1\nInteger[] newArr = Arrays.copyOf(arr,arr.length+1);\n//如果长度超出原数组的长度，则多出来的部分元素为null   \n```\n\n#### 5)fill数组元素的填充\n\n```java\nInteger[] num = new Integer[]{9,2,1};\n//使用99去填充num数组\n//可以理解成替换原来的元素\nArrays.fill(num,99);\n\n==========运行结果======\n    [99,99,99]\n```\n\n#### 6)equals 比较两个数组元素内容是否完全一致\n\n```java\nboolean equals  = Arrays.equals(arr,arr2);\n//如果两个数组元素一样，则返回true。不一样返回false\n```\n\n#### 7)asList 将一组值，转换成list\n\n```java\nList<Integer> asList = Arrays.asList(2,3,4,5,6,1);\nSystem.out.println(\"asList\"+asList);\n```\n\n\n\n\n\n## Integer和BigDecimal类\n\n### 应用场景\n\n1）BigInteger适合保存比较大的整型(整数)\n\n```java\n//当编程中需要处理很大的整数。long不够用可以使用BigInteger类\n//使用\nBigInteger bigInteger = new BigInteger(\"2222222222222222222222222222222222222222\");\n\n//运算\n//在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）\n    \nBigInteger bigInteger 2=bigInteger.add(10)；//加\n    //也可再创建一个BigInteger相加\n```\n\n\n\n2）BigDecimal适合保存精度高的浮点型(小数)\n\n```java\n//当我们需要保存一个精度很高的值时，double不够用\n//可以使用BigDecimal\nBigDecimal bigDecimal = new BigDecimal(\"22.22222222222222222222222222\");\n//运算\n//在对BigDecimal进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）\n//需要创建一个需要操作的BigDecimal，然后调用即可\n\nBigDecimal bigDecimal=bigDecimal.add(2.3);\n    //使用删除方法时，可能会出现除不尽的情况，会抛出异常\n//解决办法：在调用divede(删除)方法是，指定精度即可\nbigDecimal.divide(1.11,BigDecimal.ROUND_CEILING)\n//如果有无限循环小数，就会保留到分子的精度\n\n```\n\n# 集合\n\n## 集合框架体系\n\n### 集合体系图\n\n背下来\n\n1）单例集合（在集合里面放单个的对象）\n\n![image-20220420163040446](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163040446.png)\n\n![image-20220420163624872](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163624872.png)\n\n2）双列集合（存放键值对形式的）\n\n![image-20220420163100945](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163100945.png)\n\n![image-20220420163609594](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163609594.png)\n\n```java\n//存放单个数据的成为单例\nArrayList  arrayList = new ArrayList();\narrayList.add(\"zhangsan\");\narrayList.add(\"lisi\");\n\n//存放双列数据的成为双例集合\nHashMap hashMap = new HashMap();\nhashMap.put(\"no1\",\"zhangsan\");\n//key,value\nhashMap.put(\"no2\",\"李四\");\n```\n\n## Collection\n\nCollection接口\n\n#### Collection接口实现类的特点\n\n```java\nPublic interface Collection<E> extends Iterable<E>\n```\n\n1. Collection实现子类可以存放多个元素，每个元素可以是 Object\n2. 有些Collection的实现类，可以存放重复的元素，有些不可以\n3. 有些Collection的实现类，有些是有序的（List），有些不是有序（Set）\n4. Collection接口没有直接实现子类，是通过它的子接口Set和List来实现的\n\n#### Collection接口和常用方法\n\n![image-20220420165341922](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420165341922.png)\n\n常用方法\n\n```java\n1)add :添加单个元素\n2)remove:删除指定元素\n3)contains:查找元素是否存在\n4）size：获取元素个数\n5）isEempty：判断是否为空\n6）clear：清空\n7）addAll：添加多个元素\n8）containsAll：查找多个元素是否都存在\n9）removeAll：删除多个元素\n说明：以ArrayList实现类演示\n```\n\n```java\npublic static void main(String[] args) {\n        ArrayList list = new ArrayList();\n//        1.添加单个元素\n        list.add(\"zhangsan\");\n        list.add(\"hahah\");\n        list.add(\"lisi\");\n        list.add(123);//等价于list.add(new Integer(123);\n        System.out.println(\"数组增加\"+list);\n//      remove：删除指定元素\n        list.remove(0);//删除第一个元素,下标从0开始\n        list.remove(\"123\");//删除指定元素\n        System.out.println(\"数组删除\"+list);\n\n//       contains 查找元素是否存在\n        System.out.println(list.contains(\"zhangsan\"));//F\n//        size,显示元素的个数\n        System.out.println(list.size());\n//      isEmpty判断是否为空\n        System.out.println(list.isEmpty());\n//        clear清空\n        list.clear();//清空集合\n        System.out.println(\"list清空=\"+list);\n\n        ArrayList list1 = new ArrayList();\n//        addAll:添加多个元素\n        list1.add(\"xxx\");\n        list1.add(\"xxxxxx\");\n\n        list.addAll(list1);\n        System.out.println(\"addAll\"+list);\n//        containsAll:查找多个元素知否存在\n        System.out.println(list.containsAll(list1));\n//        removeAll：删除多个元素\n        list.removeAll(list1);\n        System.out.println(list);\n\n    }\n```\n\n#### 使用Iterator（迭代器）\n\nCollection接口遍历元素的方式1-使用Iterator（迭代器）\n\n##### 基本介绍\n\n1）Iterator对象成为迭代器，主要用于遍历Collection集合中的元素\n\n2）所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可返回一个迭代器\n\n3）Iterator的结构![image-20220420231917444](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420231917444.png)\n\n4）Iterator仅用于遍历集合，Iterator本身并不存放对象\n\n###### 迭代器的运行原\n\n![image-20220421160914060](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220421160914060.png)\n\nhasNext用于判断\n\nnext（）；下移，并返回指向的元素\n\n```java\npublic class Iteraor {\n    public static void main(String[] args) {\n        Collection list = new ArrayList();\n        list.add(new HomeWork(\"zhansgan\",12313));\n        list.add(new HomeWork(\"haha\",231));\n\n//        使用迭代器遍历\n        Iterator iterator = list.iterator();\n//        while循环  快捷方式输入 itit\n//        ctrl+j提示所有快捷键\n     while (iterator.hasNext()) {\n//            返回下一个元素，是Object类型\n            Object next =  iterator.next();\n            System.out.println(next);\n        }\n//      当退出while循环后，这是iterator迭代器，指向最后一个元素\n//        iterator.next()  ，此时再让往下移指针会报异常：NuSuchElementException\n//        如果希望再次遍历，需要我们重置迭代器\n        iterator = list.iterator();//相当于指向了第一个元素\n\n    }\n}\n\nclass HomeWork{\n    String name;\n    Integer phoneNum;\n\n    public HomeWork() {\n    }\n\n    public HomeWork(String name, Integer phoneNum) {\n        this.name = name;\n        this.phoneNum = phoneNum;\n    }\n\n    @Override\n    public String toString() {\n        return \"HomeWork{\" +\n                \"name='\" + name + '\\'' +\n                \", phoneNum=\" + phoneNum +\n                '}';\n    }\n}\n```\n\n#### for循环增强\n\nCollection接口遍历元素的方式2-\n\n增强for循环，可以代替iterator迭代器\n\n特点：增强for就是简化版的iterator，本质一样。只能用于<span style=\"color:red\">遍历集合或数组</span>\n\n###### 基本语法\n\n```java\nfor(元素类型 元素名 : 集合名或数组){\n\t访问元素\n}\n```\n\n案例\n\n```java\n for (Object homeWork:list) {\n            System.out.println(homeWork);\n        }\n\n//        增强也可以在数组中使用\n        int[] a = {1,2,3,45,6};\n        for (int i: a){\n            System.out.println(i);\n        }\n```\n\n1. 增强for底层是迭代器\n2. 可以理解成增强for是简化版的迭代器\n\n## List\n\n基本介绍：\n\nList接口是Collection接口的子接口\n\n1）list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\n\n2）list集合中的每个元素都有其对应的顺序索引，即支持索引\n\n3）list容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素\n\n4）JDK API中的List接口实现类有：ArrayList、LinkedList和Vector\n\n```java\npublic static void main(String[] args) {\n//        list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复\n        List list = new ArrayList();\n        list.add(\"jack\");\n        list.add(\"tom\");\n        list.add(\"zhangsan\");\n//        此时不会有冲突，相当于会认为有两个tom\n        list.add(\"tom\");\n//        此时输出的顺序就是存进去的顺序\n        System.out.println(\"list\"+list);\n\n//        2）list集合中的每个元素都有其对应的顺序索引，即支持索引\n//        索引从0开始\n        System.out.println(list.get(3));\n    }\n```\n\n##### List接口的常用方法\n\n1. void add（int index,Object ele）在index位置插入ele元素\n2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来\n3. Object get (int index)获取固定index位置的元素\n4. int indexOf(Object obj)  返回obj在几个中首次出现的位置\n5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置\n6. Object remove(int index) 移除指定index位置的元素，并返回此元素\n7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换\n8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合\n\n```java\npublic static void main(String[] args) {\n\n        List list = new ArrayList();\n        list.add(\"no1\");\n        list.add(\"no2\");\n//        1. void add（int index,Object ele）在index位置插入ele元素\n//        在index=1的位置插入一个对象\n        list.add(1,\"add(index,ele)\");\n        System.out.println(list);\n//        2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来\n        List list2 = new ArrayList();\n        list2.add(\"lno2\");\n        list2.add(\"lno3\");\n        list2.add(\"lno3\");\n//        在1的位置插入list2的集合\n        list.addAll(1,list2);\n        System.out.println(list);\n//        3. Object get (int index)获取固定index位置的元素\n//        4. int indexOf(Object obj)  返回obj在几个中首次出现的位置\n        System.out.println(list.indexOf(\"no1\"));\n//        5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置\n        System.out.println(list.lastIndexOf(\"lno3\"));\n//        6. Object remove(int index) 移除指定index位置的元素，并返回此元素\n        list.remove(1);\n        System.out.println( list);\n//        7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换\n//        将索引为1的改为尼诺\n        list.set(1,\"尼诺\");\n//        8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合\n        List result = list.subList(0, 2);//相当于选择了下标为0的和下标为2-1之间的元素\n        System.out.println(\"result\"+result);\n}\n```\n\n##### 注意事项\n\n1. permits all elements,including null , ArrayList 可以加入null，并且多个\n2. ArrayList 是由数组来实现数据存储的\n3. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）看源码，在多线程情况下，不建议使用ArrayList\n\n#### ArrayList\n\n#####  ArrayList底层机制和源码分析（重点）\n\n1）ArrayList中维护了一个Object类型的数组elementData\n\n​\t\ttransient Object[] elementData \n\n```\ntransient 表示瞬间，短暂的，表示该属性不会被序列化\n```\n\n\n\n2）当创建对象ArrayList时，如果使用的是无参构造器，则初始elementData容量为0\n\n3）当添加元素时，先判断是否需要扩容，则调用grow方法，否则直接添加元素到合适位置\n\n4）如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍\n\n5）如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity\n\n6）如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍\n\n\n\n#### Vector\n\n##### 介绍\n\nVevtor底层也是一个对象数组。protected Object[] elementData;\n\nVector是线程同步的，即线程安全，Vector类的操作方法带有synchronized\n\n在开发过程中，需要线程同步安全时，考虑使用Vector\n\n\n\n##### Vector 和ArrayList比较\n\n|           | 底层结构 | 版本   | 线程安全（同步）效率 | 扩容倍数                                                     |\n| --------- | -------- | ------ | -------------------- | ------------------------------------------------------------ |\n| ArrayList | 可变数组 | jdk1.2 | 不安全，效率高       | 如果有参构造1.5倍如果无参1.第一次是10，第二次按1.5扩         |\n| Vector    | 可变数组 | jdk1.0 | 安全，效率不高       | 如果是无参默认10，满后，就按两倍扩容。如果指定大小（创建）有参，则每次直接按2倍扩容 |\n\n#### LinkedList\n\n##### 说明\n\n1）LinkedList实现了双向链表和双端队列特点\n\n2）可以添加任意元素（元素可以重复），包括null\n\n3）线程不安全，没有实现同步\n\n##### LinkedList底层机制\n\n1. LinkedList底层维护了一个双向链表\n\n2. LinkedList中维护了两个属性first和last分别指向首节点和尾结点\n\n3. 每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表\n\n4. 所以LinkedList的元素的 添加和删除，不是通过该数组完成的，相对来说效率较高\n\n5. 模拟一个简单双向链表理解\n\n   ```java\n   public static void main(String[] args) {\n   //        模拟一个简单的双向链表\n           Node jack = new Node(\"jack\");\n           Node tom = new Node(\"tom\");\n           Node zhangshan = new Node(\"zhangshan\");\n   //        链接是三个结点，形成双向链表\n   //        jack->tom ->zhangsan\n           jack.next = tom;\n           tom.next =zhangshan;\n   //        zhangsan->tom->jack\n           zhangshan.pre = tom;\n           tom.pre = jack;\n   \n           Node first = jack;//让first引用指向jack，就是双向链表的头结点\n           Node last =zhangshan;//让last引用指向zhangshan，就是双向链表的尾结点\n   \n   \n   //        演示从头到尾进行遍历\n           while (true){\n               if (first == null){\n                   break;\n               }\n   //            输出first信息\n               System.out.println(first);\n               first = first.next;\n           }\n   \n   //        从未到头遍历\n           while (true){\n               if (last == null){\n                   break;\n               }\n               System.out.println(last);\n               last = last.pre;\n           }\n   \n       }\n   }\n   \n   //定义一个Node类，node对象 表示双向链表的一个结点\n   class Node{\n       public Object item;//真正存放数据\n       public Node next;//指向下一个结点\n       public Node pre;//指向前一个结点\n   \n       public Node(Object item) {\n           this.item = item;\n       }\n   \n       @Override\n       public String toString() {\n           return \"Node{\" +\n                   \"item=\" + item +\n                   '}';\n       }\n   }\n   ```\n\n   \n\n![image-20220429152321935](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429152321935.png)\n\n##### ArrayList 和LinkedList的比较\n\n|            | 底层结构 | 增删的效率         | 改查的效率 | 线程   |\n| ---------- | -------- | ------------------ | ---------- | ------ |\n| ArrayList  | 可变数组 | 较低；数组扩容     | 较高       | 不安全 |\n| LinkedList | 双向链表 | 较高，通过链表追加 | 较低       | 不安全 |\n\n何如选择\n\n1）如果我们改查的操作较多，选择ArrayList\n\n2）如果我们增删的操作多，选择LinkedList\n\n3）一般来说，在程序中80%-90%都是查询，因此大部分情况下会选择ArrayList\n\n4）在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说根据业务来进行合理选择\n\n## set\n\n介绍\n\n1）无序（添加和取出的顺序不一致），没有索引\n\n2）不允许重复元素，所以最多包含和一个null\n\n3）JDK API中Set接口的实现类有![image-20220429173926895](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429173926895.png)\n\n##### Set接口和常用方法\n\n和List接口一样，Set接口也是Collection的子接口，因此常用方法和Collection接口一样\n\n##### set接口遍历方式\n\n同Collection的遍历方式一样，因为Set接口是Collection接口的子接口\n\n* 使用迭代器\n* 增强for\n* 不能使用索引的方式获取\n\n##### 案例\n\n```java\npublic static void main(String[] args) {\n//        以set接口实现类HashSet来讲解Set接口的方法\n//        set接口的实现类的对象（set接口对象）\n//        重复添加的数据只会存进去一个，null值也是只能存放一个\n    //输出结果是无序的（存放的数据是无序的，即（添加的顺序和取出的顺序不一致））\n    //虽然取出的顺序和添加的顺序不一致，但取出的顺序是固定的，不会一直变化\n        Set set = new HashSet();\n        set.add(\"zhansgan\");\n        set.add(\"lisi\");\n        set.add(\"wa\");\n        set.add(\"zhansgan\");\n        set.add(null);\n        set.add(null);\n        System.out.println(set);\n    }\n\n//        遍历\n//        迭代器\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            Object next =  iterator.next();\n            System.out.println(next);\n        }\n//        增强for\n        for (Object o :set) {\n            System.out.println(o);\n        }\n----------------输出结果----------------------\n    [null, lisi, wa, zhansgan]\n```\n\n#### HashSet\n\n1)HashSet实现了Set接口\n\n2）HashSet实际上是HashMap，看源码\n\n![image-20220430145947382](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430145947382.png)\n\n3）可以存放null值，但是只能有一个null\n\n4）HashSet不保证元素时有序的，取决于hash之后，在确定索引的结果（即：不保证存放元素的顺序和取出的一致  ）\n\n5）不能有重复元素/对象。在前面Set接口使用已经标明\n\n```java\n//1.执行add方法后，会返回一个Boolean值\n//2.如果添加成功,返回true，否则返回false\n//3.可以通过remove指定删除哪个对象\n        HashSet set = new HashSet();\n        set.add(\"zhansgan\");\n        set.add(\"lisi\");\n        set.add(\"wa\");\n        set.add(\"zhansgan\");\n        set.add(null);\n        set.add(null);\n\n        set.remove(\"zhangsan\");\n\n        set.add(new HHHH(\"zzz\"));//添加成功\n        set.add(new HHHH(\"zzz\"));//添加成功\n    }\n}\nclass HHHH{\n    private String name;\n\n    public HHHH(String name) {\n        this.name = name;\n    }\n}\n```\n\n##### HashSet底层机制说明 \n\n1）HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树）\n\n\n\n1. HashSet底层是HashMap\n2. 添加一个元素时，先得到hash值 -会转成-索引值\n3. 找到储存数据表table，看这个索引位置是否已经存放的有元素\n4. 如果没有，直接加入\n5. 如果有调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后\n6. 在java8中，如果一条链表的元素个数到了TREEEIFY_THRESHOLD(默认是8)个，并且table的大小>=MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树）\n7. ![image-20220430160350549](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430160350549.png)\n\n源码分析\n\n```java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    //定义了一个辅助变量\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //table就是HashMap的一个属性，类型是Node[]\n     //if语句表示如果当前table是null，或者大小=0\n    //就是第一次扩容，到16个空间\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n   //（1）根据key，得到hash值去计算key应该存放到table表的哪个索引位置\n    //并且把这个位置的对象赋给p\n    //（2）判断p是否为null\n    //（2.1）如果为null，表示还没有存放元素，就创建了一个Node\n    //（2.1）就放在该位置 tab[i] = newNode(hash, key, value, null); \n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            Node<K,V> e; K k;\n          //如果当前索引位置对应的链表的第一个元素和准备谈价的key的hash值一样\n            //并且满足下面条件之一\n            //1.准备加入的key和p指向的Node结点和key是同一个对象 \n            //2.p指向的Node结点的key的equals（）和准备加入的key比较后相同\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            //如果上述条件不满足，再判断p是不是一个红黑树\n            //如果是一颗红黑树，就调用putTreeVal，来进行添加判断\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            \n            else {\n                //依次比较链表内的内容\n                //如果table对应索引的额位置，已经是一个链表，就是用for循环比较\n                //(1)依次和链表的每一个元素比较后都不相同，则加入到该链表的最后\n                  //然后立即判断该链表是否已经达到8个结点，就调用   treeifyBin()对当前这个链表进行树化（转成红黑树）\n                //注意，在转成红黑树时，要进行判断，判断条件{if(tab == null ||(n = tab.length)<MIN_TREEIEY_CAPACITY)\n                //resize();   //table数组是否小于64，结点是否到达8个并不为空      }\n                //如果上面条件成立，先table扩容\n                //如果上面条件不成立，才进行树化\n                //(2)依次和该链表的每一个元素比较过程中，如果有相同的情况，就直接break；\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        \n                        p.next = newNode(hash, key, value, null);\n                \n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n##### HashSet的扩容和转成红黑树机制\n\n1. HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（localFactor）是0.75 =12\n2. 如果table数组实用到了临界值12，就会扩容到16*2=32，新的临界值就是32 * 0.75 = 24,依次类推\n3. 在java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8),并且table的大小>=MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树），否则仍然采用数组扩容机制\n\n\n\n### LinkedHashSet\n\n**说明**\n\n1）LinkedHashSet是HashSet的子类\n\n2）LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表\n\n3）LinkedHashSet根据元素的hashCode值来决定元素的储存位置，同时使用链表维护元素的次序（图），这使得元素看起来是以插入顺序保存的![image-20220501174705977](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220501174705977.png)\n\n4）LinkedHashSet不允许添加重复元素 \n\n![image-20220502111826275](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220502111826275.png)\n\n可以理解成不同索引的数，构成双向链表\n\n1. 在LinkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）\n\n2. 每一个结点有pre和next属性，这样可以形成双向链表\n\n3. 在添加一个元素时，先求hash值，在求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加[原则和hashset一样])\n\n   ```java\n   tail.next = newElement //简单指定\n   new Element.pre = tail\n   tail = newElement;\n   ```\n\n4. 这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致\n\n\n#### TreeSet\n\n1. 当使用无参构造器创建treeset的时候仍然是无序的\n\n2. 需求：希望添加的元素按字符串大小来排序?\n\n   1. 使用TreeSet提供的一个构造器,可以传入一个比较器（匿名内部类）\n\n   2. ```java\n      public class TreeSetDemo {\n          public static void main(String[] args) {\n      //        TreeSet treeSet = new TreeSet();\n              TreeSet treeSet = new TreeSet(new Comparator() {\n                  @Override\n                  public int compare(Object o1, Object o2) {\n      //                调用String的compareTo方法比较字符串大小\n                      return ((String)o1).compareTo((String) o2);\n                  }\n              });\n              treeSet.add(\"d\");\n              treeSet.add(\"b\");\n              treeSet.add(\"a\");\n              treeSet.add(\"c\");\n      \n              System.out.println(treeSet);\n          }}\n      ```\n\n   3. \n\n\n\n## Map\n\nMap**结构**\n\n<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220503163901620.png\" alt=\"image-20220503163901620\" style=\"zoom:50%;\" />\n\nMap接口的特点（JDK8之后的）\n\n1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）\n\n2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&Node对象中\n\n3）Map中的key不允许重复，原因和HashSet一样，前面分析过\n\n4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）\n\n5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个\n\n6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）\n\n7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n\n```java\n Map map = new HashMap();\n//        1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）\n//        2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&Node对象中\n//        3）Map中的key不允许重复，原因和HashSet一样，前面分析过\n//        4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(\"no1\",\"lisi\");\n//        5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个\n        map.put(null,null);\n        map.put(null,null);\n        map.put(\"no3\",null);\n        map.put(\"no4\",null);\n        //        6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）\n        map.put(new Object(),\"zhangsan\");\n//        7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value\n//        通过get方法传入key，会返回对应的value\n        System.out.println(map.get(\"no2\"));\n        System.out.println(map);\n=============输出==================\n  lisi\n{no2=lisi, null=null, no1=lisi, no4=null, no3=null, java.lang.Object@1540e19d=zhangsan}\n\n\n```\n\n8）Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，有因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry（如图）\n\n![image-20220504165516988](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220504165516988.png)\n\n数据存放在HashMap中，将set和collection作为一组对象放在Entry里面（其中不存放数据只是存放HashMap的引用）\n\n1. 将HashMap中的key和value数据 存放到一个entrySet集合（该集合不存放数据，存放的都是引用）\n\n```java\n Map map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");//k-v\n        map.put(\"no1\",\"lisi\");//k-v\n//        1.k-v最后是HashMap$Node node = newNode(hash ,key,value,null);\n//        2.k-v为了方便程序员遍历，还会创建EntrySet集合，该集合存放的元素类型（Entry），\n//        而一个Entry对象就有k-v，EntrySet<Entry<k,v>>，即：transient Set<Map.Entry<k,v>> entrySet;\n\n//        3.在entrySet中，定义的类型是Map.Entry，但是实际上存放的是HashMap$Node类型\n//        因为HashMap$Node implement Map.Entry 因为实现了Map.Entry接口，那么这个类的对象实例可以赋给这个接口类型\n//        4.当吧HashMap$Node存放到entrySet后就方便我们的遍历，因为Map.Entry提供了两个重要的方法，getKey()和getValue方法\n        Set set = map.entrySet();\n        System.out.println(set.getClass());\n//        输出：class java.util.HashMap$EntrySet\n        for (Object o :set) {\n            System.out.println(o.getClass());\n//            输出：class java.util.HashMap$Node\n//            从HashMap$Node取出k-v\n//            先做一个向下转型\n            Map.Entry entry = (Map.Entry) o;\n            System.out.println(entry.getKey() +\"\"+ entry.getValue());\n        }\n```\n\n\n\n#### map接口和常用方法\n\n1）put：添加\n\n2）remove：根据键删除映射关系\n\n3）get：根据键获取值\n\n4）size：获取元素个数\n\n5）isEmpty：判断个数是否为0\n\n6）clear；清楚\n\n7）containsKey：查找键值否存在\n\n```java\nMap map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(null,\"lisi\");\n        map.put(\"no3\",\"lisi\");\n        map.put(\"no4\",\"2\");\n\n        map.remove(null);\n        Object lisi = map.get(\"no2\");\n        System.out.println(\"lisi==\"+lisi);\n\n        System.out.println(map.size());\n\n        map.isEmpty();\n        System.out.println(map);\n        map.clear();\n        System.out.println(map);\n\n        System.out.println(map.containsKey(\"no3\"));\n\n```\n\n\n\n#### Map遍历方法\n\n1）containsKey：查找键是否存在\n\n2）KeySet：获取所有的键\n\n3）entrySet：获取所有关系\n\n4）values：获取所有的值\n\n```java\n  Map map = new HashMap();\n        map.put(\"no1\",\"zhangsan\");\n        map.put(\"no2\",\"lisi\");\n        map.put(null,\"sss\");\n        map.put(\"no3\",\"lisdsdsi\");\n        map.put(\"no4\",\"2\");\n\n//        第一粗：先取出所有的key，通过key取出对应的value\n        Set set = map.keySet();\n//        增强for\n        for (Object o :set) {\n            System.out.println(map.get(o));\n        }\n        System.out.println(\"迭代器\");\n//        （2） 使用迭代器\n        Iterator iterator = set.iterator();\n        while (iterator.hasNext()) {\n            Object next =  iterator.next();\n            System.out.println(map.get(next));\n        }\n        System.out.println(\"=========第二中=========\");\n//      第二组：吧所有的values取出\n        Collection values = map.values();\n//        这里可以使用所有的collections使用的遍历方法\n        for (Object o :values) {\n            System.out.println(o);\n        }\n//        迭代器\n        System.out.println(\"迭代器\");\n        Iterator iterator1 = values.iterator();\n        while (iterator1.hasNext()) {\n            Object next =  iterator1.next();\n            System.out.println(next);\n        }\n\n        System.out.println(\"=========第三中=========\");\n//        通过entryset获取\n        Set set1 = map.entrySet();\n        for (Object entry :set1) {\n//            将entry转为map.entry\n            Map.Entry  entry1= (Map.Entry) entry;\n            System.out.println(entry1.getKey()+\" \"+entry1.getValue());\n        }\n        System.out.println(\"迭代器\");\n        Iterator iterator2 = set1.iterator();\n        while (iterator2.hasNext()) {\n            Object next =  iterator2.next();\n            Map.Entry m = (Map.Entry) next;\n            System.out.println(m.getKey()+\" itit \"+ m.getValue());\n        }\n```\n\n#### 小结\n\n1. Map接口的常用实现类：HashMap、Hashtable和Properties\n2. HashMap是Map接口使用频率最高的实现类\n3. HashMap是以key-value对的方式来存储数据（HashMap$Node类型）\n4. key不能重复，但值可以，允许使用null键和null值\n5. 如果添加相同的 key，则会覆盖原来的k-v，等同于修改，（key不会替换，val会替换）\n6. 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来储存的\n7. HashMap没有实现同步，因此线程不安全 的\n\n#### HashMap底层机制\n\n1）HashMap底层维护了Node类型的数组table，默认为null\n\n2）当创建对象时，将加载银子（loadfactor）初始化为0.75\n\n3）当添加key-value时，通过key的哈希值得到在table的索引，然后判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是连链表结构，做出相应处理。如果添加时发现容量不够则需扩容\n\n4）第一次添加，则需扩容table容量为16，临界值(threshold)为12\n\n5）以后再扩容，需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推\n\n6）在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小>=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化。\n\n#### HashTable\n\n**基本介绍**\n\n1）存放的元素时键值对：key-value\n\n2）hashTable的键和值都不能为null，否则会抛出空指针异常\n\n3）hashTable使用方法基本上和HashMap一样\n\n4）hashTable是线程安全的，HashMap是线程不安全的\n\n![image-20220506160740866](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220506160740866.png)\n\n#### Properties\n\n**基本介绍**\n\n1. properties类继承了Hashtable类并实现了Map接口，也是使用一种键值对(key-value)的形式来保存数据\n2. 它的使用特点和Hashtable类似\n3. properties还可用于从xxx.properties文件中，加载数据到properties类对象，并进行读取和修改\n4. 说明：工作后 xxx.properties文件常用作配置文件，io流部分(详细讲解)[www.cnblogs.com/xudong-bupt/p/3758136.html]\n\n## Collections\n\n### Collections工具类\n\n1）Collections是一个操作Set、List和Map等集合的工具类\n\n2）Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作\n\n### 排序操作（均为static方法）\n\n1. reverse（List）：反转List中元素的顺序\n\n2. shuffle（List）：对List集合元素进行随机排序\n\n3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序\n\n4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序\n\n5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换\n\n6. 案例：\n\n   ```java\n   public class Collectionsdemo {\n       public static void main(String[] args) {\n           ArrayList list = new ArrayList();\n           list.add(\"zhansgan\");\n           list.add(\"lisi\");\n           list.add(\"wngwu\");\n           list.add(\"laoliu\");\n           list.add(\"dasima\");\n           System.out.println(\"list=\"+list);\n   //        1. reverse（List）：反转List中元素的顺序\n           Collections.reverse(list);\n           System.out.println(\"reverse=\"+list);\n   //        2. shuffle（List）：对List集合元素进行随机排序\n           for (int i = 0; i < 5; i++) {\n               Collections.shuffle(list);\n               System.out.println(\"随机\"+list);\n           }\n   //        3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序\n           Collections.sort(list);\n           System.out.println(\"sort\"+list);\n   //        4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序\n           Collections.sort(list, new Comparator() {\n               @Override\n               public int compare(Object o1, Object o2) {\n                   return ((String)o1).length()-((String)o2).length();\n               }\n           });\n           System.out.println(\"字符串长度排序\"+list);\n   //        5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换\n   \n           Collections.swap(list,0,1);\n           System.out.println(\"位置交换\"+list);\n       }\n   }\n   ```\n\n\n\n### 查找、替换\n\n1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n\n2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素\n\n3. Object min（Collection)\n\n4. Object min (Collection，Comparator)\n\n5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数\n\n6. void copy（List dest，List src）：将src中的内容复制到dest中\n\n7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值\n\n8. ```java\n   public static void main(String[] args) {\n           ArrayList list = new ArrayList();\n           list.add(\"zhansgan\");\n           list.add(\"lisi\");\n           list.add(\"wngwu\");\n           list.add(\"laoliu\");\n           list.add(\"dasima\");\n           System.out.println(\"list=\"+list);\n   //        1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素\n           System.out.println(\"max num=\"+Collections.max(list));\n   //        2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素\n   //            获取最大长度的值\n           //        3. Object min（Collection)\n   //        4. Object min (Collection，Comparator)同理\n           Object max = Collections.max(list, new Comparator() {\n   \n               @Override\n               public int compare(Object o1, Object o2) {\n                   return ((String) o1).length() - ((String) o2).length();\n               }\n           });\n           System.out.println(\"字符串最大的值为=\"+max);\n   \n   \n   //        5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数\n   \n           System.out.println(\"lailiu=\"+ Collections.frequency(list,\"lailiu\"));\n   //        6. void copy（List dest，List src）：将src中的内容复制到dest中\n              ArrayList oldList =  new ArrayList();\n   //           为了完成一个拷贝，我们需要先给oldList赋值，大小和list一样,不然会报错\n           for (int i = 0; i < list.size(); i++) {\n               oldList.add(\"\");\n           }\n   //        拷贝\n           Collections.copy(oldList,list);\n           System.out.println(\"oldList=\"+oldList);\n   \n   //        7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值\n           Collections.replaceAll(list,\"laoliu\",\"老六\");\n           System.out.println(\"替换后=\"+list);\n       }\n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 总结\n\n在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择分析如下\n\n1）先判断储存类型（一组对象或一组键值对）\n\n2）一组对象[单列]：Collection接口\n\n* 允许重复：List\n  * 增删多：LinkedList（底层维护了一个双向链表）\n  * 改查多：ArrayList（底层维护了Object类型的可变数组）\n* 不允许重复：Set\n  * 无序：HashSet（底层是HashMap，维护了一个哈希表 即（数组+链表+红黑树））\n  * 排序：TreeSet\n  * 插入和取出顺序一直：LinkedHashSet，维护数组+双向链表\n\n3）一组键值对[双列]：Map\n\n* 键无序：HashMap（底层是：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树）\n* 键排序：TreeSet\n* 键插入和取出顺序一致：LinkedHashMap\n* 读取文件：Properties\n\n# 泛型\n\n## 泛型语法\n\n```java\npublic static void main(String[] args) {\n//        1.当我们ArrayList<Dog>表示放到ArrayList集合中的元素只能是Dog类型\n//        2.如果编译器发现添加的类型不满足，就会报错\n        ArrayList<Dog> dogs = new ArrayList<Dog>();\n        dogs.add(new Dog(\"laogou\",12));\n        dogs.add(new Dog(\"xiaogou\",1));\n    }\n//       方便遍历\n        for (Dog dog : dogs) {\n            System.out.println(dog);\n        }\n```\n\n好处：\n\n1. 编译时，检查添加元素的类型，提高了安全性\n2. 减少了类型转换的次数，提高效率\n3. 不再提示编译警告\n\n### 介绍\n\n理解：泛（广泛）型（类型）==> integer，String\n\n可以表示数据类型的数据类型![image-20220509171057972](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171057972.png)\n\n1）泛型又称参数化类型，时jdk5.0出现的新特性，解决数据类型的安全性问题\n\n2）在类声明或实例化时只要制定好需要的具体的类型即可\n\n3）java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮\n\n4）泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型\n\n![image-20220509171249826](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171249826.png)\n\n（此时E称为泛型，那么Dog->E（此时E为 ））\n\n```java\nCat<String> tianyuanmao = new Cat<>(\"tianyuanmao\");\n\nclass Cat<E> {\n    E e;//E表示 e的数据类型，改数据类型在定义Cat对象时指定的，即在编译期间，就确定是什么类型了\n\n    public Cat(E e) {//E也可在参数类型体现\n        this.e = e;\n    }\n    public E method(){//返回类型也可体现\n        return e;\n    }\n\n}\n```\n\n### 语法\n\n泛型的声明\n\n```java\ninterface 接口<T> {}\nclass类<K,V,...>{}(可以接收多个泛型等等)\n说明：\n    1.其中K,V,T不代表值，而是表示类型\n    2.任意字母都可以。常用T表示，是type的缩写\n```\n\n泛型的实例化\n\n```java\n要在类名后面指定类型参数的值（类型）。如\n//1\nList <String> strList = new ArrayList<String>();\n//2\nIterator <Customer> iterator = coustomers.iterator();\n\n```\n\n### 使用细节\n\n1. interface List<T>{},public class HashSet<E>{}....等等\n\n   1. 说明：T，E只能是引用类型\n   2. 不能是基本数据类型（八大基本数据类型,int,double 等等）\n\n2. 在指定泛型具体类型后，可以传入该类型或者其子类类型\n\n3. 泛型适用形式\n\n   1. ```java\n      List<integer> list1 =new ArrayList<Integer>{}\n      \n      List<Integer> list2 = new ArrayList<>();\n      ```\n\n4. 如果我们这样写List list3 = new ArrayList（）；默认给它的泛型是[<E> E就是Object 类型]\n\n   \n\n\n\n## 自定义泛型\n\n### 泛型类\n\n**基本语法**\n\n```java\nclass 类名<T,R....>{\n成员\n}\n```\n\n细节：\n\n1. 普通成员可以使用泛型（属性，方法）\n\n2. 使用泛型的数组，不能初始化\n\n3. 静态方法中不能使用类的泛型‘\n\n   1. 因为静态是和类相关的，在类加载时，对象还没创建\n   2. 所以，如果静态方法和静态属性使用泛型时 ，JVM就无法完成初始化\n\n4. 泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）\n\n5. 如果在创建对象时，没有指定类型，默认为object\n\n6. ```java\n   //1.demo后面有泛型，所以我们吧demo就称为自定义泛型类\n   //2.T,R,M泛型的标识符，一般是单个大写字母\n   //3.泛型标识符可以有多个\n   //4.普通成员可以使用泛型 （属性，方法）\n   //5.使用泛型的数组，不能初始化\n   \t//（因为数组在new的\n   \n   \n   class demo<T,R,M>{\n   String name;\n   T t;\n   R r;\n   M m;\n       T[] t1;//可以声明\n       \n       public demo11(String name, T t, R r, M m) {//构造器使用泛型\n           this.name = name;\n           this.t = t;\n           this.r = r;\n           this.m = m;\n       }\n       //方法使用泛型\n        public String getName() {\n           return name;\n       }\n   \n       public void setName(String name) {\n           this.name = name;\n       }\n   \n       public T getT() {\n           return t;\n       }\n   \n       public void setT(T t) {\n           this.t = t;\n       }\n   \n       public R getR() {\n           return r;\n       }\n   \n       public void setR(R r) {\n           this.r = r;\n       }\n   \n       public M getM() {\n           return m;\n       }\n   \n       public void setM(M m) {\n           this.m = m;\n       }\n   }\n   ```\n\n   \n\n\n\n\n\n### 泛型接口\n\n**基本语法**\n\n```java\ninterface  接口名 <T,R...>{\n\n}\n```\n\n细节：\n\n1. 接口中，静态成员也不能使用泛型\n\n2. 泛型接口的类型，在继承接口或者实现接口时确定\n\n3. 没有指定类型，默认为Object\n\n   \n\n### 泛型方法\n\n**基本语法**\n\n```java\n修饰符<T,R...>返回类型 方法名（番薯列表）{}\n```\n\n**注意细节**：\n\n1. 反省方法，可以定义在普通类中，也可以定义在泛型类中\n\n2. 当泛型方法被调用时，类型会确定\n\n3. public void eat（E e）{}，修饰符后没有<T,R..>eat方法不是泛型方法，而是使用了泛型\n\n4. ```java\n   //泛型方法，可以定义在普通类中，也可以定义在泛型类中\n   class Car{\n       public void run(){//普通方法\n   \n       }\n   //    1.T,R就是泛型标识符\n   //    2.提供给fly方法使用的\n       public <T,R> void  fly(T t, R r){//泛型方法\n   \n       }\n   \n   }\n   ```\n\n5. ```java\n   class Car2<T,R>{//泛型类\n       public <U,M> void  fly(U u, M m){//泛型方法\n       }\n       public void  fly2(T t){\n   //        1.该方法不是泛型方法\n   //        2.是fly2方法使用了类声明的泛型\n       }\n   ```\n\n6. ```java \n   Car car = new Car();\n           car.fly(\"baoma\",2000);\n           //在调用方法是，编译器会自动识别传入的参数的类型，就会确定型\n   ```\n\n7. 泛型方法可以使用类声明的泛型，也可使用自己声明的泛型\n\n## 泛型继承和通配符\n\n**介绍**\n\n1)泛型不具备继承性\n\n```java\nList<Object> list = new ArrayList<String>();\n//是错误的，因为泛型中没有继承性\n```\n\n2）<?>:支持任意泛型类型\n\n3）<? extend A>:支持A类以及 A类的子类，规定了泛型的上限\n\n![image-20220511142709072](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142709072.png)\n\n4）<? super A>:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限\n\n![image-20220511142730306](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142730306.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n  \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n# 知识点补充\n\n## JUnit\n\n1. 一个类有很多功能代码需要测试，为了测试，就需要写入main方法中\n2. 如果有很多个功能代码测试，就需要来回注销，切换很麻烦\n3. 如果可以直接运行一个方法，就会方便很多\n\n### 介绍：\n\n1. \n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n# 练习部分\n\n## 快速入门部分\n\n1. 开发一个hello.java文件，输出：老王 is studying java！\n\n   1. ```java\n      public class hello{\n      \tpublic static void main(String[] args) {\n      \tSystem.out.println(\"lao wang is studying java\");\n      \t\n      \t}\n      }\n      ```\n\n   2. 需注意的事项：记得吧类部分带上public class 带上，不要只写个方法\n\n## 制表符部分\n\n1. ![image-20220204140604059](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204140604059.png)\n\n   1. ```java\n      public class ChangeChar {\n          public static void main(String[] args) {\n              System.out.println(\"书名\\t作者\\t价格\\t销量\\n三国\\t罗贯中\\t120\\t1000\");\n          }\n      }\n      ```\n\n## 进制部分\n\n* 第一部分\n\n  ```\n  1. 0b110001100\n     =0*2^0 + 0*2^1 + 1*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 0*2^6 + 1*2^7 + 1*2^8\n     =0+0+4+8+0+0+0+128+256\n     =396\n  02456\n  =6*8^0 + 5*8^1 + 4*8^2 + 2*8^3\n  =6+40+256+1024\n  =1326\n  \n  0xA45\n  =5*16^0 + 4*16^1 + 10*16^2\n  =5 + 64 + 2560\n  =2629\n  ```\n\n## 位运算练习\n\n```\n2|3\n1. 2的原码：00000000 00000000 00000000 00000010\n2. 2的补码：00000000 00000000 00000000 00000010\n3. 3的原码：00000000 00000000 00000000 00000011\n4. 3的补码：00000000 00000000 00000000 00000011\n5.2|3：00000000 00000000 00000000 00000010（都为1结果为1否则为0）\n6. 转为原码：00000000 00000000 00000000 00000010\n7.结果为：2\n\n2^3\n1. 2的原码：00000000 00000000 00000000 00000010\n2. 2的补码：00000000 00000000 00000000 00000010\n3. 3的原码：00000000 00000000 00000000 00000011\n4. 3的补码：00000000 00000000 00000000 00000011\n5.2^3:00000000 00000000 00000000 00000001(两位一个为0，一个为1，结果为1，否则为0)\n6.转为原码：00000000 00000000 00000000 00000001\n7.结果为1\n```\n\n## switch练习\n\n1. ![image-20220225162131420](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162131420.png)\n\n   * ![image-20220225162214945](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162214945.png)\n\n2. 3,4,5为春季。6，7，8，为夏季，9,10,11位秋季。12,1,2为冬季\n\n   * ```java\n     Scanner scanner = new Scanner(System.in);\n             System.out.println(\"请输入月份\");\n             int month = scanner.nextInt();\n             if (month>0 && month<=12){\n                 switch (month){\n                     case 3:\n                     case 4:\n                     case 5:\n                         System.out.println(\"春季\");\n                         break;\n                     case 6:\n                     case 7:\n                     case 8:\n                         System.out.println(\"夏季\");\n                         break;\n                     case 9:\n                     case 10:\n                     case 11:\n                         System.out.println(\"秋季\");\n                         break;\n                     case 12:\n                     case 1:\n                     case 2:\n                         System.out.println(\"冬季\");\n                         break;\n                 }\n             }else {\n                 System.out.println(\"输入不合法\");\n             }\n     ```\n\n## 数组部分\n\n* 已知数组{10,12,45,90}。添加一个数使该数组依然是升序的\n\n```java\n//方法1：数组扩容➕冒泡排序\n\npackage basics.chapterArray;\n\nimport java.time.OffsetDateTime;\nimport java.util.Scanner;\nimport java.util.concurrent.ForkJoinPool;\n\npublic class exercisesArryHomeWork {\n    /*\n    * 已知数组{10,12,45,90}\n    * 添加一个数使该数组依然是升序的\n    * */\n    public static void main(String[] args) {\n        int[] arr = {10,12,45,90};\n        char key;\n        Scanner scanner = new Scanner(System.in);\n        int inputnum;\n        int tmp;\n\n        do {\n            int[] arr2 = new int[arr.length+1];\n            for (int i = 0; i <arr.length ; i++) {\n                arr2[i] = arr[i];\n            }\n            System.out.println(\"请输入添加一个数\");\n            inputnum = scanner.nextInt();\n            arr2[arr2.length-1] = inputnum;\n            arr = arr2;\n            for (int i = 0; i <arr.length ; i++) {\n                System.out.print(arr[i]+\"\\t\");\n            }\n\n\n            System.out.println(\"是否继续输入? y/n\");\n            key = scanner.next().charAt(0);\n            if (key == 'y'){\n                System.out.println(\"continue\");\n            }else if (key == 'n'){\n                System.out.println(\"end\");\n                break;\n            }else {\n                System.out.println(\"input error\");\n            }\n        }while (true);\n        System.out.println(\"============数组排序==============\");\n        for (int i = 0; i < arr.length-1; i++) {\n            for (int j = 0; j <arr.length ; j++) {\n                if (j>=arr.length-1){\n                    break;\n                }else if (arr[j]<=arr[j+1]){\n                    System.out.println(\"no change\");\n                }else if (arr[j]>=arr[j+1]){\n                    tmp = arr[j+1];\n                    arr[j+1] = arr[j];\n                    arr[j] = tmp;\n                }\n\n            }\n        }\n\n\n        System.out.println(\"=============输出==============\");\n        for (int i = 0; i <arr.length ; i++) {\n            System.out.print(arr[i]+\"\\t\");\n        }\n\n\n\n\n\n    }\n}\n```\n\n方法二：定位➕扩容\n\n ```\n //1. 先定义原数组 \n //2. 遍历数组，如果发现insertnum < arr[i] ,说明i就是要插入的位置\n //3. 如果index 保留 index =i\n //4. 如果遍历完后，没有发现inserNum<=arr[i] ，说明index = arr.length\n 即：添加到arr的最后\n ```\n\n```java\npackage basics.chapterArray;\n\npublic class exercisesArrayHomeWorkmethod2 {\n    public static void main(String[] args) {\n        int[] arr = {10,12,45,90};\n        int insertNum = 23;\n        int index = -1;\n//          数组定位\n//        1.遍历数组\n        for (int i = 0; i <arr.length ; i++) {\n//            2. 如果arr[i]的这个数大于insertNum则表示这个数的位置是要添加的数的位置\n            if (insertNum<=arr[i]){\n//                3. 用index接受这个位置信息\n                index = i;\n                break;\n            }\n        }\n//        4. 数组扩容添加\n        int[] arr2 = new int[arr.length+1];\n//        创建一个j，当插入前半部分时，j指向arr的数组的数不变。\n        for (int i = 0,j=0; i <arr2.length; i++) {\n//            如果i不等于上面得到的i的位置\n            if ( i != index){\n//                则将arr的数赋给对应的新数组\n                arr2[i] = arr[j];\n                j++;\n            }else {\n\n                arr2[i] = insertNum;\n            }\n        }\n        arr = arr2;\n\n        for (int i = 0; i <arr.length ; i++) {\n            System.out.print(arr[i]+\"\\t\");\n        }\n    }\n}\n\n```\n\n\n\n### 二维数组部分\n\n1. ```java\n   //            int[][] arr = {{4,6},{1,4,5,7},{-2} };\n   //          遍历数组,求和\n   ```\n\n   * ```java\n     public static void main(String[] args) {\n      \n            int sum = 0;\n            int[][] arr = {{4,6},{1,4,5,7},{-2}};\n            for (int i = 0; i < arr.length; i++) {\n                for (int j = 0; j <arr[i].length ; j++) {\n                    sum = sum+ arr[i][j];\n                }\n            }\n            System.out.println(sum);\n        }\n     ```\n\n     \n\n## 面向对象部分\n\n```java\npackage basics.method;\n\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class chapterMethod01 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"请输入一个整数\");\n        int num = scanner.nextInt();\n        AA aa = new AA();\n\n//        第一种写法\n//        boolean t = aa.odd(num);\n//        if (t==true){\n//            System.out.println(\"偶数\");\n//        }else {\n//            System.out.println(\"奇数\");\n//        }\n\n        /*\n        * 第二种写法，较为简洁 。后续较为常见\n        *\n        * */\n\n        if (aa.odd(1)){ //1 为true 2为false\n            System.out.println(\"偶数\");\n        }else {\n            System.out.println(\"奇数\");\n        }\n    }\n}\nclass AA{\n    public boolean odd(int a){\n\n//        if (a%2 ==0){\n//\n//            return true;\n//        }else {\n//\n//            return false;\n//        }\n    return a%2==0 ?  true : false;\n    }\n}\n```\n\n### 递归\n\n1、小球迷宫\n\n![image-20220311132440361](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220311132440361.png)\n\n1. 小球得到的路径和程序员设置的策略有关，即找到的上下左右的顺序相关\n2. 再得到小球路径时，可以先使用（下右上左），再改成（上右下左）\n\n```\n1. 先用二维数组创建迷宫 8行7列\nint[][] map =new int[8][7];\n2.先规定map数组，0表示可以走，1表示障碍物\n3. 将最上的一行，和最下面的一行。设置为1\nfor(int i=0;i<7;i++){\n\tmap[0][i]=1;\n\tmap[7][i]=1\n}\n```\n\n```java\npackage com.smms.demo.method;\n\npublic class homeworkForMaze {\n    public static void main(String[] args) {\n        //1. 先创建迷宫\n        int[][] map = new int[8][7];\n        //2. 定义数组\n        for (int i1 = 0; i1 <7 ; i1++) {\n            map[0][i1] = 1;\n            map[7][i1] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n        map[3][1]=1;\n        map[3][2]=1;\n\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[i].length; j++) {\n                System.out.print(map[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n        System.out.println(\"==================分割线======================\");\n\n        System.out.println(\"use findWay\");\n        T t = new T();\n        t.findWay(map,1,1);\n        System.out.println(\"out print\");\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j <map[i].length ; j++) {\n                System.out.print(map[i][j]+\"\\t\");\n\n            }\n            System.out.println();\n\n        }\n    }\n}\n\n// 使用递归回溯的思想解决该题\n/*\n1.创建findway方法\n2.如果找到，就返回true ，否则返回false\n3.map就是二维数组，即表示迷宫\n4.i,j 就是老鼠的位置，初始化的位置为(1,1)\n5.因为我们使用的是递归找路，所以先规定map内值的含义\n0 表示可以走，1表示障碍物，2表示可以走，3表示走过\n6.当map[6][5] =2就说明找到了通路，就可以结束，否则就继续\n\n7.定下找路的策略，下->右->上->左\n*\n* */\nclass T{\n    public boolean findWay(int[][] map,int i,int j){\n        if (map[6][5]==2){\n            return true;\n        }else {\n            if (map[i][j]==0){\n//                标记可以走通为2\n//                假定可以走通\n                map[i][j]=2;\n    //  找路策略,下->右->上->左\n                if (findWay(map,i+1,j)){\n                    return true;\n                }else if (findWay(map,i,j+1)){\n                    return true;\n                }else if (findWay(map,i-1,j)){\n                    return true;\n                }else if (findWay(map,i,j-1)){\n                    return true;\n                }else {\n                    map[i][j] =3;\n                    return false;\n                }\n            }\n            return false;\n        }\n    }\n}\n\n```\n\n2、汉诺塔\n\n```java\nclass A{\n    public void move(int num,char a,char b, char c){\n        if (num==1){\n            System.out.println(a+\"->\"+c);\n        }else {\n//            如果有多个盘num，可以直接看成2个，最下边的和最上边的\n//            1.先移动上面的盘子到b，借助c\n            move(num-1,a,c,b);\n//            2.吧下面的盘子移动到c\n            System.out.println(a+\"->\"+c);\n//            3.再把b塔的所有盘，移动到c，借助a\n            move(num-1,b,a,c);\n        }\n    }\n}\n```\n\n## 集合\n\n1）分析HashSet和TreeSet分别如何实现去重\n\n1. HashSet的去重机制：hahsCode()+equals()，底层先通过存入对象，进行运算得到一个hash值，通过hash得到对应的索引，如果发现table索引所在的位置没有数据直接存放，如果有数据，就进行equals比较（equals可由程序员重写），如果比较厚，不相同，就加入，相同就不加入\n2. TreeSet去重机制：如果传入了一个Comparator匿名对象，就使用实现Comparator去重，如果方法返回为0，就认为相同的元素/数据，就不添加。如果没有传入Comparator对象，则以添加的对象实现的Compareable的compareTo去重\n\n# 注意事项\n\n1. 一个java文件中只能有一个public类，其他类的个数不限\n   1. public的类名必须和文件名相同\n   2. 编译后每一个类都对应一个class文件\n2. equals方法两种书写方式\n   1. name.equals(\"xxx\");\n   2. \"xxx\".eqauls(name); //推荐这一种，可以避免空指针\n\n\n\n## \n\n\n\n# 面试题\n\n**相关可能问道的面试题目**\n\n1、 JDK、JRE、JVM的关系\n\n1. JDK = JRE + java开发工具\n2. JRE =  JVM ＋ 核心类库\n\n2、 环境变量path的作用\n\n1. 使dos界面能够使用java和javac 等命令\n2. 先配置JAVA_HOME 指向JDK主目录\n3. path根据JAVA_HOME 寻找其子目录\n\n3、 为什么计算机都是以补码的方式运行的\n\n* 因为它将正数负数都统一起来了\n\n4、 new一个对象时，此时内存里发生了什么？\n\n1. 先在方法区创建Person类\n2. 在堆中开辟一个空间，内部存放形参\n   1. 先初始化默认值，0和null，然后再将值赋进去\n   2. 当执行到构造器的时候，值才会赋进去\n   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值\n3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)\n4. ![image-20220314215432778](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png)\n\n\n\n","slug":"java基础笔记","published":1,"updated":"2022-10-27T05:23:58.499Z","layout":"post","photos":[],"link":"","_id":"cl9qmes7o000diorf8olee8va","content":"<p>[TOC]</p>\n<h1 id=\"java基础\"><a href=\"#java基础\" class=\"headerlink\" title=\"java基础\"></a>java基础</h1><p>这是快速复习java基础的笔记</p>\n<h2 id=\"重要编程思想\"><a href=\"#重要编程思想\" class=\"headerlink\" title=\"重要编程思想\"></a>重要编程思想</h2><p><strong>化繁为简</strong>：现将复杂的功能转变成简单的需求。</p>\n<p>先死后活：有限考虑固定的值，再考虑变量。</p>\n<h1 id=\"java概述\"><a href=\"#java概述\" class=\"headerlink\" title=\"java概述\"></a>java概述</h1><p>知识点：</p>\n<h2 id=\"快速练习\"><a href=\"#快速练习\" class=\"headerlink\" title=\"快速练习\"></a><a href=\"##%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E9%83%A8%E5%88%86\">快速练习</a></h2><ol>\n<li><p>使用黑窗口编译.java文件时，注意要把需要编译的java文件编码设置与cmd黑窗口编码相同</p>\n</li>\n<li><pre><code class=\"java\">javac hello.java //编译指令\t\t\t\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. ```java</span><br><span class=\"line\">   java hello //运行指令\t</span><br><span class=\"line\">   //注意不要带文件后缀，否则报错</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>java执行流程分析</p>\n<ol>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204113338135.png\" alt=\"image-20220204113338135\"></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"制表符\"><a href=\"#制表符\" class=\"headerlink\" title=\"制表符\"></a><a href=\"##%E5%88%B6%E8%A1%A8%E7%AC%A6%E9%83%A8%E5%88%86\">制表符</a></h2><ol>\n<li><pre><code>\\t 一个制表位，实现对其功能\n\\n 换行符，\n\\\\ 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠\n\\\t\\将&quot;&quot;：号输出显示出来，在前面添加\\&quot; \\&quot; 也可转义其他符号例如&#39;\n// \\r 表示一个回车 例如：System.out.println(&quot;韩顺平教育\\r北京&quot;);\n        // 执行步骤：\n        // \t1. 先输出韩顺平教育\n        //  2. 执行回车后，相当于光标来到了最开头\n        //  3. 再输出北京\n        //  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了\n        可以加个\\n换行防止覆盖\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. ````java</span><br><span class=\"line\">   class ChangeChar&#123;</span><br><span class=\"line\">   \tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">   \t\t// \\t 一个制表位，实现对其功能</span><br><span class=\"line\">   \t\tSystem.out.println(&quot;beijing\\tshanghai\\tguangzhou&quot;);</span><br><span class=\"line\">   \t\t// \\n换行</span><br><span class=\"line\">   \t\tSystem.out.println(&quot;jack\\nlisa\\nnino&quot;);</span><br><span class=\"line\">   \t\t// \\\\ 输出一个斜杠\\ </span><br><span class=\"line\">   \t\t// 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠</span><br><span class=\"line\">   \t\tSystem.out.println(&quot;c\\\\a\\\\v\\\\b.exe&quot;);</span><br><span class=\"line\">   \t\t// \\将&quot;&quot;：号输出显示出来，在前面添加\\&quot; \\&quot;</span><br><span class=\"line\">   \t\tSystem.out.println(&quot;老王说：\\&quot;hello\\&quot;&quot;);</span><br><span class=\"line\">   \t\t// \\r 表示一个回车 System.out.println(&quot;韩顺平教育\\r北京&quot;);</span><br><span class=\"line\">   \t\t// 执行步骤：</span><br><span class=\"line\">   \t\t// \t1. 先输出韩顺平教育</span><br><span class=\"line\">   \t\t//  2. 执行回车后，相当于光标来到了最开头</span><br><span class=\"line\">   \t\t//  3. 再输出北京</span><br><span class=\"line\">   \t\t//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了</span><br><span class=\"line\">   \t\tSystem.out.println(&quot;韩顺平教育\\r\\n北京&quot;);</span><br><span class=\"line\">   </span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   ````</span><br><span class=\"line\"></span><br><span class=\"line\"># 注释</span><br><span class=\"line\"></span><br><span class=\"line\">1. 文档注释</span><br><span class=\"line\"></span><br><span class=\"line\">   1. ```</span><br><span class=\"line\">      javadoc -d 路径文件 -xx -yy xxx.java</span><br><span class=\"line\">      生成文档命令</span><br><span class=\"line\">      xx yy 分别代码javadoc标签命令 例如-auther -version等</span><br></pre></td></tr></table></figure>\n\n2. ```java\n   @author 标明开发该类模块的作者 \n   @version 标明该类模块的版本 \n   @see 参考转向，也就是相关主题 \n   @param 对方法中某参数的说明 \n   @return 对方法返回值的说明 \n   @exception 对方法可能抛出的异常进行说明 \n   \n   @author 作者名 \n   @version 版本号\n   其中，@author 可以多次使用，以指明多个作者，生成的文档中每个作者之间使用逗号 (,) 隔开。@version 也可以使用多次，只有第一次有效 \n   \n   使用 @param、@return 和 @exception 说明方法 \n   这三个标记都是只用于方法的。@param 描述方法的参数，@return 描述方法的返回值，@exception 描述方法可能抛出的异常。它们的句法如下： \n   @param 参数名 参数说明 \n   @return 返回值说明 \n   @exception 异常类名 说明 \n   \n   <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 变量</span><br><span class=\"line\"></span><br><span class=\"line\">## 数据类型</span><br><span class=\"line\"></span><br><span class=\"line\">### 变量</span><br><span class=\"line\"></span><br><span class=\"line\">1. 变量本质就是一个变化的值。</span><br><span class=\"line\"></span><br><span class=\"line\">2. 变量有三个基本要素</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 类型</span><br><span class=\"line\">   2. 名称</span><br><span class=\"line\">   3. 值</span><br><span class=\"line\"></span><br><span class=\"line\">3. ```java</span><br><span class=\"line\">   public static void main(String[] args)&#123;</span><br><span class=\"line\">   \tint a=1;</span><br><span class=\"line\">   \t//定义了一个变量，类型为int，名称为a，值为1</span><br><span class=\"line\">   \ta=89;</span><br><span class=\"line\">       //把89这个值赋给了a变量</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>注意事项：</p>\n<ul>\n<li>变量表示内存中的一个储存区域，[不同的变量，类型不同，占用的空间大小不同，比如：int 4个字节，double 8个字节]</li>\n<li>该区域有自己的名称[变量名]和类型[数据类型]</li>\n<li>变量必须先声明，后使用，有着自身的顺序</li>\n<li>该区域的数据可以在同一类型范围内不断变化</li>\n<li>变量在同一个作用域内不能重名</li>\n<li>变量&#x3D;变量名+值+数据类型，变量三要素</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><ol>\n<li>+号的使用<ul>\n<li>当左右两边为数值类型的时候，做加法运算</li>\n<li>当左右两边有一方为字符串类型时，做拼接运算</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>java数据类型</p>\n<ol>\n<li><p>基本数据类型</p>\n<ul>\n<li>数值型<ul>\n<li>整数类型，存放整数（byte[1],short[2],int[4],long[8])</li>\n<li>浮点（小数）类型（float[4]，double[8])</li>\n</ul>\n</li>\n<li>字符型（char[2]），存放单个字符’a’</li>\n<li>布尔型（Boolean[1]），存放true，false</li>\n</ul>\n</li>\n<li><p>引用数据类型（面向对象部分讲解）</p>\n<ul>\n<li>类（class）</li>\n<li>接口（interface）</li>\n<li>数组（[]）</li>\n</ul>\n</li>\n<li><p>八大基本数据类型</p>\n<p>【byte，short，int，long，float，double】，char，Boolean</p>\n</li>\n<li><p>浮点数据类型</p>\n<ol>\n<li><p>默认情况下输入的字符默认是double类型的</p>\n</li>\n<li><p>如果想改成float类型需要在数值后面加上f或F</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>float a &#x3D; 1.1 &#x2F;&#x2F;错误<br>float a &#x3D; 1.1F &#x2F;&#x2F;正确<br>double b &#x3D; 1.1\t&#x2F;&#x2F;正确<br>double b &#x3D; 1.1F\t&#x2F;&#x2F;正确</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 平时使用默认的double类型就行，因为更为精确</span><br><span class=\"line\"></span><br><span class=\"line\">5. 浮点数使用陷阱</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```java</span><br><span class=\"line\">     //例如</span><br><span class=\"line\">     //2.7和8.1/3 比较</span><br><span class=\"line\">     double a = 2.7 ;</span><br><span class=\"line\">     double b = 8.1/3 ;//理论上数学得数是2.7</span><br><span class=\"line\">     System.out.println(a);//2.7</span><br><span class=\"line\">     System.out.println(b);//得数是一个接近2.7的一个小数，而不是2.7</span><br><span class=\"line\">     //因为计算机计算机制的问题，不是数学的问题。</span><br><span class=\"line\">     所以在做相等判断时需要小新</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;类似问题的解决方法<br>double a &#x3D; 2.7 ;<br>double b &#x3D; 8.1&#x2F;3 ;&#x2F;&#x2F;理论上数学得数是2.7<br>System.out.println(a);&#x2F;&#x2F;2.7<br>System.out.println(b);</p>\n<p>if(a &#x3D;&#x3D; b){<br>&#x2F;&#x2F;这样的写法会出问题<br>System.out.println(“相等”);<br>}</p>\n<p>&#x2F;&#x2F;可以使用计算其差值<br>if(Math.abs(a-b)&lt;0.001){<br>System.out.println(“差值非常小，到我规定的精度内，认为相等”);<br>   &#x2F;&#x2F; Math方法调用java API</p>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. 字符类型</span><br><span class=\"line\"></span><br><span class=\"line\">   1. char的本质就是一个整数，默认用的是Unicode编码</span><br><span class=\"line\">   2. 字符常量用单引号引出来，</span><br><span class=\"line\">      * 例：char a = &#x27;a&#x27;;</span><br><span class=\"line\">      * char b = &#x27;/n&#x27;;</span><br><span class=\"line\">   3. 不能输入双引号，否则会认成字符串，会报错。</span><br><span class=\"line\">   4. char类型时可以运算的。</span><br><span class=\"line\"></span><br><span class=\"line\">   字符型的本质</span><br><span class=\"line\"></span><br><span class=\"line\">   * 字符型储存到计算机中，需要将对应的码值（整数）找出来</span><br><span class=\"line\"></span><br><span class=\"line\">   * 字符和码值的对应关系是通过字符编码表决定的（是规定死的）</span><br><span class=\"line\"></span><br><span class=\"line\">   * ![image-20220205221255475](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220205221255475.png)</span><br><span class=\"line\"></span><br><span class=\"line\">6. 布尔类型</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 只占一个字节，只允许true和false</span><br><span class=\"line\">   2. 用于判断操作</span><br><span class=\"line\">   3. 不可用0或非0 来代替true或false，c语言可以</span><br><span class=\"line\"></span><br><span class=\"line\">## 数据类型转换</span><br><span class=\"line\"></span><br><span class=\"line\">### 1、自动类型转换</span><br><span class=\"line\"></span><br><span class=\"line\">* 精度小的类型自动转换为精度大的数据类型，反之就会报错。</span><br><span class=\"line\"></span><br><span class=\"line\">* char &lt; int &lt; long &lt; float &lt; double </span><br><span class=\"line\"></span><br><span class=\"line\">* byte &lt; short &lt; int &lt; long &lt; float &lt; double</span><br><span class=\"line\"></span><br><span class=\"line\">* ```java</span><br><span class=\"line\">  //例：</span><br><span class=\"line\">  int num = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>注意事项</p>\n<ol>\n<li>多重类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的哪种数据类型，然后再进行计算</li>\n</ol>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">float</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> n1+<span class=\"number\">1.1</span>;</span><br><span class=\"line\"><span class=\"comment\">//这是错误的，因为转换成最大单位，1.1默认的类型是double类型的，如果是n1＋1.1f 的话就是正确的</span></span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> n1+<span class=\"number\">1.1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这是正确的；</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>（ byte , short ) 和 char之间不会相互转换，当把一个具体的数赋给byte时。</p>\n<ol>\n<li>先判断该数是否在byte范围内，如果是就可以</li>\n</ol>\n</li>\n<li><p>byte，short，char 三者可以进行计算，在计算时都会先转换成int类型</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>byte b1 &#x3D; 1;<br>byte a1 &#x3D; 1;<br>short b2 &#x3D; 1;<br>short s2 &#x3D; b1 + b2&#x2F;&#x2F;错误<br>&#x2F;&#x2F;因为计算时会转换成int类型，int不能再赋给比它小的类型short<br>int s2 &#x3D; b1 + b2 &#x2F;&#x2F;正确<br>byte s3 &#x3D; a1 + b1&#x2F;&#x2F;错误<br>&#x2F;&#x2F;byte，short，char,只要涉及计算都会转换为int类型，所以错误<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   4. 布尔类型 ( boolean ) 不参与类型转换</span><br><span class=\"line\"></span><br><span class=\"line\">   5. 自动提升原则：表达式结果的类型自动提升为 操作数中最大的类型。</span><br><span class=\"line\"></span><br><span class=\"line\">### 2、强制类型转换</span><br><span class=\"line\"></span><br><span class=\"line\">1. 简介</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 大的数据类型转换为小的数据类型</span><br><span class=\"line\">   2. 使用时要加上强制转换字符（类型）</span><br><span class=\"line\">   3. 可能会出现精度降低和溢出问题</span><br><span class=\"line\"></span><br><span class=\"line\">2. 注意细节</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 将数据从大到小转换，需要强制转换</span><br><span class=\"line\"></span><br><span class=\"line\">   2. ```java</span><br><span class=\"line\">      //强制转换符只对最近的操作数有效，也就是只对下边的10数字有效，转换后再进行计算又会转换成double类型。</span><br><span class=\"line\">      int x = (int)10*3.5+6*1.5;//提示编译错误，类型是double -&gt;</span><br><span class=\"line\">      </span><br><span class=\"line\">      int x = (int)(10*3.5+6*1.5);//用小括号括起来即可完美解决上述问题</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p>3、基本数据类型和String类型的转换</p>\n<ol>\n<li><p>介绍</p>\n<ol>\n<li>在程序开发中，我们经常需要吧基本数据类型转换成String类型，或String转基本数据类型</li>\n</ol>\n</li>\n<li><p>方式</p>\n<ul>\n<li><p>基本转String</p>\n<ul>\n<li><p>基本数据类型的值+” “ </p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;例<br>int n1 &#x3D; 123;<br>float f &#x3D; 2.3f;<br>double b &#x3D; 4.5;<br>String str1 &#x3D; n1 +” “;<br>String str2 &#x3D; f +””;<br>String str3 &#x3D; b +””;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* String 转基本</span><br><span class=\"line\"></span><br><span class=\"line\">  * 调用基本类型的包装类方法parseXXX 方法即可</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```java</span><br><span class=\"line\">    String s5= &quot;123&quot;;</span><br><span class=\"line\">    integer.parseInt(s5);</span><br><span class=\"line\">    Double.parseDouble(s5);</span><br><span class=\"line\">    Float.parseFloat(s5);</span><br><span class=\"line\">    //怎么吧字符串转成字符char，含义是指吧字符串的第一个字符得到</span><br><span class=\"line\">    system.out.println(s5.charAt(0));//获取字符串的第一个字符</span><br><span class=\"line\">    //所以这个输出的值为1</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注意事项</p>\n<ol>\n<li>string转换基本类型时，要确保string类型能够转成有效数据，可以吧’123’转换成一个整数，但不能吧”hello”转换成一个整数</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"运算符-1\"><a href=\"#运算符-1\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><h2 id=\"运算符-2\"><a href=\"#运算符-2\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h3><ol>\n<li>是一种特殊符号，表示数据的运算、赋值和比较等</li>\n<li>种类<ul>\n<li>算数运算符</li>\n<li>赋值运算符</li>\n<li>关系运算符(比较运算符)</li>\n<li>逻辑运算符</li>\n<li>位运算符 [ 需要二进制基础 ]</li>\n<li>三元运算符</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-算数运算符\"><a href=\"#2-算数运算符\" class=\"headerlink\" title=\"2.算数运算符\"></a>2.算数运算符</h3><ol>\n<li>对数值类型的变量进行运算的</li>\n<li>预览：<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220211161920431.png\" alt=\"image-20220211161920431\"></li>\n<li>注意事项<ul>\n<li>取模</li>\n<li><span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">再%的本质，看一个公式 a % b &#x3D; a-a &#x2F; b * b</span></li>\n</ul>\n</li>\n<li>面试题<ol>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213151013682.png\" alt=\"image-20220213151013682\"><ol>\n<li>答案为 1<ul>\n<li>运行步骤为</li>\n<li>(1)先把 i 的值赋给一个临时变量tmp</li>\n<li>(2)再进行计算i++，结果为i&#x3D;2</li>\n<li>(3)tmp的值重新赋给i，此时i &#x3D;1</li>\n</ul>\n</li>\n<li>答案为2<ul>\n<li>运行步骤为</li>\n<li>(1)再进行计算i++，结果为i&#x3D;2</li>\n<li>(2)再将2移到临时变量tmp</li>\n<li>(3)tmp赋给 i</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-关系运算符（比较运算符）\"><a href=\"#3-关系运算符（比较运算符）\" class=\"headerlink\" title=\"3.关系运算符（比较运算符）\"></a>3.关系运算符（比较运算符）</h3><ol>\n<li>介绍<ul>\n<li>关系运算符的结果都是boolean型，</li>\n<li>通常用在if条件语句结构条件中</li>\n<li>关系运算符组成的表达式成为关系表达式</li>\n</ul>\n</li>\n<li>预览图</li>\n</ol>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213162614379.png\" alt=\"image-20220213162614379\"></p>\n<h3 id=\"4-逻辑运算符\"><a href=\"#4-逻辑运算符\" class=\"headerlink\" title=\"4.逻辑运算符\"></a>4.逻辑运算符</h3><p>预览：</p>\n<ol>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170452994.png\" alt=\"image-20220213170452994\"></p>\n</li>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170753311.png\" alt=\"image-20220213170753311\"></p>\n</li>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170926798.png\" alt=\"image-20220213170926798\"></p>\n</li>\n<li><p>&#96;&#96;&#96;<br>&amp;&amp;（短路与）\t只有两个条件都为true ，才为true\t&#x2F;&#x2F;如果第一个条件为false，则后面的条件不执行，直接输出flase，效率高</p>\n<p>&amp;\t（逻辑与）\t只有两个条件都为true ，才为true\t&#x2F;&#x2F;两个条件都执行，效率低</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. ![image-20220214140501385](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220214140501385.png)</span><br><span class=\"line\"></span><br><span class=\"line\">6. ```java</span><br><span class=\"line\">   取反</span><br><span class=\"line\">   真变假，假变真</span><br><span class=\"line\">   //a^b :叫逻辑异或，当a和b不同时，结果为true，否侧为false</span><br><span class=\"line\">   例：</span><br><span class=\"line\">   \tboolean b = (10&gt;1) ^ (3&lt;5);</span><br><span class=\"line\">   \tSystem.out.println(&quot;b=&quot;+b);//f</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"5-赋值运算符（-x3D-）、\"><a href=\"#5-赋值运算符（-x3D-）、\" class=\"headerlink\" title=\"5.赋值运算符（&#x3D;）、\"></a>5.赋值运算符（&#x3D;）、</h3><p>分类：</p>\n<ul>\n<li><p>基本赋值运算符 &#x3D; \tint a &#x3D; 10；</p>\n</li>\n<li><p>复合赋值运算符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+=，-=，*=，/=，%=等等，</span><br><span class=\"line\">例：a += b;[等价 a=a+b;]</span><br><span class=\"line\">\ta -=b;[等价 a = a-b;]</span><br><span class=\"line\">一般情况加复合赋值运算符，前边都有基本赋值运算符</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>复合运算符会进行类型转换</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">byte</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span><span class=\"number\">3</span>;</span><br><span class=\"line\">a += <span class=\"number\">2</span>; <span class=\"comment\">//此时计算结果为int类型</span></span><br><span class=\"line\"><span class=\"comment\">//不会报错，因为会自动进行类型转换</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不能直接写成</span></span><br><span class=\"line\">a=a+<span class=\"number\">2</span>; <span class=\"comment\">//会报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 像a++，++a这种会都进行自动的类型转换</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"6-三元运算符\"><a href=\"#6-三元运算符\" class=\"headerlink\" title=\"6.三元运算符\"></a>6.三元运算符</h3><ul>\n<li><p>语法：条件表达式？ 表达式1: 表达式2；</p>\n</li>\n<li><p>运算规则：</p>\n<ol>\n<li><p>如果条件表达式为true，运算后的结果是表达式1；</p>\n</li>\n<li><p>如果条件表达式为false，运算后的结果是表达式2；</p>\n<p>口诀：【一灯大师：一真大师（如果为真，返回1）】</p>\n</li>\n<li><p>例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span> ;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">99</span> ;</span><br><span class=\"line\"><span class=\"comment\">// 1.如果 结果为false</span></span><br><span class=\"line\"><span class=\"comment\">// 2.返回b--，先返回b，再进行b-1。依旧按照之前的a++,++a的计算形式</span></span><br><span class=\"line\"><span class=\"comment\">// 3.结果为99</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> a &gt; b ? a++; b--;</span><br><span class=\"line\"><span class=\"comment\">//如果a&gt;b 为真，返回a++，如果为false返回b--;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本质就是if，else语句</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"7-运算符优先级\"><a href=\"#7-运算符优先级\" class=\"headerlink\" title=\"7.运算符优先级\"></a>7.运算符优先级</h3><ul>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220215150928654.png\" alt=\"image-20220215150928654\"></li>\n<li>小结：优先级排名<ol>\n<li>() ，{}等优先级最高</li>\n<li>单目运算&#x3D;&#x3D;a ，–a等；</li>\n<li>算术运算符+-</li>\n<li>位移运算符</li>\n<li>比较运算符</li>\n<li>逻辑运算符</li>\n<li>三元运算符</li>\n<li>赋值运算符</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><p><strong>标识符的规则和规范</strong></p>\n<ol>\n<li>java中对各种变量、方法和类的命名使用的字符成为标识符。</li>\n</ol>\n<ul>\n<li>&#96;&#96;&#96;java<br>int num &#x3D;1;<br>&#x2F;&#x2F; num就是标识符<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 标识符的命名规则必须遵守</span><br><span class=\"line\">   * 标识符由26个字母的大小写，0-9，_或$符组成。</span><br><span class=\"line\">   * 不可以用数字开头</span><br><span class=\"line\">   * 不可以使用关键字和保留至，但能包含关键字和保留字</span><br><span class=\"line\">   * 标识符不能包含空格</span><br><span class=\"line\">3. 标识符命名规范</span><br><span class=\"line\">   * 包名：多单词组成时，所有字母都小写。例：aaa.bbb.ccc</span><br><span class=\"line\">   * 类名、接口名：多单词组成是，所有单词首字母大写，驼峰命名法</span><br><span class=\"line\">   * 变量名、方法名：多单词组成时，第一个单词首字母小写，后面单词的首字母大写。例：aaBbCc</span><br><span class=\"line\">   * 常量名：所有字母都大写。多单词时用下划线隔开。例：A_B_C</span><br><span class=\"line\"></span><br><span class=\"line\">##   键盘输入语句</span><br><span class=\"line\"></span><br><span class=\"line\">### 1.介绍</span><br><span class=\"line\"></span><br><span class=\"line\">在编程过程中需要接受用户的输入数据，可以使用键盘输入语句来获取。input.java，需要一个扫描器（对象），就是Scanner</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.步骤</span><br><span class=\"line\"></span><br><span class=\"line\">1）导入该类所在的包，java.utill.*</span><br><span class=\"line\"></span><br><span class=\"line\">2）创建该类对象（声明变量）</span><br><span class=\"line\"></span><br><span class=\"line\">3）调用里面的功能</span><br><span class=\"line\"></span><br><span class=\"line\">### 3.案例</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">public class KeyboardInput &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">//        创建Scanner对象</span><br><span class=\"line\">        Scanner scanner = new Scanner(System.in);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;请输入文本1&quot;);</span><br><span class=\"line\">//        z字符串类型</span><br><span class=\"line\">        scanner.next();</span><br><span class=\"line\">        System.out.println(&quot;请输入age&quot;);</span><br><span class=\"line\">//        nextint 代表接收一个int类型的输入</span><br><span class=\"line\">        scanner.nextInt();</span><br><span class=\"line\">//        接收double类型的</span><br><span class=\"line\">        scanner.nextDouble();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"进制\"><a href=\"#进制\" class=\"headerlink\" title=\"进制\"></a>进制</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>对于整数，有四种表达方式</p>\n<ul>\n<li><p>二进制（Bin&#x2F;B）：0,1，满2进1，以0b或0B开头</p>\n</li>\n<li><p>八进制（OCT&#x2F;O）：0-7，满8进1。以数字0开头表示</p>\n</li>\n<li><p>十进制（DEC&#x2F;D）：0-9，满10进1</p>\n</li>\n<li><p>十六进制（HEX&#x2F;H）：0-9及A(10)-F(15)，满16进1.以0x或0X开头表示。此处的A-F不区分大小写</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>int n1 &#x3D; 0b1010;<br>int n2 &#x3D; 01010;<br>int n3 &#x3D; 1010;<br>int n4 &#x3D; 0x10101;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">### 进制转换（基本功）*</span><br><span class=\"line\"></span><br><span class=\"line\">第一组</span><br><span class=\"line\"></span><br><span class=\"line\">1. 二进制转十进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     例</span><br><span class=\"line\">     0b 1011  =1*2^0+1*2^1+0*2^2+1*2^</span><br><span class=\"line\">     = 1+2+0+8</span><br><span class=\"line\">     =11</span><br><span class=\"line\">     </span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li><p>八进制转十进制</p>\n<ul>\n<li><p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和。</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>例：0234转成十进制<br>0 234<br>&#x3D;4<em>8^0 + 3</em>8^1 + 2*8^2<br>&#x3D;4+24+128<br>&#x3D;156</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 十六进制转十进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     例：0x 23A转成十六进制</span><br><span class=\"line\">     =10*16^0 + 3*16^1 + 2*16^2</span><br><span class=\"line\">     =10 + 48 + 512</span><br><span class=\"line\">     =570</span><br><span class=\"line\">     A(10),B(11),C(12),D(13),E(14),F(15)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p><a href=\"###%E8%BF%9B%E5%88%B6%E9%83%A8%E5%88%86\">第一部分练习</a></p>\n<p>第二组</p>\n<ol>\n<li><p>十进制转二进制</p>\n<ul>\n<li><p>规则：将该数不断除2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>将34转换成二进制<br>34%2\t余0<br>17%2  余1<br>8%2\t\t余0<br>4%2\t\t余0<br>2%2\t\t余0<br>1%2\t\t余1<br>反着读<br>结果：0b100010 &#x2F;&#x2F;前缀0b的意思为二进制<br>正确答案为：0b00100010<br>因为一个字节二进制的是八位，34的出的结果是六位所以前面需要多加两个0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 十进制转八进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * 规则：将该数不断除8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的八进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     例：将131转为八进制</span><br><span class=\"line\">     131%8\t\t余3</span><br><span class=\"line\">     16%8\t\t余0</span><br><span class=\"line\">     2%8\t\t\t2</span><br><span class=\"line\">     结果为0203前面的0代表的意思是八进制</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>十进制转十六进制</p>\n<ul>\n<li><p>规则：将该数不断除16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的十六进制</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>例：237<br>答案为 ED</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   * ![image-20220216221217568](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220216221217568.png)</span><br><span class=\"line\"></span><br><span class=\"line\">第三组</span><br><span class=\"line\"></span><br><span class=\"line\">1. 二进制转八进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * 规则：从低位开始，将二进制数的每三位一组，转成对应的八进制数即可</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     例：0b 11010101 每三个转成十进制再拼起来</span><br><span class=\"line\">     =325</span><br><span class=\"line\">     11100101</span><br><span class=\"line\">     =345</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>二进制转十六进制</p>\n<ul>\n<li><p>从低位开始，将二进制数的每四位一组，转成对应的十六进制即可</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>11010101<br>&#x3D;0xD5<br>1110010110<br>&#x3D;0x396\t每四个转成十进制再拼起来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">第四组</span><br><span class=\"line\"></span><br><span class=\"line\">1. 八进制转二进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * 规则：将八进制数每一位，转成对应的3位的二进制数</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     237  每位以十进制转二进制转成对应的3位二进制数再连起来</span><br><span class=\"line\">     2（010）3（011）7（111）</span><br><span class=\"line\">     =010011111</span><br><span class=\"line\">     </span><br><span class=\"line\">     1230</span><br><span class=\"line\">     =1(001)2(010)3(011)0(000)</span><br><span class=\"line\">     =001010011000</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>十六进制转二进制</p>\n<ul>\n<li><p>规则：将八进制数每一位，转成对应的4位的二进制数</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>23B<br>&#x3D;2(0010)3(0011)B(1011)<br>&#x3D;001000111011<br>AB29<br>&#x3D;A(1010)B(1011)2(0010)9(1001)<br>&#x3D;1010101100101001</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">源码，反码，补码（重点）</span><br><span class=\"line\"></span><br><span class=\"line\">对于有符号的数而言（八个规则）：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 二进制的最高位是符号位：0表示正数，1表示负数（口诀：0 - &gt;0   1-&gt; -）</span><br><span class=\"line\">2. 正数的原码，反码，补码都一样（三码合一）</span><br><span class=\"line\">3. 负数的反码 = 它的原码符号位不变，其他位取反（0-&gt;1,1-&gt;0）0变1,1变0.</span><br><span class=\"line\">4. 负数的补码 = 它的反码+1，负数的反码 = 负数的补码-1</span><br><span class=\"line\">5. 0的反码，补码都是0</span><br><span class=\"line\">6. java没有无符号的数，换而言之，java中的数都是有符号的</span><br><span class=\"line\">7. 计算机运算的时候，都是以 &lt;span style=&quot;color:white;background:red;font-size:文字大小;font-family:字体;&quot;&gt;补码的方式来运算的&lt;/span&gt;</span><br><span class=\"line\">8. &lt;span style=&quot;color:white;background:red;font-size:文字大小;font-family:字体;&quot;&gt;当我们看运算结果的时候，要看它的原码（！！！）&lt;/span&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 位运算</span><br><span class=\"line\"></span><br><span class=\"line\">* java中有七个位运算符（&amp;，|，^，~，&gt;&gt;，&lt;&lt;和&gt;&gt;&gt;）</span><br><span class=\"line\"></span><br><span class=\"line\">* 分别是：</span><br><span class=\"line\"></span><br><span class=\"line\">  * &amp;：按位与</span><br><span class=\"line\"></span><br><span class=\"line\">    * 规则：两位全为1，结果为1，否则为0</span><br><span class=\"line\"></span><br><span class=\"line\">    * ```</span><br><span class=\"line\">      例：</span><br><span class=\"line\">         10011010</span><br><span class=\"line\">        &amp;11011101</span><br><span class=\"line\">      -------------</span><br><span class=\"line\">        =10011000// 两个都1结果才为1</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>|：按位或</p>\n<ul>\n<li><p>规则：两位有一个为1，结果为1，否则为0</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>10011010</p>\n<h2 id=\"amp-11011101\"><a href=\"#amp-11011101\" class=\"headerlink\" title=\"  &amp;11011101\"></a>  &amp;11011101</h2><p>  &#x3D;11011111&#x2F;&#x2F; 两个有一个1结果才为1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ^：按位异或</span><br><span class=\"line\"></span><br><span class=\"line\">  * 规则：两位一个为0，一个为1，结果为1，否则为0</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    10011010</span><br><span class=\"line\">    &amp;11011101</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<pre><code>=01000111// 两位一个为0，一个为1，结果为1，否则为0\n</code></pre>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>~：按位取反</p>\n<ul>\n<li>规则：0为1,1为0</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//位移运算</span><br><span class=\"line\">int a = 1&gt;&gt;2; // 1 向右位移2位</span><br><span class=\"line\">int b = -1&gt;&gt;2;</span><br><span class=\"line\">int c = 1&lt;&lt;2; //左移 2位</span><br><span class=\"line\">int d = -1&lt;&lt;2;</span><br><span class=\"line\">int e = 3&gt;&gt;&gt;2;//无符号右移</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"##%E4%BD%8D%E8%BF%90%E7%AE%97%E7%BB%83%E4%B9%A0\">练习部分</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2&amp;3计算机计算流程（计算机是按照补码进行计算的）</span><br><span class=\"line\">因为一个字节是八位，一个int类型有4个字节</span><br><span class=\"line\">1.先得到2的补码 ===&gt;* 源码00000000 00000000 00000000 00000010 //得到原码</span><br><span class=\"line\">* 转成补码（正数的三码都一样）</span><br><span class=\"line\">00000000 00000000 00000000 00000010</span><br><span class=\"line\">2. 得到3的补码 ====&gt;先获得原码00000000 00000000 00000000 00000011</span><br><span class=\"line\">得到3的补码</span><br><span class=\"line\">00000000 00000000 00000000 00000011</span><br><span class=\"line\"></span><br><span class=\"line\">3.计算2&amp;3</span><br><span class=\"line\">补码结果为：00000000 00000000 00000000 00000010</span><br><span class=\"line\">原码也为：00000000 00000000 00000000 00000010</span><br><span class=\"line\">最终结果为：2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~-2计算过程</span><br><span class=\"line\">1. 得到-2的原码10000000 00000000 00000000 00000010</span><br><span class=\"line\">2. 算出-2的反码11111111 11111111 11111111 11111101（原符号位保持不变，其他取反）</span><br><span class=\"line\">3. 算出-2的补码11111111 11111111 11111111 11111110</span><br><span class=\"line\">4.再进行~-2操作00000000 00000000 00000000 00000001//运算后的补码</span><br><span class=\"line\">5.转为原码00000000 00000000 00000000 00000001</span><br><span class=\"line\">6.结果为1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~2的计算过程</span><br><span class=\"line\">1.得到2的原码00000000 00000000 00000000 00000010</span><br><span class=\"line\">2.获取补码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">3.计算~2:11111111 11111111 11111111 11111101</span><br><span class=\"line\">3.转为反码（）负数的反码=补码-1</span><br><span class=\"line\">11111111 11111111 11111111 11111100</span><br><span class=\"line\">4.转为原码：10000000 00000000 00000000 00000011</span><br><span class=\"line\">5.结果为-3</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>运算符&gt;&gt;，&lt;&lt;和&gt;&gt;&gt;运算规则</p>\n<ul>\n<li><p>算数右移&gt;&gt;；低位溢出，符号位不变，并用符号位补溢出的高位</p>\n<ul>\n<li><p>&#96;&#96;&#96;<br>int a &#x3D; 1&gt;&gt;2;<br>1:00000000 00000000 00000000 00000001<br>1 &gt;&gt;2 &#x2F;&#x2F;相当于把最后边的01去掉用符号位补上<br>结果：00000000 00000000 00000000 00000000<br>最后结果为0</p>\n<p>简便的方法<br>1&gt;&gt;2 &#x3D; 1&#x2F;2&#x2F;2&#x3D; 0<br>15&gt;&gt;2 &#x3D; 15&#x2F;2&#x2F;2&#x3D;3  &#x2F;&#x2F;取整</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 算数左移&lt;&lt;; 符号位不变，低位补0</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    int a =1&lt;&lt;2;</span><br><span class=\"line\">    1:00000000 00000000 00000000 00000001</span><br><span class=\"line\">    1&lt;&lt;2</span><br><span class=\"line\">    00000000 00000000 00000000 00000100</span><br><span class=\"line\">    结果为4</span><br><span class=\"line\">    </span><br><span class=\"line\">    简便的方法</span><br><span class=\"line\">    1&lt;&lt;2 =1*2*2 = 4</span><br><span class=\"line\">    4&lt;&lt;3 = 4*2*2*2 = 32</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>3.&gt;&gt;&gt;逻辑右移，也叫无符号右移，运算规则是：低位溢出，高位补0</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"程序控制结构\"><a href=\"#程序控制结构\" class=\"headerlink\" title=\"程序控制结构\"></a>程序控制结构</h1><h2 id=\"顺序控制（if-else-switch）\"><a href=\"#顺序控制（if-else-switch）\" class=\"headerlink\" title=\"顺序控制（if,else,switch）\"></a>顺序控制（if,else,switch）</h2><h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>程序从上到下逐行执行，中间没有任何判断和跳转</p>\n<h3 id=\"分支控制\"><a href=\"#分支控制\" class=\"headerlink\" title=\"分支控制\"></a>分支控制</h3><h3 id=\"1）单分支\"><a href=\"#1）单分支\" class=\"headerlink\" title=\"1）单分支\"></a><strong>1）单分支</strong></h3><p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(条件表达式)&#123;</span><br><span class=\"line\">\t执行代码块;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说明：当条件表达式为true时，则执行{}内的代码。false就不执行。如果只有一条执行语句，可以省略{}。但不建议省略</p>\n<h3 id=\"2）双分支\"><a href=\"#2）双分支\" class=\"headerlink\" title=\"2）双分支\"></a><strong>2）双分支</strong></h3><p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(条件表达式)&#123;</span><br><span class=\"line\">\t执行代码块<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t执行代码块<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3）多分支\"><a href=\"#3）多分支\" class=\"headerlink\" title=\"3）多分支\"></a><strong>3）多分支</strong></h3><p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(条件表达式)&#123;</span><br><span class=\"line\">\t执行代码块<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(条件表达式)&#123;</span><br><span class=\"line\">\t执行代码块<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t执行代码块....;</span><br><span class=\"line\">&#125;.....</span><br></pre></td></tr></table></figure>\n\n<p>流程图：</p>\n<p>else只能有一个执行入口</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220222162201564.png\" alt=\"image-20220222162201564\"></p>\n<p>特别说明：</p>\n<ol>\n<li>多分支可以没有else，如果所有条件都不成立，则一个执行入口都没有</li>\n<li>如果有else，如果所有的条件表达式都不成立，则默认执行else代码块。</li>\n</ol>\n<p>练习：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ifChapter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入0-100的数字&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> scanner.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num&lt;<span class=\"number\">1</span> &amp;&amp; num&gt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num==<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;信用极好&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num&gt;<span class=\"number\">80</span> &amp;&amp; num &lt;= <span class=\"number\">99</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;信用优秀&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num &gt;= <span class=\"number\">60</span> &amp;&amp; num &lt;= <span class=\"number\">80</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;信用一般&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num &lt;<span class=\"number\">60</span>)&#123;<span class=\"comment\">//或直接不写这个条件语句，但这个会有bug</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;不及格&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;请输入合法数字&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;输入不合法&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4）嵌套分支\"><a href=\"#4）嵌套分支\" class=\"headerlink\" title=\"4）嵌套分支\"></a><strong>4）嵌套分支</strong></h3><p>介绍：</p>\n<p>一个分支完整的嵌套了另一个分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支。</p>\n<p>规范：不建议超过三层（可读性不好）</p>\n<p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>()&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>()&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>.....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5）switch分支\"><a href=\"#5）switch分支\" class=\"headerlink\" title=\"5）switch分支\"></a>5）switch分支</h3><p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(表达式)&#123; <span class=\"comment\">//表达式为具体的一个值</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> 常量<span class=\"number\">1</span>:</span><br><span class=\"line\">语句块<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> 常量<span class=\"number\">2</span>:</span><br><span class=\"line\">语句块<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ······:</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\"> ...........</span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"keyword\">default</span> :</span><br><span class=\"line\"><span class=\"keyword\">default</span>语句块</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>switch 关键字,表示swtich分支</li>\n<li>表达式   对应一个值</li>\n<li>case常量1：当表达式的值等于常量1，就执行语句块1</li>\n<li>break：表示退出switch</li>\n<li>如果case 常量1 匹配，就执行语句块1，如果没有则继续case 常量2；</li>\n<li>如果一个都没有匹配上，就执行default</li>\n</ol>\n<p>Switch流程图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220224155515378.png\" alt=\"image-20220224155515378\"></p>\n<p> 注意：</p>\n<ul>\n<li>穿透<ol>\n<li>如果case1 没有break</li>\n<li>则case不进行判断直接执行case2 的语句块</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> week;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入字母&quot;</span>);</span><br><span class=\"line\">        week = scanner.next().charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (week)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Monday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Tuesday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;c&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Wednesday&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thursday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;e&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Friday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;f&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Saturday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;g&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;sunday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;输入有误，请输入a-g的字母&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意事项和细节</p>\n<ol>\n<li><p>表达式数据类型，应和case后的常量类型一致，或者是可以自动转换成可以相互比较的类型，比如输入的是字符，而常量是int</p>\n</li>\n<li><p>Switch(表达式)中表达式的返回值必须是：（byte，short，int，char，enum，String）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//比如下列例子，是不可以的</span></span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">1.1</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span>(a)&#123;<span class=\"comment\">//错误</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">1.1</span>:<span class=\"comment\">//case后面不可以有变量</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;···&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>case子句中的值必须是常量，不能是变量</p>\n</li>\n<li><p>default子句是可选的，当没有匹配的case时，执行default。default语句是可选的，当没有匹配的任何常量，则没有任何输出。</p>\n</li>\n<li><p>break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有则会出现穿透现象，使程序执行后面所有的case语句块，除非遇到break；</p>\n</li>\n<li><p><a href=\"##switch%E7%BB%83%E4%B9%A0\">练习</a></p>\n</li>\n</ol>\n<p><strong>switch 和if的比较</strong></p>\n<ol>\n<li>如果判断的具体数值不多，而且符合byte，short，int，char，enum，string类型虽然这两个语句都可以用，建议用switch</li>\n<li>其他情况，对区间判断，对结果为boolean配型判断，使用if，if的使用范围更广</li>\n</ol>\n<h2 id=\"循环控制（for-while-dowhile-多重循环-重点-）\"><a href=\"#循环控制（for-while-dowhile-多重循环-重点-）\" class=\"headerlink\" title=\"循环控制（for,while,dowhile,多重循环[重点]）\"></a>循环控制（for,while,dowhile,多重循环[重点]）</h2><h3 id=\"1）for循环\"><a href=\"#1）for循环\" class=\"headerlink\" title=\"1）for循环\"></a>1）for循环</h3><ol>\n<li><p>基本语法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(循环变量初始化；循环条件；循环变量迭代)&#123;</span><br><span class=\"line\">\t循环操作；(可多条语句)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>说明</p>\n<ol>\n<li>for关键字，表示循环控制</li>\n<li>for有四要素，1）循环变量初始化，2）循环条件，3）循环操作，4）循环变量迭代</li>\n<li>循环操作，这里可以有很多条语句，也就是我们要执行的代码块</li>\n<li>如果 循环操作(语句)只有一条语句，可以省略{}，建议不要省略</li>\n</ol>\n</li>\n</ol>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//练习： 打印100句“韩顺平教育”</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;韩顺平教育&quot;</span> +i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>for循环流程图<ul>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227123857620.png\" alt=\"image-20220227123857620\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"注意事项：\"><a href=\"#注意事项：\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h4><ul>\n<li><p>循环条件返回一个布尔值(Boolean)</p>\n</li>\n<li><p>for（；循环条件；）中的初始化和变量迭代可以写到其他地方，但两边的分号不能省略</p>\n<ul>\n<li><pre><code class=\"java\">//演示\nint i = 0;\nfor (i; i &lt; 10;) &#123;\n            System.out.println(&quot;韩顺平教育&quot; +i);\n             i++;\n        &#125;\n\n//补充\nfor(;;)&#123;//表示一个无限循环\n   System.out.println(&quot;韩顺平教育&quot; +i);\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 循环初始值，可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```java</span><br><span class=\"line\">    //例</span><br><span class=\"line\">    int count =3;</span><br><span class=\"line\">    for (i =0 ,j = 0 ;i&lt;count; i++, j+=2)&#123;</span><br><span class=\"line\">    \tSystem.out.println(&quot;i=&quot;+i &quot;j=&quot; +j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    输出 ：00 12 24</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>00 12 24</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"编程技巧\"><a href=\"#编程技巧\" class=\"headerlink\" title=\"编程技巧\"></a><strong>编程技巧</strong></h4><ul>\n<li>化繁为简：将复杂的需求拆解成简单的需求</li>\n<li>先死后活：先考虑固定的值，然后转成可以灵活变化的值</li>\n</ul>\n<p><strong>练习</strong></p>\n<ol>\n<li><p>打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]</p>\n<ul>\n<li><p>&#96;&#96;&#96;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```java</span><br><span class=\"line\">  //打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]</span><br><span class=\"line\">        //1、先输出1-100循环</span><br><span class=\"line\">        //2、在输出的过程中过滤9的倍数</span><br><span class=\"line\">        //3、定义一个变量来累计计算个数</span><br><span class=\"line\">        //4、定义一个变量来累计计算总和</span><br><span class=\"line\">  public static void main(String[] args) &#123;</span><br><span class=\"line\">          int count= 0;</span><br><span class=\"line\">          int sum =0;</span><br><span class=\"line\">          for (int i = 1; i &lt;=100 ; i++) &#123;</span><br><span class=\"line\">              if (i%9==0)&#123;</span><br><span class=\"line\">                  System.out.println(&quot;i=&quot;+i);</span><br><span class=\"line\">                  count++;</span><br><span class=\"line\">                  System.out.println(&quot;数量&quot;+count);</span><br><span class=\"line\">                  sum+=i;// = sum + i</span><br><span class=\"line\">                  System.out.println(&quot;sum=&quot;+sum);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">          &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2）while循环\"><a href=\"#2）while循环\" class=\"headerlink\" title=\"2）while循环\"></a>2）while循环</h3><p>基础语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>（循环条件）&#123;</span><br><span class=\"line\">\t循环体（语句）；</span><br><span class=\"line\">\t循环变量迭代；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ol>\n<li>while循环也有四要素</li>\n<li>只是四要素放的位置，和for不一样</li>\n</ol>\n<p><strong>流程图</strong></p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227143009846.png\" alt=\"image-20220227143009846\"></p>\n<h4 id=\"注意事项：-1\"><a href=\"#注意事项：-1\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h4><ol>\n<li>循环条件是返回布尔值</li>\n<li>while循环是先判断再执行语句</li>\n</ol>\n<h3 id=\"3）do…while循环控制\"><a href=\"#3）do…while循环控制\" class=\"headerlink\" title=\"3）do…while循环控制\"></a>3）do…while循环控制</h3><p>基础语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t循环体(语句);</span><br><span class=\"line\">\t循环变量迭代;</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(循环条件);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 说明:</p>\n<ol>\n<li><p>do  while 是关键字</p>\n</li>\n<li><p>也有循环四要素，只是位置不一样</p>\n</li>\n<li><p>先执行，在判断，也就是说，一定会执行一次</p>\n</li>\n<li><p>最后有一个分号</p>\n</li>\n<li><p>while和do… while区别</p>\n<ul>\n<li><p>while是先判断再执行</p>\n</li>\n<li><p>do .. while是先执行再判断</p>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;阿巴阿巴&quot;</span>);</span><br><span class=\"line\">            i++;<span class=\"comment\">//不要忘记加上，否则容易死循环</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span> (i&lt;=<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;exit dowhile&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>流程图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227163555197.png\" alt=\"image-20220227163555197\"></p>\n<h4 id=\"注意事项：-2\"><a href=\"#注意事项：-2\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h4><ol>\n<li>循环条件是返回一个布尔值的表达式</li>\n<li>do…while 循环是先执行后判断，因此它至少执行一次</li>\n</ol>\n<h3 id=\"4）多重循环\"><a href=\"#4）多重循环\" class=\"headerlink\" title=\"4）多重循环\"></a>4）多重循环</h3><h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ol>\n<li><p>讲一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do …while均可以作为外层循环和内层循环 。【建议一般使用两层，最多不超过三层，否则代码可读性很差】</p>\n</li>\n<li><p>实质上，嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环</p>\n</li>\n<li><p>例：设外层循环次数为m次，内层为n次。则内层循环体实际上需要执行m*n次</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;i = &quot;</span>+i+ <span class=\"string\">&quot;,&quot;</span>+<span class=\"string\">&quot;j = &quot;</span>+j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------输出------------------------</span><br><span class=\"line\">i = <span class=\"number\">0</span> , j =<span class=\"number\">0</span></span><br><span class=\"line\">i = <span class=\"number\">0</span> , j =<span class=\"number\">1</span></span><br><span class=\"line\">i = <span class=\"number\">0</span> , j =<span class=\"number\">2</span></span><br><span class=\"line\">i = <span class=\"number\">1</span> , j =<span class=\"number\">0</span></span><br><span class=\"line\">i = <span class=\"number\">1</span> , j =<span class=\"number\">1</span></span><br><span class=\"line\">i = <span class=\"number\">1</span> , j =<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h4><ol>\n<li><p>统计3个班成绩情况，每个班有5名同学，求出各个班的平均成绩和所有班级的平均分【学生的成绩从键盘输入】</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>Scanner scanner &#x3D; new Scanner(System.in);<br>&#x2F;&#x2F;        int clss &#x3D; 1;<br>        int stu &#x3D;0;<br>        double sum &#x3D; 0;<br>    for (int i &#x3D; 1; i &lt;&#x3D;3 ; i++) {<br>        for ( int j &#x3D; 1;j&lt;&#x3D;5;j++){<br><br>            System.out.println(“请输入”+i+”班”+j+”成绩”);<br>            int s &#x3D; scanner.nextInt();<br>            sum &#x3D; sum + s;<br>        }<br>        System.out.println(i+”班的平均分为：”+(sum &#x2F; 5));<br>        sum &#x3D;0;<br>    }<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">     </span><br><span class=\"line\"></span><br><span class=\"line\">2. 打印99乘法表</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```java</span><br><span class=\"line\">     for (int i = 1; i &lt;=9 ; i++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">                 for (int j = 1; j &lt;=i ; j++) &#123;</span><br><span class=\"line\">                     System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+(i*j)+&quot;  &quot;);</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 System.out.println(&quot;&quot;);</span><br><span class=\"line\">             &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>打印空心金字塔</p>\n<ul>\n<li><pre><code class=\"java\">//        实心金字塔\n        for (int i = 1; i &lt;=5 ; i++) &#123;\n            for (int k = 1; k &lt;=5-i ; k++) &#123;\n//                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                System.out.print(&quot; &quot;);\n            &#125;\n//            控制每个打印的*的层数\n            for (int j = 1; j &lt;=2*i-1 ; j++) &#123;\n\n                System.out.print(&quot;*&quot;);\n            &#125;\n            System.out.println(&quot; &quot;);\n        &#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```java</span><br><span class=\"line\">  空心金字塔 【难点】</span><br><span class=\"line\">          for (int i = 1; i &lt;=5 ; i++) &#123;</span><br><span class=\"line\">              for (int k = 1; k &lt;=5-i ; k++) &#123;</span><br><span class=\"line\">  //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数</span><br><span class=\"line\">                  System.out.print(&quot; &quot;);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              </span><br><span class=\"line\">              </span><br><span class=\"line\">  //            控制每个打印的*的层数</span><br><span class=\"line\">              for (int j = 1; j &lt;=2*i-1 ; j++) &#123;</span><br><span class=\"line\">              </span><br><span class=\"line\">              </span><br><span class=\"line\">  \t\t\t\t//1.空心金字塔的第一层和最后一层的*全部输出</span><br><span class=\"line\">  \t\t\t\t//2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示</span><br><span class=\"line\">  \t\t\t\t//3.再加一个条件 i == 5</span><br><span class=\"line\">  \t\t\t\tif(j == 1 || j == 2*i-1 || i==5 )&#123;</span><br><span class=\"line\">  \t\t\t\t\t System.out.print(&quot;*&quot;);</span><br><span class=\"line\">  \t\t\t\t&#125;else&#123;</span><br><span class=\"line\">  \t\t\t\t\t System.out.print(&quot; &quot;);</span><br><span class=\"line\">  \t\t\t\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  //可以将其中的5 提出来换成变量，实时控制金字塔的层数</span><br><span class=\"line\">  </span><br><span class=\"line\">                 </span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              System.out.println(&quot; &quot;);</span><br><span class=\"line\">          &#125;</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;可手动修改的</p>\n<pre><code>  Scanner scanner = new Scanner(System.in);\n  System.out.println(&quot;请输入层数&quot;);\n  int layer = scanner.nextInt();\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 1; i &lt;=layer ; i++) &#123;</span><br><span class=\"line\">            for (int k = 1; k &lt;=layer-i ; k++) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">//                在输出*之前，先输出对应的空格 = 总层数 - 当前层数</span><br><span class=\"line\">                System.out.print(&quot; &quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">//            控制每个打印的*的层数</span><br><span class=\"line\">            for (int j = 1; j &lt;=2*i-1 ; j++) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">                //1.空心金字塔的第一层和最后一层的*全部输出</span><br><span class=\"line\">                //2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示</span><br><span class=\"line\">                //3.再加一个条件 i == 5</span><br><span class=\"line\">                if(j == 1 || j == 2*i-1 || i==layer )&#123;</span><br><span class=\"line\">                    System.out.print(&quot;*&quot;);</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    System.out.print(&quot; &quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot; &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure></li>\n<li><p>改为菱形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## break</span><br><span class=\"line\"></span><br><span class=\"line\">介绍</span><br><span class=\"line\"></span><br><span class=\"line\">1. 跳转控制语句-----&gt;break</span><br><span class=\"line\">2. 当某个条件满足时，终止循环</span><br><span class=\"line\">3. break语句用于终止某个语句块的执行，一般用于switch或者循环中</span><br><span class=\"line\"></span><br><span class=\"line\">基本语法：</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">break;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p>以while循环为例流程图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228111326348.png\" alt=\"image-20220228111326348\"></p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ol>\n<li><p>break语句出现在多层嵌套语句块时，可以通过标签指明要终止的是哪一层语句块</p>\n</li>\n<li><p>标签的基本使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label1:&#123;.....</span><br><span class=\"line\">label2:\t\t&#123;.....</span><br><span class=\"line\">label3:\t\t\t&#123;.....</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span> label2;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>break语句可以指定退出哪层</li>\n<li>label1是标签，由程序员决定</li>\n<li>break后指定到哪个label就退出到哪里</li>\n<li>在实际开发中，尽量不要使用标签</li>\n<li>如果没有指定break，默认退出最近的循环体</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"continue-跳转控制语句\"><a href=\"#continue-跳转控制语句\" class=\"headerlink\" title=\"continue-跳转控制语句\"></a>continue-跳转控制语句</h2><p>介绍：</p>\n<ol>\n<li><u><strong>continue语句用于结束本次循环，继续执行下次循环</strong>。</u></li>\n<li>continue语句多出现在多层嵌套的循环语句中时，可以用过标签指明要跳过的是哪一环，这个和前面的标签使用一样</li>\n</ol>\n<p>基本语法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\"><span class=\"keyword\">continue</span>;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>流程图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228153036178.png\" alt=\"image-20220228153036178\"></p>\n<h2 id=\"return-跳转控制语句\"><a href=\"#return-跳转控制语句\" class=\"headerlink\" title=\"return-跳转控制语句\"></a>return-跳转控制语句</h2><p>介绍：</p>\n<p>return使用在方法，表示跳出所在的方法</p>\n<p>注意：</p>\n<ol>\n<li>如果吧return放在main方法中会退出程序</li>\n</ol>\n<h1 id=\"数组【重点】\"><a href=\"#数组【重点】\" class=\"headerlink\" title=\"数组【重点】\"></a>数组【重点】</h1><h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p><strong>介绍</strong></p>\n<p>数组可以存放 <u>多个</u><em><u>同一类型</u></em> 的数据。数组也是一种数据类型，是引用数据类型。</p>\n<p>即：数（数据）组（一组）就是一组数据</p>\n<p><span id = \"数组案例01\">案例</span>（快速入门）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">   \t\t\t<span class=\"type\">double</span> <span class=\"variable\">totalWeght</span> <span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">double</span>[] hen = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">  <span class=\"comment\">//可以通过 for循环访问数组的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;hen.length ; i++) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//可以通过下标来访问数组的元素 hen[下标]</span></span><br><span class=\"line\">          <span class=\"comment\">//下标是从0开始的，比如【0，1，2，3】</span></span><br><span class=\"line\">          <span class=\"comment\">//第二个元素是hen[1]</span></span><br><span class=\"line\">    </span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span>+(i+<span class=\"number\">1</span>)+<span class=\"string\">&quot;个元素的值为&quot;</span>+hen[i]);</span><br><span class=\"line\">          totalWeght+=hen[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  \t\tSystem.out.println(<span class=\"string\">&quot;总体重为&quot;</span>+totalWeght+<span class=\"string\">&quot;平均体重为=&quot;</span>+(totalWeght/hen.length));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态初始化\"><a href=\"#动态初始化\" class=\"headerlink\" title=\"动态初始化\"></a>动态初始化</h3><h4 id=\"使用方式1\"><a href=\"#使用方式1\" class=\"headerlink\" title=\"使用方式1\"></a>使用方式1</h4><p>先new出一个数组，再动态的给它赋值。</p>\n<p>数组的定义：</p>\n<p>数据类型\t数组名[] &#x3D; new 数据类型[大小]</p>\n<p>数据类型[]\t数组名 &#x3D; new 数据类型[大小]</p>\n<p>以上两种写法的效果都是等价的</p>\n<p>例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个数组，名字为a，长度为5个int</span></span><br></pre></td></tr></table></figure>\n\n<p>内存图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302092916369.png\" alt=\"image-20220302092916369\"></p>\n<p>例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.smms.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">chapterArray01</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"comment\">//new数组类型时，记得加上数组的长度</span></span><br><span class=\"line\">        <span class=\"type\">double</span>[] doubles = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; doubles.length; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;请输入第&quot;</span>+(i+<span class=\"number\">1</span>)+<span class=\"string\">&quot;个数&quot;</span>);</span><br><span class=\"line\">            doubles[i] = scanner.nextDouble();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;========================================&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;doubles.length ; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;输入的数为&quot;</span>+doubles[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用方式2\"><a href=\"#使用方式2\" class=\"headerlink\" title=\"使用方式2\"></a>使用方式2</h4><ol>\n<li><em><strong><u>先声明数组</u></strong></em></li>\n</ol>\n<p>语法：</p>\n<ul>\n<li><p>数据类型 数组名[];\t或\t\t数据类型[] \t数组名;</p>\n</li>\n<li><p>int a[]  &#x2F; int[]  a;</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><em><strong><u>创建数组</u></strong></em></li>\n</ol>\n<p>语法：</p>\n<ul>\n<li>数组名 &#x3D; new 数据类型 [ 大小 ];</li>\n<li>a &#x3D; new int[5];</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//        double[] doubles = new double[5];</span></span><br><span class=\"line\"><span class=\"comment\">//相当于吧使用方法1给拆分成两个</span></span><br><span class=\"line\"><span class=\"comment\">//\t1.先声明</span></span><br><span class=\"line\">        <span class=\"type\">double</span> doubles[];</span><br><span class=\"line\">        <span class=\"comment\">//2.再创建</span></span><br><span class=\"line\">        doubles = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[<span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<p>解释：1.先声明，在内存中相当于创建了一个空的变量，这时没有任何左右</p>\n<p>2.再创建，才使得这个数组有意义。不写的话会报空指针异常</p>\n<h3 id=\"静态初始化\"><a href=\"#静态初始化\" class=\"headerlink\" title=\"静态初始化\"></a>静态初始化</h3><p>语法：</p>\n<p>数据类型\t数组名[] &#x3D; {元素值，元素值，元素值，……}</p>\n<p><a href=\"#%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B01\">案例</a>跳转</p>\n<h3 id=\"注意事项和细节\"><a href=\"#注意事项和细节\" class=\"headerlink\" title=\"注意事项和细节\"></a>注意事项和细节</h3><ol>\n<li>数组是多核相同的数据类型的组合，实现对这些数据的统一管理</li>\n<li>数组中的元素可以使任何数据类型，包括基本数据类型和引用数据类型，但不能混用</li>\n<li>数组创建后，如果没有赋值，会有默认值：int 0 , short 0 , byte 0 ,long 0, float 0 ,double 0.0 , char \\u0000, boolean false , String null;</li>\n<li>使用数组的步骤：<ol>\n<li>声明数组并开辟空间</li>\n<li>给数组各个元素赋值</li>\n<li>使用数组</li>\n</ol>\n</li>\n<li>数组的下表是从0开始的 </li>\n<li>数组下表必须在指定范围内使用，否则报：下标越界异常，比如: int[] arr &#x3D; new int [5] ; 则有效下标为0-4</li>\n<li>数组属于引用数据类型，数组行数据是对象（object）</li>\n<li>boolean 类型没有赋值的情况下默认false</li>\n</ol>\n<h3 id=\"数组赋值机制\"><a href=\"#数组赋值机制\" class=\"headerlink\" title=\"数组赋值机制\"></a>数组赋值机制</h3><ol>\n<li><p>基本数据类型赋值，这个值就是具体的数据，而且相互不影响</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本数据类型赋值，复制方式为值拷贝</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">2</span> ; </span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> n1 ;</span><br><span class=\"line\"></span><br><span class=\"line\">n2的变化不会影响n1</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数组再默认情况下是引用传递，赋的值是地址。赋值方式为引用传递</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] array1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"type\">int</span>[] array2 = array1; </span><br><span class=\"line\"></span><br><span class=\"line\">array2[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">//此时运行的结果 array1的第0个元素会变成10</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p> <img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302141207302.png\" alt=\"image-20220302141207302\"></p>\n<h3 id=\"数组拷贝\"><a href=\"#数组拷贝\" class=\"headerlink\" title=\"数组拷贝\"></a>数组拷贝</h3><p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] arr1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">//1. 创建一个新的数组arr2,开辟一个新的数据空间</span></span><br><span class=\"line\"><span class=\"comment\">//2. 大小 = arr1.length</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr2[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr1.length];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历arr1到对应的位置</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class=\"line\">    arr2[i] = arr1[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>jvm内存图分析:</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142048498.png\" alt=\"image-20220302142048498\"></p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142253236.png\" alt=\"image-20220302142253236\"></p>\n<h3 id=\"数组翻转\"><a href=\"#数组翻转\" class=\"headerlink\" title=\"数组翻转\"></a>数组翻转</h3><p>案例：</p>\n<p>要求：需要把数组的元素内容反转。</p>\n<p>arr { 1 , 2 , 3 , 4 , 5 }–&gt;{5 , 4 , 3 , 2 , 1}</p>\n<p>方式1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">11</span> , <span class=\"number\">22</span> , <span class=\"number\">33</span> , <span class=\"number\">44</span> , <span class=\"number\">55</span> , <span class=\"number\">66</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1. 把 arr[0] 和 arr[5] 进行交换</span></span><br><span class=\"line\"><span class=\"comment\">//2. 把 arr[1] 和 arr[4] 进行交换</span></span><br><span class=\"line\"><span class=\"comment\">//3. 把 arr[2] 和 arr[3] 进行交换</span></span><br><span class=\"line\"><span class=\"comment\">//4. 一共要交换 3 次 = arr.length</span></span><br><span class=\"line\"><span class=\"comment\">//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;len/<span class=\"number\">2</span> ; i++) &#123;</span><br><span class=\"line\">            temp = arr[len-<span class=\"number\">1</span>-i];</span><br><span class=\"line\">            arr[len-<span class=\"number\">1</span>-i] = arr[i];</span><br><span class=\"line\">            arr[i] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>方式2</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">11</span> , <span class=\"number\">22</span> , <span class=\"number\">33</span> , <span class=\"number\">44</span> , <span class=\"number\">55</span> , <span class=\"number\">66</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//1. 先创建一个arr2</span></span><br><span class=\"line\">        <span class=\"comment\">//2. 逆序遍历arr，再将每个元素赋给arr2的元素中</span></span><br><span class=\"line\">        <span class=\"comment\">//3. 增加一个循环变量j</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr.length];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,j=arr.length-<span class=\"number\">1</span> ; j&gt;=<span class=\"number\">0</span>; i++,j--) &#123;</span><br><span class=\"line\">            arr2[j] =arr[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//4.当for循环结束，arr2就是一个逆序数组，&#123;66 , 55 , 44 , 33 , 22 , 11&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//5. 让arr指向arr2数据空间,此时arr原来的数据空间就没有变量引用</span></span><br><span class=\"line\"><span class=\"comment\">//会被当做垃圾处理</span></span><br><span class=\"line\">arr = arr2</span><br><span class=\"line\">    <span class=\"comment\">//6. 遍历输出</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">            System.out.println(arr[i]);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"数组扩容\"><a href=\"#数组扩容\" class=\"headerlink\" title=\"数组扩容\"></a>数组扩容</h3><p>数组缩减同理</p>\n<p>数组添加</p>\n<p>要求：实现动态的给数组添加元素效果，实现对数组扩容</p>\n<p>1）原始数组使用静态分配int[] arr &#x3D; {1,2,3}</p>\n<p>2）增加的元素4，直接放在数组的最后 arr &#x3D; {1,2,3,4}</p>\n<p>3）用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y&#x2F;n</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.smms.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">chapterArrayAdd</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">char</span> key ;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span>[] arr2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr1.length+<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class=\"line\">                    arr2[i] = arr1[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;请输入一个要添加的值&quot;</span>);</span><br><span class=\"line\">                arr2[arr2.length - <span class=\"number\">1</span>] = scanner.nextInt();</span><br><span class=\"line\"></span><br><span class=\"line\">            arr1 = arr2;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;是否继续添加？请输入y/n&quot;</span>);</span><br><span class=\"line\">            key = scanner.next().charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key==<span class=\"string\">&#x27;y&#x27;</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;继续增加&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key== <span class=\"string\">&#x27;n&#x27;</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;跳出&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span> ;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;输入不合法&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"><span class=\"comment\">//            将arry1的地址指定到arry2的地址，此时原arry1的地址被没有变量引用，所以被jvm销毁</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr1.length ; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;arr1 = &quot;</span>+arr1[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>介绍</p>\n<p>排序的分类：</p>\n<ol>\n<li>内部排序：</li>\n</ol>\n<ul>\n<li>指将需要处理的所有数据都加载到内部存储中进行排序。包括（交换式排序法，选择时排序法和插入式排序法）</li>\n</ul>\n<ol start=\"2\">\n<li>外部排序法：<ul>\n<li>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>基本思想：通过对待排序序列从后向前（从下标较大的元素开始），一次比较相邻元素的值若发现逆序则交换，使值较大的元素从前移向后部。像水下的气泡一样逐渐向上冒。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220303105607719.png\" alt=\"image-20220303105607719\"></p>\n<p>特点：</p>\n<ol>\n<li><p>一共有五个元素</p>\n</li>\n<li><p>一共进行了四轮排序，可以看成外层循环</p>\n</li>\n<li><p>每1轮排序可以确定一个数的位置，比如第一轮排序确最大数，第二轮确定第二大的数 的位置，依次类推</p>\n</li>\n<li><p>当进行比较时，如果前面的数大于后面的数，就交换</p>\n</li>\n</ol>\n<p>案例说明:</p>\n<p>将五个无序：24,69,80,57,13使用冒泡排序，从小到大排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.smms.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">chapterBall</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] a  = &#123;<span class=\"number\">24</span>,<span class=\"number\">69</span>,<span class=\"number\">80</span>,<span class=\"number\">57</span>,<span class=\"number\">13</span>&#125;;</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.length-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; a.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j&gt;=a.length-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[j]&lt;a[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;不做交换&quot;</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    tmp = a[j];</span><br><span class=\"line\">                    a[j]  = a[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    a[j+<span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;交换第&quot;</span>+j+<span class=\"string\">&quot;个数为&quot;</span>+a[j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;a.length ; i++) &#123;</span><br><span class=\"line\">            System.out.println(a[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h3 id=\"1）顺序查找：\"><a href=\"#1）顺序查找：\" class=\"headerlink\" title=\"1）顺序查找：\"></a>1）顺序查找：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.smms.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">exercisesSequence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*有一个数列：</span></span><br><span class=\"line\"><span class=\"comment\">        * 白眉鹰王，金毛狮王，紫衫龙王，青翼蝠王猜数游戏</span></span><br><span class=\"line\"><span class=\"comment\">        * 从键盘任意输入一个名称，判断数列中是否包含此名称（顺序查找）</span></span><br><span class=\"line\"><span class=\"comment\">        * 要求：如果找到了，就提示找到，并给出下标</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        String[] a =&#123;<span class=\"string\">&quot;白眉鹰王&quot;</span>,<span class=\"string\">&quot;金毛狮王&quot;</span>,<span class=\"string\">&quot;紫衫龙王&quot;</span>,<span class=\"string\">&quot;青翼蝠王&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">        <span class=\"comment\">//用于判断是否没找到</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">nub</span> <span class=\"operator\">=</span>-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;a.length ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next.equals(a[i]))&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;找到了&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">//如果找到了就把i的值赋给sub</span></span><br><span class=\"line\">                nub = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">//如果nub==-1就代表没找到</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nub == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;没找到&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2）二分查找：\"><a href=\"#2）二分查找：\" class=\"headerlink\" title=\"2）二分查找：\"></a>2）二分查找：</h3><p>算法部分讲解补充</p>\n<h2 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h2><p>介绍：一个数组内，还有数组</p>\n<p>要理解的点：</p>\n<ol>\n<li>看到定义形式就可知道是不是二维数组</li>\n<li>二维数组的每一个元素都是一维数组</li>\n<li>二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历</li>\n<li></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果需要访问第（i+<span class=\"number\">1</span>)个一维数组，第（j+<span class=\"number\">1</span>)个值。arr2d[i][j]</span><br><span class=\"line\"> 或需要访问第i个一维数组，第j个值。arr2d[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]   </span><br></pre></td></tr></table></figure>\n\n\n\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 请用二维数组输入如下图形</span></span><br><span class=\"line\"><span class=\"comment\">         0 0 0 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">         0 0 1 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">         0 2 0 3 0 0</span></span><br><span class=\"line\"><span class=\"comment\">         0 0 0 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        1. 定义形式 int[][]</span></span><br><span class=\"line\"><span class=\"comment\">//        2.可以理解为一个数组内的每个元素都是一个数组</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] arr2d= &#123;&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">                        &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;二维数组的元素个数&quot;</span>+arr2d.length);</span><br><span class=\"line\"><span class=\"comment\">//\t二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//        获取多个少个一维数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr2d.length; i++) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            遍历二维数组的每一个元素（数组）,</span></span><br><span class=\"line\"><span class=\"comment\">//            arr2d[i].length  获取二维数组内对应的每一个一维数组的长度</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; arr2d[i].length; j++) &#123;</span><br><span class=\"line\">                System.out.print(arr2d[i][j]+<span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二维数组内存原理图：\"><a href=\"#二维数组内存原理图：\" class=\"headerlink\" title=\"二维数组内存原理图：\"></a>二维数组内存原理图：</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165024843.png\" alt=\"image-20220304165024843\"></p>\n<h3 id=\"二维数组的使用方式\"><a href=\"#二维数组的使用方式\" class=\"headerlink\" title=\"二维数组的使用方式\"></a>二维数组的使用方式</h3><p>方式1：动态初始化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.语法：类型[][] 数组名 = new 类型[大小][大小];</span><br><span class=\"line\">例如： int[][] = new int[2][3];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>方式2：动态初始化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 先声明：类型 数组名[][];</span><br><span class=\"line\">2. 再定义（开辟空间）： 数组名 = new 类型[大小][大小];</span><br><span class=\"line\">3. 赋值（有默认值，比如int 类型默认值就是0）</span><br></pre></td></tr></table></figure>\n\n<p>方式3：动态初始化</p>\n<ol>\n<li>列数不确定</li>\n<li>java不强制每个数组的长度都一样</li>\n<li>例：<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165929272.png\" alt=\"image-20220304165929272\"></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            动态创建下面二维数组，并输出</span></span><br><span class=\"line\"><span class=\"comment\">            i = 0 : 1</span></span><br><span class=\"line\"><span class=\"comment\">            i = 1 : 2 2</span></span><br><span class=\"line\"><span class=\"comment\">            i = 2 : 3 3 3</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">//1. 创建一个二维数组，因为数组内的每一堆数组的元素都是不确定的，所以不填。</span></span><br><span class=\"line\">        <span class=\"comment\">// 填了的话相当于固定了长度</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] arr= <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>][];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            给数组内的一维数组开辟空间</span></span><br><span class=\"line\"><span class=\"comment\">//            如果没有给一堆数组开辟空间，那么这个空间的就是null</span></span><br><span class=\"line\">            arr[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[i+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"comment\">//            遍历一维数组，给一堆数组的每个元素赋值</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; arr[i].length ; j++) &#123;</span><br><span class=\"line\">                arr[i][j]= i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        遍历出这个二维数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt;arr[i].length ; j++) &#123;</span><br><span class=\"line\">                System.out.print(arr[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>杨辉三角形</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220305143151743.png\" alt=\"image-20220305143151743\"></p>\n<p>提示：</p>\n<ol>\n<li><p>第一行有一个元素，第n行有n个元素</p>\n</li>\n<li><p>第一行的第一个元素和最后一个元素都是1</p>\n</li>\n<li><p>从第三行开始，对于非第一个元素和最后一个元素的元素的值，arr[i],[j]</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>中间的数为：<br>arr[i][j]  &#x3D; arr[i-1][j]+ arr[i-1][j-1]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">package basics.chapterArray;</span><br><span class=\"line\"></span><br><span class=\"line\">public class exerciseArrayYangHuiTriangle &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[][] arr =  new int[10][];</span><br><span class=\"line\">        for (int i = 0; i &lt;10 ; i++) &#123;</span><br><span class=\"line\">            arr[i] = new int[i+1];</span><br><span class=\"line\">            for (int j = 0; j &lt; arr[i].length; j++) &#123;</span><br><span class=\"line\">                if (j==0 || j == arr[i].length-1)&#123;</span><br><span class=\"line\">                    arr[i][j] = 1;</span><br><span class=\"line\">                &#125;else &#123;</span><br><span class=\"line\">                    arr[i][j] = arr[i-1][j]+arr[i-1][j-1];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt;arr[i].length ; j++) &#123;</span><br><span class=\"line\">                System.out.print(arr[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><h2 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h2><p>1）类是抽象的，概念的。代表一类事物，比如人类，猫类，狗类。。。。，即它是实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">cat</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//属性/也叫成员变量</span></span><br><span class=\"line\">   <span class=\"comment\">// 成员变量 =属性 = field(字段)</span></span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实例</span></span><br><span class=\"line\"><span class=\"type\">cat</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ca</span>();</span><br></pre></td></tr></table></figure>\n\n<p>2） 对象是具体的，实际的，代表一个具体事务，即是实例</p>\n<p>3） 类是对象的模板，对象是类的一个个体，对应一个实例</p>\n<p>属性可以使基本数据类型，也可以是引用数据类型(对象，数组)</p>\n<h3 id=\"对象在内存中存在的形式（重要）\"><a href=\"#对象在内存中存在的形式（重要）\" class=\"headerlink\" title=\"对象在内存中存在的形式（重要）\"></a>对象在内存中存在的形式（重要）</h3><p>java内存的结构分析：</p>\n<ol>\n<li>栈：一般存放基本数据类型（局部变量）</li>\n<li>堆：存放对象（Cat cat ，数组等）</li>\n<li>方法区：常量池（常量，比如字符串），类加载信息</li>\n<li>示意图：[Cat(name,age,price)]</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">p.name = <span class=\"string\">&quot;jack&quot;</span>;</span><br><span class=\"line\">p.age = <span class=\"number\">12</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>先加载Person类信息（属性和方法信息，只会加载一次）</span><br><span class=\"line\"><span class=\"number\">2.</span>在堆中分配空间，进行默认初始化（看规则），</span><br><span class=\"line\"><span class=\"number\">3.</span>把堆中的地址返回给p，p就指向对象</span><br><span class=\"line\"><span class=\"number\">4.</span>进行指定初始化，比如：p.name = <span class=\"string\">&quot;jack&quot;</span>,p.age = <span class=\"number\">12</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>对象和数组都是引用类型</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307112129768.png\" alt=\"image-20220307112129768\"></p>\n<p>如果存放的数据，类型是基本数据类型则存放在堆中，引用的数据类型则存放在方法区</p>\n<h3 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>1） 属性的定义语法同变量，示例：<span style=\"color:blue\">访问修饰符</span><span style= \"color:red\" > 属性类型  属性名;</span></p>\n<p>2） 属性的定义类型可以为任意类型，包含基本类型或引用类型</p>\n<p>3） 属性如果不赋值，有默认值，规则和数组一致</p>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><ol>\n<li><p>先声明在创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAT cat;</span><br><span class=\"line\">cat  = <span class=\"keyword\">new</span> <span class=\"title class_\">CAT</span>();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CAT</span> <span class=\"variable\">cat</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CAT</span>();</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>访问属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对象名.属性名；</span><br><span class=\"line\">cat.xxx;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类对象的内存分配机制\"><a href=\"#类对象的内存分配机制\" class=\"headerlink\" title=\"类对象的内存分配机制\"></a>类对象的内存分配机制</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307145803905.png\" alt=\"image-20220307145803905\"></p>\n<h2 id=\"成员方法\"><a href=\"#成员方法\" class=\"headerlink\" title=\"成员方法\"></a>成员方法</h2><p>介绍：</p>\n<p>用于描述对象的行为，成为方法</p>\n<p>案例：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307161842380.png\" alt=\"image-20220307161842380\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.smms.demo.method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">exercisesMethod01</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">        person.speal();</span><br><span class=\"line\">        person.cal01();</span><br><span class=\"line\">        person.cal02(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">//        调用getSum方法，并给了1,3的值</span></span><br><span class=\"line\"><span class=\"comment\">//        用returnsum接收getSum返回的值</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">returnsum</span> <span class=\"operator\">=</span> person.getSum(<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;returnsum=&quot;</span>+returnsum);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">speal</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是一个好人&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">cal01</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            sum+=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;1+~+1000=&quot;</span>+sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">cal02</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;=n ; i++) &#123;</span><br><span class=\"line\">            sum = sum+i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;1+n=&quot;</span>+sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getSum</span><span class=\"params\">(<span class=\"type\">double</span> a, <span class=\"type\">double</span> b)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        sum = a+b;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;a+b=&quot;</span>+sum);</span><br><span class=\"line\"><span class=\"comment\">//        表示返回sum</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内存分析流程图\"><a href=\"#内存分析流程图\" class=\"headerlink\" title=\"内存分析流程图\"></a>内存分析流程图</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220308162432089.png\" alt=\"image-20220308162432089\"></p>\n<p>方法的优点：</p>\n<ol>\n<li>提高了代码的复用性</li>\n<li>可将实现的细节封装起来，然后提供其他用户来调用</li>\n</ol>\n<h3 id=\"成员方法的定义\"><a href=\"#成员方法的定义\" class=\"headerlink\" title=\"成员方法的定义\"></a>成员方法的定义</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> 返回数据类型\\<span class=\"keyword\">void</span>（表示没有返回值）\t方法名(形参列表...)&#123;<span class=\"comment\">//方法体</span></span><br><span class=\"line\">语句;</span><br><span class=\"line\"><span class=\"keyword\">return</span>；<span class=\"comment\">//返回值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>参数列表：表示成员方法输入cal(int n)</li>\n<li>数据类型(返回类型)：表示成员方法输出，void表示没有返回值</li>\n<li>方法主体:表示为了实现某一功能代码块</li>\n<li>return语句不是必须的</li>\n</ol>\n<h3 id=\"注意事项-2\"><a href=\"#注意事项-2\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li><p>访问修饰符</p>\n</li>\n<li><p>&#96;&#96;&#96; java<br>访问修饰符 返回数据类型\\void（表示没有返回值）\t方法名(形参列表…){&#x2F;&#x2F;方法体<br>语句;<br>return；&#x2F;&#x2F;返回值<br>}</p>\n<ol>\n<li>访问修饰符（作用是控制 方法的适用范围）<br> 如果不写默认访问，[有四种：public protected 默认]</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">3. 返回数据类型</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>一个方法最多有一个返回值<br> 返回多个结果，返回数组</p>\n</li>\n<li><p>返回类型可以为任意类型，包含基本类型和引用类型(数组，对象)</p>\n</li>\n<li><p>如果方法要求有返回数据类型，则方法体中最后执行的语句必须为return值；而且要求返回值类型必须和return的值的类型一致或兼容</p>\n</li>\n<li><p>如果方法是void，则方法体照片那个可以没有return语句，或者 只写 return；</p>\n</li>\n</ol>\n<p>方法命名；使用驼峰命名法，最好见名知意</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开。例：getSum(int a,int b)</span><br><span class=\"line\"></span><br><span class=\"line\">5. 参数类型可以为任意类型，包含基本类型或引用类型。</span><br><span class=\"line\"></span><br><span class=\"line\">6. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数</span><br><span class=\"line\"></span><br><span class=\"line\">7. 方法定义时的参数成为形式参数（形参）；方法调用时的参数成为实际参数，简称实参。实参和形参的类型要一致或兼容、个数、顺序必须一致</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```java</span><br><span class=\"line\">     public static void main()&#123;</span><br><span class=\"line\">     \tMethod a = new Method();</span><br><span class=\"line\">     \ta.input(123,345//这里成为实参);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     class Method&#123;</span><br><span class=\"line\">     \tpublic int input(int a,int b//这里成为形参)&#123;</span><br><span class=\"line\">     \tsystem.out.print(&quot;xxx&quot;);</span><br><span class=\"line\">     \treturn xxx;</span><br><span class=\"line\">     \t&#125;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法体</p>\n<p>​\t里面写完成功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义</p>\n<p>调用细节</p>\n<ol>\n<li><p>同一类中的方法调用：直接调用即可</p>\n<ul>\n<li>直接输入：方法名（参数）即可</li>\n</ul>\n</li>\n<li><p>跨类中的方法A类调用B类方法：需要通过对象名调用。比如：对象名.方法名(参数)</p>\n</li>\n</ol>\n<h2 id=\"成员方法传参（重要）\"><a href=\"#成员方法传参（重要）\" class=\"headerlink\" title=\"成员方法传参（重要）\"></a>成员方法传参（重要）</h2><p>基本数据类型</p>\n<ol>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310134944831.png\" alt=\"image-20220310134944831\"></li>\n<li><span style = \"color:red\">基本数据类型</span>，传递的值（拷贝），形参的任何改变不影响实参！</li>\n</ol>\n<p>引用数据类型</p>\n<ol>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310140041330.png\" alt=\"image-20220310140041330\"></li>\n<li>引用类型传递的是地址（传递也是值，但值是地址），可以通过形参影响实参。</li>\n</ol>\n<h2 id=\"递归机制（recursion）\"><a href=\"#递归机制（recursion）\" class=\"headerlink\" title=\"递归机制（recursion）\"></a>递归机制（recursion）</h2><p>递归调用的本质，是方法的调用</p>\n<ol>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310164428690.png\" alt=\"image-20220310164428690\"></li>\n<li>栈是先进后出，先出后进（所以图中的test栈2先输出，然后是3，4）</li>\n<li>每次这个栈内的方法执行完成后，外边的方法（图中test方法）都会执行一边</li>\n<li>哪里调用就返回给哪里</li>\n</ol>\n<h3 id=\"阶乘（factorial）\"><a href=\"#阶乘（factorial）\" class=\"headerlink\" title=\"阶乘（factorial）\"></a>阶乘（factorial）</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310203253490.png\" alt=\"image-20220310203253490\"></p>\n<h3 id=\"递归调用的规则\"><a href=\"#递归调用的规则\" class=\"headerlink\" title=\"递归调用的规则\"></a>递归调用的规则</h3><ol>\n<li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li>\n<li>方法的局部变量是独立的，不会相互影响，比如n变量</li>\n<li>如果方法中使用的是引用类型变量（比如数组，或者对象），就会共享该引用类型的数据。</li>\n<li>递归必须像退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:)</li>\n<li>当一个方法执行完毕，或者遇到return，就会执行完毕或者返回时，该方法也就执行</li>\n</ol>\n<h3 id=\"斐波拉契数练习\"><a href=\"#斐波拉契数练习\" class=\"headerlink\" title=\"斐波拉契数练习\"></a>斐波拉契数练习</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> basics;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">exerciseRecursion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">T</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> t.racursionNum(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">racursionNum</span><span class=\"params\">(<span class=\"type\">int</span> n1)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n1 == <span class=\"number\">1</span> || n1 == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> racursionNum(n1 - <span class=\"number\">1</span>) + racursionNum(n1 - <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解析图</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310225335626.png\" alt=\"image-20220310225335626\"></p>\n<h2 id=\"重载（overload）\"><a href=\"#重载（overload）\" class=\"headerlink\" title=\"重载（overload）\"></a>重载（overload）</h2><p>介绍：java允许同一个类中，多个同名方法的存在，但要求形参列表不一致！！！</p>\n<p>好处：</p>\n<ol>\n<li>减轻了起名的麻烦</li>\n<li>减轻了记名的麻烦</li>\n</ol>\n<p>注意细节：</p>\n<ol>\n<li>方法名：必须相同</li>\n<li>形参参列表：必须不同（参数类型或个数或顺序，至少有一样不同）</li>\n<li>返回类型：无要求</li>\n</ol>\n<h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><p>介绍：</p>\n<p>java允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p>\n<p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">访问修饰符\t 返回类型\t方法名（数据类型 .... 参数名）&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">hasMestod</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    public int sum(int a,int b)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return a+b;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    public int sum(int a,int b,int c)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return a+b+c;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    public int sum(int a,int b,int c,int d)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return a+b+c+d;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    ........以此类推</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    可变参数优化</span></span><br><span class=\"line\"><span class=\"comment\">//    上面三个方法名称相同，功能相同，只是参数个数不同----&gt;使用可变参数优化</span></span><br><span class=\"line\"><span class=\"comment\">//    1.int...表示接收的是可变参数，类型时int，即可以接收多个int（0-多）</span></span><br><span class=\"line\"><span class=\"comment\">//    2.使用可变参数时，可以当做数组；来使用，即nums 可以当做数组使用</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"type\">int</span> <span class=\"title function_\">sum1</span><span class=\"params\">(<span class=\"type\">int</span>... nums)</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;接收的个数为&quot;</span>+nums.length);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class=\"line\">            sum=sum+nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意事项：</p>\n<ol>\n<li><p>可变参数的实参可以为0或任意多个</p>\n</li>\n<li><p>可变参数的实参可以为数组</p>\n</li>\n<li><p>可变参数的本质就是数组</p>\n</li>\n<li><p>可变参数可以和普通类型的参数<u><em>一起放在形参列表</em></u>，但必须保证可变参数在最后</p>\n</li>\n<li><p>一个形参列表中只能出现一个可变参数</p>\n</li>\n</ol>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><ol>\n<li>在java中，主要的变量就是属性（成员变量）和局部变量</li>\n<li>我们说的局部变量一般是指在成员方法中定义的变量</li>\n<li>作用域的分类<ol>\n<li>全局变量：也就是属性，作用域为整个整体</li>\n<li>局部变量：也就是除了属性以外的其他变量，作用域为定义它的代码块中</li>\n</ol>\n</li>\n<li>全局变量可以不赋值，直接使用，因为有默认值（也可指定值），局部变量必须赋值后，才能使用，因为没有默认值。    、</li>\n</ol>\n<p>注意事项和细节</p>\n<ol>\n<li>属性和局部变量可以重名，访问时遵循就近原则</li>\n<li>在一个作用域中，比如在同一个成员方法中，两个局部变量，不能重</li>\n<li>属性生命周期较长，伴随对象的创建而创建，伴随对象的死亡而死亡。局部变量，生命周期较短，伴随它的代码块的执行而创建，伴随代码块的结束而死亡</li>\n<li>作用域范围不同：<ol>\n<li>全集变量&#x2F;属性：可以被本类使用，或其他类使用（通过对象调用）</li>\n<li>局部变量：智能在本类中对应的方法中使用</li>\n</ol>\n</li>\n<li>修饰符不同<ol>\n<li>全局变量&#x2F;属性可以加修饰符</li>\n<li>局部变量不可以加修饰符</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"构造器-constructor\"><a href=\"#构造器-constructor\" class=\"headerlink\" title=\"构造器(constructor)\"></a>构造器(constructor)</h2><p>基本介绍：构造方法又称构造器(constructor)，是类的一种特殊方法，它的主要作用是完成对<span style = \"color:red\">新的对象初始化。</span></p>\n<p>特点：</p>\n<ol>\n<li>方法和类名相同</li>\n<li>没有返回值</li>\n<li>在创建对象时，系统会自动调用该类的构造器完成对对象的初始化</li>\n</ol>\n<p>需求案例：</p>\n<p>案例1:创建一个人类的对象，显示把一个对象创建好后，再给他的年龄姓名等属性赋值，如果现在我要求，在创建人类对象的时候，就直接指定这个对象的年龄和姓名。 此时可以使用构造器</p>\n<p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[修饰符] 方法名(形参列)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t方法体;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>构造器的修饰符可以默认，也可是public，protected，private</li>\n<li>构造器没有返回值,也不能写void</li>\n<li>方法名和类名必须一样</li>\n<li>参数列表和成员方法一样的规则</li>\n<li>构造器的调用<span style = \"color:red\">系统完成</span></li>\n</ol>\n<p>细节：</p>\n<ol>\n<li>一个类可以定义多个不同的构造器，即构造器的重载<ul>\n<li>比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄</li>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314163037454.png\" alt=\"image-20220314163037454\"></li>\n</ul>\n</li>\n<li>构造器是完成对象的初始化，并不是创建对象</li>\n<li>如果程序员没有定义构造器，系统会自动生成一个默认的无参构造器(也叫默认构造方法),比如Person(){ }</li>\n<li>一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的午餐构造器，除非显示的定义一下，即自己再手写一边Person(){ }</li>\n</ol>\n<p>对象创建流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span><span class=\"number\">90</span>;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tPerson(String n , <span class=\"type\">int</span> a)&#123;</span><br><span class=\"line\">\tname = n;</span><br><span class=\"line\">\tage = a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;zhangsan&quot;</span> , <span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png\" alt=\"image-20220314215432778\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 先在方法区加载Person类</span><br><span class=\"line\">2. 在堆中开辟一个空间，内部存放形参</span><br><span class=\"line\">   1. 先初始化默认值，0和null，然后再将值赋进去</span><br><span class=\"line\">   2. 当执行到构造器的时候，值才会赋进去</span><br><span class=\"line\">   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值</span><br><span class=\"line\">3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>加载Person.class，只会加载一次。</p>\n</li>\n<li><p>在堆中分配空间(地址)</p>\n</li>\n<li><p>完成对象初始化</p>\n<p>3.1 默认初始化 age&#x3D;0\tname &#x3D; null\t</p>\n<p>3.2 显示初始化 age&#x3D;90,name&#x3D;null,</p>\n<p>3.3 构造器的初始化 age&#x3D;20，name&#x3D;zhangsan</p>\n</li>\n<li><p>在对象堆中的地址，返回给p(也可理解成对象的引用)</p>\n</li>\n</ol>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t旧方法：</span></span><br><span class=\"line\"><span class=\"comment\">\t\tint age =90;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tString name;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tPerson(String n , int a)&#123; //此时形参的起名不能与属性名一致</span></span><br><span class=\"line\"><span class=\"comment\">\t\tname = n;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tage = a;</span></span><br><span class=\"line\"><span class=\"comment\">     1.如果可以将构造器的形参，直接写成属性名就好了</span></span><br><span class=\"line\"><span class=\"comment\">     2.但是会出现一个问题，根据变量的作用域原则</span></span><br><span class=\"line\"><span class=\"comment\">     3.构造器的name 是局部变量，而不是属性。相当于自己赋给自己</span></span><br><span class=\"line\"><span class=\"comment\">     4.构造器的age 是局部变量，而不是属性、</span></span><br><span class=\"line\"><span class=\"comment\">     5.==&gt;此时使用this关键字\t</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name,<span class=\"type\">int</span> age)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name<span class=\"comment\">/*表示当前对象的属性*/</span> = name;<span class=\"comment\">/*表示当前构造器的局部变量*/</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>介绍：</p>\n<p>java虚拟机会给每个对象分配this，代表当前对象。</p>\n<p>分析图：</p>\n<p>每一个对象都有一个隐藏的属性this</p>\n<p>这个this它指向自己</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314222909415.png\" alt=\"image-20220314222909415\"></p>\n<p>简单说，哪个对象调用this就指向哪个对象</p>\n<p>注意事项：</p>\n<ol>\n<li><p>this关键字可以用来访问本类的属性，方法，构造器</p>\n</li>\n<li><p>this用于区分当前类的属性和局部变量</p>\n</li>\n<li><p>访问成员方法的语法：this.方法名(参数列表)；</p>\n</li>\n<li><p>访问构造器语法：this(参数列表);&#x2F;&#x2F;注意，只能在构造器中访问另外一个构造器(当有访问构造器的语法this时，必须放在构造器语句里的第一行 )</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>class T{<br>String name;<br>int age;<br>&#x2F;&#x2F;无参构造器<br>public T(){<br>    &#x2F;&#x2F;当执行无参构造器时，我们想去访问有参构造器<br>    this(“zhangsan”,12);&#x2F;&#x2F;这样访问有参构造器<br>   &#x2F;&#x2F;当有访问构造器的语法this时，必须放在构造器语句里的第一行<br><br>    System.out.println(“T() 构造器”);<br><br><br><br>}<br><br>&#x2F;&#x2F;有参构造器<br>public T(String name,int age){<br>    System.out.println(“T(String name,int age) 构造器”);<br>}<br>}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. this不能再类定义的外部使用，只能在类定义的范围中使用</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">package chapterObject;</span><br><span class=\"line\">/*</span><br><span class=\"line\">* 创建一个employee类</span><br><span class=\"line\">* 属性有（名字，性别，年龄，职位，薪水）</span><br><span class=\"line\">* 提供三个构造器</span><br><span class=\"line\">* 1.名字，性别，年龄，职位，薪水</span><br><span class=\"line\">* 2.名字，性别，年龄</span><br><span class=\"line\">* 3.职位，薪水*/</span><br><span class=\"line\">public class ObjectHomeWork06 &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Employee&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    char sex;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    String post;</span><br><span class=\"line\">    double salary;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Employee(String name,char sex,int age)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Employee(String post,double salary)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        this.post = post;</span><br><span class=\"line\">        this.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Employee(String name,char sex,int age,String post,double salary)&#123;</span><br><span class=\"line\">        this(name, sex, age);</span><br><span class=\"line\">//        因为构造器调用只能放在第一行，所以最多只能调用一个构造器</span><br><span class=\"line\">        this.post = post;</span><br><span class=\"line\">        this.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//    public Employee(String name,char sex,int age,String post,double salary)&#123;</span><br><span class=\"line\">//        this.name = name;</span><br><span class=\"line\">//        this.sex = sex;</span><br><span class=\"line\">//        this.age = age;</span><br><span class=\"line\">//        this.post = post;</span><br><span class=\"line\">//        this.salary = salary;</span><br><span class=\"line\">//</span><br><span class=\"line\">//    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"面向对象（中级）\"><a href=\"#面向对象（中级）\" class=\"headerlink\" title=\"面向对象（中级）\"></a>面向对象（中级）</h1><h2 id=\"idea\"><a href=\"#idea\" class=\"headerlink\" title=\"idea\"></a>idea</h2><h3 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自定义快捷键</span><br><span class=\"line\">settings - - &gt; Keymap</span><br><span class=\"line\">删除当前行 ctrl+y  自定义 alt+D</span><br><span class=\"line\">复制当前行 ctrl+d</span><br><span class=\"line\"></span><br><span class=\"line\">快速格式化代码 ctrl + alt + L</span><br><span class=\"line\">快速运行程序  自定义alt + R</span><br><span class=\"line\"></span><br><span class=\"line\">查看类的层级关系 ctrl + H</span><br><span class=\"line\">将光标放在一个方法上，输入ctrl+b，可以定位到该方法的上</span><br><span class=\"line\">自动分配变量名   在后面添加.var</span><br><span class=\"line\">例：new Scanner(System.in).var+回车</span><br><span class=\"line\">会生成Scanner scanner = new Scanner(System.in);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><p> 设置路径</p>\n<p>file -&gt; settings -&gt; editor -&gt; live templates-&gt;</p>\n<p>可以自己自定义，也可查看预设的模板</p>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>三大作用：</p>\n<ol>\n<li>区分相同名字的类</li>\n<li>当类不同的时候，可以很好的管理</li>\n<li>控制访问范围</li>\n</ol>\n<p>基本语法：</p>\n<p>package com.xxx;</p>\n<ol>\n<li>package 关键字，表示打包</li>\n<li>com.xxx:表示包名</li>\n</ol>\n<p>包的本质</p>\n<p>就是创建不同的文件&#x2F;目录保存文件</p>\n<h3 id=\"包的命名\"><a href=\"#包的命名\" class=\"headerlink\" title=\"包的命名\"></a>包的命名</h3><p>规则：</p>\n<p>智能包含数字，字母，下划线，小圆点，但不能用数字开头，不能是关键字或保留字</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demo.class.exec1 <span class=\"comment\">//falsee不允许有关键字class</span></span><br><span class=\"line\">demo<span class=\"number\">.12</span>\t\t<span class=\"comment\">//false,不能数字开头</span></span><br><span class=\"line\">demo.ad12.oa <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>规范</p>\n<p>一般是小写字母+小圆点</p>\n<p>com.公司名.项目名.业务模块名</p>\n<p>例：com.alibaba.taobao.login</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.sina.crm.user</span><br><span class=\"line\">等等</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"java常用的包\"><a href=\"#java常用的包\" class=\"headerlink\" title=\"java常用的包\"></a>java常用的包</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang <span class=\"comment\">// lang包是基础包，默认引入，不用手动输入</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.util <span class=\"comment\">//系统提供的工具包，工具类，例如Scanner类</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.net <span class=\"comment\">// 网络包，网络开发</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.awt  <span class=\"comment\">// 是做java的界面开发，GUI</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>包的引入</p>\n<p>建议需要什么类就引入什么类，不建议(java.util.* )全部引入</p>\n<h2 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h2><p>介绍</p>\n<p>java提供了四种访问控制修饰符号控制方法和属性(成员变量)的访问权限(范围)</p>\n<ol>\n<li>公开级别：public 修饰，对外公开</li>\n<li>受保护级别：用protected修饰，对子类和统一包中的类公开</li>\n<li>默认级别：没有修饰符号，向同一包的内公开</li>\n<li>私有级别：用private修饰，只有类本身可以访问，不对外公开</li>\n</ol>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220317140746725.png\" alt=\"image-20220317140746725\"></p>\n<p>注意事项：</p>\n<ol>\n<li>修饰符可以用修饰类中的属性，成员方法以及类</li>\n<li>只有默认的和public才能修饰类，并且遵循上述访问权限的特点</li>\n<li>成员方法访问规则和属性完全一样</li>\n</ol>\n<h2 id=\"封装（重要）\"><a href=\"#封装（重要）\" class=\"headerlink\" title=\"封装（重要）\"></a><u><em>封装</em></u>（重要）</h2><p>封装（encapsulation）就是把抽象出来的数据[<strong>属性</strong>]和对数据的操作[<strong>方法</strong>]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[<strong>方法</strong>]，才能对数据进行操作。</p>\n<p><strong>封装的好处</strong></p>\n<ol>\n<li>隐藏实现细节  方法(连接数据库)&lt;—-调用(传入参数)</li>\n<li>可对数据进行验证，保证安全合理</li>\n</ol>\n<p>封装的实现步骤 ( 三 步 ) </p>\n<ol>\n<li><p>将属性进行私有化，private</p>\n</li>\n<li><p>提供一个公共的set方法，对属性进行判断并赋值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setXXX</span><span class=\"params\">(类型\t参数名)</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//加入数据验证的业务逻辑</span></span><br><span class=\"line\">属性 = 参数名；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提供一个公共的get方法，用于获取属性的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getXXX</span><span class=\"params\">(类型\t参数名)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> xx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"继承（重要）extends\"><a href=\"#继承（重要）extends\" class=\"headerlink\" title=\"继承（重要）extends\"></a><u><em>继承</em></u>（重要）extends</h2><h3 id=\"继承作用：\"><a href=\"#继承作用：\" class=\"headerlink\" title=\"继承作用：\"></a>继承作用：</h3><p>解决代码复用性</p>\n<h3 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>相当多个类存在相同的属性（变量）  和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些属性和方法，只需通过extend来声明继承父类即可</p>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 子类 extends 父类&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1.</span> 子类会自动拥有父类定义的方法</span><br><span class=\"line\"><span class=\"number\">2.</span> 父类又叫超类，基类</span><br><span class=\"line\"><span class=\"number\">3.</span> 子类又叫派生类</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>示意图</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318104942566.png\" alt=\"image-20220318104942566\"></p>\n<h3 id=\"注意事项-3\"><a href=\"#注意事项-3\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li><p>子类继承了所有的属性和方法，但是私有属性不能再子类直接访问，需要通过公共方法访问</p>\n</li>\n<li><p>子类必须调用父类的构造器，完成父类的初始化</p>\n</li>\n<li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中调用super去指定使用父类的那个构造器完成对父类的初始化工作，否则编译不通过</p>\n</li>\n<li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下{super ( 参数 ) }</p>\n</li>\n<li><p>super在使用时，需要放在第一行。super只能在构造器中使用</p>\n</li>\n<li><p>super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器</p>\n</li>\n<li><p>java所有类都是Object的子类，是所有类的基类   Ctrl+H可以看到类的继承关系</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318165601997.png\" alt=\"image-20220318165601997\"></p>\n</li>\n<li><p>父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类)</p>\n</li>\n<li><p>子类对多只能继承一个父类(指直接传承)，即java中是单继承机制。</p>\n</li>\n<li><p>不能滥用继承，子类和父类之间必须满足is-a的逻辑关系</p>\n<ol>\n<li>person is a music</li>\n<li>person music</li>\n<li>music extends  person</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"继承的本质（分析）\"><a href=\"#继承的本质（分析）\" class=\"headerlink\" title=\"继承的本质（分析）\"></a>继承的本质（分析）</h3><p>当子类创建号对象以后，建立查找关系</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//案例：</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Grandpa</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;爷爷&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">hobby</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;旅游&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">GrandPa</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;大头爸爸&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> <span class=\"number\">30</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Father</span>&#123;</span><br><span class=\"line\"> \t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;儿子&quot;</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"type\">Son</span> <span class=\"variable\">son</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>();</span><br><span class=\"line\"> son.name=?      <span class=\"comment\">//儿子</span></span><br><span class=\"line\"> son.age = ?\t <span class=\"comment\">//30\t</span></span><br><span class=\"line\"> son.hobby = ?\t <span class=\"comment\">// 旅游</span></span><br><span class=\"line\"> <span class=\"comment\">//\t\t1. 此时请注意，要按照查找关系返回信息</span></span><br><span class=\"line\"> <span class=\"comment\">/*     2. 首先看子类是否有该属性</span></span><br><span class=\"line\"><span class=\"comment\"> \t\t3. 如果子类有这个属性，并且可以访问，则返回信息</span></span><br><span class=\"line\"><span class=\"comment\"> \t\t4. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回)</span></span><br><span class=\"line\"><span class=\"comment\"> \t\t5. 如果父类没有4的规则，继续找上级，直到object</span></span><br><span class=\"line\"><span class=\"comment\">   */</span>  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内存原理图：\"><a href=\"#内存原理图：\" class=\"headerlink\" title=\"内存原理图：\"></a>内存原理图：</h3><p> <img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320170828664.png\" alt=\"image-20220320170828664\"></p>\n<h2 id=\"Super\"><a href=\"#Super\" class=\"headerlink\" title=\"Super\"></a>Super</h2><h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>super代表父类的构造器，用于访问父类的属性，方法，构造器</p>\n<h3 id=\"基本语法-1\"><a href=\"#基本语法-1\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><ol>\n<li>访问父类的属性，但不能访问父类的private属性[案例]<ul>\n<li>super.属性名；</li>\n</ul>\n</li>\n<li>访问父类的方法名，不能访问父类的private方法<ul>\n<li>super.方法名(参数列表);</li>\n</ul>\n</li>\n<li>访问父类的构造器(这点前面用过);<ul>\n<li>super(参数列表);</li>\n<li>只能放在构造器的第一句并只能出现一句</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"细节和注意事项\"><a href=\"#细节和注意事项\" class=\"headerlink\" title=\"细节和注意事项\"></a>细节和注意事项</h3><ol>\n<li><p>调用父类的构造器的好处（分工明确，弗雷属性由父类初始化，子类的属性由子类初始化）</p>\n</li>\n<li><p>当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>案例<br>class A{<br>public void cal(){<br>    System.out.println(“a类的cal方法”);<br>}<br>}<br>class B{<br>public void sum(){<br>    System.out.println(“b类的sum方法”);<br>&#x2F;*\t<br>    此时有三种方法调用cal<br>    1. 找cal方法时，顺序是：先找本类，如果有，开始调用。<br>    2. 如果没有。则找父类（如果有则调用）<br>    3. 如果父类没有则继续找父类的父类。以此类推。直到Object类‘<br><br>    提示：如果查找的过程中找到了，但不能访问，则报错<br>         如果查找的过程中没找到。则提示没找到<br><em>&#x2F;<br>    cal();<br><br><br>    this.cal();&#x2F;&#x2F;等价cal（）；<br><br>     &#x2F;</em><br>    跳过本类直接查找父类<br>    其他规则一样<br>    *&#x2F;<br>    super.cal();<br><br>}<br>}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。（相当于跳过本类，从父类开始按规则找。父类找不到找爷爷类·····）</span><br><span class=\"line\"></span><br><span class=\"line\">### super和this的比较</span><br><span class=\"line\"></span><br><span class=\"line\">![image-20220320190806497](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190806497.png)</span><br><span class=\"line\"></span><br><span class=\"line\">![image-20220320190935663](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190935663.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## 重写（overwrite）</span><br><span class=\"line\"></span><br><span class=\"line\">### 基本介绍</span><br><span class=\"line\"></span><br><span class=\"line\">简单地说：方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这方法覆盖了父类的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">### 案例</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">\tpublic void cry()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;叫&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\">\t1. 因为dog是Animal的子类</span><br><span class=\"line\">    2. Dog的cry方法和Animal的cry方法定义形式一样(名称，返回类型，参数)</span><br><span class=\"line\">    3. 这时我们就说Dog的cry方法，重写了Animal的cry方法</span><br><span class=\"line\">  */      </span><br><span class=\"line\">class dog extends Animal&#123;</span><br><span class=\"line\">\tpublic void cry()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;汪汪汪&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"注意事项和使用细节\"><a href=\"#注意事项和使用细节\" class=\"headerlink\" title=\"注意事项和使用细节\"></a>注意事项和使用细节</h3><ol>\n<li><p>子类的方法的形参列表，方法名称，要和父类的方法的参数，方法名称完全一样。</p>\n</li>\n<li><p>子类方法的返回类型和父类方法返回类型一样，或者父类返回类型的子类</p>\n<p>比如 父类返回类型是Object，子类方法返回类型是String</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">getInfo</span><span class=\"params\">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getInfo</span><span class=\"params\">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>子类方法不能缩小父类方法的访问权限public &gt; protected &gt; 默认(default ) &gt; private </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">sayOk</span><span class=\"params\">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayOk</span><span class=\"params\">()</span>&#123;&#125;<span class=\"comment\">//这样是可以的，但不能缩小</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"重写与重载的区别\"><a href=\"#重写与重载的区别\" class=\"headerlink\" title=\"重写与重载的区别\"></a>重写与重载的区别</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320211941817.png\" alt=\"image-20220320211941817\"></p>\n<p>练习</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> seatWork;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">override</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 1. 编写一个Person类，包括属性/private（name,age），</span></span><br><span class=\"line\"><span class=\"comment\">    * 构造器，方法say（返回组我介绍的字符串）</span></span><br><span class=\"line\"><span class=\"comment\">    * 2. 编写一个student类，继承Person类，增加id，score属性/private，</span></span><br><span class=\"line\"><span class=\"comment\">    * 以及构造器，定义say方法（返回自我介绍信息）</span></span><br><span class=\"line\"><span class=\"comment\">    * 3. 在main方法中，分别创建Person和Student对象，调用say方法输出自我介绍*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;lisi&quot;</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">say1</span> <span class=\"operator\">=</span> person.say();</span><br><span class=\"line\">        System.out.println(say1);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">student</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">12</span>,<span class=\"number\">12345</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">say</span> <span class=\"operator\">=</span> student.say();</span><br><span class=\"line\">        System.out.println(say);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name, <span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是父类&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(&quot;name&quot;+getName()+&quot;\\t&quot;+&quot;age&quot;+getAge()+&quot;\\t&quot;);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;name&quot;</span>+getName()+<span class=\"string\">&quot;\\t&quot;</span>+<span class=\"string\">&quot;age&quot;</span>+getAge()+<span class=\"string\">&quot;\\t&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">double</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Student</span><span class=\"params\">(String name, <span class=\"type\">int</span> age, <span class=\"type\">int</span> id, <span class=\"type\">double</span> score)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getScore</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setScore</span><span class=\"params\">(<span class=\"type\">double</span> score)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.say()+<span class=\"string\">&quot;id&quot;</span>+getId()+<span class=\"string\">&quot;\\t&quot;</span>+<span class=\"string\">&quot;score&quot;</span>+getScore()+<span class=\"string\">&quot;\\t&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(&quot;name&quot;+getName()+&quot;\\t&quot;+&quot;age&quot;+getAge()+&quot;\\t&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//        +&quot;id&quot;+getId()+&quot;\\t&quot;+&quot;score&quot;+getScore()+&quot;\\t&quot;);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多态（重要）\"><a href=\"#多态（重要）\" class=\"headerlink\" title=\"多态（重要）\"></a><u><em>多态</em></u>（重要）</h2><p> 多态可以提高代码的复用性</p>\n<h3 id=\"基本介绍-1\"><a href=\"#基本介绍-1\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>多态(多种)（状态）</p>\n<ol>\n<li>方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础之上的额</li>\n</ol>\n<h3 id=\"多态的具体体现\"><a href=\"#多态的具体体现\" class=\"headerlink\" title=\"多态的具体体现\"></a>多态的具体体现</h3><h4 id=\"方法上体现\"><a href=\"#方法上体现\" class=\"headerlink\" title=\"方法上体现\"></a>方法上体现</h4><ol>\n<li><p>方法的多态</p>\n<p>重写和重载就体现多态</p>\n</li>\n<li><p>案例说明</p>\n</li>\n<li><p>重载上体现</p>\n<ol>\n<li>对某一方法，传入不同的参数，调用不同的方法</li>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320215939959.png\" alt=\"image-20220320215939959\"></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"对象的多态（核心，难点，重点）\"><a href=\"#对象的多态（核心，难点，重点）\" class=\"headerlink\" title=\"对象的多态（核心，难点，重点）\"></a>对象的多态（核心，难点，重点）</h3><p>要记住几点：</p>\n<ol>\n<li><p>一个对象的编译类型和运行类型可以不一致</p>\n<ul>\n<li>&#96;&#96;&#96;<br>例如：<br>Animal animal &#x3D; new Dog();【animal编译类型时Animal，运行类型是Dog】<br>animal  &#x3D; new Cat(); \t【animal的运行类型变成了Cat，编译类型仍然是Animal】<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 编译类型在定义对象时，就确定了，不能改变</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     Animal animal = new Dog()   编译类型在定以后就不能改变，所以可以直接用引用接收其他的运行类型</span><br><span class=\"line\">     animal  = new Cat();</span><br><span class=\"line\">     animal  = new PIG();`````</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>运行类型是可以变化的</p>\n</li>\n<li><p>编译类型看定义时 &#x3D; 号的左边，运行类型看 &#x3D; 号的右边</p>\n<ul>\n<li>&#96;&#96;&#96;<br>Animal animal &#x3D; new Dog()  animal就是变异类型，dog就是运行类型<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">//编译类型和运行类型的体现</span><br><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">\tpublic void say()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;动物在叫&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Cat extends Animal&#123;</span><br><span class=\"line\">\tpublic void say()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;猫在叫&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Dog extends Animal&#123;</span><br><span class=\"line\">\tpublic void say()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;狗在叫&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class test&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\t//animal编译类型就是Animal，运行类型Dog</span><br><span class=\"line\">\t\tAnimal animal = new Dog();</span><br><span class=\"line\">\t\tanimal.say();//因为运行类型是dog，animal的运行类型是dog，所以输出dog类的say方法。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        animal = new Cat();</span><br><span class=\"line\">        animal.say();//此时animal的运行类型是cat，所以输出cat类的say方法；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"注意事项和细节-1\"><a href=\"#注意事项和细节-1\" class=\"headerlink\" title=\"注意事项和细节\"></a>注意事项和细节</h3><p>多态的前提是：两个对象(类)存在继承关系</p>\n<h4 id=\"多态的向上转型\"><a href=\"#多态的向上转型\" class=\"headerlink\" title=\"多态的向上转型\"></a>多态的向上转型</h4><ol>\n<li><p>本质：父类的引用指向了子类的对象</p>\n</li>\n<li><p>语法：父类类型    引用名 &#x3D; new    子类类型()；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Father</span> <span class=\"variable\">father</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>();</span><br><span class=\"line\"><span class=\"comment\">//此时可称为向上转型</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特点：编译类型看左边，运行类型看右边</p>\n<p><span style=\"color:red;\">可以调用父类中的所有成员(需要遵循访问权限),</span></p>\n<p><span style=\"color:red;\">不能调用子类中特有成员</span></p>\n<p>（<span style=\"color:red;\">因为在编译阶段，不能调用那些成员，是由编译类型来决定的。</span>）</p>\n<p>最终运行效果按子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法</p>\n<p>然后调用，与前面的方法调用规则一致</p>\n</li>\n</ol>\n<h4 id=\"多态的向下转型\"><a href=\"#多态的向下转型\" class=\"headerlink\" title=\"多态的向下转型\"></a>多态的向下转型</h4><p>语法：子类类型   引用名 &#x3D; (子类类型) 父类引用;</p>\n<ol>\n<li><p>只能强转父类的引用，不能强转父类的对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//此时的向上转型</span></span><br><span class=\"line\"><span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">adimal.a();</span><br><span class=\"line\"><span class=\"comment\">//等等方法，这些方法只能调用父类子类的共同拥有的方法，不能调用子类的特殊方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//此时这样写</span></span><br><span class=\"line\"><span class=\"comment\">//强转一下，上述父类的引用</span></span><br><span class=\"line\"><span class=\"type\">Cat</span> <span class=\"variable\">cat</span> <span class=\"operator\">=</span>  (Cat)animal；</span><br><span class=\"line\">    cat.catchMouse();</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>要求父类的引用必须指向的是当前目标类型的对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//也就是说animal必须是指向对应的子类</span></span><br><span class=\"line\"><span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();<span class=\"comment\">//必须有这句话</span></span><br><span class=\"line\"><span class=\"type\">Cat</span> <span class=\"variable\">cat</span> <span class=\"operator\">=</span>  (Cat)animal；<span class=\"comment\">//才能强转成cat类型</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>可以调用子类类型中所有的成员</p>\n</li>\n</ol>\n<h4 id=\"属性没有重写之说\"><a href=\"#属性没有重写之说\" class=\"headerlink\" title=\"属性没有重写之说\"></a>属性没有重写之说</h4><p>属性的值看编译类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例:</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] atgs)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">A</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">B</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>.out.print(a.count);</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">//此时输入的值为1</span></span><br><span class=\"line\">        <span class=\"comment\">//因为属性的值是看编译类型</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"type\">B</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">B</span>();</span><br><span class=\"line\">        <span class=\"keyword\">public</span>.out.print(a.count);</span><br><span class=\"line\">        <span class=\"comment\">//此时输出2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"instanceOf比较操作符，\"><a href=\"#instanceOf比较操作符，\" class=\"headerlink\" title=\"instanceOf比较操作符，\"></a>instanceOf比较操作符，</h4><p>用于判断对象的类型是否为xx类型或xx类型的子类型</p>\n<p>判断对象的运行类型是否为xx类型，或这个xx类型的子类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t count = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] atgs)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">BB</span> <span class=\"variable\">bb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BB</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>.out.print(bb <span class=\"keyword\">instanceof</span> BB);<span class=\"comment\">//true</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>.out.print(bb <span class=\"keyword\">instanceof</span> AA);<span class=\"comment\">//true</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//编译类型AA ，运行类型BB</span></span><br><span class=\"line\">     <span class=\"type\">AA</span> <span class=\"variable\">aa</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AA</span>();</span><br><span class=\"line\">        <span class=\"keyword\">public</span>.out.print(aa <span class=\"keyword\">instanceof</span> AA);<span class=\"comment\">//true</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span>.out.print(aa <span class=\"keyword\">instanceof</span> BB);<span class=\"comment\">//true </span></span><br><span class=\"line\">        \t</span><br><span class=\"line\">     <span class=\"type\">Object</span> <span class=\"variable\">obj</span>   <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">public</span>.out.print(obj <span class=\"keyword\">instanceof</span> AA);<span class=\"comment\">//false,因为obj不是AA类，也不是AA的子类</span></span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;&#125;\t</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"java动态绑定机制-重要\"><a href=\"#java动态绑定机制-重要\" class=\"headerlink\" title=\"java动态绑定机制(重要)\"></a>java动态绑定机制(重要)</h4><ol>\n<li>当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</li>\n<li>当调用对象属性时，没有动态绑定机制，哪里声明，那里使用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//2</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sum</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//3  </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> geti()+<span class=\"number\">10</span>;<span class=\"comment\">//5</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sum1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i+<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">geti</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sum1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i+<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//4</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">geti</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">A</span> <span class=\"variable\">a</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">B</span>()</span><br><span class=\"line\">   <span class=\"comment\">//1</span></span><br><span class=\"line\">a.sum <span class=\"comment\">//40</span></span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">//因为执行到sum方法，开始准备执行geti方法时，因为有java动态绑定的机制，会跳到b类的geti方法执行</span></span><br><span class=\"line\">    <span class=\"comment\">//再根据继承跳回去</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"多态的应用\"><a href=\"#多态的应用\" class=\"headerlink\" title=\"多态的应用\"></a>多态的应用</h4><p>1）多态数组</p>\n<p>数组的定义类型为父类类型，里面保存的实际元素类型为子类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> seatWork;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.PrivateKey;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">polySeatwork</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 要求创建一个person对象name ，age</span></span><br><span class=\"line\"><span class=\"comment\">        * 两个student 对象和2个teacher对象，统一放在数组中，</span></span><br><span class=\"line\"><span class=\"comment\">        * 并调用每个对象的say方法</span></span><br><span class=\"line\"><span class=\"comment\">        * */</span></span><br><span class=\"line\">        Person1[] person1s = <span class=\"keyword\">new</span> <span class=\"title class_\">Person1</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\">        person1s[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Person1</span>(<span class=\"string\">&quot;human&quot;</span>,<span class=\"number\">00</span>);</span><br><span class=\"line\">        person1s[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Student1</span>(<span class=\"string\">&quot;tom1&quot;</span>,<span class=\"number\">12</span>,<span class=\"number\">150</span>);</span><br><span class=\"line\">        person1s[<span class=\"number\">2</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Student1</span>(<span class=\"string\">&quot;tom2&quot;</span>,<span class=\"number\">13</span>,<span class=\"number\">143</span>);</span><br><span class=\"line\">        person1s[<span class=\"number\">3</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">teacher</span>(<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">30</span>,<span class=\"number\">4000</span>);</span><br><span class=\"line\">        person1s[<span class=\"number\">4</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">teacher</span>(<span class=\"string\">&quot;lisi&quot;</span>,<span class=\"number\">28</span>,<span class=\"number\">5000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//循环遍历多态数组，调用say方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; person1s.length ; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//老韩提示， person1s[i]的编译类型是Person，</span></span><br><span class=\"line\">            <span class=\"comment\">// 运行类型是根据实际情况而变化</span></span><br><span class=\"line\">            System.out.println(person1s[i].say());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person1</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Person1</span><span class=\"params\">(String name, <span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;name = &quot;</span>+name+<span class=\"string\">&quot;age = &quot;</span>+age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student1</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Person1</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">double</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Student1</span><span class=\"params\">(String name, <span class=\"type\">int</span> age, <span class=\"type\">double</span> score)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getScore</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setScore</span><span class=\"params\">(<span class=\"type\">double</span> score)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">say</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.say()+<span class=\"string\">&quot;score = &quot;</span>+score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">study</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(getName()+<span class=\"string\">&quot;学习······&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">teacher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Person1</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">double</span> salary;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">teacher</span><span class=\"params\">(String name, <span class=\"type\">int</span> age, <span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getSalary</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setSalary</span><span class=\"params\">(<span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">say</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.say()+<span class=\"string\">&quot;salary = &quot;</span>+salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(getName()+<span class=\"string\">&quot;教书·············&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>案例升级：如何调用子类的特有方法，比如Teacher 有一个teach，Student有一个study方法。如何调用?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//循环遍历多态数组，调用say方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; person1s.length ; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//老韩提示， person1s[i]的编译类型是Person，</span></span><br><span class=\"line\">            <span class=\"comment\">// 运行类型是根据实际情况而变化</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//判断person1s[i]的运行类型</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( person1s[i] <span class=\"keyword\">instanceof</span> Student1)&#123;</span><br><span class=\"line\">               <span class=\"type\">Student1</span> <span class=\"variable\">student1</span> <span class=\"operator\">=</span>  (Student1)person1s[i];</span><br><span class=\"line\">               student1.say();</span><br><span class=\"line\">               <span class=\"comment\">//也可以写成一条语句</span></span><br><span class=\"line\">               ((Student1)person1s[i]).study();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (person1s[i] <span class=\"keyword\">instanceof</span> teacher)&#123;</span><br><span class=\"line\">                ((teacher)person1s[i]).teach();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;============类型有误==============&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(person1s[i].say());</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多态参数\"><a href=\"#多态参数\" class=\"headerlink\" title=\"多态参数\"></a>多态参数</h4><p>方法定义的形参类型为父类型，实参类型允许为子类类型</p>\n<ul>\n<li><p>polyParameter.java</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>package seatWork;</p>\n<p>public class polyParameter {<br>&#x2F;*<br>* 定义员工类Employee，包含姓名和月工资[private]，以及计算年工资getAnnual的方法。<br>* 普通员工和经理继承了员工，经理类多了奖金bonus属性和管理manage方法，<br>* 普通员工类多了work方法，普通员工和经理类要求分别重写getAnnual方法<br>*<br>*<br>* 测试类中添加一个方法showEmployAnnual（Employee e ),<br>* 实现获取任何员工对象的年工资，<br>* 并在main方法中调用该方法[e.getAnnual()]<br>*<br>* 测试类中添加一个方法，testWork，如果是普通员工，<br>* 则调用work方法，如果是经理，则调用manage方法<br><em>&#x2F;<br>public static void main(String[] args) {<br>    GeneralStaff staff &#x3D; new GeneralStaff(“zhangsan”, 5000);<br>    Manager manager &#x3D; new Manager(“lisi”, 5000, 10000);<br>    polyParameter polyParameter &#x3D; new polyParameter();<br>    polyParameter.showEmployAnnual(staff);<br>    polyParameter.showEmployAnnual(manager);<br><br>    polyParameter.testWork(staff);<br>    polyParameter.testWork(manager);<br><br>}<br>public void showEmployAnnual(Emplyee e){<br><br>    System.out.println(e.getAnnual());<br>}<br>&#x2F;</em><br>* 添加一个方法，testwork<br>* 如果是普通员工，则调用work方法<br>* 如果是经理则调用manage方法<br>* <em>&#x2F;<br>public void testWork(Emplyee e){<br>    if (e instanceof GeneralStaff){<br>        ((GeneralStaff) e).work();&#x2F;&#x2F;向下转型<br>    }else if (e instanceof Manager){<br>        ((Manager) e).manage();&#x2F;&#x2F;向下转型<br>    }<br>}<br>}<br>class Emplyee {<br>private String name;<br>private double salary;<br><br>public Emplyee(String name, double salary) {<br>    this.name &#x3D; name;<br>    this.salary &#x3D; salary;<br>}<br><br>public String getName() {<br>    return name;<br>}<br><br>public void setName(String name) {<br>    this.name &#x3D; name;<br>}<br><br>public double getSalary() {<br>    return salary;<br>}<br><br>public void setSalary(double salary) {<br>    this.salary &#x3D; salary;<br>}<br><br>public double getAnnual(){<br>    double tmp &#x3D; 12</em>salary;<br><br>    return tmp;<br>}<br>}</p>\n<p>class GeneralStaff extends Emplyee{</p>\n<pre><code>public GeneralStaff(String name, double salary) &#123;\n    super(name, salary);\n&#125;\n\n@Override\npublic double getAnnual() &#123;\n    return super.getAnnual();\n&#125;\n\npublic void work()&#123;\n    System.out.println(&quot;work method&quot;);\n&#125;\n</code></pre>\n<p>}<br>class Manager extends Emplyee{<br>private double bonus;<br><br>public Manager(String name, double salary,double bonus) {<br>    super(name, salary);<br>    this.bonus &#x3D; bonus;<br>}<br><br>public void manage(){<br>    System.out.println(“manage method”);<br>}<br><br>@Override<br>public double getAnnual() {<br>    return super.getAnnual()+bonus;<br>}<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## Obeject类详解</span><br><span class=\"line\"></span><br><span class=\"line\">类Object是类的层次结构的根类，每个类都使用Object作为超类，所有对象(包括数组)都实现了这个类的方法</span><br><span class=\"line\"></span><br><span class=\"line\">#### equals</span><br><span class=\"line\"></span><br><span class=\"line\">==和equals的对比</span><br><span class=\"line\"></span><br><span class=\"line\">==是一个比较运算符</span><br><span class=\"line\"></span><br><span class=\"line\">1. 既可以判断基本类型，又可以判断引用类型</span><br><span class=\"line\">2. 如果判断基本类型，判断值是否相等。例如：int i = 10; double b = 10.0;</span><br><span class=\"line\">3. 如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">equals：是Object类中的方法，只能判断引用类型，</span><br><span class=\"line\"></span><br><span class=\"line\">判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等</span><br><span class=\"line\"></span><br><span class=\"line\">案例：</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">package seatWork;</span><br><span class=\"line\"></span><br><span class=\"line\">public class equalsExercise &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Person02 person02 = new Person02(&quot;zhangsan&quot;, 123, &#x27;男&#x27;);</span><br><span class=\"line\">        Person02 person03 = new Person02(&quot;zhangsan&quot;, 123, &#x27;男&#x27;);</span><br><span class=\"line\">        //在没有重写equals方法时是不相等，此时的方法时比对是否指向同一对象</span><br><span class=\"line\">        System.out.println(person02.equals(person03));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Person02&#123;</span><br><span class=\"line\">//    判断两个Person是否相等</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private char gender;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Person02(String name, int age, char gender) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.gender = gender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public char getGender() &#123;</span><br><span class=\"line\">        return gender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setGender(char gender) &#123;</span><br><span class=\"line\">        this.gender = gender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean equals(Object obj) &#123;</span><br><span class=\"line\">//        1. 先判断两个是否指向同一对象</span><br><span class=\"line\">        if (this == obj)&#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">//        2.进行类型判断</span><br><span class=\"line\">        if (obj instanceof Person02) &#123;</span><br><span class=\"line\">//            3.向下转型，得到所有的属性信息进行比对</span><br><span class=\"line\">            Person02 person02 = (Person02) obj;</span><br><span class=\"line\">            return this.name.equals(person02.name)&amp;&amp;this.age== person02.age&amp;&amp;this.gender==person02.gender;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">//        如果不是Person类型，则直接返回false</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"hashCode\"><a href=\"#hashCode\" class=\"headerlink\" title=\"hashCode\"></a>hashCode</h4><p>介绍：</p>\n<p>返回对象的哈希码值，支持此方法是为了提高哈希表的性能</p>\n<p>实际上，由object类定义的hashCode方法确定会针对不同的对象返回不同的证书，(这一般是通过将该对象的内部地址转移换成一个整数来实现的，但是java编程语言不需要这种实现技巧)</p>\n<p>老韩六小结：</p>\n<ol>\n<li><p>提高具有哈希结构容器的效率</p>\n</li>\n<li><p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</p>\n</li>\n<li><p>两个引用，如果指向的是不同的对象，则哈希值是不一样的（极大概率不一样）</p>\n</li>\n<li><p>哈希值主要根据地址号来的！，不能完全将哈希值等价于地址</p>\n</li>\n<li><p>案例演示obj.hashCode() [测试 A obj1 &#x3D; new A(); A obj2 &#x3D; new A(); A obj3 &#x3D; obj1]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> seatWork;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">hashCodeExcise</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">A</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">        <span class=\"type\">A</span> <span class=\"variable\">a1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">        <span class=\"type\">A</span> <span class=\"variable\">a3</span> <span class=\"operator\">=</span> a;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;a.hashCode() = &quot;</span>+a.hashCode());       System.out.println(<span class=\"string\">&quot;a1.hashCode() = &quot;</span>+a1.hashCode());       System.out.println(<span class=\"string\">&quot;a3.hashCode() = &quot;</span>+a3.hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220323164744164.png\" alt=\"image-20220323164744164\"></p>\n</li>\n<li><p>后面在集合，中hashCode如果需要的话，也会重写</p>\n</li>\n</ol>\n<h4 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h4><p>介绍：</p>\n<p>默认返回：全类名+@+哈希值的十六进制，[查看object的tostring方法]</p>\n<p>子类往往会重写toString方法，用于<span style=\"color:red;background:yellow\">返回对象的属性信息</span></p>\n<p>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。</p>\n<p>当直接输出一个对象时，toString方法会被默认的调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(xxx);</span><br><span class=\"line\">等价于System.out.print(xxx.toString);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"finalize\"><a href=\"#finalize\" class=\"headerlink\" title=\"finalize()\"></a>finalize()</h4><p>介绍：</p>\n<p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</p>\n<ol>\n<li>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作</li>\n<li>什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制销毁该对象，在销毁该对象前，会先调用finalize方法</li>\n<li>垃圾回收机制的调用，是由系统来决定的(即有自己的GC算法 )，也可以通过System.gc()主动触犯垃圾回收机制</li>\n</ol>\n<h2 id=\"断点调试（debug）\"><a href=\"#断点调试（debug）\" class=\"headerlink\" title=\"断点调试（debug）\"></a>断点调试（debug）</h2><h4 id=\"提示：\"><a href=\"#提示：\" class=\"headerlink\" title=\"提示：\"></a>提示：</h4><p>在断点调试的过程中，是运行状态，是以对象运行类型来执行的</p>\n<h4 id=\"介绍：-1\"><a href=\"#介绍：-1\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h4><p>​\t断点调试是指程序在的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步一步往下调，调试过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug。</p>\n<h4 id=\"快捷键-1\"><a href=\"#快捷键-1\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h4><ul>\n<li>F7（跳入）<ul>\n<li>跳入方法内</li>\n</ul>\n</li>\n<li>F8（跳过）<ul>\n<li>逐行执行代码</li>\n</ul>\n</li>\n<li>shift+F8（跳出）<ul>\n<li>跳出方法</li>\n</ul>\n</li>\n<li>F9（resume，执行到下一个断点）</li>\n</ul>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220324141333874.png\" alt=\"image-20220324141333874\"></p>\n<h1 id=\"面向对象（高级）\"><a href=\"#面向对象（高级）\" class=\"headerlink\" title=\"面向对象（高级）\"></a>面向对象（高级）</h1><h2 id=\"类变量和类方法\"><a href=\"#类变量和类方法\" class=\"headerlink\" title=\"类变量和类方法\"></a>类变量和类方法</h2><h3 id=\"一、类变量\"><a href=\"#一、类变量\" class=\"headerlink\" title=\"一、类变量\"></a>一、类变量</h3><p>案例理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Child&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//定义一个变量count，是一个类变量（静态变量）static静态</span></span><br><span class=\"line\">    <span class=\"comment\">//该变量最大的特点就是会被Child类的所有的对象实例共享</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Child （String name）&#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">join</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(name+<span class=\"string\">&quot;加入了游戏····&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">main()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义一个变量count，统计多少小孩加入了游戏</span></span><br><span class=\"line\">    <span class=\"comment\">//传统方法，定义一个count然后统计</span></span><br><span class=\"line\">    <span class=\"comment\">//int count  = 0;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">Child</span> <span class=\"variable\">child0</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&quot;xiaoming&quot;</span>)；</span><br><span class=\"line\">        child0.join();</span><br><span class=\"line\">    \t<span class=\"comment\">//count++;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//改进后</span></span><br><span class=\"line\">    \tchild0.count++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">Child</span> <span class=\"variable\">child1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&quot;xiaoming&quot;</span>)；</span><br><span class=\"line\">        child1.join();</span><br><span class=\"line\">    \tchild1.count++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">Child</span> <span class=\"variable\">child2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&quot;xiaoming&quot;</span>)；</span><br><span class=\"line\">        child2.join();</span><br><span class=\"line\">    \tchild2.count++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//类变量可以通过类名来访问</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;共有&quot;</span>+child.count+<span class=\"string\">&quot;小孩加入了游戏&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>static变量会开辟一个独立的空间，所以new的对象空间不会再单独创建一个static变量的空间。所以这个static变量空间对于这个类的所有实例是共享的</p>\n<h4 id=\"内存分析\"><a href=\"#内存分析\" class=\"headerlink\" title=\"内存分析\"></a>内存分析</h4><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220402161426676.png\" alt=\"image-20220402161426676\"></p>\n<ol>\n<li>static变量是对象共享的</li>\n<li>不管static变量在哪<ol>\n<li>static变量是同一个类，所有对象共享</li>\n<li>static类变量，在类加载的时候就生成了</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"定义语法\"><a href=\"#定义语法\" class=\"headerlink\" title=\"定义语法\"></a>定义语法</h4><p>访问修饰符\tstatic\t数据类型\t变量名；【推荐】</p>\n<p>static\t访问修饰符\t数据类型\t变量名；</p>\n<h4 id=\"类变量访问\"><a href=\"#类变量访问\" class=\"headerlink\" title=\"类变量访问\"></a>类变量访问</h4><p>类名.类变量名【推荐】</p>\n<p>或者\t</p>\n<p>对象名.类变量名 [静态变量的访问修饰符的访问权限和范围和普通属性是一样的]</p>\n<p>推荐使用第一种</p>\n<h4 id=\"使用细节\"><a href=\"#使用细节\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h4><ol>\n<li>什么时候使用类变量？<ul>\n<li>当我们需要让某个类的所有对象都共享一个变量时，就可以使用类变量（静态变量）：比如上述的统计人数的案例</li>\n</ul>\n</li>\n<li>类变量与实际变量的区别<ul>\n<li>变量是该类的所有对象共享的</li>\n<li>实例变量是每个对象独享的</li>\n</ul>\n</li>\n<li>加上static成为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量</li>\n<li>类变量可以通过<span style=\"color:red\">类名.类变量名</span>或者<span style=\"color:red\">对象名.类变量名</span>来访问。推荐第一种方式访问（前提是得满足访问权限）</li>\n<li>实例变量不能通过<span style=\"color:red\">类名.类变量名</span>方式访问</li>\n<li>类变量是在类加载时就初始化了，也就是说，及时没有创建对象，只要加载类了，就可使用类变量了</li>\n<li>类变量的声明周期是随类的加载开始，随着类的消亡而销毁</li>\n</ol>\n<h3 id=\"二、类方法\"><a href=\"#二、类方法\" class=\"headerlink\" title=\"二、类方法\"></a>二、类方法</h3><h4 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>类方法也称静态方法</p>\n<h3 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">访问修饰符\t<span class=\"keyword\">static</span>\t数据源返回类型\t方法名()&#123;&#125;\t【推荐】</span><br><span class=\"line\"><span class=\"keyword\">static</span>\t访问修饰符\t数据返回类型\t方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"类方法调用\"><a href=\"#类方法调用\" class=\"headerlink\" title=\"类方法调用\"></a>类方法调用</h4><p>使用方式：</p>\n<p><span style=\"color:red\">类名.类方法名</span></p>\n<p>或</p>\n<p><span style=\"color:red\">对象名.类方法名</span></p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。</p>\n<p>比如：工具类中的方法utils</p>\n<p>Math类、Arrays类、Collections集合类</p>\n<h4 id=\"使用细节-1\"><a href=\"#使用细节-1\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h4><ol>\n<li>类方法和普通方法都是随着类的加载而加载，将结构信息储存在方法区：<ul>\n<li>类方法中无this的参数</li>\n<li>普通方法中隐含this参数</li>\n</ul>\n</li>\n<li>类方法可以通过类名调用，也可以通过对象名调用</li>\n<li>普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用</li>\n<li>类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以</li>\n<li>类方法(静态方法)中，只能访问 静态变量和静态方法</li>\n<li>普通成员方法，既可以访问静态的成员，非静态的方法。可以访问静态成员和非静态成员</li>\n</ol>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>静态方法，只能访问静态的成员，</p>\n<p>非静态方法，可以访问静态的 成员和非静态的成员</p>\n<p>（前提是必须遵守访问权限规则）</p>\n<h2 id=\"理解main方法语法\"><a href=\"#理解main方法语法\" class=\"headerlink\" title=\"理解main方法语法\"></a>理解main方法语法</h2><h4 id=\"深入理解main方法\"><a href=\"#深入理解main方法\" class=\"headerlink\" title=\"深入理解main方法\"></a>深入理解main方法</h4><p>解释main方法的形式：public static void main(String[] args){}</p>\n<p>main方法是java虚拟机调用的</p>\n<ol>\n<li><p>java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public</p>\n</li>\n<li><p>java虚拟机在执行main()方法是不必创建对象，所有该方法必须是static</p>\n</li>\n<li><p>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</p>\n</li>\n<li><p>java执行的程序 参数1 参数2  参数3</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220403184106869.png\" alt=\"image-20220403184106869\"></p>\n</li>\n</ol>\n<h4 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h4><ol>\n<li><p>在main（）方法中我们可以直接调用main方法所在类的静态方法或静态属性</p>\n</li>\n<li><p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，再能通过这个对象去访问类中的非静态成员</p>\n</li>\n<li><p>例：</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>class A{<br>private int a;<br>private static int b;<br><br>private void a(){<br>    System.out.println(“非静态方法a”);<br>}<br>private static void b(){<br>    System.out.println(“静态方法a”);<br>}<br><br><br><br>public static void main(String[] args){<br>    System.out.println(“id &#x3D; “ +a);&#x2F;&#x2F;错误 a是非静态变量，得实例一个对象才能调用<br>    System.out.println(“id &#x3D; “ +new A().a);&#x2F;&#x2F;这样是正确的，创建了个匿名对象调用<br>    System.out.println(“id &#x3D; “ +b);&#x2F;&#x2F;正确， 因为b是静态变量，可以直接调用<br>    System.out.println(“id &#x3D; “ +a());&#x2F;&#x2F;错误，和上述a的非静态变量的原因相同<br>    System.out.println(“id &#x3D; “ +new A().a());&#x2F;&#x2F;改成这样就是正确的，因为a()是非静态的方法<br><br>    A a &#x3D; new A();<br>    System.out.println(“id &#x3D; “ +a.a());&#x2F;&#x2F;同理<br>}<br>}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   * </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 代码块</span><br><span class=\"line\"></span><br><span class=\"line\">#### 介绍</span><br><span class=\"line\"></span><br><span class=\"line\">代码块又称初始化块，属于类中的成员【即 是类的一部分】。类似于方法，将罗技语句封装在方法体中，通过&#123;&#125;包围起来</span><br><span class=\"line\"></span><br><span class=\"line\">和方法不同，没有方法名，没有返回，没有参数，只有方法体。而且不用通过对象或类显式调用，而是在家类是，或创建对象时隐式调用。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 基本语法</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">[修饰符]&#123;</span><br><span class=\"line\">\t代码</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><ol>\n<li>修饰符 可选，要写的话，也只能写static</li>\n<li>代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块</li>\n<li>逻辑语句可以为任何罗技语句（输入，输出，方法调用，循环，判断等）</li>\n<li>; 号可以写上，也可以省略。</li>\n</ol>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作</li>\n<li>如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</li>\n</ol>\n<h4 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Movie</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">double</span> price;</span><br><span class=\"line\">\tpricate String director;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    使用场景</span></span><br><span class=\"line\"><span class=\"comment\">    1. 下面三个构造器都有相同的语句</span></span><br><span class=\"line\"><span class=\"comment\">    2. 这样重写大量的代码</span></span><br><span class=\"line\"><span class=\"comment\">    3. 可以吧相同语句提取出来，放到一个代码块中</span></span><br><span class=\"line\"><span class=\"comment\">    4. 我们不管调用哪个构造器，创建对象，都会先执行代码块</span></span><br><span class=\"line\"><span class=\"comment\">    5. 代码块调用的顺序都是优先于构造器</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;电影屏幕打开···&quot;</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;广告···&quot;</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;开始播放电影···&quot;</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Movie</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        System.out.println(&quot;电影屏幕打开···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;广告···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;开始播放电影···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Movie</span><span class=\"params\">(String name,<span class=\"type\">double</span> price)</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        System.out.println(&quot;电影屏幕打开···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;广告···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;开始播放电影···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Movie</span><span class=\"params\">(String name,<span class=\"type\">double</span> price,String director)</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        System.out.println(&quot;电影屏幕打开···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;广告···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;开始播放电影···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.price = price;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.director = director;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用细节-2\"><a href=\"#使用细节-2\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h4><ol>\n<li><p>static代码块也叫静态代码块，作用就是对类进行初始化，</p>\n<p>而且它随着类的加载而执行</p>\n<p>并且只会执行一次。</p>\n<p>如果是普通代码块，每创建一个对象，就执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//静态代码块</span></span><br><span class=\"line\"><span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">\txxxx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//普通代码块</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\txxxx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类什么时候被加载？[重要]</p>\n<ol>\n<li>创建对象实例时（new xxx)</li>\n<li>创建子类对象实例，父类也会被加载<ol>\n<li>先在家父类的代码块，再执行子类的</li>\n</ol>\n</li>\n<li>使用类的静态成员时（静态属性，静态方法）</li>\n</ol>\n<p>案例：A类 extends B类的静态块</p>\n<p>​\t\t\t先执行a的静态块，然后再执行b的</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220404151232983.png\" alt=\"image-20220404151232983\"></p>\n</li>\n<li><p>普通代码块，在创建对象实例时，会被隐式调用。</p>\n<p>被创建一次，就会调用一次</p>\n<p>如果只是使用类的静态成员时，普通代码块并不会执行</p>\n</li>\n<li><p>创建一个对象时，在一个类 调用顺序是（重点，难点）</p>\n<ol>\n<li><p>调用静态代码块和静态属性初始化</p>\n<p>（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例理解</span><br><span class=\"line\">    </span><br><span class=\"line\">    因为<span class=\"keyword\">static</span>的优先级一样，</span><br><span class=\"line\">    所以哪个写在前面，哪个就先执行</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> getn1();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;A&#x27;s static codeBlock&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getn1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;use getn1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">============================================</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">============================================</span><br><span class=\"line\">use getn1</span><br><span class=\"line\">A<span class=\"string\">&#x27;s static codeBlock</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">=========================分割线=========================</span></span><br><span class=\"line\"><span class=\"string\">//如果更换顺序</span></span><br><span class=\"line\"><span class=\"string\">class A&#123;</span></span><br><span class=\"line\"><span class=\"string\">    static &#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;A&#x27;</span>s <span class=\"keyword\">static</span> codeBlock<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    private static  int n1 = getn1();</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    public static int getn1()&#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;</span>use getn1<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">        return 100;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;   </span></span><br><span class=\"line\"><span class=\"string\">============================================</span></span><br><span class=\"line\"><span class=\"string\">输出结果：</span></span><br><span class=\"line\"><span class=\"string\">============================================</span></span><br><span class=\"line\"><span class=\"string\"> A&#x27;s static codeBlock</span></span><br><span class=\"line\"><span class=\"string\">use getn1</span></span><br><span class=\"line\"><span class=\"string\">   </span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>调用普通代码块和普通属性的初始化</p>\n<p>（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义的顺序调用） </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先执行静态的，和上述的一样，</span></span><br><span class=\"line\"><span class=\"comment\">//然后再执行非静态的，规则也是和上述一样，谁写前面先执行谁</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> getn2();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;普通代码块被执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;A&#x27;s static codeBlock&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> getn1();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getn1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;use getn1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getn2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;getn2 被调用&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">============================================</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">============================================</span><br><span class=\"line\">A<span class=\"string\">&#x27;s static codeBlock</span></span><br><span class=\"line\"><span class=\"string\">use getn1</span></span><br><span class=\"line\"><span class=\"string\">getn2 被调用</span></span><br><span class=\"line\"><span class=\"string\">普通代码块被执行</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">=========================分割线=========================</span></span><br><span class=\"line\"><span class=\"string\">class A&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;普通代码块被执行&quot;);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    private int b = getn2();</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    static &#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;A&#x27;</span>s <span class=\"keyword\">static</span> codeBlock<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    private static  int n1 = getn1();</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    public static int getn1()&#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;</span>use getn1<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">        return 100;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    public int getn2()&#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;</span>getn2 被调用<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">        return 1;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;    </span></span><br><span class=\"line\"><span class=\"string\">============================================</span></span><br><span class=\"line\"><span class=\"string\">输出结果：</span></span><br><span class=\"line\"><span class=\"string\">============================================</span></span><br><span class=\"line\"><span class=\"string\">A&#x27;s static codeBlock</span></span><br><span class=\"line\"><span class=\"string\">use getn1</span></span><br><span class=\"line\"><span class=\"string\">普通代码块被执行</span></span><br><span class=\"line\"><span class=\"string\">getn2 被调用</span></span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>调用构造器</p>\n<p>构造器优先级最低，上述的两个规则执行完成后<br>才会执行构造器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">A</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;构造器被执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;普通代码块被执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> getn2();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;A&#x27;s static codeBlock&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> getn1();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getn1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;use getn1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getn2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;getn2 被调用&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">============================================</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">============================================</span><br><span class=\"line\">A<span class=\"string\">&#x27;s static codeBlock</span></span><br><span class=\"line\"><span class=\"string\">use getn1</span></span><br><span class=\"line\"><span class=\"string\">普通代码块被执行</span></span><br><span class=\"line\"><span class=\"string\">getn2 被调用</span></span><br><span class=\"line\"><span class=\"string\">构造器被执行</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>构造器 的最前面其实隐含了super() 和调用普通代码块</p>\n<p>静态相关的代码块，属性初始化，在类加载时，就执行完毕。因此是优先于 构造器和普通代码块执行的</p>\n<p>演示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">A</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里存在隐藏的调用</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//(1) super();</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//(2) 调用普通代码块</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t System.out.println(<span class=\"string\">&quot;xxxx&quot;</span>);\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AAA</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">AAA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这里存在隐藏的调用</span></span><br><span class=\"line\">        <span class=\"comment\">//(1) super();</span></span><br><span class=\"line\">        <span class=\"comment\">//(2) 调用普通代码块</span></span><br><span class=\"line\">        <span class=\"comment\">//因为Object的代码块没有输出</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//1.先输出</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;AAA的构造器被调用&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BBB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AAA</span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"><span class=\"comment\">//        根据规则父类的输出完毕后，再调用方法区</span></span><br><span class=\"line\"><span class=\"comment\">//        2. 再执行普通代码块</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;bbb的普通代码块执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BBB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这里存在隐藏的调用</span></span><br><span class=\"line\">        <span class=\"comment\">//(1) super();</span></span><br><span class=\"line\">        <span class=\"comment\">//(2) 调用普通代码块</span></span><br><span class=\"line\"><span class=\"comment\">//        等上述执行完毕后，最后执行该语句</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;BBB的无参构造被执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个子类对象时(继承关系),他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：</p>\n<ol>\n<li>父类的静态代码块和静态属性（优先级一样，按定义的顺序执行）</li>\n<li>子类的静态代码块和静态属性（优先级一样，按定义的顺序执行）</li>\n<li>父类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）</li>\n<li>父类的构造器</li>\n<li>子类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）</li>\n<li>子类的构造器</li>\n</ol>\n</li>\n<li><p>静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任何成员</p>\n</li>\n</ol>\n<h2 id=\"单例设计模式\"><a href=\"#单例设计模式\" class=\"headerlink\" title=\"单例设计模式\"></a>单例设计模式</h2><h4 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ol>\n<li>所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且只提供一个取得对象实例的方法</li>\n<li>单例模式有两种方式：1）饿汉式 2）懒汉式<ol>\n<li>二者最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例,而懒汉式在使用时才创建</li>\n<li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li>\n<li>饿汉式存在浪费资源的可能。（因为如果程序员一个对象实例都没使用，那么饿汉式创建的对象就是浪费了，懒汉式是使用时才创建，就不存在这个问题</li>\n<li>在javaSE标准类中，java.lang.Runtim就是经典的单例设计模式</li>\n</ol>\n</li>\n</ol>\n<p>演示：</p>\n<ol>\n<li><p>恶汉式</p>\n<p>类加载的时候，对象就被创建实例对象，可能会出现创建了，但是没有使用</p>\n<p>步骤：</p>\n<ol>\n<li><p>构造器私有化 &#x3D;&gt; 防止直接new</p>\n</li>\n<li><p>类的内部创建对象</p>\n</li>\n<li><p>向外露出一个静态的公共方法。</p>\n</li>\n<li><p>代码实现</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>public class singleDesign {<br>public static void main(String[] args) {<br>    System.out.println(GirlFriend.info());<br>}<br>}<br>&#x2F;&#x2F;有一个女朋友类<br>&#x2F;&#x2F;只能有一个女朋友<br>class GirlFriend{<br>private String name;<br>&#x2F;&#x2F;    2.创建一个对象<br>&#x2F;&#x2F;    3.为了能够接收静态方法，需要修饰为static<br>private static GirlFriend girl &#x3D; new GirlFriend(info());<br>&#x2F;&#x2F;    如何保证只能有一个对象实例<br>&#x2F;&#x2F;    public girlFriend(String name) {<br>&#x2F;&#x2F;        this.name &#x3D; name;<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;    1. 改成私有的构造器<br>private GirlFriend(String name) {<br>    this.name &#x3D; name;<br>}<br>&#x2F;&#x2F;    4.创建一个静态方法，用于接收实例对象<br>public static String info(){<br>    return “g”;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 懒汉式</span><br><span class=\"line\"></span><br><span class=\"line\">   使用时才创建实例</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 构造器私有化=&gt; 防止直接new</span><br><span class=\"line\"></span><br><span class=\"line\">   2. 类的内部创建对象</span><br><span class=\"line\"></span><br><span class=\"line\">   3. 向外暴露一个静态的公共方法</span><br><span class=\"line\"></span><br><span class=\"line\">   4. ```java</span><br><span class=\"line\">      public class SingleDesign01 &#123;</span><br><span class=\"line\">          public static void main(String[] args) &#123;</span><br><span class=\"line\">              System.out.println(Cat.i);</span><br><span class=\"line\">      //        此时只是初始化了cat ，但没有创建对象，其他的静态参数可以直接调用</span><br><span class=\"line\">              System.out.println(Cat.getCat());</span><br><span class=\"line\">      //        当只有调用了这个方法时，才会创建对象(通过判断发现没有cat类，此时创建后返回)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      //懒汉式</span><br><span class=\"line\">      //希望在程序运行中，只创建一个cat</span><br><span class=\"line\">      </span><br><span class=\"line\">      class Cat&#123;</span><br><span class=\"line\">          private String name;</span><br><span class=\"line\">          public static int i =1;</span><br><span class=\"line\">      //    2.定义一个静态属性static</span><br><span class=\"line\">          private  static Cat cat;</span><br><span class=\"line\">      </span><br><span class=\"line\">      //    3.提供一个公共的static方法 可以返回一个Cat对象</span><br><span class=\"line\">          public  static  Cat getCat()&#123;</span><br><span class=\"line\">              if (cat == null)&#123; //如果还没创建对象</span><br><span class=\"line\">                  cat = new Cat(&quot;little cute&quot;);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              return cat;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      //    1.创建私有构造器</span><br><span class=\"line\">          private Cat(String name)&#123;</span><br><span class=\"line\">              this.name = name;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"final关键字\"><a href=\"#final关键字\" class=\"headerlink\" title=\"final关键字\"></a>final关键字</h2><h4 id=\"介绍-5\"><a href=\"#介绍-5\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>final &#x2F; 最后的，最终的</p>\n<p>fianl 可以修饰类、属性、方法和局部变量</p>\n<p>某些情况下，程序员可能有以下需求，就会使用到final：</p>\n<ol>\n<li>当不希望类被继承时，可以用final修饰</li>\n<li>当不希望父类的某个方法可以被子类覆盖&#x2F;重写（override）时，可以用final关键字修饰</li>\n<li>当不希望类的某个属性的值被修改，可以使用final修饰</li>\n<li>当不希望某个局部变量被修改，可以使用final修饰</li>\n</ol>\n<h4 id=\"使用细节-3\"><a href=\"#使用细节-3\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h4><ol>\n<li><p>final修饰的属性又叫常量，一般用XX_XX_XX来命名</p>\n</li>\n<li><p>final修饰的属性在定义时，必须赋初始值，并且以后都不能修改，赋值可以在如下位置之一（选择一个位置赋初始值即可）</p>\n<ol>\n<li><p>定义时：例如  public final double TAX_PATE&#x3D;0.09;</p>\n</li>\n<li><p>在构造器中</p>\n</li>\n<li><p>在代码块中</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>class A{<br>&#x2F;&#x2F;定义时赋值<br>public final double ATX_A &#x3D; 0.9;<br>&#x2F;&#x2F;在构造器中赋值<br>public final double ATX_B；<br>public A{<br>    ATX_B&#x3D;0.8；<br>}<br>&#x2F;&#x2F;在代码块中赋值<br>public final double ATX_C；<br>{<br>    ATX_C&#x3D;0.2；<br>}<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 如果final修饰的属性是静态的，则初始化的位置只能是</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 定义时</span><br><span class=\"line\">   2. 在静态代码块 </span><br><span class=\"line\">   3. 不能再构造器中赋值</span><br><span class=\"line\"></span><br><span class=\"line\">4. final类不能被继承，但是可以实例化对象</span><br><span class=\"line\"></span><br><span class=\"line\">5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</span><br><span class=\"line\"></span><br><span class=\"line\">6. 一般来说，如果一个类已经是final类，就没有必要再将方法修饰成final方法。</span><br><span class=\"line\"></span><br><span class=\"line\">7. final不能修饰构造方法（即构造器）</span><br><span class=\"line\"></span><br><span class=\"line\">8. final和static 往往搭配使用，效率更高，不会导致类的加载。底层编译器做了优化处理</span><br><span class=\"line\"></span><br><span class=\"line\">9. 包装类(integer,Double,Float,Boolean等等都是final),String 也是final类</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 抽象类</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">编写一个父类</span><br><span class=\"line\">//class Animal&#123;</span><br><span class=\"line\">abstract Animal&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tpublic Animal(String name)&#123;</span><br><span class=\"line\">\t this.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t这里的eat方法 实现了，没有什么意义</span><br><span class=\"line\">\t即父类中的方法不确定性的问题</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t1.考虑将该方法设计为抽象(abstract)方法</span><br><span class=\"line\">\t2.所谓抽象方法就是没有实现的方法</span><br><span class=\"line\">\t3.所谓的没有实现就是没有方法体</span><br><span class=\"line\">\t4.当一个类存在抽象方法时，就需要将该类声明为abstract类</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t一般来说，抽象类会被继承，有其子类来实现抽象方法</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">    </span><br><span class=\"line\">\t//public void eat()&#123;</span><br><span class=\"line\">\t//\tSystem.out.println(&quot;这个是一个吃方法，但不知道吃啥&quot;);</span><br><span class=\"line\">\t//&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tpublic abstract void eat();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"介绍-6\"><a href=\"#介绍-6\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ol>\n<li><p>用abstract 关键字修饰的类时，这个类就是抽象类</p>\n<ol>\n<li>&#96;&#96;&#96;java<br>访问修饰符 abstract 类名{<br>}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 用abstract 关键字来修饰一个方法时，这个方法就是抽象方法</span><br><span class=\"line\"></span><br><span class=\"line\">   1. ```java</span><br><span class=\"line\">      访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()</p>\n</li>\n</ol>\n<h4 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h4><ol>\n<li>抽象类不能被实例化</li>\n<li>抽象类不一定包含abstract方法。也就是说，抽象类可以没有abstract方法</li>\n<li>一旦包含了abstract方法，则这个类必须声明为abstract </li>\n<li>abstract 只能修饰类和方法，不能修饰属性和其他的</li>\n<li>抽象类可以有任意成员【抽象类的本质还是类】，比如：非抽象方法、构造器、静态属性等等</li>\n<li>抽象方法不能有主体，即不能实现。例如：abstract void method()；不能有{}</li>\n<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract 类（所谓实现就是有那个{}就可，具体内容不管）</li>\n<li>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</li>\n</ol>\n<h4 id=\"抽象类实践-模板设计模式\"><a href=\"#抽象类实践-模板设计模式\" class=\"headerlink\" title=\"抽象类实践-模板设计模式\"></a>抽象类实践-模板设计模式</h4><p>现有个需求</p>\n<ol>\n<li>有多个类，完成不同的任务job</li>\n<li>要求能得到各自完成任务的时间</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> seatWork;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Template</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">son1</span> <span class=\"variable\">son1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">son1</span>();</span><br><span class=\"line\">        son1.getCurrentTime();</span><br><span class=\"line\">        <span class=\"type\">son2</span> <span class=\"variable\">son2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">son2</span>();</span><br><span class=\"line\">        son2.getCurrentTime();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Father</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//在抽象类中定义一个抽象方法，这个方法后期会填入不同子类的不同不同方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">job</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"comment\">//创建一个子类中的公共部分，在其中添加 不同的部分抽象类(方法)，</span></span><br><span class=\"line\"><span class=\"comment\">// 由于动态绑定机制，当调用该方法时，根据实例不同的子类实现不同的输出结果</span></span><br><span class=\"line\"><span class=\"comment\">//    也就是说相当于创建了个模板，不同的类用填不同的内容</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getCurrentTime</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        job();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;用时：&quot;</span>+(end-start));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">son1</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Father</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">job</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            sum+=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">son2</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Father</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">job</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">60000</span>; i++) &#123;</span><br><span class=\"line\">            sum+=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接口（重要）\"><a href=\"#接口（重要）\" class=\"headerlink\" title=\"接口（重要）\"></a>接口（重要）</h2><h4 id=\"介绍-7\"><a href=\"#介绍-7\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>接口就是给出一些没有实现的方法，封装到一起，起到某个类要使用的时候，在根据具体情况吧这些方法写出来</p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface 类名 implements 接口&#123;</span><br><span class=\"line\"> 自己的属性；</span><br><span class=\"line\"> 自己的方法；</span><br><span class=\"line\"> 必须实现的接口的抽象方法；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>小结:</p>\n<ol>\n<li>jdk7之前，接口中所有方法否是抽象方法</li>\n<li>jdk8之后，接口中可以有实现方法，但需要使用default关键字修饰</li>\n<li>jdk8之后可以有静态方法</li>\n<li>abstract关键字可以省略</li>\n</ol>\n<h4 id=\"注意事项-4\"><a href=\"#注意事项-4\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ol>\n<li><p>接口不能被实例化</p>\n</li>\n<li><p>接口中所有的方法是public方法，接口中抽象方法，可以不用填写abstract，因为默认修饰的就是public abstract xxx。</p>\n</li>\n<li><p>一个普通类实现接口，就必须将该接口的所有方法都实现</p>\n</li>\n<li><p>抽象类实现接口，可以不用实现接口的方法</p>\n</li>\n<li><p>一个类同时可以实现多个接口</p>\n</li>\n<li><p>接口的属性，只能是final的，而且public static final 修饰符，比如：int a &#x3D;1; 实际上是public static final int a &#x3D;1；（必须）初始化</p>\n</li>\n<li><p>接口中属性的访问形式：接口名.属性名</p>\n</li>\n<li><p>一个接口不能继承其他的类，但是可以继承多个别的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">A</span> extend B,c,d...&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接口的修饰符只能是public和默认，这点和类的修饰符是一样的。</p>\n</li>\n</ol>\n<p>小结：</p>\n<p>继承vs接口</p>\n<ol>\n<li>当子类继承了父类，就自动拥有了父类的功能</li>\n<li>如果子类需要拓展功能，可以通过实现接口的方式扩展</li>\n<li>可以理解，接口是对java单继承机制的一个补充</li>\n</ol>\n<p>继承的价值：解决代码的复用性和可维护性</p>\n<p>接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。更加的灵活</p>\n<h2 id=\"内部类（重点）\"><a href=\"#内部类（重点）\" class=\"headerlink\" title=\"内部类（重点）\"></a>内部类（重点）</h2><h4 id=\"介绍：-2\"><a href=\"#介绍：-2\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h4><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类成为内部类（inner class)，嵌套其他类的类成为外部类(out class)。是我们类的第五大成员</p>\n<p>类的五大成员：</p>\n<ol>\n<li>属性</li>\n<li>方法</li>\n<li>构造器</li>\n<li>代码块</li>\n<li>内部类</li>\n</ol>\n<h4 id=\"基本语法-2\"><a href=\"#基本语法-2\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span>&#123;<span class=\"comment\">//外部类</span></span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">inner</span>&#123;<span class=\"comment\">//内部类</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">other</span>&#123;<span class=\"comment\">//外部其他类</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内部类的分类\"><a href=\"#内部类的分类\" class=\"headerlink\" title=\"内部类的分类\"></a>内部类的分类</h4><p>定义在外部类局部位置上（比如方法内）</p>\n<h5 id=\"1）局部内部类（有类名）\"><a href=\"#1）局部内部类（有类名）\" class=\"headerlink\" title=\"1）局部内部类（有类名）\"></a>1）局部内部类（有类名）</h5><p>​\t\t说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">outclass</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"comment\">//局部内部类师是定义在外部类的局部位置，通常在方法内</span></span><br><span class=\"line\"> <span class=\"comment\">// 1.第一种在局部位置</span></span><br><span class=\"line\"> \t<span class=\"keyword\">class</span> <span class=\"title class_\">innerClass</span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">//2. 在方法内，（局部内部类）</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">mehtod</span><span class=\"params\">()</span>&#123;<span class=\"comment\">//局部内部类（本质仍然是一个类）</span></span><br><span class=\"line\">    \t<span class=\"keyword\">class</span> <span class=\"title class_\">innerClass</span>&#123;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">&quot;n=&quot;</span>+n);</span><br><span class=\"line\">      &#125;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>可以直接访问外部类的所有成员，包括私有的</p>\n</li>\n<li><p>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但可以使用final修饰，因为局部变量也可以使用final修饰符的</p>\n</li>\n<li><p>作用域：仅仅在定义它的方法或代码块中</p>\n</li>\n<li><p>局部内部类—访问—-&gt;外部类的成员【访问方式：直接访问】</p>\n</li>\n<li><p>外部类—-访问—-&gt;局部内部类的成员</p>\n<p>访问方式：创建对象，再访问（注意：必须在作用域内）</p>\n</li>\n<li><p>外部其它类—-&gt;不能访问—-&gt;局部内部类（因为 局部内部类地位是一个局部变量）</p>\n</li>\n<li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>class Outer{<br>private int n1 &#x3D; 10;<br>private static String name &#x3D; “张三”;<br>public void say(){<br>    int n3 &#x3D; 30;<br>  &#x2F;&#x2F;局部内部类是定义在外部类的局部位置，通常在方法<br>    &#x2F;&#x2F;不能添加访问修饰符，可以使用final修饰<br>  class localInner{&#x2F;&#x2F;局部内部类（本质仍然是一个类）<br>int n1 &#x3D; 100;<br>   int n2 &#x3D; 40;<br>    &#x2F;&#x2F;可以直接访问外部类的所有成员，包括私有的<br>  public void show(){<br>  &#x2F;&#x2F;默认输入内部类的n1的值 100<br>    System.out.print(“n1&#x3D;”+n1);<br>  &#x2F;&#x2F;输入outer.this.n1 输出的才是外部类的n1<br>  System.out.print(“n1&#x3D;”+outer.this.n1);<br><br>  }<br>}<br>}<br>  &#x2F;&#x2F;外部类使用内部类<br>  localInner inner &#x3D; new localInner();<br>  inner.show();<br> }</p>\n<p>&#x2F;&#x2F;外部其他类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">9. </span><br><span class=\"line\"></span><br><span class=\"line\">##### 2）匿名内部类（没有类名，重点！！！！）</span><br><span class=\"line\"></span><br><span class=\"line\">###### 介绍：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 本质是类</span><br><span class=\"line\">2. 是一个内部类</span><br><span class=\"line\">3. 该类没有名字</span><br><span class=\"line\">4. 同时还是一个对象</span><br><span class=\"line\"></span><br><span class=\"line\">匿名内部类是定义在外部类的局部位置</span><br><span class=\"line\"></span><br><span class=\"line\">比如在方法中，并且没有类名</span><br><span class=\"line\"></span><br><span class=\"line\">###### 基本语法</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">new 类 或 接口（参数列表）&#123;</span><br><span class=\"line\">\t类体</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">anonymous</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h6 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> chapterObjectHeightLevel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AnonymousClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">outer</span> <span class=\"variable\">outer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">outer</span>();</span><br><span class=\"line\">        outer.method();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">outer</span>&#123;<span class=\"comment\">//外部类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//现有一个需求，使用IA接口，并创建对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        传统方法：新建一个类tiger 实现IA接口，并new tiger调用</span></span><br><span class=\"line\"><span class=\"comment\">//        IA tiger = new Tiger();</span></span><br><span class=\"line\"><span class=\"comment\">//        tiger.cry();</span></span><br><span class=\"line\"><span class=\"comment\">//        当此时的需求是只需要这个Tiger类使用一次，并且以后再也不使用</span></span><br><span class=\"line\"><span class=\"comment\">//        如果再用传统方法的话，会造成资源浪费，而且没有必要再去新建一个类</span></span><br><span class=\"line\"><span class=\"comment\">//        此时就需要匿名内部类来简化开发，如下</span></span><br><span class=\"line\">        <span class=\"type\">IA</span> <span class=\"variable\">tiger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IA</span>()&#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             *此时底层是这样的</span></span><br><span class=\"line\"><span class=\"comment\">             * class xxx(该类名是系统自动创建的) implements IA&#123;</span></span><br><span class=\"line\"><span class=\"comment\">             *     <span class=\"doctag\">@Override</span></span></span><br><span class=\"line\"><span class=\"comment\">             *     public void cry() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">             *         System.out.println(&quot;老虎叫`````&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">             *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">             * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">             *</span></span><br><span class=\"line\"><span class=\"comment\">             * 之后在让tiger指向xxx的地址</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;老虎叫`````&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        tiger.cry();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//演示基于类的匿名内部类</span></span><br><span class=\"line\"><span class=\"comment\">//        1. father的编译类型 Father(不加&#123;&#125;号)</span></span><br><span class=\"line\"><span class=\"comment\">//        2. father的编译类型 xxx$2(加&#123;&#125;号）</span></span><br><span class=\"line\"><span class=\"comment\">//        2.1 底层会创建匿名内部类</span></span><br><span class=\"line\">        <span class=\"type\">Father</span> <span class=\"variable\">father</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Father</span>(<span class=\"string\">&quot;tiger&quot;</span>)&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;override test method&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">            * 相当于创建了哥匿名内部类重写了test方法</span></span><br><span class=\"line\"><span class=\"comment\">            * class xxx implement test&#123;</span></span><br><span class=\"line\"><span class=\"comment\">             *      <span class=\"doctag\">@Override</span></span></span><br><span class=\"line\"><span class=\"comment\">             *      public void test() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">             *          System.out.println(&quot;override test method&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">             *       &#125;</span></span><br><span class=\"line\"><span class=\"comment\">             * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">             * 然后再将father指向xxx的地址</span></span><br><span class=\"line\"><span class=\"comment\">            * */</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        father.test();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//class Tiger implements IA&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//    @Override</span></span><br><span class=\"line\"><span class=\"comment\">//    public void cry() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(&quot;老虎叫`````&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Father</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"注意细节\"><a href=\"#注意细节\" class=\"headerlink\" title=\"注意细节\"></a>注意细节</h6><ol>\n<li><p>匿名内部类既是一个类的定义，同事它也是一个对象，因此从语法上来看，它既有定义类的特征，也有创建对象的特征，对前面的代码分析可以看出这个特点，因此调用匿名内部类方法有两种</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.第一种方式</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tSystem.out.print(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;.cry();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.第二种方式</span></span><br><span class=\"line\">A a=<span class=\"keyword\">new</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tSystem.out.print(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.cry();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以访问外部类的所有成员，包括私有的</p>\n</li>\n<li><p>不能添加访问修饰符，因为它的地位就是一个局部变量</p>\n</li>\n<li><p>作用域：方法或代码块中</p>\n</li>\n<li><p>匿名内部类—&gt;范围跟—&gt;外部类成员</p>\n</li>\n<li><p>外部其他类—&gt;不能访问—&gt;匿名内部类（因为 匿名内部类地位是一个局部变量）</p>\n</li>\n<li><p>如果外部类和内部类的成员变量重名时，内部类访问的话，默认就是就近原则，如果想访问外部，可以使用（外部类名.this.成员）去访问</p>\n</li>\n</ol>\n<p>定义在外部类的成员位置上</p>\n<h5 id=\"1）成员内部类（没用static修饰）\"><a href=\"#1）成员内部类（没用static修饰）\" class=\"headerlink\" title=\"1）成员内部类（没用static修饰）\"></a>1）成员内部类（没用static修饰）</h5><p>介绍：</p>\n<ol>\n<li><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">outer</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;zhangsan&quot;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">inner</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t\tSystem.out.print(<span class=\"string\">&quot;outer n1 = &quot;</span>+n1+<span class=\"string\">&quot;outer name = &quot;</span>+name);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位是一个成员</p>\n</li>\n<li><p>作用域</p>\n<p>和外部类的其他成员一样，为整个类体比如前面的案例，在外部类的成员方法中创建成员内部类对象，再调用方法</p>\n</li>\n<li><p>成员内部类–&gt;访问—&gt;外部类成员</p>\n<p>(比如属性)【访问方式：直接访问】</p>\n</li>\n<li><p>外部类 —访问—内部类</p>\n<p>访问方式：创建对象，再访问</p>\n</li>\n<li><p>外部其他类—–访问—–成员内部类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//三种方式:</span></span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\">outer.<span class=\"type\">inner</span> <span class=\"variable\">class</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">outer</span>.<span class=\"keyword\">new</span> <span class=\"title class_\">inner</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种方式</span></span><br><span class=\"line\"> <span class=\"number\">1.</span>定义一个方法，用于创建内部类并返回内部类的实例</span><br><span class=\"line\">   <span class=\"keyword\">public</span> inner <span class=\"title function_\">getInner</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">   <span class=\"type\">Inner</span> <span class=\"variable\">inner</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\">   <span class=\"keyword\">return</span> inner;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"number\">2.</span> 在需要的地方<span class=\"keyword\">new</span>一个外部类.这个方法</span><br><span class=\"line\">  Outer.<span class=\"type\">Inner</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer</span>.getInner();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3这个方法不建议使用</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">Outer</span>().<span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409142725630.png\" alt=\"image-20220409142725630\"></p>\n</li>\n</ol>\n<h5 id=\"2）静态内部类（使用static修饰）\"><a href=\"#2）静态内部类（使用static修饰）\" class=\"headerlink\" title=\"2）静态内部类（使用static修饰）\"></a>2）静态内部类（使用static修饰）</h5><h6 id=\"介绍-8\"><a href=\"#介绍-8\" class=\"headerlink\" title=\"介绍\"></a>介绍</h6><p>静态内部类定义在外部类的成员位置，并且有static修饰</p>\n<ol>\n<li>可以直接访问外部的所有静态成员，包含私有的，但不能直接访问非静态成员</li>\n<li>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员</li>\n<li>作用域：同其他的成员，为整个类体</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">outer</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> n1=<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;zhangsan&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//inner就是静态内部类</span></span><br><span class=\"line\">  <span class=\"comment\">//1. 放在外部类的成员位置</span></span><br><span class=\"line\">  <span class=\"comment\">//2. 使用static修饰</span></span><br><span class=\"line\">  <span class=\"comment\">//3. 不能直接访问非静态成员</span></span><br><span class=\"line\">  <span class=\"comment\">//4. 可以添加修饰符</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      \tSystem.out.println(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>静态内部类—访问—-外部类</p>\n<p>（比如：静态属性）[访问方式：直接访问所有静态成员]</p>\n</li>\n<li><p>外部类–访问—静态内部类 </p>\n<p>访问方式：创建对象，再访问</p>\n</li>\n<li><p>外部其他类 –访问 –内部类</p>\n<p>访问方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//访问方式1</span></span><br><span class=\"line\"><span class=\"comment\">//因为静态内部类，是可以通过类名直接访问（前提是满足访问权限）</span></span><br><span class=\"line\">Outer.<span class=\"type\">Inner</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer</span>.Inner();</span><br><span class=\"line\">inner.xxx();</span><br><span class=\"line\"><span class=\"comment\">//访问方式2</span></span><br><span class=\"line\"><span class=\"comment\">//写一个方法，返回静态内部类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Inner <span class=\"title function_\">getInner</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Outer.<span class=\"type\">Inner</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> Outer.getInner();</span><br><span class=\"line\"></span><br><span class=\"line\">inner.xxx();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者将方法换成静态</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Inner <span class=\"title function_\">getInner</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果外部类和静态内部类的成员重名时，静态内部访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问</p>\n</li>\n</ol>\n<h1 id=\"枚举和注解\"><a href=\"#枚举和注解\" class=\"headerlink\" title=\"枚举和注解\"></a>枚举和注解</h1><h2 id=\"枚举（enum）\"><a href=\"#枚举（enum）\" class=\"headerlink\" title=\"枚举（enum）\"></a>枚举（enum）</h2><h3 id=\"介绍-9\"><a href=\"#介绍-9\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>1）枚举对应的英文（enumeration,简写enum）</p>\n<p>2）枚举是一组常量的集合</p>\n<p>3）可以理解：枚举属于一种特殊的类，里面只包含一组有限的特定对象（比如一年只有四个季节，建一个季节类的话只能有四个，而且有被添加其他季节的风险）</p>\n<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><h4 id=\"1）自定义枚举\"><a href=\"#1）自定义枚举\" class=\"headerlink\" title=\"1）自定义枚举\"></a>1）自定义枚举</h4><ol>\n<li>不需要提供set方法，因为枚举对象通常为只读</li>\n<li>对枚举对象&#x2F;属性使用final +static共同修饰，实现底层优化</li>\n<li>枚举对象通常使用大写，常量的命名规范</li>\n<li>枚举对象根据需要，也可以有多个属性</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> chapterEnum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">understandForEnum</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">season</span> <span class=\"variable\">autumn</span> <span class=\"operator\">=</span> season.AUTUMN;</span><br><span class=\"line\">        System.out.println(autumn.getSeasonName()+autumn.getSeasonDescription());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//定义一个季节类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">season</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String seasonName;<span class=\"comment\">//季节名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String seasonDescription;<span class=\"comment\">//季节描述</span></span><br><span class=\"line\">  <span class=\"comment\">//1.将构造器私有化</span></span><br><span class=\"line\">  <span class=\"comment\">//2.去掉setxx方法，防止属性被修改</span></span><br><span class=\"line\">  <span class=\"comment\">//3.在season内部，直接创建固定的对象</span></span><br><span class=\"line\">  <span class=\"comment\">//4.优化，添加final</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getSeasonName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seasonName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getSeasonDescription</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seasonDescription;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">season</span><span class=\"params\">(String seasonName, String seasonDescription)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.seasonName = seasonName;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.seasonDescription = seasonDescription;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//定义了四个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">season</span> <span class=\"variable\">SPRING</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">season</span>(<span class=\"string\">&quot;春天&quot;</span>,<span class=\"string\">&quot;温暖&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">season</span> <span class=\"variable\">SUMMER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">season</span>(<span class=\"string\">&quot;夏天&quot;</span>,<span class=\"string\">&quot;炎热&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">season</span> <span class=\"variable\">AUTUMN</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">season</span>(<span class=\"string\">&quot;秋天&quot;</span>,<span class=\"string\">&quot;凉爽&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">season</span> <span class=\"variable\">WINTER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">season</span>(<span class=\"string\">&quot;冬天&quot;</span>,<span class=\"string\">&quot;寒冷&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>总结：定义枚举类型有一下几个特点</p>\n<ol>\n<li>构造器私有化</li>\n<li>本类内部创建一组对象</li>\n<li>对外暴露对象（添加public final static 修饰）</li>\n<li>可以提供get方法，但不需要提供set方法</li>\n</ol>\n<h4 id=\"2）使用enum关键字实现\"><a href=\"#2）使用enum关键字实现\" class=\"headerlink\" title=\"2）使用enum关键字实现\"></a>2）使用enum关键字实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> chapterEnum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">understandForEnum02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(season02.SPRING);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">season02</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 实现步骤</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.使用enum代替class</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.直接使用 常量名(实参列表)</span></span><br><span class=\"line\"><span class=\"comment\">     *   SPRING(&quot;春天&quot;,&quot;温暖&quot;),</span></span><br><span class=\"line\"><span class=\"comment\">     *   如果有多个常量则用,号隔开</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * enum修饰必须将常量对象写在第一行</span></span><br><span class=\"line\"><span class=\"comment\">     *  必须写在定义的变量和方法前面</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.编写常量，私有构造器和get方法</span></span><br><span class=\"line\"><span class=\"comment\">     * */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SPRING(<span class=\"string\">&quot;春天&quot;</span>,<span class=\"string\">&quot;温暖&quot;</span>),</span><br><span class=\"line\">    SUMMER(<span class=\"string\">&quot;夏天&quot;</span>,<span class=\"string\">&quot;炎热&quot;</span>),</span><br><span class=\"line\">    AUTUMN(<span class=\"string\">&quot;秋天&quot;</span>,<span class=\"string\">&quot;凉爽&quot;</span>),</span><br><span class=\"line\">    WINTER(<span class=\"string\">&quot;冬天&quot;</span>,<span class=\"string\">&quot;寒冷&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String seasonName;<span class=\"comment\">//季节名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String seasonDescription;<span class=\"comment\">//季节描述</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getSeasonName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seasonName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getSeasonDescription</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seasonDescription;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">season02</span><span class=\"params\">(String seasonName, String seasonDescription)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.seasonName = seasonName;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.seasonDescription = seasonDescription;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;season02&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;, seasonDescription=&#x27;&quot;</span> + seasonDescription + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//定义四个固定对象</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    public final static season02 SPRING = new season02(&quot;春天&quot;,&quot;温暖&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    public final static season02 SUMMER = new season02(&quot;夏天&quot;,&quot;炎热&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    public final static season02 AUTUMN = new season02(&quot;秋天&quot;,&quot;凉爽&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    public final static season02 WINTER = new season02(&quot;冬天&quot;,&quot;寒冷&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意事项-5\"><a href=\"#注意事项-5\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><ol>\n<li>当我们使用enum关键字开发一个枚举类时，默认会继承Enum类</li>\n<li>传统的public static final SPRING &#x3D; new season(“春天”,”温暖”);简化成SPRING(“春天”,”温暖”),这里必须知道，它调用的是哪个构造器</li>\n<li>如果使用无参构造器 创建枚举对象，则实参列表和小括号都可以省略</li>\n<li>当有多个枚举对象时，使用，号间隔，最后一个分号结尾</li>\n<li>枚举对象必须放在枚举的行首</li>\n</ol>\n<h3 id=\"enum常用方法说明\"><a href=\"#enum常用方法说明\" class=\"headerlink\" title=\"enum常用方法说明\"></a>enum常用方法说明</h3><p>使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类的相关方法</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409204654918.png\" alt=\"image-20220409204654918\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//        使用season02 枚举类，演示各个方法</span></span><br><span class=\"line\">        <span class=\"type\">season02</span> <span class=\"variable\">summer</span> <span class=\"operator\">=</span> season02.SUMMER;</span><br><span class=\"line\"><span class=\"comment\">//        输出枚举对象的名字</span></span><br><span class=\"line\"><span class=\"comment\">//        summer.name();</span></span><br><span class=\"line\">        System.out.println(summer.name());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        ordinal()输出的是该枚举对象的次序/编号，按枚举的顺序从0开始编号</span></span><br><span class=\"line\"><span class=\"comment\">//        summer枚举对象时第二个，因此返回 1</span></span><br><span class=\"line\">        System.out.println(summer.ordinal());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        从反编译可以看出values方法，返货season02[]</span></span><br><span class=\"line\"><span class=\"comment\">//        含有定义所有的枚举对象</span></span><br><span class=\"line\">        season02[] values = season02.values();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;values.length ; i++) &#123;</span><br><span class=\"line\">            System.out.println(values[i].name());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        增强for循环演示</span></span><br><span class=\"line\"><span class=\"comment\">//        每执行一次values就会扔一个对象给season、</span></span><br><span class=\"line\"><span class=\"comment\">//        简单来说就是依次取出数组赋给season</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;==========增强for=========&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(season02 season:values)&#123;</span><br><span class=\"line\">            System.out.println(season.name());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        valueOf:将字符串转换成枚举对象，要求字符串必须VT为己有的常量名，否则会报错</span></span><br><span class=\"line\"><span class=\"comment\">//        1.根据输入的&quot;xia&quot;到season02中的枚举对象去查找</span></span><br><span class=\"line\"><span class=\"comment\">//        2.如果找到了，就返回，如果没有找到就报错，如下这个例子</span></span><br><span class=\"line\">        <span class=\"comment\">/*season02 vaof = chapterEnum.season02.valueOf(&quot;xia&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">        System.out.println(&quot;vaof = &quot;+ vaof);*/</span></span><br><span class=\"line\"><span class=\"comment\">//        3.只要valueOf()中的参数和枚举对象一致才能正常返回，如下</span></span><br><span class=\"line\">        <span class=\"type\">season02</span> <span class=\"variable\">xia</span> <span class=\"operator\">=</span> chapterEnum.season02.valueOf(<span class=\"string\">&quot;SUMMER&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;xia = &quot;</span> +xia);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        compareTo:比较两个枚举常量，比较的是编号</span></span><br><span class=\"line\"><span class=\"comment\">//        就是把season02.SPRING和season02.SUMMER的编号进行比较</span></span><br><span class=\"line\"><span class=\"comment\">//        底层是第一个的编号减去第二的编号，</span></span><br><span class=\"line\"><span class=\"comment\">//        如果=0则是相等的，</span></span><br><span class=\"line\"><span class=\"comment\">//        如果大于1，则代表前面那个编号大于后面一个编号</span></span><br><span class=\"line\"><span class=\"comment\">//        如果小于1，则反之</span></span><br><span class=\"line\">        System.out.println(season02.SPRING.compareTo(season02.SUMMER));<span class=\"comment\">//= -1</span></span><br><span class=\"line\">        System.out.println(season02.SPRING.compareTo(season02.WINTER));<span class=\"comment\">//= -3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用细节-4\"><a href=\"#使用细节-4\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h3><ol>\n<li>enum修饰的类不能在继承其他父类，因为enum会隐式继承一个Enum类</li>\n<li>enum实现的类，仍然是一个类，所以还是可以实现接口的</li>\n</ol>\n<h3 id=\"Switch中使用枚举\"><a href=\"#Switch中使用枚举\" class=\"headerlink\" title=\"Switch中使用枚举\"></a>Switch中使用枚举</h3><p>案例</p>\n<ol>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410224921752.png\" alt=\"image-20220410224921752\"></p>\n</li>\n<li><pre><code class=\"java\">package homeWork.Annotation;\n\npublic class AnnotationHomeWork08 &#123;\n    public static void main(String[] args) &#123;\n//        Color.BLACK.show();\n//        Color.RED.show();\n    Color red = Color.RED;\n//    在小（）内放入枚举对象\n//        在每个case后，直接写上枚举类，定义枚举对象即可\n        switch (red)&#123;\n            case RED:\n                System.out.println(&quot;红色&quot;);\n                break;\n            case BLUE:\n                System.out.println(&quot;蓝色&quot;);\n                break;\n            case BLACK:\n                System.out.println(&quot;黑色&quot;);\n                break;\n            case YELLOW:\n                System.out.println(&quot;黄色&quot;);\n                break;\n            case GREEN:\n                System.out.println(&quot;绿色&quot;);\n                break;\n            default:\n                System.out.println(&quot;没匹配到&quot;);\n\n        &#125;\n    &#125;\n&#125;\ninterface Tint&#123;\n    public void show();\n&#125;\nenum Color implements Tint&#123;\n    RED(255,0,0),\n    BLUE(0,0,255),\n    BLACK(0,0,0),\n    YELLOW(255,255,0),\n    GREEN(0,255,0);\n\n    private int redValue;\n    private int greenValue;\n    private int blueValue;\n\n    Color(int redValue, int greenValue, int blueValue) &#123;\n        this.redValue = redValue;\n        this.greenValue = greenValue;\n        this.blueValue = blueValue;\n    &#125;\n\n    @Override\n    public void show() &#123;\n        System.out.println(redValue+&quot;\\t&quot;+greenValue+&quot;\\t&quot;+blueValue);\n    &#125;\n&#125;\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 注解</span><br><span class=\"line\"></span><br><span class=\"line\">#### 介绍</span><br><span class=\"line\"></span><br><span class=\"line\">1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息</span><br><span class=\"line\">2. 和注解一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</span><br><span class=\"line\">3. 在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等，在javase中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替javaee旧版中所遗留 的繁冗代码和xml配置等</span><br><span class=\"line\"></span><br><span class=\"line\">使用Annotation时，前面要加@符号，并把Annotation当成一个修饰符使用。用于修饰它支持的程序元素</span><br><span class=\"line\"></span><br><span class=\"line\">1. @Override：限定某个方法，是重写父类方法，该注解只能用于方法</span><br><span class=\"line\"></span><br><span class=\"line\">   ```java</span><br><span class=\"line\">   class son extends father&#123;</span><br><span class=\"line\">   //1.@Override注解方法fly方法上，表示子类fly方法重写了父类的fly</span><br><span class=\"line\">   //2.如果这里没有写@Override ，还是重写了fly</span><br><span class=\"line\">   //3.如果写了@Override注解，编译器就会去检查该方法是否真的重写了fly方法，</span><br><span class=\"line\">   \t如果的确重写了，则编译通过。如果没有构成重写，则编译错误</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   public void fly()&#123;</span><br><span class=\"line\">    System.out.println(&quot;son fly...&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n@Override只能修饰方法，不能修饰其他类\n</code></pre>\n</li>\n<li><p>@Deprecated：用于表示某个程序元素(类、方法等)已过时</p>\n</li>\n<li><p>@SuppressWarnings：抑制编译器警告</p>\n<ol>\n<li><p>当写一些方法时，会出现一些无关不影响运行的警告。</p>\n<p>可以使用@SuppressWarnings来抑制警告信息</p>\n</li>\n<li><p>可以在@SuppressWarnings{“”}中写入希望抑制的警告信息</p>\n</li>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410190809537.png\" alt=\"image-20220410190809537\"></p>\n</li>\n<li><p>位置在哪就屏蔽哪里</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"元注解（了解）\"><a href=\"#元注解（了解）\" class=\"headerlink\" title=\"元注解（了解）\"></a>元注解（了解）</h3><p>@Target是修饰注解的注解，称为元注解  （了解）</p>\n<p>元注解的种类（使用不多，要求看到直到是干啥的）</p>\n<h4 id=\"1）Retention-x2F-x2F-指定注解的作用范围，三种SOURCE-CLASS-RUNTIME\"><a href=\"#1）Retention-x2F-x2F-指定注解的作用范围，三种SOURCE-CLASS-RUNTIME\" class=\"headerlink\" title=\"1）Retention &#x2F;&#x2F;指定注解的作用范围，三种SOURCE,CLASS,RUNTIME\"></a>1）Retention &#x2F;&#x2F;指定注解的作用范围，三种SOURCE,CLASS,RUNTIME</h4><p>说明：</p>\n<p>只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，</p>\n<p>@Rentention包含一个RententionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值</p>\n<p>@Rentention的三种值：</p>\n<p>RententionPolicy.SOURCE &#x2F;&#x2F;编译器使用后，直接丢弃这种策略的注释</p>\n<p>RententionPolicy.CLASS &#x2F;&#x2F; 编译器将把注释记录在class文件中，当运行java程序时，JVM不会保留注释，这是默认值</p>\n<p>RententionPolicy.RUNTIME  &#x2F;&#x2F;编译器将把注解记录在class文件中，当运行java程序时，JVM会保留注释，程序可以通过反射获取该注释</p>\n<p>示意图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410203107921.png\" alt=\"image-20220410203107921\"></p>\n<h4 id=\"2）Target-x2F-x2F-指定注解可以在哪些地方使用\"><a href=\"#2）Target-x2F-x2F-指定注解可以在哪些地方使用\" class=\"headerlink\" title=\"2）Target     &#x2F;&#x2F;指定注解可以在哪些地方使用\"></a>2）Target     &#x2F;&#x2F;指定注解可以在哪些地方使用</h4><p>用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素</p>\n<p>简单来说就是在哪些元素上使用</p>\n<p>@Target   也包含一个名为value的成员变量\t</p>\n<p>Target(value &#x3D; CONSTRUCTOR（构造器）, FIELD（field） , LOACL_VARIABLE（局部变量）, METHOD（方法）,PACKAGE（包）,PARAMETER ,TYPE )</p>\n<h4 id=\"3）Documented-x2F-x2F-指定该注解是否会在javadoc中体现\"><a href=\"#3）Documented-x2F-x2F-指定该注解是否会在javadoc中体现\" class=\"headerlink\" title=\"3）Documented    &#x2F;&#x2F;指定该注解是否会在javadoc中体现\"></a>3）Documented    &#x2F;&#x2F;指定该注解是否会在javadoc中体现</h4><p>@Documented   用于指定该元注解修饰的Annotation类将被Javadoc 工具提取成文档，即在生成文档时，可以看到注解</p>\n<p>定义Documented  注解必须设置Retention 值为RUNTIME</p>\n<h4 id=\"4）Inherited-x2F-x2F-子类会继承父类注解\"><a href=\"#4）Inherited-x2F-x2F-子类会继承父类注解\" class=\"headerlink\" title=\"4）Inherited    &#x2F;&#x2F;子类会继承父类注解\"></a>4）Inherited    &#x2F;&#x2F;子类会继承父类注解</h4><h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><h2 id=\"异常的概念\"><a href=\"#异常的概念\" class=\"headerlink\" title=\"异常的概念\"></a>异常的概念</h2><h3 id=\"介绍-10\"><a href=\"#介绍-10\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>java语言中，将程序执行中发生的不正常情况成为“异常”。（开发过程中的语法错误和逻辑错误不属于异常）</p>\n<p>执行过程中所发生的异常事件可分为两类</p>\n<ol>\n<li>Error（错误）：java虚拟机无法解决的严重问题。例如：JVM系统内部错误，资源耗尽等严重情况。例：StackOverflowError[栈溢出]和OOM（out of memory),Error是严重错误，程序会崩溃。</li>\n<li>Exception：因为，其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对想的代码进行处理，例如空指针访问，视图读取不存在的文件，网络连接中断等等，Exception分为两大类，运行时异常[程序运行发生的异常]和编译时异常[编译时，编译器查出的异常]</li>\n</ol>\n<h2 id=\"异常体系图（重要）\"><a href=\"#异常体系图（重要）\" class=\"headerlink\" title=\"异常体系图（重要）\"></a>异常体系图（重要）</h2><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411214601035.png\" alt=\"image-20220411214601035\"></p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411215335526.png\" alt=\"image-20220411215335526\"></p>\n<p>小结：</p>\n<ol>\n<li><p>异常分为两大类，运行时异常和编译时异常</p>\n</li>\n<li><p>运行时异常，编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该避免出现的异常。java.lang.RuntimeException类及它的子类都是运行程序</p>\n</li>\n<li><p>对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影像</p>\n</li>\n<li><p>编译时异常，是编译器要求必须处置的异常</p>\n</li>\n</ol>\n<h2 id=\"常见的异常\"><a href=\"#常见的异常\" class=\"headerlink\" title=\"常见的异常\"></a>常见的异常</h2><h3 id=\"常见的运行异常\"><a href=\"#常见的运行异常\" class=\"headerlink\" title=\"常见的运行异常\"></a>常见的运行异常</h3><h4 id=\"1）NullPoniterException-空指针异常\"><a href=\"#1）NullPoniterException-空指针异常\" class=\"headerlink\" title=\"1）NullPoniterException 空指针异常\"></a>1）NullPoniterException 空指针异常</h4><ol>\n<li>当程序试图在需要对象的地方使用 null时，抛出该异常</li>\n</ol>\n<h4 id=\"2-ArithmeticException数字运算异常\"><a href=\"#2-ArithmeticException数字运算异常\" class=\"headerlink\" title=\"2 ) ArithmeticException\t数字运算异常\"></a>2 ) ArithmeticException\t数字运算异常</h4><ol>\n<li>当出现异常的运行条件时，抛出此异常</li>\n<li>例如 一个整数”除以零”时，抛出此类的一个实例</li>\n</ol>\n<h4 id=\"3）ArrayIndexOutOfBoundsException数组下标异常\"><a href=\"#3）ArrayIndexOutOfBoundsException数组下标异常\" class=\"headerlink\" title=\"3）ArrayIndexOutOfBoundsException\t数组下标异常\"></a>3）ArrayIndexOutOfBoundsException\t数组下标异常</h4><ol>\n<li>用非法索引访问数组时抛出的异常，如果索引为负或者大于等于数组大小，则该索引为非法索引</li>\n</ol>\n<h4 id=\"4）ClassCastException类型转换异常\"><a href=\"#4）ClassCastException类型转换异常\" class=\"headerlink\" title=\"4）ClassCastException\t类型转换异常\"></a>4）ClassCastException\t类型转换异常</h4><ol>\n<li>当试图将对象强制转换为不是实例的子类时，抛出该异常</li>\n</ol>\n<h4 id=\"5）NumberFormatException数字格式不正确异常\"><a href=\"#5）NumberFormatException数字格式不正确异常\" class=\"headerlink\" title=\"5）NumberFormatException\t数字格式不正确异常[]\"></a>5）NumberFormatException\t数字格式不正确异常[]</h4><ol>\n<li>当应用程序试图将字符串转换成一种数值类型，但该字符不能转换为适当格式时，抛出该异常</li>\n<li>使用该异常我们可以确保输入的是满足条件的数字</li>\n</ol>\n<h3 id=\"常见的编译异常\"><a href=\"#常见的编译异常\" class=\"headerlink\" title=\"常见的编译异常\"></a>常见的编译异常</h3><h4 id=\"介绍-11\"><a href=\"#介绍-11\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>编译异常是指在编译期间。就必须处理的异常，否则代码不能通过编译</p>\n<h4 id=\"常见的编译异常-1\"><a href=\"#常见的编译异常-1\" class=\"headerlink\" title=\"常见的编译异常\"></a>常见的编译异常</h4><ol>\n<li>SQLException\t&#x2F;&#x2F;操作数据库时，查询表可能发生的异常</li>\n<li>IOException\t\t&#x2F;&#x2F;操作文件时，发生的异常</li>\n<li>FileNotFoundException\t&#x2F;&#x2F;当操作一个不存在的文件时，发生异常</li>\n<li>ClassNotFoundException\t&#x2F;&#x2F;加载类，该类不存在时，异常</li>\n<li>EOFException\t\t&#x2F;&#x2F;操作文件，到文件末尾，发生异常</li>\n<li>IIIegalArguementException\t&#x2F;&#x2F;参数异常</li>\n</ol>\n<h2 id=\"异常处理概念\"><a href=\"#异常处理概念\" class=\"headerlink\" title=\"异常处理概念\"></a>异常处理概念</h2><h3 id=\"基本介绍-2\"><a href=\"#基本介绍-2\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>异常处理就是当异常发生时，对异常处理的方式</p>\n<h3 id=\"异常处理方式\"><a href=\"#异常处理方式\" class=\"headerlink\" title=\"异常处理方式\"></a>异常处理方式</h3><h4 id=\"1）try-catch-finally\"><a href=\"#1）try-catch-finally\" class=\"headerlink\" title=\"1）try-catch-finally\"></a>1）try-catch-finally</h4><p>程序员在代码中捕获发生的异常，自行处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\t代码/可能有异常</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\"><span class=\"comment\">//捕获的异常，传给e</span></span><br><span class=\"line\"><span class=\"comment\">//1.当异常发生时</span></span><br><span class=\"line\"><span class=\"comment\">//2.系统将异常封装成Exception对象e，传递给catch</span></span><br><span class=\"line\"><span class=\"comment\">//3.得到异常对象后，程序员自己处理</span></span><br><span class=\"line\"><span class=\"comment\">//4.如果没有发生异常，则catch代码块不执行</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不管try代码块是否有异常发生，始终都要执行finally</span></span><br><span class=\"line\">    <span class=\"comment\">//通常将释放资源的代码方法finally代码块中</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2）throws\"><a href=\"#2）throws\" class=\"headerlink\" title=\"2）throws\"></a>2）throws</h4><p>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p>\n<h5 id=\"处理机制图\"><a href=\"#处理机制图\" class=\"headerlink\" title=\"处理机制图\"></a>处理机制图</h5><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411224543192.png\" alt=\"image-20220411224543192\"></p>\n<p>throws处理机制</p>\n<ol>\n<li>try-catch-finally和throws二选一</li>\n<li>如果程序员，没有显示是处理异常，默认throws</li>\n</ol>\n<h2 id=\"异常处理分类\"><a href=\"#异常处理分类\" class=\"headerlink\" title=\"异常处理分类\"></a>异常处理分类</h2><h3 id=\"try-catch方式处理异常说明\"><a href=\"#try-catch方式处理异常说明\" class=\"headerlink\" title=\"try-catch方式处理异常说明\"></a>try-catch方式处理异常说明</h3><h4 id=\"1）java提供try和catch块来处理异常。\"><a href=\"#1）java提供try和catch块来处理异常。\" class=\"headerlink\" title=\"1）java提供try和catch块来处理异常。\"></a>1）java提供try和catch块来处理异常。</h4><p>try块用于包含可能出错的代码块。catch用于处理try块中发生的异常，可以根据需要在程序中有多个数量的try…catch块</p>\n<h4 id=\"2）基本语法\"><a href=\"#2）基本语法\" class=\"headerlink\" title=\"2）基本语法\"></a>2）基本语法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//可疑代码</span></span><br><span class=\"line\"><span class=\"comment\">//将异常生成对应的异常对象，传递给catch块</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(异常)&#123;</span><br><span class=\"line\"><span class=\"comment\">//对异常的处理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//没有finally是可以通过的</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用案例</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;糖&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">a</span>  <span class=\"operator\">=</span> Integer.parseInt(str);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;数字=&quot;</span>+a);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;异常信息=&quot;</span>+e.getMessage());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意事项-6\"><a href=\"#注意事项-6\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ol>\n<li><p>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块</p>\n</li>\n<li><p>如果异常没有发生，则顺序执行try代码块，不会进入到catch块</p>\n</li>\n<li><p>如果希望不管是否能发生异常，都执行某段代码块（比如关闭链接，释放资源等）、</p>\n</li>\n<li><p>可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求是父类异异常在后，子类异常在前，比如（Exception 在后，NullPointerException 在前）如果发生异常，只会匹配一个catch</p>\n<ol>\n<li><p>&#96;&#96;&#96;java<br>例:<br>try{</p>\n<p>}catch(NullPointerException e){</p>\n<p>}catch(Exception e){</p>\n<p>}finally{</p>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. 可以记性try-finally配合使用，这种方法相当于没有捕获异常，因此程序会直接崩掉</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 应用场景：就是执行一段代码，不论是否发生异常，都必须执行某个业务逻辑</span><br><span class=\"line\"></span><br><span class=\"line\">#### 小结</span><br><span class=\"line\"></span><br><span class=\"line\">1. 如果没有出现异常，则执行try块中所有语句，不执行catch块中的语句，如果有finally，最后还要执行finally语句</span><br><span class=\"line\">2. 如果出现异常，则try块异常发生后，剩下的语句不在执行，将执行catch块中的语句，如果有finally，最后还要执行finally里面的语句</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### throws异常处理</span><br><span class=\"line\"></span><br><span class=\"line\">#### 介绍：</span><br><span class=\"line\"></span><br><span class=\"line\">1）如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理异常，则此方法应显示的声明抛出异常，表明该方法将不对这些异常进行处理，而且由该方法的调用者负责处理</span><br><span class=\"line\"></span><br><span class=\"line\">2）在方法声明throws语句可以声明排除异常的列表，throws后面的异常类型可以是方法产生的异常类型，也可以是它的父类</span><br><span class=\"line\"></span><br><span class=\"line\">#### 注意事项</span><br><span class=\"line\"></span><br><span class=\"line\">1. 对于编译异常，程 序必须处理，比如try-catch或者throws</span><br><span class=\"line\">2. 对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</span><br><span class=\"line\">3. 子类重写父类的方法是，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一直，要么为父类抛出的异常的类型和子类型</span><br><span class=\"line\">4. 在throws过程中，如果有try-catch，就相当于处理异常，就可以不必throws</span><br><span class=\"line\">5. ![image-20220412135104986](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412135104986.png)</span><br><span class=\"line\">6. </span><br><span class=\"line\"></span><br><span class=\"line\">## 自定义异常  </span><br><span class=\"line\"></span><br><span class=\"line\">### 介绍：</span><br><span class=\"line\"></span><br><span class=\"line\">当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述错误信息。</span><br><span class=\"line\"></span><br><span class=\"line\">### 自定义异常的步骤</span><br><span class=\"line\"></span><br><span class=\"line\">1. 定义类：自定义异常类名（程序员自己写）继承Exceotion或RuntimeException</span><br><span class=\"line\">2. 如果继承Ecxeption，属于编译异常</span><br><span class=\"line\">3. 如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">//当我们接受Person对象年龄时，要求范围在18-120之间，否则抛出一个自定义异常（要求继承RuntimeException），并提示</span><br><span class=\"line\">public class CustomException &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age =30;</span><br><span class=\"line\">//        结果取反</span><br><span class=\"line\">        if (!(age&gt;=18&amp;&amp;age&lt;=120))&#123;</span><br><span class=\"line\">//            通过构造器设置输出信息</span><br><span class=\"line\">            throw new AgeException(&quot;年龄需要在18-120之间&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;你的年龄为&quot;+age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//定义一个异常类继承RuntimeException</span><br><span class=\"line\">//一般情况下，我们自定义异常都继承RuntimeException</span><br><span class=\"line\">//也就是说大都是定义为运行时异常，好处是我们可以使用默认处理机制</span><br><span class=\"line\">//即比较方便</span><br><span class=\"line\">class AgeException extends RuntimeException&#123;</span><br><span class=\"line\">//    定义一个构造器</span><br><span class=\"line\">    public AgeException(String message) &#123;</span><br><span class=\"line\">        super(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"throw和throws的对比\"><a href=\"#throw和throws的对比\" class=\"headerlink\" title=\"throw和throws的对比\"></a>throw和throws的对比</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>意义</th>\n<th>位置</th>\n<th align=\"center\">后面跟的东西</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>throws</td>\n<td>异常处理的一种方式</td>\n<td>方法声明处</td>\n<td align=\"center\">异常类型</td>\n</tr>\n<tr>\n<td>throw</td>\n<td>手动生成异常对象的关键字</td>\n<td>方法体中</td>\n<td align=\"center\">异常对象</td>\n</tr>\n</tbody></table>\n<p>throws</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">xxx</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">    <span class=\"comment\">//throws通常放在定义方法的末尾</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>throw</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//throw后面跟的是异常对象</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AgeException</span>(<span class=\"string\">&quot;年龄需要在18-120之间&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h1><h2 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h2><h3 id=\"包装类的分类-Wrapper\"><a href=\"#包装类的分类-Wrapper\" class=\"headerlink\" title=\"包装类的分类   Wrapper\"></a>包装类的分类   Wrapper</h3><p>1、针对八种基本数据类型相应类型的引用类型—包装类</p>\n<p>2、有了类的特点，就可以调用类中的方法</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">包装类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Character</td>\n</tr>\n<tr>\n<td align=\"center\">byte</td>\n<td align=\"center\"><code>Byte</code></td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\"><code>Short</code></td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\"><code>Integer</code></td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\"><code>Long</code></td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\"><code>Float</code></td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\"><code>Doble</code></td>\n</tr>\n</tbody></table>\n<p>上述标出来的6个数据类型父类均为Number</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412164154544.png\" alt=\"image-20220412164154544\"></p>\n<h3 id=\"包装类和基本数据的转换\"><a href=\"#包装类和基本数据的转换\" class=\"headerlink\" title=\"包装类和基本数据的转换\"></a>包装类和基本数据的转换</h3><h4 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h4><p>演示包装类和基本数据类型的相互转换，以int和integer演示</p>\n<p>1）jdk5前的手动装箱和拆箱方式，装箱：基本类型-&gt;包装类型,反之拆箱</p>\n<p>2）jdk5以后（包括jdk5）的自动装箱和拆箱方式</p>\n<p>3）自动装箱底层调用的是valueOf方法，比如integer.valueOf();</p>\n<p>4）其他类型同理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本类型——————&gt;包装类型[手动装箱]</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(i);</span><br><span class=\"line\"><span class=\"type\">integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> Integer.value(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//包装类型————————&gt;基本类型[手动拆箱]</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">99</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">j1</span> <span class=\"operator\">=</span> j.intValue();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//jdk5.0之后的方式</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">m2</span> <span class=\"operator\">=</span>m;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">99</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> n;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;n+100&quot;</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;n*2&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(n&gt;<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"包装类型和String类型的相互转换\"><a href=\"#包装类型和String类型的相互转换\" class=\"headerlink\" title=\"包装类型和String类型的相互转换\"></a>包装类型和String类型的相互转换</h3><h4 id=\"案例-2\"><a href=\"#案例-2\" class=\"headerlink\" title=\"案例\"></a>案例</h4><p>以integer和String转为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//包装类型----&gt;String类型</span></span><br><span class=\"line\"><span class=\"type\">integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">//方式1</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> i.toString();</span><br><span class=\"line\"><span class=\"comment\">//方式2</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> String.valueOf(i);</span><br><span class=\"line\"><span class=\"comment\">//方式3</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s3</span> <span class=\"operator\">=</span> i+<span class=\"string\">&quot;&quot;</span>; </span><br><span class=\"line\">System.out.println(s3);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//String ---&gt;包装类</span></span><br><span class=\"line\"><span class=\"comment\">//方式1</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(s1);</span><br><span class=\"line\"><span class=\"comment\">//方式2</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j2</span> <span class=\"operator\">=</span> Integer.valueOf(s2);</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">Integer.parseInt(s3);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Integer类和Character类常方法\"><a href=\"#Integer类和Character类常方法\" class=\"headerlink\" title=\"Integer类和Character类常方法\"></a>Integer类和Character类常方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.MIN_VALUE <span class=\"comment\">//返回最小值</span></span><br><span class=\"line\">Integer.MAX_VALUE <span class=\"comment\">//返回最大值</span></span><br><span class=\"line\"></span><br><span class=\"line\">Character.isDigit(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//判断是不是数字</span></span><br><span class=\"line\">Character.isLetter(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//判断是不是字母</span></span><br><span class=\"line\">Character.isUpperCase(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//判断是不是大写</span></span><br><span class=\"line\">Character.inLowerCase(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//判断是不是小写</span></span><br><span class=\"line\"></span><br><span class=\"line\">Character.isWhitespace(<span class=\"string\">&#x27;a&#x27;</span>)；<span class=\"comment\">//判断是不是空格</span></span><br><span class=\"line\">Character.toUpperCase(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//转成大写</span></span><br><span class=\"line\">Character.toLowerCase(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//转成小写</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Integer面试题\"><a href=\"#Integer面试题\" class=\"headerlink\" title=\"Integer面试题\"></a>Integer面试题</h3><p>1.看代码输出什么，为啥</p>\n<ol>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164815801.png\" alt=\"image-20220413164815801\"></p>\n</li>\n<li><p>因为integer的原码定义好了从-128-127之间不返回一个对象</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164729185.png\" alt=\"image-20220413164729185\"></p>\n<p>2.integer面试题总结</p>\n<p>看下列代码输出什么结果</p>\n<p><span style=\"color:red;background:yellow \" >只要有基本数据类型会自动拆箱，比对的是数值。判断的是值是否相等</span></p>\n<p>如下的示例六和七，比对的是</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413205739995.png\" alt=\"image-20220413205739995\"></p>\n</li>\n</ol>\n<h2 id=\"String-重要\"><a href=\"#String-重要\" class=\"headerlink\" title=\"String(重要)\"></a>String(重要)</h2><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413213320195.png\" alt=\"image-20220413213320195\"></p>\n<p>String实现了三个接口并继承了Object类</p>\n<ul>\n<li>Serializable接口：说明String可以串行化。（可以在网络传输）</li>\n<li>Comparable接口：说明String对象可以相互比较</li>\n<li>CharSequence接口：字符序列</li>\n</ul>\n<p><span style=\"color:blue;background:pink\">String类是final类，String类不能被其他类继承</span></p>\n<p><span style=\"color:blue;background:pink\">String 有属性，private final char value[];用于存放字符串内容（字符串的本质就是char数组）</span></p>\n<p><span style=\"color:red;background:pink\">(注意：value是一个final类型，不可修改（即：value不能指向新的地址，但是单个字符内容时可以变化的）)</span></p>\n<h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>1）String对象用于保存字符串，也就是一组字符序列</p>\n<p>2）字符串常量对象时用双引号括起来的字符序列。例如：”你好”，”21.213”，”boy”等等</p>\n<p>3）字符串的字符使用Unicode字符编码，一个字符（不区分字幕还是汉字）占两个字节</p>\n<p>4）String类较常用的构造方法（其他手册）</p>\n<ul>\n<li>String s1 &#x3D; new String();</li>\n<li>String s2 &#x3D; new String(String original);</li>\n<li>String s3 &#x3D; new String(char[] a);</li>\n<li>String s4 &#x3D; new String(char[] a,int startIndex, int count)</li>\n</ul>\n<h3 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h3><h4 id=\"1）方式一：直接赋值String-s-x3D-“xxx”\"><a href=\"#1）方式一：直接赋值String-s-x3D-“xxx”\" class=\"headerlink\" title=\"1）方式一：直接赋值String s &#x3D; “xxx”;\"></a>1）方式一：直接赋值String s &#x3D; “xxx”;</h4><p>创建流程：</p>\n<p>先从常量池查看是否有”xxx”数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</p>\n<h4 id=\"2）方式二：调用构造器-String-s-x3D-new-String-“xxx”-；\"><a href=\"#2）方式二：调用构造器-String-s-x3D-new-String-“xxx”-；\" class=\"headerlink\" title=\"2）方式二：调用构造器 String s &#x3D; new String(“xxx”)；\"></a>2）方式二：调用构造器 String s &#x3D; new String(“xxx”)；</h4><p>流程：现在堆中创建空间，里面维护了value属性，指向常量池的xxx空间。如果常量池没有”xxx”，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414101904944.png\" alt=\"image-20220414101904944\"></p>\n<h3 id=\"String字符串的特性\"><a href=\"#String字符串的特性\" class=\"headerlink\" title=\"String字符串的特性\"></a>String字符串的特性</h3><p>1）String是一个final类，代表不可变的字符序列</p>\n<p>2）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的 </p>\n<h4 id=\"面试题、\"><a href=\"#面试题、\" class=\"headerlink\" title=\"面试题、\"></a>面试题、</h4><p>1）String a &#x3D; “hello”+”abc”;创建了几个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编译器会在后台会进行优化，判断创建的常量池对象，是否有引用指向</span><br><span class=\"line\">优化等价于<span class=\"type\">String</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;helloabc&quot;</span>；</span><br><span class=\"line\"></span><br><span class=\"line\">所以答案是创建了一个对象</span><br><span class=\"line\">不是创建了三个</span><br></pre></td></tr></table></figure>\n\n<p>2）String a &#x3D; “hello”;</p>\n<p>String b &#x3D; “abc”;</p>\n<p>String c &#x3D; a+b;</p>\n<p>总共创建了几个对象</p>\n<p>所以只创建了一个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行流程</span><br><span class=\"line\"><span class=\"number\">1.</span> 先创建了一个<span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> StringBuilder();</span><br><span class=\"line\"><span class=\"number\">2.</span>执行sb.append(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"><span class=\"number\">3.</span>sb.append(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"number\">4.</span><span class=\"type\">String</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> sb.toString();</span><br><span class=\"line\">最后其实是c指向了堆中的对象（String）value[],堆中的对象指向了池中的“helloabc”</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414140922725.png\" alt=\"image-20220414140922725\"></p>\n<p>小结:底层是StringBuilder sb &#x3D; new StringBuilder();sb.append(a);sb.append(b);sb是在堆中，并append是在原来的字符串的基础上追加的。</p>\n<p>重要规则：String c1 &#x3D; “sb”+”cd”;常量相加，看的是池。String c1 &#x3D; a+b;变量相加，是在堆中</p>\n<h3 id=\"String类的常见方法\"><a href=\"#String类的常见方法\" class=\"headerlink\" title=\"String类的常见方法\"></a>String类的常见方法</h3><h4 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h4><p>​\tString类是保存字符串常量的。每次更新都需要重新开辟空间，效率低，因此java设计者还提供StringBuilder和StringBuffer来增强String的功能，并提高效率。</p>\n<h4 id=\"Strng常见的方法\"><a href=\"#Strng常见的方法\" class=\"headerlink\" title=\"Strng常见的方法\"></a>Strng常见的方法</h4><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414145929644.png\" alt=\"image-20220414145929644\"></p>\n<ul>\n<li><p>equals\t\t&#x2F;&#x2F;区分大小写，判断是否相等</p>\n</li>\n<li><p>equalsIgnoreCase   &#x2F;&#x2F;忽略大小写，判断内容是否相等</p>\n</li>\n<li><p>length  &#x2F;&#x2F;获取字符的个数，字符窜长度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </p>\n</li>\n<li><p>indexOf  &#x2F;&#x2F;获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到返回-1</p>\n</li>\n<li><p>lastIndexOf   &#x2F;&#x2F;获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，返回-1</p>\n</li>\n<li><p>substring &#x2F;&#x2F;截取指定范围字符串</p>\n</li>\n<li><p>trim  &#x2F;&#x2F;去前后空格</p>\n</li>\n<li><p>charAt &#x2F;&#x2F;获取某索引处的字符，之一不能使用Str[index]这种方式</p>\n</li>\n<li><p>toUpperCase  &#x2F;&#x2F;字符串转换成大写</p>\n</li>\n<li><p>toLowerCase  &#x2F;&#x2F;字符串转换成小写</p>\n</li>\n<li><p>concat  &#x2F;&#x2F;拼接字符串</p>\n</li>\n<li><p>replace  替换字符串中字符</p>\n</li>\n<li><p>split 分割字符串，罪域某些分割字符，我们需要转义</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">poem</span> <span class=\"operator\">=</span><span class=\"string\">&quot;锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦&quot;</span>;</span><br><span class=\"line\">String[] split = poem.split(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//以，号为标准，分割上述整个字符串</span></span><br><span class=\"line\"><span class=\"comment\">//上述字符串被分割为4个部分用数组接收</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在堆字符串进行分割时，如f</span></span><br><span class=\"line\">poem = <span class=\"string\">&quot;E:\\\\aaa\\\\bbb&quot;</span>;</span><br><span class=\"line\">split  = poem.split(<span class=\"string\">&quot;\\\\\\\\&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>和 文件路径</p>\n</li>\n<li><p>compareTo &#x2F;&#x2F;比较两个字符串的大小，如果前者大则返回正数，如果后者大则返回负数，</p>\n<p>如果相等（</p>\n<p>1.如果长度相同，并且字符串也相同返回0。</p>\n<p>2.如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回if(c1 !&#x3D; c2）{</p>\n<p>​\t\treturn c1 - c2;</p>\n<p>}</p>\n<p>3.如果前面的部分都相同，就返回str1.len - str2.len）</p>\n</li>\n<li><p>toCharArray &#x2F;&#x2F;字符串转成字符数组</p>\n</li>\n<li><p>format&#x2F;&#x2F;格式化字符串，%s字符串，%c字符，%d 整型，%.2f 浮点型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  %s%d%.2f%c成为占位符</span></span><br><span class=\"line\"><span class=\"comment\">//  这些占位符由后面的变量来替换</span></span><br><span class=\"line\"><span class=\"comment\">//  %s表示后面由字符串替换</span></span><br><span class=\"line\"><span class=\"comment\">//  %d表示整数替换</span></span><br><span class=\"line\"><span class=\"comment\">//  %.2f表示使用小数来替换，替换后，只会保留小数两位，并且会进行四舍五入的处理</span></span><br><span class=\"line\"><span class=\"comment\">//  %c是char类型替换</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span><span class=\"string\">&quot;jack&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"variable\">score</span> <span class=\"operator\">=</span> <span class=\"number\">98.3</span> /<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> <span class=\"variable\">gender</span> <span class=\"operator\">=</span><span class=\"string\">&#x27;男&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//传统方法拼接</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;名字是&quot;</span>+name+<span class=\"string\">&quot;年龄是&quot;</span>+age+<span class=\"string\">&quot;成绩是&quot;</span>+score+<span class=\"string\">&quot;性别：&quot;</span>+gender<span class=\"string\">&quot;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">//使用format拼接</span></span><br><span class=\"line\"><span class=\"string\">String info2 =String.format(&quot;</span>姓名是%s年龄是%d成绩是%d性别时%c<span class=\"string\">&quot;,name,age,score,gender);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">//可以做成一个模板后面直接调用</span></span><br><span class=\"line\"><span class=\"string\">String formatstr = &quot;</span>姓名是%s年龄是%d成绩是%d性别时%c<span class=\"string\">&quot;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">String info2 =String.format(formatstr,name,age,score,gender);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">System.out.println(&quot;</span>info2 =<span class=\"string\">&quot;+info2);</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"StringBuffer-重要\"><a href=\"#StringBuffer-重要\" class=\"headerlink\" title=\"StringBuffer(重要)\"></a>StringBuffer(重要)</h2><p><span style=\"color:red;background:pink\">串行化（对象可以网络传输，可以保存到文件）</span></p>\n<h3 id=\"基本介绍-3\"><a href=\"#基本介绍-3\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>java.lang.StringBuffer代表可变字符序列，可以对字符串内容进行增删</p>\n<p>很多方法与String相同，但StringBuffer是可变长度的</p>\n<p>StringBuffer是一个容器</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415090614911.png\" alt=\"image-20220415090614911\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringBuffer</span> <span class=\"variable\">stringBuffer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//1.StringBuffer 的直接父类是 AbstractStringBuilder</span></span><br><span class=\"line\"><span class=\"comment\">//2.StringBuffer 实现了Serializable，即StringBuffer的对象可以串行化</span></span><br><span class=\"line\"><span class=\"comment\">//3.在父类中，AbstractStringBuilder 有属性 char[] value ，不是final</span></span><br><span class=\"line\">\t该value 数组存放祖父穿内容，因数存放在堆中的</span><br><span class=\"line\"><span class=\"comment\">//4.StringBuffer是一个final类， 不能被继承</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"String-对比StringBuffer\"><a href=\"#String-对比StringBuffer\" class=\"headerlink\" title=\"String 对比StringBuffer\"></a>String 对比StringBuffer</h3><p>1）String保存的是字符串常量，里面的值不能更改，每次String类的更新实际是更改地址，效率较低&#x2F;&#x2F;private final char value[]；</p>\n<p>2）StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用更新地址，效率较高&#x2F;&#x2F;char[] value &#x2F;&#x2F;这个放在堆</p>\n<h3 id=\"StringBuffer构造器\"><a href=\"#StringBuffer构造器\" class=\"headerlink\" title=\"StringBuffer构造器\"></a>StringBuffer构造器</h3><p>StringBuffer()</p>\n<ul>\n<li><p>构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;创建一个大小为16的char[]，用于存放字符串内容<br>StringBuffer stringBuffer &#x3D; new StringBuffer();</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">StringBuffer(CharSequence seq)</span><br><span class=\"line\"></span><br><span class=\"line\">* public java.lang.StringBuffer(CharSequence seq)构造一个字符串缓冲区，它包含与指定的CharSequence 相同的字符</span><br><span class=\"line\"></span><br><span class=\"line\">StringBuffer(int capacity)//capacity[容量]</span><br><span class=\"line\"></span><br><span class=\"line\">* 构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对char[]大小进行指定</span><br><span class=\"line\"></span><br><span class=\"line\">* ```java</span><br><span class=\"line\">  //通过构造器指定 char[]大小</span><br><span class=\"line\">  StringBuffer stringBuffer = new StringBuffer(100);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>StringBuffer(String str)</p>\n<ul>\n<li><p>构造一个字符串缓冲器，并将其内容初始化为指定的字符串内容</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;通过给一个String 创建StringBuffer,char[] 大小就是str.length()+16<br>StringBuffer stringBuffer &#x3D; new StringBuffer(“hello”);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### String和StringBuffer</span><br><span class=\"line\"></span><br><span class=\"line\">#### String-&gt;StringBuffer</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">//        String-&gt;StringBuffer</span><br><span class=\"line\">//        方式一</span><br><span class=\"line\">        String str =&quot;xxx&quot;;</span><br><span class=\"line\">//        注意：返回的是StringBuffer对象，对str本身是没有影响的</span><br><span class=\"line\">        StringBuffer stringBuffer = new StringBuffer(str);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//        方式二，使用append方法</span><br><span class=\"line\">        StringBuffer stringBuffer1 = new StringBuffer();</span><br><span class=\"line\">        stringBuffer1 = stringBuffer1.append(str);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"StringBuffer-gt-String\"><a href=\"#StringBuffer-gt-String\" class=\"headerlink\" title=\"StringBuffer-&gt;String\"></a>StringBuffer-&gt;String</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        StringBuffer-&gt;String</span></span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">stringBuffer2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(<span class=\"string\">&quot;xxxxxx&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        方式一,使用StringBuffer提供的 toString方法;</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> stringBuffer2.toString();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        方式二,使用构造器搞定</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(stringBuffer2);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"StirngBuffer类常见方法\"><a href=\"#StirngBuffer类常见方法\" class=\"headerlink\" title=\"StirngBuffer类常见方法\"></a>StirngBuffer类常见方法</h3><ol>\n<li>增 append</li>\n<li>删 delete(start,end)</li>\n<li>改 replace(start,end,string)&#x2F;&#x2F;将start—end间的内容替换掉，不含end</li>\n<li>查 indexOf &#x2F;&#x2F;查询字符串第1次出现的索引，如果找不回返回-1</li>\n<li>插 insert</li>\n<li>获取长度 length</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       <span class=\"type\">StringBuffer</span> <span class=\"variable\">stringBuffer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        stringBuffer.append(<span class=\"string\">&#x27;x&#x27;</span>);</span><br><span class=\"line\">        stringBuffer.append(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">        stringBuffer.append(<span class=\"string\">&quot;wangwu&quot;</span>).append(<span class=\"literal\">true</span>).append(<span class=\"number\">10.2</span>);</span><br><span class=\"line\">        System.out.println(stringBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        删除</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span></span><br><span class=\"line\"><span class=\"comment\">        * 解读：删除11~14的字符[11,14)</span></span><br><span class=\"line\"><span class=\"comment\">        * */</span></span><br><span class=\"line\">        stringBuffer.delete(<span class=\"number\">11</span>,<span class=\"number\">14</span>);</span><br><span class=\"line\">        System.out.println(stringBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//    改</span></span><br><span class=\"line\"><span class=\"comment\">//        修改本质就是替换</span></span><br><span class=\"line\"><span class=\"comment\">//        使用fff替换索引11-14的字符</span></span><br><span class=\"line\">        stringBuffer.replace(<span class=\"number\">11</span>,<span class=\"number\">14</span>,<span class=\"string\">&quot;fff&quot;</span>);</span><br><span class=\"line\">        System.out.println(stringBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        查</span></span><br><span class=\"line\"><span class=\"comment\">//        查找指定的子串在字符串出现的索引.如果找不到返回-1</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> stringBuffer.indexOf(<span class=\"string\">&quot;zhang&quot;</span>);</span><br><span class=\"line\">        System.out.println(index);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        插入</span></span><br><span class=\"line\"><span class=\"comment\">//        指定一个位置插入</span></span><br><span class=\"line\"><span class=\"comment\">//        在索引为9的位置插入&quot;老王&quot;，原来索引为9的内容自动后移</span></span><br><span class=\"line\">        stringBuffer.insert(<span class=\"number\">9</span>,<span class=\"string\">&quot;老王&quot;</span>);</span><br><span class=\"line\">        System.out.println(stringBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        获取长度</span></span><br><span class=\"line\">        System.out.println(stringBuffer.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 输入商品名称和商品价格，要求打印效果示例，实用前面学习的方法完成</span></span><br><span class=\"line\"><span class=\"comment\">         * 商品名  商品价格</span></span><br><span class=\"line\"><span class=\"comment\">         * 手机123，456.56  //比如 价格价格1,456,786.5</span></span><br><span class=\"line\"><span class=\"comment\">         * 要求：价格的小数点前面每三位用,号隔开，再输出</span></span><br><span class=\"line\"><span class=\"comment\">        * */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String prices;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">price</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">stringBuffer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(price);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        先完成最简单的实现21,312,412.32</span></span><br><span class=\"line\"><span class=\"comment\">//        找到小数点的索引,然后再该位置的前三位插入,</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> stringBuffer.lastIndexOf(<span class=\"string\">&quot;.&quot;</span>)-<span class=\"number\">3</span>; j &gt;<span class=\"number\">0</span> ; j-=<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            stringBuffer = stringBuffer.insert(j, <span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(stringBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"StringBuilder-重要\"><a href=\"#StringBuilder-重要\" class=\"headerlink\" title=\"StringBuilder(重要)\"></a>StringBuilder(重要)</h2><h3 id=\"基本介绍-4\"><a href=\"#基本介绍-4\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>1）一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder 不是线程安全)。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快（单线程的情况下，优先使用StringBuilder）</p>\n<p>2）在StringBuilder上主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据</p>\n<h3 id=\"StringBuilder常用方法\"><a href=\"#StringBuilder常用方法\" class=\"headerlink\" title=\"StringBuilder常用方法\"></a>StringBuilder常用方法</h3><p>StringBuilder和StringBuffer均代表可变字符序列，方法是一样的，所以使用和StringBuffer一样。</p>\n<ol>\n<li>StringBuilder是final类，不能被继承</li>\n<li>StringBuilder对象可以串行化</li>\n<li>继承了AbstractStringBuilder属性 char[] value，内容存到value</li>\n<li>实现了Serializable接口，序列化（所谓系列化既可以保存类型和数据本身）</li>\n</ol>\n<h2 id=\"String、StringBuffer、StringBuilder的比较☆\"><a href=\"#String、StringBuffer、StringBuilder的比较☆\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder的比较☆\"></a>String、StringBuffer、StringBuilder的比较☆</h2><p>1）StringBuilder和StringBuffer非常类似，均代表可变字符序列，而且方法也一样</p>\n<p>2）String：不可变字符序列，效率低，但是复用率高。</p>\n<p>3）StringBuffer：可变字符序列、效率较高（增删）、线程安全</p>\n<p>4）StringBuilder：可变字符序列、效率最高、线程不安全</p>\n<p>5）String使用注意事项：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s=<span class=\"string\">&quot;a&quot;</span>; <span class=\"comment\">//创建了一个字符串</span></span><br><span class=\"line\">s+= <span class=\"string\">&quot;b&quot;</span>;   <span class=\"comment\">//实际上原来的&quot;a&quot;字符串对象已经丢弃了，现在又产生了一个转字符串s+&quot;b&quot;（也就是&quot;ab&quot;).如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=》</span></span><br><span class=\"line\"><span class=\"comment\">//结论：如果我们对Stirng做大量修改，不要使用String</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h3><p>StringBuilder  &gt; StringBuffer &gt;String </p>\n<h3 id=\"使用原则，结论\"><a href=\"#使用原则，结论\" class=\"headerlink\" title=\"使用原则，结论\"></a>使用原则，结论</h3><ol>\n<li>如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder</li>\n<li>如果字符串存在大量的修改操作，并且在单线程的情况下使用StringBuilder</li>\n<li>如果字符串存在大量的修改操作，并且在多线程的情况下使用StringBuffer</li>\n<li>如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等</li>\n</ol>\n<p>StringBuffer和StringBuilder的方法使用一样</p>\n<h2 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h2><h3 id=\"基本介绍-5\"><a href=\"#基本介绍-5\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>Math类包含用于执行基本数学运算方法，如初等指数，对数，平方根和三角函数</p>\n<p>方法一览（均为静态方法）<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415145338171.png\" alt=\"image-20220415145338171\"></p>\n<h3 id=\"Match常用的方法\"><a href=\"#Match常用的方法\" class=\"headerlink\" title=\"Match常用的方法\"></a>Match常用的方法</h3><ol>\n<li><p>abs  绝对值</p>\n</li>\n<li><p>pow  求幂</p>\n</li>\n<li><p>ceil   向上取整  (返回&gt;&#x3D;该参数的最小整数)</p>\n</li>\n<li><p>floor   向下取整  (返回&lt;&#x3D;该参数的最大整数)</p>\n</li>\n<li><p>round   四舍五入</p>\n</li>\n<li><p>sqrt  求开方</p>\n</li>\n<li><p>random  求随机数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        random随机数</span></span><br><span class=\"line\"><span class=\"comment\">        random默认返回 0&lt;= x &lt;1之间的一个随机小数</span></span><br><span class=\"line\"><span class=\"comment\">        请写出a-b之间的一个随机整数，a,b均为整数比如a=2,b=7</span></span><br><span class=\"line\"><span class=\"comment\">        即返回一个2 - 7 之间的随机数</span></span><br><span class=\"line\"><span class=\"comment\">        * */</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * random返回的是0&lt;=x &lt;1之间的一个随机小数</span></span><br><span class=\"line\"><span class=\"comment\">         * Math.random()*(b-a)返回的就是0&lt;= 数 &lt;=b-a</span></span><br><span class=\"line\"><span class=\"comment\">         * (1)(int)(a)&lt;= x &lt;(int)(a+Math.random() * (b-a +1))</span></span><br><span class=\"line\"><span class=\"comment\">        * (2)集体使用解析</span></span><br><span class=\"line\"><span class=\"comment\">         * (int)(a+Math.random() * (b-a +1))</span></span><br><span class=\"line\"><span class=\"comment\">         *  = (int)(2+Math.random() * 6)</span></span><br><span class=\"line\"><span class=\"comment\">         *  Math.random() * 6返回的就是0&lt;= x &lt;6小数</span></span><br><span class=\"line\"><span class=\"comment\">         *  2+Math.random() * 6返回的就是2&lt;= x &lt;8小数</span></span><br><span class=\"line\"><span class=\"comment\">         *  (int)(2+Math.random() * 6) = 2 &lt;=x &lt;=7</span></span><br><span class=\"line\"><span class=\"comment\">        * */</span></span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//      公式就是：(int)(a+Math.random() * (b-a +1))</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println((<span class=\"type\">int</span>) (<span class=\"number\">2</span> +Math.random()*(<span class=\"number\">7</span>-<span class=\"number\">2</span>+<span class=\"number\">1</span>)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>max   求两个数的最大值</p>\n</li>\n<li><p>min    求两个数的最小值</p>\n</li>\n</ol>\n<h2 id=\"Date-Calender-LoaclDate\"><a href=\"#Date-Calender-LoaclDate\" class=\"headerlink\" title=\"Date,Calender,LoaclDate.\"></a>Date,Calender,LoaclDate.</h2><h3 id=\"Date-知道怎么查，怎么用即可\"><a href=\"#Date-知道怎么查，怎么用即可\" class=\"headerlink\" title=\"Date[知道怎么查，怎么用即可]\"></a>Date[知道怎么查，怎么用即可]</h3><h4 id=\"第一代日期类\"><a href=\"#第一代日期类\" class=\"headerlink\" title=\"第一代日期类\"></a>第一代日期类</h4><p>Date：精确到毫秒，代表特定的瞬间</p>\n<p>SimpleDateFormat：格式和解析日期的类SimpleDateFormat 格式化和解析日期的具体类。它允许进行格式（日期-&gt;文本、解析（文本-&gt;日期）和规范化</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420110144786.png\" alt=\"image-20220420110144786\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取当前时间</span></span><br><span class=\"line\"><span class=\"comment\">//默认输出的格式是国外的格式</span></span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();、</span><br><span class=\"line\"><span class=\"comment\">//因此需要对格式进行转换</span></span><br><span class=\"line\"><span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">simpleDateFormat</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//其他格式的字母意思，查看手册</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">foramt</span> <span class=\"operator\">=</span> d1.format(d1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取某个时间对应的毫秒数</span></span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">d2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(<span class=\"number\">23123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可以吧一个格式化的字符串转成对应的date</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;2000年7月五日 20:12:20 星期一&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">pares</span> <span class=\"operator\">=</span> simpleDateFormat.parse(s);</span><br><span class=\"line\"><span class=\"comment\">//接收的格式必须个定义的格式一样</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Calendar-日历\"><a href=\"#Calendar-日历\" class=\"headerlink\" title=\"Calendar(日历)\"></a>Calendar(日历)</h3><h4 id=\"第二代日期类\"><a href=\"#第二代日期类\" class=\"headerlink\" title=\"第二代日期类\"></a>第二代日期类</h4><p>主要就是Calendar类（日历）</p>\n<p>1）public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable&lt;Calendar</p>\n<p>2)calendar类是一个抽象类，他为特定瞬间为一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等，日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建日历对象，</span></span><br><span class=\"line\"><span class=\"type\">Calendar</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span>Calendar.getInstance();</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;年&quot;</span>+c.get(Calendar.YEAR))；</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;月&quot;</span>+c.get(Calendar.MONTH)+<span class=\"number\">1</span>)；</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;日&quot;</span>+c.get(Calendar.DAY_OF_MONTH))；</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;小时&quot;</span>+c.get(Calendar.HOUR))；</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;分钟&quot;</span>+c.get(Calendar.MINUTE))；</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;秒&quot;</span>+c.get(Calendar.SECOND))；</span><br><span class=\"line\"><span class=\"comment\">//Calendar没有专门的格式化方法，所以程序员自己组合</span></span><br><span class=\"line\">System.out.print(c.get(Calendar.SECOND)+<span class=\"string\">&quot;年&quot;</span>+(c.get(Calendar.MONTH)+<span class=\"number\">1</span>)+<span class=\"string\">&quot;月&quot;</span>+c.get(Calendar.DAY_OF_MONTH)+<span class=\"string\">&quot;日&quot;</span>)；</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第三代日期类\"><a href=\"#第三代日期类\" class=\"headerlink\" title=\"第三代日期类\"></a>第三代日期类</h3><p>前面两代的不足分析</p>\n<p>（jdk1.0中包含了一个java.Util.Date类，但是他的大多数方法已经存在JDK1.1引入Calendar类之后被弃用。Calendar也存在着很多问题</p>\n<ol>\n<li>可变性：像日期和时间这样的类应该是不可变的。</li>\n<li>偏移性：Date中年份是从1900开始的，而月份是从0开始的</li>\n<li>格式化：格式化只对Date有用，Calendar则不行</li>\n<li>此外，他们不是线程安全的，不能处理闰秒等（每隔两天多出1s）</li>\n</ol>\n<h4 id=\"第三代日期类-1\"><a href=\"#第三代日期类-1\" class=\"headerlink\" title=\"第三代日期类\"></a>第三代日期类</h4><p>1）LoaclDate（日期）、localTime（时间）、loacalDateTime（日期和时间内）</p>\n<p>JDK8</p>\n<p>LoaclDate：只包含日期，可以获取日期字段</p>\n<p>localTime：包含时间，可以获取时间字段</p>\n<p>loacalDateTime包含日期和时间，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">loacalDateTime</span> <span class=\"variable\">ln</span> <span class=\"operator\">=</span> loacalDateTime.now();</span><br><span class=\"line\">ln.getYear();</span><br><span class=\"line\">ln.getMonth();</span><br><span class=\"line\">ln.getMonthValue();<span class=\"comment\">//输出数字版的月份</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2）DateTimeFormatter格式日期类\"><a href=\"#2）DateTimeFormatter格式日期类\" class=\"headerlink\" title=\"2）DateTimeFormatter格式日期类\"></a>2）DateTimeFormatter格式日期类</h5><p>类似于SimpleDateFormat</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">dtf</span> <span class=\"operator\">=</span> DateTimeFormatter.ofPattern(格式);<span class=\"comment\">//(yyyyMMdd....)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">srt</span> <span class=\"operator\">=</span> dtf.format(日期对象);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Instant-时间戳\"><a href=\"#Instant-时间戳\" class=\"headerlink\" title=\"Instant 时间戳\"></a>Instant 时间戳</h4><p>类似于Date</p>\n<p>提供了一系列和Date类转换的方式</p>\n<p>Instant—-&gt;Date;</p>\n<p>Date date &#x3D; Date.from(instant);</p>\n<p>Date —&gt;Instant;</p>\n<p>Instant instant &#x3D; date.toInstant();</p>\n<p>案例演示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Instant</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> Instant.now();</span><br><span class=\"line\">System.out.print(now);</span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> Date.from(now);</span><br><span class=\"line\"><span class=\"type\">Instant</span> <span class=\"variable\">instant</span> <span class=\"operator\">=</span> date.toInstant();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h2 id=\"System\"><a href=\"#System\" class=\"headerlink\" title=\"System\"></a>System</h2><h3 id=\"常见方法\"><a href=\"#常见方法\" class=\"headerlink\" title=\"常见方法\"></a>常见方法</h3><p>1）exit 退出当前程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.exit(0);表示退出</span><br><span class=\"line\">//0代表一个正常状态状态  。</span><br></pre></td></tr></table></figure>\n\n<p>2）Arraycopy：复制数组元素，比较合适底层调用，一般使用Arrays.copyOf完成数组复制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] src = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span>[] dest = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\">System.arraycopy(src,<span class=\"number\">0</span>,dest,<span class=\"number\">0</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"> \tsrc:源数组</span><br><span class=\"line\">    srcpos：从原数组的哪个索引位置开始开始拷贝</span><br><span class=\"line\">    dest:目标数组，即吧原数组的数据拷贝到哪个数组</span><br><span class=\"line\">    destpos：把原数组的数据拷贝到 目标数组的哪个索引</span><br><span class=\"line\">    length:从原数组拷贝多少个数据到目标数组</span><br></pre></td></tr></table></figure>\n\n<p>3）currentTimeMillens：返回当前时间距离1970-1-1(1970年1月1日到现在) 的毫秒数</p>\n<p>4）gc：运行垃圾回收机制System.gc();</p>\n<h2 id=\"Arrays类\"><a href=\"#Arrays类\" class=\"headerlink\" title=\"Arrays类\"></a>Arrays类</h2><h3 id=\"介绍-12\"><a href=\"#介绍-12\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Arrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><h4 id=\"1）-toString返回数组的字符串形式，将数组拼接成字符串返回\"><a href=\"#1）-toString返回数组的字符串形式，将数组拼接成字符串返回\" class=\"headerlink\" title=\"1） toString返回数组的字符串形式，将数组拼接成字符串返回\"></a>1） toString返回数组的字符串形式，将数组拼接成字符串返回</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.ToString(arr)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-sort排序（自然排序和定制排序）\"><a href=\"#2-sort排序（自然排序和定制排序）\" class=\"headerlink\" title=\"2)sort排序（自然排序和定制排序）\"></a>2)sort排序（自然排序和定制排序）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer arr[] = &#123;<span class=\"number\">1</span>,-<span class=\"number\">1</span>,<span class=\"number\">7</span>,<span class=\"number\">0</span>,<span class=\"number\">89</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//可以直接使用该方法进行排序。不用再动手去敲方法</span></span><br><span class=\"line\"><span class=\"comment\">//因为数组时引用类型，所以通过sort排序后，会影响到实参arr</span></span><br><span class=\"line\">Arrays.sort(arr);<span class=\"comment\">//正序排序</span></span><br><span class=\"line\"><span class=\"comment\">//sort重载的，也可以通过传入一个接口Comparator实现定制排序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>、调用定制排序时，传入两个参数</span><br><span class=\"line\">    (<span class=\"number\">1</span>)排序数组的参数</span><br><span class=\"line\">    (<span class=\"number\">2</span>)实现Comparator接口的匿名内部类。要求实现Compare方法</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//      这里体现了接口编程的方式</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        倒序排序</span></span><br><span class=\"line\">        Arrays.sort(a, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Object o1, Object o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> (Integer) o1;</span><br><span class=\"line\">                <span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> (Integer) o2;</span><br><span class=\"line\"><span class=\"comment\">//                return大于0 就是正序排序，小于0就是倒序</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i2 -i1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(Arrays.toString(a));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       bubble(a,<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Object o1, Object o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> (Integer) o1;</span><br><span class=\"line\">                <span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> (Integer) o2;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i1 -i2 ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;定制类&quot;</span>+Arrays.toString(a));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    定制排序</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bubble</span><span class=\"params\">(Integer[] arr,Comparator c)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr.length-<span class=\"number\">1</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt;arr.length-<span class=\"number\">1</span>-i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c.compare(arr[j],arr[j+<span class=\"number\">1</span>])&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    temp =arr[j];</span><br><span class=\"line\">                    arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    arr[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3）binarySearch-二分搜索\"><a href=\"#3）binarySearch-二分搜索\" class=\"headerlink\" title=\"3）binarySearch 二分搜索\"></a>3）binarySearch 二分搜索</h4><p>binarySearch 通过二分搜索法进行查找，要求必须排好序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//如果这个数组是有序的，可以通过该方法查找知否有这个数</span></span><br><span class=\"line\"> <span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">1</span>,<span class=\"number\">23</span>,<span class=\"number\">45</span>,<span class=\"number\">65</span>,<span class=\"number\">78</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//如果不存在该元素就返回，return -(low +1)//意思就是返回负的他该出现的位置的下标+1</span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> Arrays.binarySearch(arr,<span class=\"number\">3</span>);<span class=\"comment\">//返回-2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4）copyOf数组元素的复制\"><a href=\"#4）copyOf数组元素的复制\" class=\"headerlink\" title=\"4）copyOf数组元素的复制\"></a>4）copyOf数组元素的复制</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//表示从arr数组中拷贝arr.length个长度的元素到新的arr数组中</span></span><br><span class=\"line\">Integer[] newArr = Arrays.copyOf(arr,arr.length);</span><br><span class=\"line\">Integer[] newArr = Arrays.copyOf(arr,arr.length-<span class=\"number\">1</span>);就是拷贝原数组长度-<span class=\"number\">1</span></span><br><span class=\"line\">Integer[] newArr = Arrays.copyOf(arr,arr.length+<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">//如果长度超出原数组的长度，则多出来的部分元素为null   </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-fill数组元素的填充\"><a href=\"#5-fill数组元素的填充\" class=\"headerlink\" title=\"5)fill数组元素的填充\"></a>5)fill数组元素的填充</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] num = <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>[]&#123;<span class=\"number\">9</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//使用99去填充num数组</span></span><br><span class=\"line\"><span class=\"comment\">//可以理解成替换原来的元素</span></span><br><span class=\"line\">Arrays.fill(num,<span class=\"number\">99</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">==========运行结果======</span><br><span class=\"line\">    [<span class=\"number\">99</span>,<span class=\"number\">99</span>,<span class=\"number\">99</span>]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-equals-比较两个数组元素内容是否完全一致\"><a href=\"#6-equals-比较两个数组元素内容是否完全一致\" class=\"headerlink\" title=\"6)equals 比较两个数组元素内容是否完全一致\"></a>6)equals 比较两个数组元素内容是否完全一致</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">equals</span>  <span class=\"operator\">=</span> Arrays.equals(arr,arr2);</span><br><span class=\"line\"><span class=\"comment\">//如果两个数组元素一样，则返回true。不一样返回false</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-asList-将一组值，转换成list\"><a href=\"#7-asList-将一组值，转换成list\" class=\"headerlink\" title=\"7)asList 将一组值，转换成list\"></a>7)asList 将一组值，转换成list</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; asList = Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;asList&quot;</span>+asList);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"Integer和BigDecimal类\"><a href=\"#Integer和BigDecimal类\" class=\"headerlink\" title=\"Integer和BigDecimal类\"></a>Integer和BigDecimal类</h2><h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>1）BigInteger适合保存比较大的整型(整数)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当编程中需要处理很大的整数。long不够用可以使用BigInteger类</span></span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">bigInteger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigInteger</span>(<span class=\"string\">&quot;2222222222222222222222222222222222222222&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运算</span></span><br><span class=\"line\"><span class=\"comment\">//在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）</span></span><br><span class=\"line\">    </span><br><span class=\"line\">BigInteger bigInteger <span class=\"number\">2</span>=bigInteger.add(<span class=\"number\">10</span>)；<span class=\"comment\">//加</span></span><br><span class=\"line\">    <span class=\"comment\">//也可再创建一个BigInteger相加</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>2）BigDecimal适合保存精度高的浮点型(小数)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当我们需要保存一个精度很高的值时，double不够用</span></span><br><span class=\"line\"><span class=\"comment\">//可以使用BigDecimal</span></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bigDecimal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;22.22222222222222222222222222&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//运算</span></span><br><span class=\"line\"><span class=\"comment\">//在对BigDecimal进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）</span></span><br><span class=\"line\"><span class=\"comment\">//需要创建一个需要操作的BigDecimal，然后调用即可</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal bigDecimal=bigDecimal.add(<span class=\"number\">2.3</span>);</span><br><span class=\"line\">    <span class=\"comment\">//使用删除方法时，可能会出现除不尽的情况，会抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">//解决办法：在调用divede(删除)方法是，指定精度即可</span></span><br><span class=\"line\">bigDecimal.divide(<span class=\"number\">1.11</span>,BigDecimal.ROUND_CEILING)</span><br><span class=\"line\"><span class=\"comment\">//如果有无限循环小数，就会保留到分子的精度</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><h2 id=\"集合框架体系\"><a href=\"#集合框架体系\" class=\"headerlink\" title=\"集合框架体系\"></a>集合框架体系</h2><h3 id=\"集合体系图\"><a href=\"#集合体系图\" class=\"headerlink\" title=\"集合体系图\"></a>集合体系图</h3><p>背下来</p>\n<p>1）单例集合（在集合里面放单个的对象）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163040446.png\" alt=\"image-20220420163040446\"></p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163624872.png\" alt=\"image-20220420163624872\"></p>\n<p>2）双列集合（存放键值对形式的）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163100945.png\" alt=\"image-20220420163100945\"></p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163609594.png\" alt=\"image-20220420163609594\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//存放单个数据的成为单例</span></span><br><span class=\"line\"><span class=\"type\">ArrayList</span>  <span class=\"variable\">arrayList</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">arrayList.add(<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">arrayList.add(<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//存放双列数据的成为双例集合</span></span><br><span class=\"line\"><span class=\"type\">HashMap</span> <span class=\"variable\">hashMap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">hashMap.put(<span class=\"string\">&quot;no1&quot;</span>,<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//key,value</span></span><br><span class=\"line\">hashMap.put(<span class=\"string\">&quot;no2&quot;</span>,<span class=\"string\">&quot;李四&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><p>Collection接口</p>\n<h4 id=\"Collection接口实现类的特点\"><a href=\"#Collection接口实现类的特点\" class=\"headerlink\" title=\"Collection接口实现类的特点\"></a>Collection接口实现类的特点</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Public <span class=\"keyword\">interface</span> <span class=\"title class_\">Collection</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Iterable</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Collection实现子类可以存放多个元素，每个元素可以是 Object</li>\n<li>有些Collection的实现类，可以存放重复的元素，有些不可以</li>\n<li>有些Collection的实现类，有些是有序的（List），有些不是有序（Set）</li>\n<li>Collection接口没有直接实现子类，是通过它的子接口Set和List来实现的</li>\n</ol>\n<h4 id=\"Collection接口和常用方法\"><a href=\"#Collection接口和常用方法\" class=\"headerlink\" title=\"Collection接口和常用方法\"></a>Collection接口和常用方法</h4><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420165341922.png\" alt=\"image-20220420165341922\"></p>\n<p>常用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>)add :添加单个元素</span><br><span class=\"line\"><span class=\"number\">2</span>)remove:删除指定元素</span><br><span class=\"line\"><span class=\"number\">3</span>)contains:查找元素是否存在</span><br><span class=\"line\"><span class=\"number\">4</span>）size：获取元素个数</span><br><span class=\"line\"><span class=\"number\">5</span>）isEempty：判断是否为空</span><br><span class=\"line\"><span class=\"number\">6</span>）clear：清空</span><br><span class=\"line\"><span class=\"number\">7</span>）addAll：添加多个元素</span><br><span class=\"line\"><span class=\"number\">8</span>）containsAll：查找多个元素是否都存在</span><br><span class=\"line\"><span class=\"number\">9</span>）removeAll：删除多个元素</span><br><span class=\"line\">说明：以ArrayList实现类演示</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ArrayList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\"><span class=\"comment\">//        1.添加单个元素</span></span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;hahah&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"number\">123</span>);<span class=\"comment\">//等价于list.add(new Integer(123);</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;数组增加&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//      remove：删除指定元素</span></span><br><span class=\"line\">        list.remove(<span class=\"number\">0</span>);<span class=\"comment\">//删除第一个元素,下标从0开始</span></span><br><span class=\"line\">        list.remove(<span class=\"string\">&quot;123&quot;</span>);<span class=\"comment\">//删除指定元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;数组删除&quot;</span>+list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//       contains 查找元素是否存在</span></span><br><span class=\"line\">        System.out.println(list.contains(<span class=\"string\">&quot;zhangsan&quot;</span>));<span class=\"comment\">//F</span></span><br><span class=\"line\"><span class=\"comment\">//        size,显示元素的个数</span></span><br><span class=\"line\">        System.out.println(list.size());</span><br><span class=\"line\"><span class=\"comment\">//      isEmpty判断是否为空</span></span><br><span class=\"line\">        System.out.println(list.isEmpty());</span><br><span class=\"line\"><span class=\"comment\">//        clear清空</span></span><br><span class=\"line\">        list.clear();<span class=\"comment\">//清空集合</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;list清空=&quot;</span>+list);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ArrayList</span> <span class=\"variable\">list1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\"><span class=\"comment\">//        addAll:添加多个元素</span></span><br><span class=\"line\">        list1.add(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">        list1.add(<span class=\"string\">&quot;xxxxxx&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        list.addAll(list1);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;addAll&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//        containsAll:查找多个元素知否存在</span></span><br><span class=\"line\">        System.out.println(list.containsAll(list1));</span><br><span class=\"line\"><span class=\"comment\">//        removeAll：删除多个元素</span></span><br><span class=\"line\">        list.removeAll(list1);</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用Iterator（迭代器）\"><a href=\"#使用Iterator（迭代器）\" class=\"headerlink\" title=\"使用Iterator（迭代器）\"></a>使用Iterator（迭代器）</h4><p>Collection接口遍历元素的方式1-使用Iterator（迭代器）</p>\n<h5 id=\"基本介绍-6\"><a href=\"#基本介绍-6\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h5><p>1）Iterator对象成为迭代器，主要用于遍历Collection集合中的元素</p>\n<p>2）所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可返回一个迭代器</p>\n<p>3）Iterator的结构<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420231917444.png\" alt=\"image-20220420231917444\"></p>\n<p>4）Iterator仅用于遍历集合，Iterator本身并不存放对象</p>\n<h6 id=\"迭代器的运行原\"><a href=\"#迭代器的运行原\" class=\"headerlink\" title=\"迭代器的运行原\"></a>迭代器的运行原</h6><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220421160914060.png\" alt=\"image-20220421160914060\"></p>\n<p>hasNext用于判断</p>\n<p>next（）；下移，并返回指向的元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Iteraor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Collection</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">HomeWork</span>(<span class=\"string\">&quot;zhansgan&quot;</span>,<span class=\"number\">12313</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">HomeWork</span>(<span class=\"string\">&quot;haha&quot;</span>,<span class=\"number\">231</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        使用迭代器遍历</span></span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> list.iterator();</span><br><span class=\"line\"><span class=\"comment\">//        while循环  快捷方式输入 itit</span></span><br><span class=\"line\"><span class=\"comment\">//        ctrl+j提示所有快捷键</span></span><br><span class=\"line\">     <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            返回下一个元素，是Object类型</span></span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span>  iterator.next();</span><br><span class=\"line\">            System.out.println(next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//      当退出while循环后，这是iterator迭代器，指向最后一个元素</span></span><br><span class=\"line\"><span class=\"comment\">//        iterator.next()  ，此时再让往下移指针会报异常：NuSuchElementException</span></span><br><span class=\"line\"><span class=\"comment\">//        如果希望再次遍历，需要我们重置迭代器</span></span><br><span class=\"line\">        iterator = list.iterator();<span class=\"comment\">//相当于指向了第一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeWork</span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    Integer phoneNum;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HomeWork</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HomeWork</span><span class=\"params\">(String name, Integer phoneNum)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.phoneNum = phoneNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;HomeWork&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;, phoneNum=&quot;</span> + phoneNum +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"for循环增强\"><a href=\"#for循环增强\" class=\"headerlink\" title=\"for循环增强\"></a>for循环增强</h4><p>Collection接口遍历元素的方式2-</p>\n<p>增强for循环，可以代替iterator迭代器</p>\n<p>特点：增强for就是简化版的iterator，本质一样。只能用于<span style=\"color:red\">遍历集合或数组</span></p>\n<h6 id=\"基本语法-3\"><a href=\"#基本语法-3\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(元素类型 元素名 : 集合名或数组)&#123;</span><br><span class=\"line\">\t访问元素</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">for</span> (Object homeWork:list) &#123;</span><br><span class=\"line\">            System.out.println(homeWork);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        增强也可以在数组中使用</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] a = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">45</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i: a)&#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>增强for底层是迭代器</li>\n<li>可以理解成增强for是简化版的迭代器</li>\n</ol>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>基本介绍：</p>\n<p>List接口是Collection接口的子接口</p>\n<p>1）list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</p>\n<p>2）list集合中的每个元素都有其对应的顺序索引，即支持索引</p>\n<p>3）list容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p>\n<p>4）JDK API中的List接口实现类有：ArrayList、LinkedList和Vector</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//        list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</span></span><br><span class=\"line\">        <span class=\"type\">List</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;jack&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;tom&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        此时不会有冲突，相当于会认为有两个tom</span></span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;tom&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        此时输出的顺序就是存进去的顺序</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;list&quot;</span>+list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        2）list集合中的每个元素都有其对应的顺序索引，即支持索引</span></span><br><span class=\"line\"><span class=\"comment\">//        索引从0开始</span></span><br><span class=\"line\">        System.out.println(list.get(<span class=\"number\">3</span>));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"List接口的常用方法\"><a href=\"#List接口的常用方法\" class=\"headerlink\" title=\"List接口的常用方法\"></a>List接口的常用方法</h5><ol>\n<li>void add（int index,Object ele）在index位置插入ele元素</li>\n<li>boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来</li>\n<li>Object get (int index)获取固定index位置的元素</li>\n<li>int indexOf(Object obj)  返回obj在几个中首次出现的位置</li>\n<li>int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置</li>\n<li>Object remove(int index) 移除指定index位置的元素，并返回此元素</li>\n<li>Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换</li>\n<li>List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">List</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;no1&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;no2&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        1. void add（int index,Object ele）在index位置插入ele元素</span></span><br><span class=\"line\"><span class=\"comment\">//        在index=1的位置插入一个对象</span></span><br><span class=\"line\">        list.add(<span class=\"number\">1</span>,<span class=\"string\">&quot;add(index,ele)&quot;</span>);</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\"><span class=\"comment\">//        2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class=\"line\">        <span class=\"type\">List</span> <span class=\"variable\">list2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        list2.add(<span class=\"string\">&quot;lno2&quot;</span>);</span><br><span class=\"line\">        list2.add(<span class=\"string\">&quot;lno3&quot;</span>);</span><br><span class=\"line\">        list2.add(<span class=\"string\">&quot;lno3&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        在1的位置插入list2的集合</span></span><br><span class=\"line\">        list.addAll(<span class=\"number\">1</span>,list2);</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\"><span class=\"comment\">//        3. Object get (int index)获取固定index位置的元素</span></span><br><span class=\"line\"><span class=\"comment\">//        4. int indexOf(Object obj)  返回obj在几个中首次出现的位置</span></span><br><span class=\"line\">        System.out.println(list.indexOf(<span class=\"string\">&quot;no1&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//        5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置</span></span><br><span class=\"line\">        System.out.println(list.lastIndexOf(<span class=\"string\">&quot;lno3&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//        6. Object remove(int index) 移除指定index位置的元素，并返回此元素</span></span><br><span class=\"line\">        list.remove(<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println( list);</span><br><span class=\"line\"><span class=\"comment\">//        7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换</span></span><br><span class=\"line\"><span class=\"comment\">//        将索引为1的改为尼诺</span></span><br><span class=\"line\">        list.set(<span class=\"number\">1</span>,<span class=\"string\">&quot;尼诺&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合</span></span><br><span class=\"line\">        <span class=\"type\">List</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> list.subList(<span class=\"number\">0</span>, <span class=\"number\">2</span>);<span class=\"comment\">//相当于选择了下标为0的和下标为2-1之间的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;result&quot;</span>+result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意事项-7\"><a href=\"#注意事项-7\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><ol>\n<li>permits all elements,including null , ArrayList 可以加入null，并且多个</li>\n<li>ArrayList 是由数组来实现数据存储的</li>\n<li>ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）看源码，在多线程情况下，不建议使用ArrayList</li>\n</ol>\n<h4 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h4><h5 id=\"ArrayList底层机制和源码分析（重点）\"><a href=\"#ArrayList底层机制和源码分析（重点）\" class=\"headerlink\" title=\"ArrayList底层机制和源码分析（重点）\"></a>ArrayList底层机制和源码分析（重点）</h5><p>1）ArrayList中维护了一个Object类型的数组elementData</p>\n<p>​\t\ttransient Object[] elementData </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transient 表示瞬间，短暂的，表示该属性不会被序列化</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2）当创建对象ArrayList时，如果使用的是无参构造器，则初始elementData容量为0</p>\n<p>3）当添加元素时，先判断是否需要扩容，则调用grow方法，否则直接添加元素到合适位置</p>\n<p>4）如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍</p>\n<p>5）如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity</p>\n<p>6）如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍</p>\n<h4 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h4><h5 id=\"介绍-13\"><a href=\"#介绍-13\" class=\"headerlink\" title=\"介绍\"></a>介绍</h5><p>Vevtor底层也是一个对象数组。protected Object[] elementData;</p>\n<p>Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized</p>\n<p>在开发过程中，需要线程同步安全时，考虑使用Vector</p>\n<h5 id=\"Vector-和ArrayList比较\"><a href=\"#Vector-和ArrayList比较\" class=\"headerlink\" title=\"Vector 和ArrayList比较\"></a>Vector 和ArrayList比较</h5><table>\n<thead>\n<tr>\n<th></th>\n<th>底层结构</th>\n<th>版本</th>\n<th>线程安全（同步）效率</th>\n<th>扩容倍数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList</td>\n<td>可变数组</td>\n<td>jdk1.2</td>\n<td>不安全，效率高</td>\n<td>如果有参构造1.5倍如果无参1.第一次是10，第二次按1.5扩</td>\n</tr>\n<tr>\n<td>Vector</td>\n<td>可变数组</td>\n<td>jdk1.0</td>\n<td>安全，效率不高</td>\n<td>如果是无参默认10，满后，就按两倍扩容。如果指定大小（创建）有参，则每次直接按2倍扩容</td>\n</tr>\n</tbody></table>\n<h4 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h4><h5 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h5><p>1）LinkedList实现了双向链表和双端队列特点</p>\n<p>2）可以添加任意元素（元素可以重复），包括null</p>\n<p>3）线程不安全，没有实现同步</p>\n<h5 id=\"LinkedList底层机制\"><a href=\"#LinkedList底层机制\" class=\"headerlink\" title=\"LinkedList底层机制\"></a>LinkedList底层机制</h5><ol>\n<li><p>LinkedList底层维护了一个双向链表</p>\n</li>\n<li><p>LinkedList中维护了两个属性first和last分别指向首节点和尾结点</p>\n</li>\n<li><p>每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表</p>\n</li>\n<li><p>所以LinkedList的元素的 添加和删除，不是通过该数组完成的，相对来说效率较高</p>\n</li>\n<li><p>模拟一个简单双向链表理解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//        模拟一个简单的双向链表</span></span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">jack</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"string\">&quot;jack&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">tom</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"string\">&quot;tom&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">zhangshan</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"string\">&quot;zhangshan&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        链接是三个结点，形成双向链表</span></span><br><span class=\"line\"><span class=\"comment\">//        jack-&gt;tom -&gt;zhangsan</span></span><br><span class=\"line\">        jack.next = tom;</span><br><span class=\"line\">        tom.next =zhangshan;</span><br><span class=\"line\"><span class=\"comment\">//        zhangsan-&gt;tom-&gt;jack</span></span><br><span class=\"line\">        zhangshan.pre = tom;</span><br><span class=\"line\">        tom.pre = jack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">first</span> <span class=\"operator\">=</span> jack;<span class=\"comment\">//让first引用指向jack，就是双向链表的头结点</span></span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">last</span> <span class=\"operator\">=</span>zhangshan;<span class=\"comment\">//让last引用指向zhangshan，就是双向链表的尾结点</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        演示从头到尾进行遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"><span class=\"comment\">//            输出first信息</span></span><br><span class=\"line\">            System.out.println(first);</span><br><span class=\"line\">            first = first.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        从未到头遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (last == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(last);</span><br><span class=\"line\">            last = last.pre;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义一个Node类，node对象 表示双向链表的一个结点</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object item;<span class=\"comment\">//真正存放数据</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node next;<span class=\"comment\">//指向下一个结点</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node pre;<span class=\"comment\">//指向前一个结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">(Object item)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.item = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Node&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;item=&quot;</span> + item +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429152321935.png\" alt=\"image-20220429152321935\"></p>\n<h5 id=\"ArrayList-和LinkedList的比较\"><a href=\"#ArrayList-和LinkedList的比较\" class=\"headerlink\" title=\"ArrayList 和LinkedList的比较\"></a>ArrayList 和LinkedList的比较</h5><table>\n<thead>\n<tr>\n<th></th>\n<th>底层结构</th>\n<th>增删的效率</th>\n<th>改查的效率</th>\n<th>线程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList</td>\n<td>可变数组</td>\n<td>较低；数组扩容</td>\n<td>较高</td>\n<td>不安全</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td>双向链表</td>\n<td>较高，通过链表追加</td>\n<td>较低</td>\n<td>不安全</td>\n</tr>\n</tbody></table>\n<p>何如选择</p>\n<p>1）如果我们改查的操作较多，选择ArrayList</p>\n<p>2）如果我们增删的操作多，选择LinkedList</p>\n<p>3）一般来说，在程序中80%-90%都是查询，因此大部分情况下会选择ArrayList</p>\n<p>4）在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说根据业务来进行合理选择</p>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><p>介绍</p>\n<p>1）无序（添加和取出的顺序不一致），没有索引</p>\n<p>2）不允许重复元素，所以最多包含和一个null</p>\n<p>3）JDK API中Set接口的实现类有<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429173926895.png\" alt=\"image-20220429173926895\"></p>\n<h5 id=\"Set接口和常用方法\"><a href=\"#Set接口和常用方法\" class=\"headerlink\" title=\"Set接口和常用方法\"></a>Set接口和常用方法</h5><p>和List接口一样，Set接口也是Collection的子接口，因此常用方法和Collection接口一样</p>\n<h5 id=\"set接口遍历方式\"><a href=\"#set接口遍历方式\" class=\"headerlink\" title=\"set接口遍历方式\"></a>set接口遍历方式</h5><p>同Collection的遍历方式一样，因为Set接口是Collection接口的子接口</p>\n<ul>\n<li>使用迭代器</li>\n<li>增强for</li>\n<li>不能使用索引的方式获取</li>\n</ul>\n<h5 id=\"案例-3\"><a href=\"#案例-3\" class=\"headerlink\" title=\"案例\"></a>案例</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//        以set接口实现类HashSet来讲解Set接口的方法</span></span><br><span class=\"line\"><span class=\"comment\">//        set接口的实现类的对象（set接口对象）</span></span><br><span class=\"line\"><span class=\"comment\">//        重复添加的数据只会存进去一个，null值也是只能存放一个</span></span><br><span class=\"line\">    <span class=\"comment\">//输出结果是无序的（存放的数据是无序的，即（添加的顺序和取出的顺序不一致））</span></span><br><span class=\"line\">    <span class=\"comment\">//虽然取出的顺序和添加的顺序不一致，但取出的顺序是固定的，不会一直变化</span></span><br><span class=\"line\">        <span class=\"type\">Set</span> <span class=\"variable\">set</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>();</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;zhansgan&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;wa&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;zhansgan&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        set.add(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        System.out.println(set);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        遍历</span></span><br><span class=\"line\"><span class=\"comment\">//        迭代器</span></span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> set.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span>  iterator.next();</span><br><span class=\"line\">            System.out.println(next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        增强for</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o :set) &#123;</span><br><span class=\"line\">            System.out.println(o);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">----------------输出结果----------------------</span><br><span class=\"line\">    [<span class=\"literal\">null</span>, lisi, wa, zhansgan]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h4><p>1)HashSet实现了Set接口</p>\n<p>2）HashSet实际上是HashMap，看源码</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430145947382.png\" alt=\"image-20220430145947382\"></p>\n<p>3）可以存放null值，但是只能有一个null</p>\n<p>4）HashSet不保证元素时有序的，取决于hash之后，在确定索引的结果（即：不保证存放元素的顺序和取出的一致  ）</p>\n<p>5）不能有重复元素&#x2F;对象。在前面Set接口使用已经标明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.执行add方法后，会返回一个Boolean值</span></span><br><span class=\"line\"><span class=\"comment\">//2.如果添加成功,返回true，否则返回false</span></span><br><span class=\"line\"><span class=\"comment\">//3.可以通过remove指定删除哪个对象</span></span><br><span class=\"line\">        <span class=\"type\">HashSet</span> <span class=\"variable\">set</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>();</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;zhansgan&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;wa&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;zhansgan&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        set.add(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        set.remove(<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        set.add(<span class=\"keyword\">new</span> <span class=\"title class_\">HHHH</span>(<span class=\"string\">&quot;zzz&quot;</span>));<span class=\"comment\">//添加成功</span></span><br><span class=\"line\">        set.add(<span class=\"keyword\">new</span> <span class=\"title class_\">HHHH</span>(<span class=\"string\">&quot;zzz&quot;</span>));<span class=\"comment\">//添加成功</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HHHH</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HHHH</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"HashSet底层机制说明\"><a href=\"#HashSet底层机制说明\" class=\"headerlink\" title=\"HashSet底层机制说明\"></a>HashSet底层机制说明</h5><p>1）HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树）</p>\n<ol>\n<li>HashSet底层是HashMap</li>\n<li>添加一个元素时，先得到hash值 -会转成-索引值</li>\n<li>找到储存数据表table，看这个索引位置是否已经存放的有元素</li>\n<li>如果没有，直接加入</li>\n<li>如果有调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</li>\n<li>在java8中，如果一条链表的元素个数到了TREEEIFY_THRESHOLD(默认是8)个，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树）</li>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430160350549.png\" alt=\"image-20220430160350549\"></li>\n</ol>\n<p>源码分析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent,</span></span><br><span class=\"line\"><span class=\"params\">                   <span class=\"type\">boolean</span> evict)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义了一个辅助变量</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"type\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">//table就是HashMap的一个属性，类型是Node[]</span></span><br><span class=\"line\">     <span class=\"comment\">//if语句表示如果当前table是null，或者大小=0</span></span><br><span class=\"line\">    <span class=\"comment\">//就是第一次扩容，到16个空间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">   <span class=\"comment\">//（1）根据key，得到hash值去计算key应该存放到table表的哪个索引位置</span></span><br><span class=\"line\">    <span class=\"comment\">//并且把这个位置的对象赋给p</span></span><br><span class=\"line\">    <span class=\"comment\">//（2）判断p是否为null</span></span><br><span class=\"line\">    <span class=\"comment\">//（2.1）如果为null，表示还没有存放元素，就创建了一个Node</span></span><br><span class=\"line\">    <span class=\"comment\">//（2.1）就放在该位置 tab[i] = newNode(hash, key, value, null); </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">          <span class=\"comment\">//如果当前索引位置对应的链表的第一个元素和准备谈价的key的hash值一样</span></span><br><span class=\"line\">            <span class=\"comment\">//并且满足下面条件之一</span></span><br><span class=\"line\">            <span class=\"comment\">//1.准备加入的key和p指向的Node结点和key是同一个对象 </span></span><br><span class=\"line\">            <span class=\"comment\">//2.p指向的Node结点的key的equals（）和准备加入的key比较后相同</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">            <span class=\"comment\">//如果上述条件不满足，再判断p是不是一个红黑树</span></span><br><span class=\"line\">            <span class=\"comment\">//如果是一颗红黑树，就调用putTreeVal，来进行添加判断</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"built_in\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//依次比较链表内的内容</span></span><br><span class=\"line\">                <span class=\"comment\">//如果table对应索引的额位置，已经是一个链表，就是用for循环比较</span></span><br><span class=\"line\">                <span class=\"comment\">//(1)依次和链表的每一个元素比较后都不相同，则加入到该链表的最后</span></span><br><span class=\"line\">                  <span class=\"comment\">//然后立即判断该链表是否已经达到8个结点，就调用   treeifyBin()对当前这个链表进行树化（转成红黑树）</span></span><br><span class=\"line\">                <span class=\"comment\">//注意，在转成红黑树时，要进行判断，判断条件&#123;if(tab == null ||(n = tab.length)&lt;MIN_TREEIEY_CAPACITY)</span></span><br><span class=\"line\">                <span class=\"comment\">//resize();   //table数组是否小于64，结点是否到达8个并不为空      &#125;</span></span><br><span class=\"line\">                <span class=\"comment\">//如果上面条件成立，先table扩容</span></span><br><span class=\"line\">                <span class=\"comment\">//如果上面条件不成立，才进行树化</span></span><br><span class=\"line\">                <span class=\"comment\">//(2)依次和该链表的每一个元素比较过程中，如果有相同的情况，就直接break；</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                </span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"HashSet的扩容和转成红黑树机制\"><a href=\"#HashSet的扩容和转成红黑树机制\" class=\"headerlink\" title=\"HashSet的扩容和转成红黑树机制\"></a>HashSet的扩容和转成红黑树机制</h5><ol>\n<li>HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（localFactor）是0.75 &#x3D;12</li>\n<li>如果table数组实用到了临界值12，就会扩容到16*2&#x3D;32，新的临界值就是32 * 0.75 &#x3D; 24,依次类推</li>\n<li>在java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8),并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树），否则仍然采用数组扩容机制</li>\n</ol>\n<h3 id=\"LinkedHashSet\"><a href=\"#LinkedHashSet\" class=\"headerlink\" title=\"LinkedHashSet\"></a>LinkedHashSet</h3><p><strong>说明</strong></p>\n<p>1）LinkedHashSet是HashSet的子类</p>\n<p>2）LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表</p>\n<p>3）LinkedHashSet根据元素的hashCode值来决定元素的储存位置，同时使用链表维护元素的次序（图），这使得元素看起来是以插入顺序保存的<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220501174705977.png\" alt=\"image-20220501174705977\"></p>\n<p>4）LinkedHashSet不允许添加重复元素 </p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220502111826275.png\" alt=\"image-20220502111826275\"></p>\n<p>可以理解成不同索引的数，构成双向链表</p>\n<ol>\n<li><p>在LinkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）</p>\n</li>\n<li><p>每一个结点有pre和next属性，这样可以形成双向链表</p>\n</li>\n<li><p>在添加一个元素时，先求hash值，在求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加[原则和hashset一样])</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail.next = newElement <span class=\"comment\">//简单指定</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Element</span>.pre = <span class=\"type\">tail</span></span><br><span class=\"line\"><span class=\"variable\">tail</span> <span class=\"operator\">=</span> newElement;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p>\n</li>\n</ol>\n<h4 id=\"TreeSet\"><a href=\"#TreeSet\" class=\"headerlink\" title=\"TreeSet\"></a>TreeSet</h4><ol>\n<li><p>当使用无参构造器创建treeset的时候仍然是无序的</p>\n</li>\n<li><p>需求：希望添加的元素按字符串大小来排序?</p>\n<ol>\n<li><p>使用TreeSet提供的一个构造器,可以传入一个比较器（匿名内部类）</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>public class TreeSetDemo {<br>public static void main(String[] args) {<br>&#x2F;&#x2F;        TreeSet treeSet &#x3D; new TreeSet();<br>    TreeSet treeSet &#x3D; new TreeSet(new Comparator() {<br>        @Override<br>        public int compare(Object o1, Object o2) {<br>&#x2F;&#x2F;                调用String的compareTo方法比较字符串大小<br>            return ((String)o1).compareTo((String) o2);<br>        }<br>    });<br>    treeSet.add(“d”);<br>    treeSet.add(“b”);<br>    treeSet.add(“a”);<br>    treeSet.add(“c”);<br><br>    System.out.println(treeSet);<br>}}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   3. </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## Map</span><br><span class=\"line\"></span><br><span class=\"line\">Map**结构**</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;img src=&quot;https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220503163901620.png&quot; alt=&quot;image-20220503163901620&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Map接口的特点（JDK8之后的）</span><br><span class=\"line\"></span><br><span class=\"line\">1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）</span><br><span class=\"line\"></span><br><span class=\"line\">2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&amp;Node对象中</span><br><span class=\"line\"></span><br><span class=\"line\">3）Map中的key不允许重复，原因和HashSet一样，前面分析过</span><br><span class=\"line\"></span><br><span class=\"line\">4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）</span><br><span class=\"line\"></span><br><span class=\"line\">5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个</span><br><span class=\"line\"></span><br><span class=\"line\">6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）</span><br><span class=\"line\"></span><br><span class=\"line\">7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"> Map map = new HashMap();</span><br><span class=\"line\">//        1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）</span><br><span class=\"line\">//        2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&amp;Node对象中</span><br><span class=\"line\">//        3）Map中的key不允许重复，原因和HashSet一样，前面分析过</span><br><span class=\"line\">//        4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）</span><br><span class=\"line\">        map.put(&quot;no1&quot;,&quot;zhangsan&quot;);</span><br><span class=\"line\">        map.put(&quot;no2&quot;,&quot;lisi&quot;);</span><br><span class=\"line\">        map.put(&quot;no1&quot;,&quot;lisi&quot;);</span><br><span class=\"line\">//        5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个</span><br><span class=\"line\">        map.put(null,null);</span><br><span class=\"line\">        map.put(null,null);</span><br><span class=\"line\">        map.put(&quot;no3&quot;,null);</span><br><span class=\"line\">        map.put(&quot;no4&quot;,null);</span><br><span class=\"line\">        //        6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）</span><br><span class=\"line\">        map.put(new Object(),&quot;zhangsan&quot;);</span><br><span class=\"line\">//        7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</span><br><span class=\"line\">//        通过get方法传入key，会返回对应的value</span><br><span class=\"line\">        System.out.println(map.get(&quot;no2&quot;));</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">=============输出==================</span><br><span class=\"line\">  lisi</span><br><span class=\"line\">&#123;no2=lisi, null=null, no1=lisi, no4=null, no3=null, java.lang.Object@1540e19d=zhangsan&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<p>8）Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，有因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry（如图）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220504165516988.png\" alt=\"image-20220504165516988\"></p>\n<p>数据存放在HashMap中，将set和collection作为一组对象放在Entry里面（其中不存放数据只是存放HashMap的引用）</p>\n<ol>\n<li>将HashMap中的key和value数据 存放到一个entrySet集合（该集合不存放数据，存放的都是引用）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">Map</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no1&quot;</span>,<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no2&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);<span class=\"comment\">//k-v</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no1&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);<span class=\"comment\">//k-v</span></span><br><span class=\"line\"><span class=\"comment\">//        1.k-v最后是HashMap$Node node = newNode(hash ,key,value,null);</span></span><br><span class=\"line\"><span class=\"comment\">//        2.k-v为了方便程序员遍历，还会创建EntrySet集合，该集合存放的元素类型（Entry），</span></span><br><span class=\"line\"><span class=\"comment\">//        而一个Entry对象就有k-v，EntrySet&lt;Entry&lt;k,v&gt;&gt;，即：transient Set&lt;Map.Entry&lt;k,v&gt;&gt; entrySet;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        3.在entrySet中，定义的类型是Map.Entry，但是实际上存放的是HashMap$Node类型</span></span><br><span class=\"line\"><span class=\"comment\">//        因为HashMap$Node implement Map.Entry 因为实现了Map.Entry接口，那么这个类的对象实例可以赋给这个接口类型</span></span><br><span class=\"line\"><span class=\"comment\">//        4.当吧HashMap$Node存放到entrySet后就方便我们的遍历，因为Map.Entry提供了两个重要的方法，getKey()和getValue方法</span></span><br><span class=\"line\">        <span class=\"type\">Set</span> <span class=\"variable\">set</span> <span class=\"operator\">=</span> map.entrySet();</span><br><span class=\"line\">        System.out.println(set.getClass());</span><br><span class=\"line\"><span class=\"comment\">//        输出：class java.util.HashMap$EntrySet</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o :set) &#123;</span><br><span class=\"line\">            System.out.println(o.getClass());</span><br><span class=\"line\"><span class=\"comment\">//            输出：class java.util.HashMap$Node</span></span><br><span class=\"line\"><span class=\"comment\">//            从HashMap$Node取出k-v</span></span><br><span class=\"line\"><span class=\"comment\">//            先做一个向下转型</span></span><br><span class=\"line\">            Map.<span class=\"type\">Entry</span> <span class=\"variable\">entry</span> <span class=\"operator\">=</span> (Map.Entry) o;</span><br><span class=\"line\">            System.out.println(entry.getKey() +<span class=\"string\">&quot;&quot;</span>+ entry.getValue());</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"map接口和常用方法\"><a href=\"#map接口和常用方法\" class=\"headerlink\" title=\"map接口和常用方法\"></a>map接口和常用方法</h4><p>1）put：添加</p>\n<p>2）remove：根据键删除映射关系</p>\n<p>3）get：根据键获取值</p>\n<p>4）size：获取元素个数</p>\n<p>5）isEmpty：判断个数是否为0</p>\n<p>6）clear；清楚</p>\n<p>7）containsKey：查找键值否存在</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Map</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no1&quot;</span>,<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no2&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"literal\">null</span>,<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no3&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no4&quot;</span>,<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        map.remove(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">lisi</span> <span class=\"operator\">=</span> map.get(<span class=\"string\">&quot;no2&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;lisi==&quot;</span>+lisi);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(map.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        map.isEmpty();</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">        map.clear();</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(map.containsKey(<span class=\"string\">&quot;no3&quot;</span>));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Map遍历方法\"><a href=\"#Map遍历方法\" class=\"headerlink\" title=\"Map遍历方法\"></a>Map遍历方法</h4><p>1）containsKey：查找键是否存在</p>\n<p>2）KeySet：获取所有的键</p>\n<p>3）entrySet：获取所有关系</p>\n<p>4）values：获取所有的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"type\">Map</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no1&quot;</span>,<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no2&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"literal\">null</span>,<span class=\"string\">&quot;sss&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no3&quot;</span>,<span class=\"string\">&quot;lisdsdsi&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no4&quot;</span>,<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        第一粗：先取出所有的key，通过key取出对应的value</span></span><br><span class=\"line\">        <span class=\"type\">Set</span> <span class=\"variable\">set</span> <span class=\"operator\">=</span> map.keySet();</span><br><span class=\"line\"><span class=\"comment\">//        增强for</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o :set) &#123;</span><br><span class=\"line\">            System.out.println(map.get(o));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;迭代器&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        （2） 使用迭代器</span></span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> set.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span>  iterator.next();</span><br><span class=\"line\">            System.out.println(map.get(next));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;=========第二中=========&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//      第二组：吧所有的values取出</span></span><br><span class=\"line\">        <span class=\"type\">Collection</span> <span class=\"variable\">values</span> <span class=\"operator\">=</span> map.values();</span><br><span class=\"line\"><span class=\"comment\">//        这里可以使用所有的collections使用的遍历方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o :values) &#123;</span><br><span class=\"line\">            System.out.println(o);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        迭代器</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;迭代器&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">iterator1</span> <span class=\"operator\">=</span> values.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator1.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span>  iterator1.next();</span><br><span class=\"line\">            System.out.println(next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;=========第三中=========&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        通过entryset获取</span></span><br><span class=\"line\">        <span class=\"type\">Set</span> <span class=\"variable\">set1</span> <span class=\"operator\">=</span> map.entrySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object entry :set1) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            将entry转为map.entry</span></span><br><span class=\"line\">            Map.Entry  entry1= (Map.Entry) entry;</span><br><span class=\"line\">            System.out.println(entry1.getKey()+<span class=\"string\">&quot; &quot;</span>+entry1.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;迭代器&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">iterator2</span> <span class=\"operator\">=</span> set1.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator2.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span>  iterator2.next();</span><br><span class=\"line\">            Map.<span class=\"type\">Entry</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> (Map.Entry) next;</span><br><span class=\"line\">            System.out.println(m.getKey()+<span class=\"string\">&quot; itit &quot;</span>+ m.getValue());</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ol>\n<li>Map接口的常用实现类：HashMap、Hashtable和Properties</li>\n<li>HashMap是Map接口使用频率最高的实现类</li>\n<li>HashMap是以key-value对的方式来存储数据（HashMap$Node类型）</li>\n<li>key不能重复，但值可以，允许使用null键和null值</li>\n<li>如果添加相同的 key，则会覆盖原来的k-v，等同于修改，（key不会替换，val会替换）</li>\n<li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来储存的</li>\n<li>HashMap没有实现同步，因此线程不安全 的</li>\n</ol>\n<h4 id=\"HashMap底层机制\"><a href=\"#HashMap底层机制\" class=\"headerlink\" title=\"HashMap底层机制\"></a>HashMap底层机制</h4><p>1）HashMap底层维护了Node类型的数组table，默认为null</p>\n<p>2）当创建对象时，将加载银子（loadfactor）初始化为0.75</p>\n<p>3）当添加key-value时，通过key的哈希值得到在table的索引，然后判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是连链表结构，做出相应处理。如果添加时发现容量不够则需扩容</p>\n<p>4）第一次添加，则需扩容table容量为16，临界值(threshold)为12</p>\n<p>5）以后再扩容，需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推</p>\n<p>6）在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64)，就会进行树化。</p>\n<h4 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h4><p><strong>基本介绍</strong></p>\n<p>1）存放的元素时键值对：key-value</p>\n<p>2）hashTable的键和值都不能为null，否则会抛出空指针异常</p>\n<p>3）hashTable使用方法基本上和HashMap一样</p>\n<p>4）hashTable是线程安全的，HashMap是线程不安全的</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220506160740866.png\" alt=\"image-20220506160740866\"></p>\n<h4 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h4><p><strong>基本介绍</strong></p>\n<ol>\n<li>properties类继承了Hashtable类并实现了Map接口，也是使用一种键值对(key-value)的形式来保存数据</li>\n<li>它的使用特点和Hashtable类似</li>\n<li>properties还可用于从xxx.properties文件中，加载数据到properties类对象，并进行读取和修改</li>\n<li>说明：工作后 xxx.properties文件常用作配置文件，io流部分(详细讲解)[<a href=\"http://www.cnblogs.com/xudong-bupt/p/3758136.html]\">www.cnblogs.com/xudong-bupt/p/3758136.html]</a></li>\n</ol>\n<h2 id=\"Collections\"><a href=\"#Collections\" class=\"headerlink\" title=\"Collections\"></a>Collections</h2><h3 id=\"Collections工具类\"><a href=\"#Collections工具类\" class=\"headerlink\" title=\"Collections工具类\"></a>Collections工具类</h3><p>1）Collections是一个操作Set、List和Map等集合的工具类</p>\n<p>2）Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</p>\n<h3 id=\"排序操作（均为static方法）\"><a href=\"#排序操作（均为static方法）\" class=\"headerlink\" title=\"排序操作（均为static方法）\"></a>排序操作（均为static方法）</h3><ol>\n<li><p>reverse（List）：反转List中元素的顺序</p>\n</li>\n<li><p>shuffle（List）：对List集合元素进行随机排序</p>\n</li>\n<li><p>sort（List）：根据元素的自然顺序对指定List集合元素按升序排序</p>\n</li>\n<li><p>sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序</p>\n</li>\n<li><p>swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换</p>\n</li>\n<li><p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Collectionsdemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ArrayList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;zhansgan&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;wngwu&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;laoliu&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;dasima&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;list=&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//        1. reverse（List）：反转List中元素的顺序</span></span><br><span class=\"line\">        Collections.reverse(list);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;reverse=&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//        2. shuffle（List）：对List集合元素进行随机排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            Collections.shuffle(list);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;随机&quot;</span>+list);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序</span></span><br><span class=\"line\">        Collections.sort(list);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sort&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//        4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序</span></span><br><span class=\"line\">        Collections.sort(list, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Object o1, Object o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((String)o1).length()-((String)o2).length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;字符串长度排序&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//        5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Collections.swap(list,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;位置交换&quot;</span>+list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"查找、替换\"><a href=\"#查找、替换\" class=\"headerlink\" title=\"查找、替换\"></a>查找、替换</h3><ol>\n<li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p>\n</li>\n<li><p>Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素</p>\n</li>\n<li><p>Object min（Collection)</p>\n</li>\n<li><p>Object min (Collection，Comparator)</p>\n</li>\n<li><p>int frequency （Collection，Object）：染回指定集合中指定元素的出现次数</p>\n</li>\n<li><p>void copy（List dest，List src）：将src中的内容复制到dest中</p>\n</li>\n<li><p>boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>public static void main(String[] args) {<br>    ArrayList list &#x3D; new ArrayList();<br>    list.add(“zhansgan”);<br>    list.add(“lisi”);<br>    list.add(“wngwu”);<br>    list.add(“laoliu”);<br>    list.add(“dasima”);<br>    System.out.println(“list&#x3D;”+list);<br>&#x2F;&#x2F;        1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>    System.out.println(“max num&#x3D;”+Collections.max(list));<br>&#x2F;&#x2F;        2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素<br>&#x2F;&#x2F;            获取最大长度的值<br>    &#x2F;&#x2F;        3. Object min（Collection)<br>&#x2F;&#x2F;        4. Object min (Collection，Comparator)同理<br>    Object max &#x3D; Collections.max(list, new Comparator() {<br><br>        @Override<br>        public int compare(Object o1, Object o2) {<br>            return ((String) o1).length() - ((String) o2).length();<br>        }<br>    });<br>    System.out.println(“字符串最大的值为&#x3D;”+max);<br>&#x2F;&#x2F;        5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数</p>\n<pre><code>    System.out.println(&quot;lailiu=&quot;+ Collections.frequency(list,&quot;lailiu&quot;));\n</code></pre>\n<p>&#x2F;&#x2F;        6. void copy（List dest，List src）：将src中的内容复制到dest中<br>       ArrayList oldList &#x3D;  new ArrayList();<br>&#x2F;&#x2F;           为了完成一个拷贝，我们需要先给oldList赋值，大小和list一样,不然会报错<br>    for (int i &#x3D; 0; i &lt; list.size(); i++) {<br>        oldList.add(“”);<br>    }<br>&#x2F;&#x2F;        拷贝<br>    Collections.copy(oldList,list);<br>    System.out.println(“oldList&#x3D;”+oldList);<br>&#x2F;&#x2F;        7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值<br>    Collections.replaceAll(list,”laoliu”,”老六”);<br>    System.out.println(“替换后&#x3D;”+list);<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 总结</span><br><span class=\"line\"></span><br><span class=\"line\">在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择分析如下</span><br><span class=\"line\"></span><br><span class=\"line\">1）先判断储存类型（一组对象或一组键值对）</span><br><span class=\"line\"></span><br><span class=\"line\">2）一组对象[单列]：Collection接口</span><br><span class=\"line\"></span><br><span class=\"line\">* 允许重复：List</span><br><span class=\"line\">  * 增删多：LinkedList（底层维护了一个双向链表）</span><br><span class=\"line\">  * 改查多：ArrayList（底层维护了Object类型的可变数组）</span><br><span class=\"line\">* 不允许重复：Set</span><br><span class=\"line\">  * 无序：HashSet（底层是HashMap，维护了一个哈希表 即（数组+链表+红黑树））</span><br><span class=\"line\">  * 排序：TreeSet</span><br><span class=\"line\">  * 插入和取出顺序一直：LinkedHashSet，维护数组+双向链表</span><br><span class=\"line\"></span><br><span class=\"line\">3）一组键值对[双列]：Map</span><br><span class=\"line\"></span><br><span class=\"line\">* 键无序：HashMap（底层是：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树）</span><br><span class=\"line\">* 键排序：TreeSet</span><br><span class=\"line\">* 键插入和取出顺序一致：LinkedHashMap</span><br><span class=\"line\">* 读取文件：Properties</span><br><span class=\"line\"></span><br><span class=\"line\"># 泛型</span><br><span class=\"line\"></span><br><span class=\"line\">## 泛型语法</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">//        1.当我们ArrayList&lt;Dog&gt;表示放到ArrayList集合中的元素只能是Dog类型</span><br><span class=\"line\">//        2.如果编译器发现添加的类型不满足，就会报错</span><br><span class=\"line\">        ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();</span><br><span class=\"line\">        dogs.add(new Dog(&quot;laogou&quot;,12));</span><br><span class=\"line\">        dogs.add(new Dog(&quot;xiaogou&quot;,1));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">//       方便遍历</span><br><span class=\"line\">        for (Dog dog : dogs) &#123;</span><br><span class=\"line\">            System.out.println(dog);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>好处：</p>\n<ol>\n<li>编译时，检查添加元素的类型，提高了安全性</li>\n<li>减少了类型转换的次数，提高效率</li>\n<li>不再提示编译警告</li>\n</ol>\n<h3 id=\"介绍-14\"><a href=\"#介绍-14\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>理解：泛（广泛）型（类型）&#x3D;&#x3D;&gt; integer，String</p>\n<p>可以表示数据类型的数据类型<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171057972.png\" alt=\"image-20220509171057972\"></p>\n<p>1）泛型又称参数化类型，时jdk5.0出现的新特性，解决数据类型的安全性问题</p>\n<p>2）在类声明或实例化时只要制定好需要的具体的类型即可</p>\n<p>3）java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮</p>\n<p>4）泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171249826.png\" alt=\"image-20220509171249826\"></p>\n<p>（此时E称为泛型，那么Dog-&gt;E（此时E为 ））</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cat&lt;String&gt; tianyuanmao = <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>&lt;&gt;(<span class=\"string\">&quot;tianyuanmao&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    E e;<span class=\"comment\">//E表示 e的数据类型，改数据类型在定义Cat对象时指定的，即在编译期间，就确定是什么类型了</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Cat</span><span class=\"params\">(E e)</span> &#123;<span class=\"comment\">//E也可在参数类型体现</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.e = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">method</span><span class=\"params\">()</span>&#123;<span class=\"comment\">//返回类型也可体现</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>泛型的声明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface 接口&lt;T&gt; &#123;&#125;</span><br><span class=\"line\">class类&lt;K,V,...&gt;&#123;&#125;(可以接收多个泛型等等)</span><br><span class=\"line\">说明：</span><br><span class=\"line\">    <span class=\"number\">1.</span>其中K,V,T不代表值，而是表示类型</span><br><span class=\"line\">    <span class=\"number\">2.</span>任意字母都可以。常用T表示，是type的缩写</span><br></pre></td></tr></table></figure>\n\n<p>泛型的实例化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">要在类名后面指定类型参数的值（类型）。如</span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\">List &lt;String&gt; strList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\">Iterator &lt;Customer&gt; iterator = coustomers.iterator();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用细节-5\"><a href=\"#使用细节-5\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h3><ol>\n<li><p>interface List<T>{},public class HashSet<E>{}….等等</p>\n<ol>\n<li>说明：T，E只能是引用类型</li>\n<li>不能是基本数据类型（八大基本数据类型,int,double 等等）</li>\n</ol>\n</li>\n<li><p>在指定泛型具体类型后，可以传入该类型或者其子类类型</p>\n</li>\n<li><p>泛型适用形式</p>\n<ol>\n<li><p>&#96;&#96;&#96;java<br>List<integer> list1 &#x3D;new ArrayList<Integer>{}</p>\n<p>List<Integer> list2 &#x3D; new ArrayList&lt;&gt;();</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 如果我们这样写List list3 = new ArrayList（）；默认给它的泛型是[&lt;E&gt; E就是Object 类型]</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 自定义泛型</span><br><span class=\"line\"></span><br><span class=\"line\">### 泛型类</span><br><span class=\"line\"></span><br><span class=\"line\">**基本语法**</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">class 类名&lt;T,R....&gt;&#123;</span><br><span class=\"line\">成员</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<p>细节：</p>\n<ol>\n<li><p>普通成员可以使用泛型（属性，方法）</p>\n</li>\n<li><p>使用泛型的数组，不能初始化</p>\n</li>\n<li><p>静态方法中不能使用类的泛型‘</p>\n<ol>\n<li>因为静态是和类相关的，在类加载时，对象还没创建</li>\n<li>所以，如果静态方法和静态属性使用泛型时 ，JVM就无法完成初始化</li>\n</ol>\n</li>\n<li><p>泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）</p>\n</li>\n<li><p>如果在创建对象时，没有指定类型，默认为object</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;1.demo后面有泛型，所以我们吧demo就称为自定义泛型类<br>&#x2F;&#x2F;2.T,R,M泛型的标识符，一般是单个大写字母<br>&#x2F;&#x2F;3.泛型标识符可以有多个<br>&#x2F;&#x2F;4.普通成员可以使用泛型 （属性，方法）<br>&#x2F;&#x2F;5.使用泛型的数组，不能初始化<br>&#x2F;&#x2F;（因为数组在new的<br>class demo&lt;T,R,M&gt;{<br>String name;<br>T t;<br>R r;<br>M m;<br>T[] t1;&#x2F;&#x2F;可以声明<br><br>public demo11(String name, T t, R r, M m) {&#x2F;&#x2F;构造器使用泛型<br>    this.name &#x3D; name;<br>    this.t &#x3D; t;<br>    this.r &#x3D; r;<br>    this.m &#x3D; m;<br>}<br>&#x2F;&#x2F;方法使用泛型<br> public String getName() {<br>    return name;<br>}<br><br>public void setName(String name) {<br>    this.name &#x3D; name;<br>}<br><br>public T getT() {<br>    return t;<br>}<br><br>public void setT(T t) {<br>    this.t &#x3D; t;<br>}<br><br>public R getR() {<br>    return r;<br>}<br><br>public void setR(R r) {<br>    this.r &#x3D; r;<br>}<br><br>public M getM() {<br>    return m;<br>}<br><br>public void setM(M m) {<br>    this.m &#x3D; m;<br>}<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 泛型接口</span><br><span class=\"line\"></span><br><span class=\"line\">**基本语法**</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">interface  接口名 &lt;T,R...&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>细节：</p>\n<ol>\n<li><p>接口中，静态成员也不能使用泛型</p>\n</li>\n<li><p>泛型接口的类型，在继承接口或者实现接口时确定</p>\n</li>\n<li><p>没有指定类型，默认为Object</p>\n</li>\n</ol>\n<h3 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h3><p><strong>基本语法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符&lt;T,R...&gt;返回类型 方法名（番薯列表）&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意细节</strong>：</p>\n<ol>\n<li><p>反省方法，可以定义在普通类中，也可以定义在泛型类中</p>\n</li>\n<li><p>当泛型方法被调用时，类型会确定</p>\n</li>\n<li><p>public void eat（E e）{}，修饰符后没有&lt;T,R..&gt;eat方法不是泛型方法，而是使用了泛型</p>\n</li>\n<li><pre><code class=\"java\">//泛型方法，可以定义在普通类中，也可以定义在泛型类中\nclass Car&#123;\n    public void run()&#123;//普通方法\n\n    &#125;\n//    1.T,R就是泛型标识符\n//    2.提供给fly方法使用的\n    public &lt;T,R&gt; void  fly(T t, R r)&#123;//泛型方法\n\n    &#125;\n\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. ```java</span><br><span class=\"line\">   class Car2&lt;T,R&gt;&#123;//泛型类</span><br><span class=\"line\">       public &lt;U,M&gt; void  fly(U u, M m)&#123;//泛型方法</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       public void  fly2(T t)&#123;</span><br><span class=\"line\">   //        1.该方法不是泛型方法</span><br><span class=\"line\">   //        2.是fly2方法使用了类声明的泛型</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>&#96;&#96;&#96;java<br>Car car &#x3D; new Car();<br>    car.fly(“baoma”,2000);<br>    &#x2F;&#x2F;在调用方法是，编译器会自动识别传入的参数的类型，就会确定型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">7. 泛型方法可以使用类声明的泛型，也可使用自己声明的泛型</span><br><span class=\"line\"></span><br><span class=\"line\">## 泛型继承和通配符</span><br><span class=\"line\"></span><br><span class=\"line\">**介绍**</span><br><span class=\"line\"></span><br><span class=\"line\">1)泛型不具备继承性</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">List&lt;Object&gt; list = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">//是错误的，因为泛型中没有继承性</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>2）&lt;?&gt;:支持任意泛型类型</p>\n<p>3）&lt;? extend A&gt;:支持A类以及 A类的子类，规定了泛型的上限</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142709072.png\" alt=\"image-20220511142709072\"></p>\n<p>4）&lt;? super A&gt;:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142730306.png\" alt=\"image-20220511142730306\"></p>\n<h1 id=\"知识点补充\"><a href=\"#知识点补充\" class=\"headerlink\" title=\"知识点补充\"></a>知识点补充</h1><h2 id=\"JUnit\"><a href=\"#JUnit\" class=\"headerlink\" title=\"JUnit\"></a>JUnit</h2><ol>\n<li>一个类有很多功能代码需要测试，为了测试，就需要写入main方法中</li>\n<li>如果有很多个功能代码测试，就需要来回注销，切换很麻烦</li>\n<li>如果可以直接运行一个方法，就会方便很多</li>\n</ol>\n<h3 id=\"介绍：-3\"><a href=\"#介绍：-3\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>1. </p>\n<h1 id=\"练习部分\"><a href=\"#练习部分\" class=\"headerlink\" title=\"练习部分\"></a>练习部分</h1><h2 id=\"快速入门部分\"><a href=\"#快速入门部分\" class=\"headerlink\" title=\"快速入门部分\"></a>快速入门部分</h2><ol>\n<li><p>开发一个hello.java文件，输出：老王 is studying java！</p>\n<ol>\n<li>&#96;&#96;&#96;java<br>public class hello{<br>public static void main(String[] args) {<br>System.out.println(“lao wang is studying java”);<br><br>}<br>}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   2. 需注意的事项：记得吧类部分带上public class 带上，不要只写个方法</span><br><span class=\"line\"></span><br><span class=\"line\">## 制表符部分</span><br><span class=\"line\"></span><br><span class=\"line\">1. ![image-20220204140604059](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204140604059.png)</span><br><span class=\"line\"></span><br><span class=\"line\">   1. ```java</span><br><span class=\"line\">      public class ChangeChar &#123;</span><br><span class=\"line\">          public static void main(String[] args) &#123;</span><br><span class=\"line\">              System.out.println(&quot;书名\\t作者\\t价格\\t销量\\n三国\\t罗贯中\\t120\\t1000&quot;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"进制部分\"><a href=\"#进制部分\" class=\"headerlink\" title=\"进制部分\"></a>进制部分</h2><ul>\n<li><p>第一部分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 0b110001100</span><br><span class=\"line\">   =0*2^0 + 0*2^1 + 1*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 0*2^6 + 1*2^7 + 1*2^8</span><br><span class=\"line\">   =0+0+4+8+0+0+0+128+256</span><br><span class=\"line\">   =396</span><br><span class=\"line\">02456</span><br><span class=\"line\">=6*8^0 + 5*8^1 + 4*8^2 + 2*8^3</span><br><span class=\"line\">=6+40+256+1024</span><br><span class=\"line\">=1326</span><br><span class=\"line\"></span><br><span class=\"line\">0xA45</span><br><span class=\"line\">=5*16^0 + 4*16^1 + 10*16^2</span><br><span class=\"line\">=5 + 64 + 2560</span><br><span class=\"line\">=2629</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"位运算练习\"><a href=\"#位运算练习\" class=\"headerlink\" title=\"位运算练习\"></a>位运算练习</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2|3</span><br><span class=\"line\">1. 2的原码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">2. 2的补码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">3. 3的原码：00000000 00000000 00000000 00000011</span><br><span class=\"line\">4. 3的补码：00000000 00000000 00000000 00000011</span><br><span class=\"line\">5.2|3：00000000 00000000 00000000 00000010（都为1结果为1否则为0）</span><br><span class=\"line\">6. 转为原码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">7.结果为：2</span><br><span class=\"line\"></span><br><span class=\"line\">2^3</span><br><span class=\"line\">1. 2的原码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">2. 2的补码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">3. 3的原码：00000000 00000000 00000000 00000011</span><br><span class=\"line\">4. 3的补码：00000000 00000000 00000000 00000011</span><br><span class=\"line\">5.2^3:00000000 00000000 00000000 00000001(两位一个为0，一个为1，结果为1，否则为0)</span><br><span class=\"line\">6.转为原码：00000000 00000000 00000000 00000001</span><br><span class=\"line\">7.结果为1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"switch练习\"><a href=\"#switch练习\" class=\"headerlink\" title=\"switch练习\"></a>switch练习</h2><ol>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162131420.png\" alt=\"image-20220225162131420\"></p>\n<ul>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162214945.png\" alt=\"image-20220225162214945\"></li>\n</ul>\n</li>\n<li><p>3,4,5为春季。6，7，8，为夏季，9,10,11位秋季。12,1,2为冬季</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>Scanner scanner &#x3D; new Scanner(System.in);<br>    System.out.println(“请输入月份”);<br>    int month &#x3D; scanner.nextInt();<br>    if (month&gt;0 &amp;&amp; month&lt;&#x3D;12){<br>        switch (month){<br>            case 3:<br>            case 4:<br>            case 5:<br>                System.out.println(“春季”);<br>                break;<br>            case 6:<br>            case 7:<br>            case 8:<br>                System.out.println(“夏季”);<br>                break;<br>            case 9:<br>            case 10:<br>            case 11:<br>                System.out.println(“秋季”);<br>                break;<br>            case 12:<br>            case 1:<br>            case 2:<br>                System.out.println(“冬季”);<br>                break;<br>        }<br>    }else {<br>        System.out.println(“输入不合法”);<br>    }<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 数组部分</span><br><span class=\"line\"></span><br><span class=\"line\">* 已知数组&#123;10,12,45,90&#125;。添加一个数使该数组依然是升序的</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">//方法1：数组扩容➕冒泡排序</span><br><span class=\"line\"></span><br><span class=\"line\">package basics.chapterArray;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.time.OffsetDateTime;</span><br><span class=\"line\">import java.util.Scanner;</span><br><span class=\"line\">import java.util.concurrent.ForkJoinPool;</span><br><span class=\"line\"></span><br><span class=\"line\">public class exercisesArryHomeWork &#123;</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    * 已知数组&#123;10,12,45,90&#125;</span><br><span class=\"line\">    * 添加一个数使该数组依然是升序的</span><br><span class=\"line\">    * */</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;10,12,45,90&#125;;</span><br><span class=\"line\">        char key;</span><br><span class=\"line\">        Scanner scanner = new Scanner(System.in);</span><br><span class=\"line\">        int inputnum;</span><br><span class=\"line\">        int tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\">            int[] arr2 = new int[arr.length+1];</span><br><span class=\"line\">            for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">                arr2[i] = arr[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;请输入添加一个数&quot;);</span><br><span class=\"line\">            inputnum = scanner.nextInt();</span><br><span class=\"line\">            arr2[arr2.length-1] = inputnum;</span><br><span class=\"line\">            arr = arr2;</span><br><span class=\"line\">            for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">                System.out.print(arr[i]+&quot;\\t&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(&quot;是否继续输入? y/n&quot;);</span><br><span class=\"line\">            key = scanner.next().charAt(0);</span><br><span class=\"line\">            if (key == &#x27;y&#x27;)&#123;</span><br><span class=\"line\">                System.out.println(&quot;continue&quot;);</span><br><span class=\"line\">            &#125;else if (key == &#x27;n&#x27;)&#123;</span><br><span class=\"line\">                System.out.println(&quot;end&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                System.out.println(&quot;input error&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;while (true);</span><br><span class=\"line\">        System.out.println(&quot;============数组排序==============&quot;);</span><br><span class=\"line\">        for (int i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt;arr.length ; j++) &#123;</span><br><span class=\"line\">                if (j&gt;=arr.length-1)&#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;else if (arr[j]&lt;=arr[j+1])&#123;</span><br><span class=\"line\">                    System.out.println(&quot;no change&quot;);</span><br><span class=\"line\">                &#125;else if (arr[j]&gt;=arr[j+1])&#123;</span><br><span class=\"line\">                    tmp = arr[j+1];</span><br><span class=\"line\">                    arr[j+1] = arr[j];</span><br><span class=\"line\">                    arr[j] = tmp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;=============输出==============&quot;);</span><br><span class=\"line\">        for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">            System.out.print(arr[i]+&quot;\\t&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p>方法二：定位➕扩容</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1. 先定义原数组 </span><br><span class=\"line\">//2. 遍历数组，如果发现insertnum &lt; arr[i] ,说明i就是要插入的位置</span><br><span class=\"line\">//3. 如果index 保留 index =i</span><br><span class=\"line\">//4. 如果遍历完后，没有发现inserNum&lt;=arr[i] ，说明index = arr.length</span><br><span class=\"line\">即：添加到arr的最后</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> basics.chapterArray;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">exercisesArrayHomeWorkmethod2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">10</span>,<span class=\"number\">12</span>,<span class=\"number\">45</span>,<span class=\"number\">90</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">insertNum</span> <span class=\"operator\">=</span> <span class=\"number\">23</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//          数组定位</span></span><br><span class=\"line\"><span class=\"comment\">//        1.遍历数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            2. 如果arr[i]的这个数大于insertNum则表示这个数的位置是要添加的数的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (insertNum&lt;=arr[i])&#123;</span><br><span class=\"line\"><span class=\"comment\">//                3. 用index接受这个位置信息</span></span><br><span class=\"line\">                index = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        4. 数组扩容添加</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr.length+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"comment\">//        创建一个j，当插入前半部分时，j指向arr的数组的数不变。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,j=<span class=\"number\">0</span>; i &lt;arr2.length; i++) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            如果i不等于上面得到的i的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( i != index)&#123;</span><br><span class=\"line\"><span class=\"comment\">//                则将arr的数赋给对应的新数组</span></span><br><span class=\"line\">                arr2[i] = arr[j];</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                arr2[i] = insertNum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr = arr2;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">            System.out.print(arr[i]+<span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"二维数组部分\"><a href=\"#二维数组部分\" class=\"headerlink\" title=\"二维数组部分\"></a>二维数组部分</h3><ol>\n<li>&#96;&#96;&#96;java<br>&#x2F;&#x2F;            int[][] arr &#x3D;</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>[TOC]</p>\n<h1 id=\"java基础\"><a href=\"#java基础\" class=\"headerlink\" title=\"java基础\"></a>java基础</h1><p>这是快速复习java基础的笔记</p>\n<h2 id=\"重要编程思想\"><a href=\"#重要编程思想\" class=\"headerlink\" title=\"重要编程思想\"></a>重要编程思想</h2><p><strong>化繁为简</strong>：现将复杂的功能转变成简单的需求。</p>\n<p>先死后活：有限考虑固定的值，再考虑变量。</p>\n<h1 id=\"java概述\"><a href=\"#java概述\" class=\"headerlink\" title=\"java概述\"></a>java概述</h1><p>知识点：</p>\n<h2 id=\"快速练习\"><a href=\"#快速练习\" class=\"headerlink\" title=\"快速练习\"></a><a href=\"##%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E9%83%A8%E5%88%86\">快速练习</a></h2><ol>\n<li><p>使用黑窗口编译.java文件时，注意要把需要编译的java文件编码设置与cmd黑窗口编码相同</p>\n</li>\n<li><pre><code class=\"java\">javac hello.java //编译指令\t\t\t\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. ```java</span><br><span class=\"line\">   java hello //运行指令\t</span><br><span class=\"line\">   //注意不要带文件后缀，否则报错</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>java执行流程分析</p>\n<ol>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204113338135.png\" alt=\"image-20220204113338135\"></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"制表符\"><a href=\"#制表符\" class=\"headerlink\" title=\"制表符\"></a><a href=\"##%E5%88%B6%E8%A1%A8%E7%AC%A6%E9%83%A8%E5%88%86\">制表符</a></h2><ol>\n<li><pre><code>\\t 一个制表位，实现对其功能\n\\n 换行符，\n\\\\ 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠\n\\\t\\将&quot;&quot;：号输出显示出来，在前面添加\\&quot; \\&quot; 也可转义其他符号例如&#39;\n// \\r 表示一个回车 例如：System.out.println(&quot;韩顺平教育\\r北京&quot;);\n        // 执行步骤：\n        // \t1. 先输出韩顺平教育\n        //  2. 执行回车后，相当于光标来到了最开头\n        //  3. 再输出北京\n        //  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了\n        可以加个\\n换行防止覆盖\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. ````java</span><br><span class=\"line\">   class ChangeChar&#123;</span><br><span class=\"line\">   \tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">   \t\t// \\t 一个制表位，实现对其功能</span><br><span class=\"line\">   \t\tSystem.out.println(&quot;beijing\\tshanghai\\tguangzhou&quot;);</span><br><span class=\"line\">   \t\t// \\n换行</span><br><span class=\"line\">   \t\tSystem.out.println(&quot;jack\\nlisa\\nnino&quot;);</span><br><span class=\"line\">   \t\t// \\\\ 输出一个斜杠\\ </span><br><span class=\"line\">   \t\t// 第一个斜杠代表转义，第二个代表结果 所以要输入\\\\两个斜杠</span><br><span class=\"line\">   \t\tSystem.out.println(&quot;c\\\\a\\\\v\\\\b.exe&quot;);</span><br><span class=\"line\">   \t\t// \\将&quot;&quot;：号输出显示出来，在前面添加\\&quot; \\&quot;</span><br><span class=\"line\">   \t\tSystem.out.println(&quot;老王说：\\&quot;hello\\&quot;&quot;);</span><br><span class=\"line\">   \t\t// \\r 表示一个回车 System.out.println(&quot;韩顺平教育\\r北京&quot;);</span><br><span class=\"line\">   \t\t// 执行步骤：</span><br><span class=\"line\">   \t\t// \t1. 先输出韩顺平教育</span><br><span class=\"line\">   \t\t//  2. 执行回车后，相当于光标来到了最开头</span><br><span class=\"line\">   \t\t//  3. 再输出北京</span><br><span class=\"line\">   \t\t//  4. 最终输出的结果是“北京平教育”  ，相当于北京把前面的韩顺覆盖掉了</span><br><span class=\"line\">   \t\tSystem.out.println(&quot;韩顺平教育\\r\\n北京&quot;);</span><br><span class=\"line\">   </span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   ````</span><br><span class=\"line\"></span><br><span class=\"line\"># 注释</span><br><span class=\"line\"></span><br><span class=\"line\">1. 文档注释</span><br><span class=\"line\"></span><br><span class=\"line\">   1. ```</span><br><span class=\"line\">      javadoc -d 路径文件 -xx -yy xxx.java</span><br><span class=\"line\">      生成文档命令</span><br><span class=\"line\">      xx yy 分别代码javadoc标签命令 例如-auther -version等</span><br></pre></td></tr></table></figure>\n\n2. ```java\n   @author 标明开发该类模块的作者 \n   @version 标明该类模块的版本 \n   @see 参考转向，也就是相关主题 \n   @param 对方法中某参数的说明 \n   @return 对方法返回值的说明 \n   @exception 对方法可能抛出的异常进行说明 \n   \n   @author 作者名 \n   @version 版本号\n   其中，@author 可以多次使用，以指明多个作者，生成的文档中每个作者之间使用逗号 (,) 隔开。@version 也可以使用多次，只有第一次有效 \n   \n   使用 @param、@return 和 @exception 说明方法 \n   这三个标记都是只用于方法的。@param 描述方法的参数，@return 描述方法的返回值，@exception 描述方法可能抛出的异常。它们的句法如下： \n   @param 参数名 参数说明 \n   @return 返回值说明 \n   @exception 异常类名 说明 \n   \n   <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 变量</span><br><span class=\"line\"></span><br><span class=\"line\">## 数据类型</span><br><span class=\"line\"></span><br><span class=\"line\">### 变量</span><br><span class=\"line\"></span><br><span class=\"line\">1. 变量本质就是一个变化的值。</span><br><span class=\"line\"></span><br><span class=\"line\">2. 变量有三个基本要素</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 类型</span><br><span class=\"line\">   2. 名称</span><br><span class=\"line\">   3. 值</span><br><span class=\"line\"></span><br><span class=\"line\">3. ```java</span><br><span class=\"line\">   public static void main(String[] args)&#123;</span><br><span class=\"line\">   \tint a=1;</span><br><span class=\"line\">   \t//定义了一个变量，类型为int，名称为a，值为1</span><br><span class=\"line\">   \ta=89;</span><br><span class=\"line\">       //把89这个值赋给了a变量</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>注意事项：</p>\n<ul>\n<li>变量表示内存中的一个储存区域，[不同的变量，类型不同，占用的空间大小不同，比如：int 4个字节，double 8个字节]</li>\n<li>该区域有自己的名称[变量名]和类型[数据类型]</li>\n<li>变量必须先声明，后使用，有着自身的顺序</li>\n<li>该区域的数据可以在同一类型范围内不断变化</li>\n<li>变量在同一个作用域内不能重名</li>\n<li>变量&#x3D;变量名+值+数据类型，变量三要素</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><ol>\n<li>+号的使用<ul>\n<li>当左右两边为数值类型的时候，做加法运算</li>\n<li>当左右两边有一方为字符串类型时，做拼接运算</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>java数据类型</p>\n<ol>\n<li><p>基本数据类型</p>\n<ul>\n<li>数值型<ul>\n<li>整数类型，存放整数（byte[1],short[2],int[4],long[8])</li>\n<li>浮点（小数）类型（float[4]，double[8])</li>\n</ul>\n</li>\n<li>字符型（char[2]），存放单个字符’a’</li>\n<li>布尔型（Boolean[1]），存放true，false</li>\n</ul>\n</li>\n<li><p>引用数据类型（面向对象部分讲解）</p>\n<ul>\n<li>类（class）</li>\n<li>接口（interface）</li>\n<li>数组（[]）</li>\n</ul>\n</li>\n<li><p>八大基本数据类型</p>\n<p>【byte，short，int，long，float，double】，char，Boolean</p>\n</li>\n<li><p>浮点数据类型</p>\n<ol>\n<li><p>默认情况下输入的字符默认是double类型的</p>\n</li>\n<li><p>如果想改成float类型需要在数值后面加上f或F</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>float a &#x3D; 1.1 &#x2F;&#x2F;错误<br>float a &#x3D; 1.1F &#x2F;&#x2F;正确<br>double b &#x3D; 1.1\t&#x2F;&#x2F;正确<br>double b &#x3D; 1.1F\t&#x2F;&#x2F;正确</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 平时使用默认的double类型就行，因为更为精确</span><br><span class=\"line\"></span><br><span class=\"line\">5. 浮点数使用陷阱</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```java</span><br><span class=\"line\">     //例如</span><br><span class=\"line\">     //2.7和8.1/3 比较</span><br><span class=\"line\">     double a = 2.7 ;</span><br><span class=\"line\">     double b = 8.1/3 ;//理论上数学得数是2.7</span><br><span class=\"line\">     System.out.println(a);//2.7</span><br><span class=\"line\">     System.out.println(b);//得数是一个接近2.7的一个小数，而不是2.7</span><br><span class=\"line\">     //因为计算机计算机制的问题，不是数学的问题。</span><br><span class=\"line\">     所以在做相等判断时需要小新</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;类似问题的解决方法<br>double a &#x3D; 2.7 ;<br>double b &#x3D; 8.1&#x2F;3 ;&#x2F;&#x2F;理论上数学得数是2.7<br>System.out.println(a);&#x2F;&#x2F;2.7<br>System.out.println(b);</p>\n<p>if(a &#x3D;&#x3D; b){<br>&#x2F;&#x2F;这样的写法会出问题<br>System.out.println(“相等”);<br>}</p>\n<p>&#x2F;&#x2F;可以使用计算其差值<br>if(Math.abs(a-b)&lt;0.001){<br>System.out.println(“差值非常小，到我规定的精度内，认为相等”);<br>   &#x2F;&#x2F; Math方法调用java API</p>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. 字符类型</span><br><span class=\"line\"></span><br><span class=\"line\">   1. char的本质就是一个整数，默认用的是Unicode编码</span><br><span class=\"line\">   2. 字符常量用单引号引出来，</span><br><span class=\"line\">      * 例：char a = &#x27;a&#x27;;</span><br><span class=\"line\">      * char b = &#x27;/n&#x27;;</span><br><span class=\"line\">   3. 不能输入双引号，否则会认成字符串，会报错。</span><br><span class=\"line\">   4. char类型时可以运算的。</span><br><span class=\"line\"></span><br><span class=\"line\">   字符型的本质</span><br><span class=\"line\"></span><br><span class=\"line\">   * 字符型储存到计算机中，需要将对应的码值（整数）找出来</span><br><span class=\"line\"></span><br><span class=\"line\">   * 字符和码值的对应关系是通过字符编码表决定的（是规定死的）</span><br><span class=\"line\"></span><br><span class=\"line\">   * ![image-20220205221255475](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220205221255475.png)</span><br><span class=\"line\"></span><br><span class=\"line\">6. 布尔类型</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 只占一个字节，只允许true和false</span><br><span class=\"line\">   2. 用于判断操作</span><br><span class=\"line\">   3. 不可用0或非0 来代替true或false，c语言可以</span><br><span class=\"line\"></span><br><span class=\"line\">## 数据类型转换</span><br><span class=\"line\"></span><br><span class=\"line\">### 1、自动类型转换</span><br><span class=\"line\"></span><br><span class=\"line\">* 精度小的类型自动转换为精度大的数据类型，反之就会报错。</span><br><span class=\"line\"></span><br><span class=\"line\">* char &lt; int &lt; long &lt; float &lt; double </span><br><span class=\"line\"></span><br><span class=\"line\">* byte &lt; short &lt; int &lt; long &lt; float &lt; double</span><br><span class=\"line\"></span><br><span class=\"line\">* ```java</span><br><span class=\"line\">  //例：</span><br><span class=\"line\">  int num = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>注意事项</p>\n<ol>\n<li>多重类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的哪种数据类型，然后再进行计算</li>\n</ol>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">float</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> n1+<span class=\"number\">1.1</span>;</span><br><span class=\"line\"><span class=\"comment\">//这是错误的，因为转换成最大单位，1.1默认的类型是double类型的，如果是n1＋1.1f 的话就是正确的</span></span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> n1+<span class=\"number\">1.1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这是正确的；</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>（ byte , short ) 和 char之间不会相互转换，当把一个具体的数赋给byte时。</p>\n<ol>\n<li>先判断该数是否在byte范围内，如果是就可以</li>\n</ol>\n</li>\n<li><p>byte，short，char 三者可以进行计算，在计算时都会先转换成int类型</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>byte b1 &#x3D; 1;<br>byte a1 &#x3D; 1;<br>short b2 &#x3D; 1;<br>short s2 &#x3D; b1 + b2&#x2F;&#x2F;错误<br>&#x2F;&#x2F;因为计算时会转换成int类型，int不能再赋给比它小的类型short<br>int s2 &#x3D; b1 + b2 &#x2F;&#x2F;正确<br>byte s3 &#x3D; a1 + b1&#x2F;&#x2F;错误<br>&#x2F;&#x2F;byte，short，char,只要涉及计算都会转换为int类型，所以错误<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   4. 布尔类型 ( boolean ) 不参与类型转换</span><br><span class=\"line\"></span><br><span class=\"line\">   5. 自动提升原则：表达式结果的类型自动提升为 操作数中最大的类型。</span><br><span class=\"line\"></span><br><span class=\"line\">### 2、强制类型转换</span><br><span class=\"line\"></span><br><span class=\"line\">1. 简介</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 大的数据类型转换为小的数据类型</span><br><span class=\"line\">   2. 使用时要加上强制转换字符（类型）</span><br><span class=\"line\">   3. 可能会出现精度降低和溢出问题</span><br><span class=\"line\"></span><br><span class=\"line\">2. 注意细节</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 将数据从大到小转换，需要强制转换</span><br><span class=\"line\"></span><br><span class=\"line\">   2. ```java</span><br><span class=\"line\">      //强制转换符只对最近的操作数有效，也就是只对下边的10数字有效，转换后再进行计算又会转换成double类型。</span><br><span class=\"line\">      int x = (int)10*3.5+6*1.5;//提示编译错误，类型是double -&gt;</span><br><span class=\"line\">      </span><br><span class=\"line\">      int x = (int)(10*3.5+6*1.5);//用小括号括起来即可完美解决上述问题</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p>3、基本数据类型和String类型的转换</p>\n<ol>\n<li><p>介绍</p>\n<ol>\n<li>在程序开发中，我们经常需要吧基本数据类型转换成String类型，或String转基本数据类型</li>\n</ol>\n</li>\n<li><p>方式</p>\n<ul>\n<li><p>基本转String</p>\n<ul>\n<li><p>基本数据类型的值+” “ </p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;例<br>int n1 &#x3D; 123;<br>float f &#x3D; 2.3f;<br>double b &#x3D; 4.5;<br>String str1 &#x3D; n1 +” “;<br>String str2 &#x3D; f +””;<br>String str3 &#x3D; b +””;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* String 转基本</span><br><span class=\"line\"></span><br><span class=\"line\">  * 调用基本类型的包装类方法parseXXX 方法即可</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```java</span><br><span class=\"line\">    String s5= &quot;123&quot;;</span><br><span class=\"line\">    integer.parseInt(s5);</span><br><span class=\"line\">    Double.parseDouble(s5);</span><br><span class=\"line\">    Float.parseFloat(s5);</span><br><span class=\"line\">    //怎么吧字符串转成字符char，含义是指吧字符串的第一个字符得到</span><br><span class=\"line\">    system.out.println(s5.charAt(0));//获取字符串的第一个字符</span><br><span class=\"line\">    //所以这个输出的值为1</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注意事项</p>\n<ol>\n<li>string转换基本类型时，要确保string类型能够转成有效数据，可以吧’123’转换成一个整数，但不能吧”hello”转换成一个整数</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"运算符-1\"><a href=\"#运算符-1\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><h2 id=\"运算符-2\"><a href=\"#运算符-2\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h3><ol>\n<li>是一种特殊符号，表示数据的运算、赋值和比较等</li>\n<li>种类<ul>\n<li>算数运算符</li>\n<li>赋值运算符</li>\n<li>关系运算符(比较运算符)</li>\n<li>逻辑运算符</li>\n<li>位运算符 [ 需要二进制基础 ]</li>\n<li>三元运算符</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-算数运算符\"><a href=\"#2-算数运算符\" class=\"headerlink\" title=\"2.算数运算符\"></a>2.算数运算符</h3><ol>\n<li>对数值类型的变量进行运算的</li>\n<li>预览：<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220211161920431.png\" alt=\"image-20220211161920431\"></li>\n<li>注意事项<ul>\n<li>取模</li>\n<li><span style=\"color:white;background:red;font-size:文字大小;font-family:字体;\">再%的本质，看一个公式 a % b &#x3D; a-a &#x2F; b * b</span></li>\n</ul>\n</li>\n<li>面试题<ol>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213151013682.png\" alt=\"image-20220213151013682\"><ol>\n<li>答案为 1<ul>\n<li>运行步骤为</li>\n<li>(1)先把 i 的值赋给一个临时变量tmp</li>\n<li>(2)再进行计算i++，结果为i&#x3D;2</li>\n<li>(3)tmp的值重新赋给i，此时i &#x3D;1</li>\n</ul>\n</li>\n<li>答案为2<ul>\n<li>运行步骤为</li>\n<li>(1)再进行计算i++，结果为i&#x3D;2</li>\n<li>(2)再将2移到临时变量tmp</li>\n<li>(3)tmp赋给 i</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-关系运算符（比较运算符）\"><a href=\"#3-关系运算符（比较运算符）\" class=\"headerlink\" title=\"3.关系运算符（比较运算符）\"></a>3.关系运算符（比较运算符）</h3><ol>\n<li>介绍<ul>\n<li>关系运算符的结果都是boolean型，</li>\n<li>通常用在if条件语句结构条件中</li>\n<li>关系运算符组成的表达式成为关系表达式</li>\n</ul>\n</li>\n<li>预览图</li>\n</ol>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213162614379.png\" alt=\"image-20220213162614379\"></p>\n<h3 id=\"4-逻辑运算符\"><a href=\"#4-逻辑运算符\" class=\"headerlink\" title=\"4.逻辑运算符\"></a>4.逻辑运算符</h3><p>预览：</p>\n<ol>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170452994.png\" alt=\"image-20220213170452994\"></p>\n</li>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170753311.png\" alt=\"image-20220213170753311\"></p>\n</li>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220213170926798.png\" alt=\"image-20220213170926798\"></p>\n</li>\n<li><p>&#96;&#96;&#96;<br>&amp;&amp;（短路与）\t只有两个条件都为true ，才为true\t&#x2F;&#x2F;如果第一个条件为false，则后面的条件不执行，直接输出flase，效率高</p>\n<p>&amp;\t（逻辑与）\t只有两个条件都为true ，才为true\t&#x2F;&#x2F;两个条件都执行，效率低</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. ![image-20220214140501385](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220214140501385.png)</span><br><span class=\"line\"></span><br><span class=\"line\">6. ```java</span><br><span class=\"line\">   取反</span><br><span class=\"line\">   真变假，假变真</span><br><span class=\"line\">   //a^b :叫逻辑异或，当a和b不同时，结果为true，否侧为false</span><br><span class=\"line\">   例：</span><br><span class=\"line\">   \tboolean b = (10&gt;1) ^ (3&lt;5);</span><br><span class=\"line\">   \tSystem.out.println(&quot;b=&quot;+b);//f</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"5-赋值运算符（-x3D-）、\"><a href=\"#5-赋值运算符（-x3D-）、\" class=\"headerlink\" title=\"5.赋值运算符（&#x3D;）、\"></a>5.赋值运算符（&#x3D;）、</h3><p>分类：</p>\n<ul>\n<li><p>基本赋值运算符 &#x3D; \tint a &#x3D; 10；</p>\n</li>\n<li><p>复合赋值运算符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+=，-=，*=，/=，%=等等，</span><br><span class=\"line\">例：a += b;[等价 a=a+b;]</span><br><span class=\"line\">\ta -=b;[等价 a = a-b;]</span><br><span class=\"line\">一般情况加复合赋值运算符，前边都有基本赋值运算符</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>复合运算符会进行类型转换</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">byte</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span><span class=\"number\">3</span>;</span><br><span class=\"line\">a += <span class=\"number\">2</span>; <span class=\"comment\">//此时计算结果为int类型</span></span><br><span class=\"line\"><span class=\"comment\">//不会报错，因为会自动进行类型转换</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不能直接写成</span></span><br><span class=\"line\">a=a+<span class=\"number\">2</span>; <span class=\"comment\">//会报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 像a++，++a这种会都进行自动的类型转换</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"6-三元运算符\"><a href=\"#6-三元运算符\" class=\"headerlink\" title=\"6.三元运算符\"></a>6.三元运算符</h3><ul>\n<li><p>语法：条件表达式？ 表达式1: 表达式2；</p>\n</li>\n<li><p>运算规则：</p>\n<ol>\n<li><p>如果条件表达式为true，运算后的结果是表达式1；</p>\n</li>\n<li><p>如果条件表达式为false，运算后的结果是表达式2；</p>\n<p>口诀：【一灯大师：一真大师（如果为真，返回1）】</p>\n</li>\n<li><p>例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span> ;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">99</span> ;</span><br><span class=\"line\"><span class=\"comment\">// 1.如果 结果为false</span></span><br><span class=\"line\"><span class=\"comment\">// 2.返回b--，先返回b，再进行b-1。依旧按照之前的a++,++a的计算形式</span></span><br><span class=\"line\"><span class=\"comment\">// 3.结果为99</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> a &gt; b ? a++; b--;</span><br><span class=\"line\"><span class=\"comment\">//如果a&gt;b 为真，返回a++，如果为false返回b--;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本质就是if，else语句</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"7-运算符优先级\"><a href=\"#7-运算符优先级\" class=\"headerlink\" title=\"7.运算符优先级\"></a>7.运算符优先级</h3><ul>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220215150928654.png\" alt=\"image-20220215150928654\"></li>\n<li>小结：优先级排名<ol>\n<li>() ，{}等优先级最高</li>\n<li>单目运算&#x3D;&#x3D;a ，–a等；</li>\n<li>算术运算符+-</li>\n<li>位移运算符</li>\n<li>比较运算符</li>\n<li>逻辑运算符</li>\n<li>三元运算符</li>\n<li>赋值运算符</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><p><strong>标识符的规则和规范</strong></p>\n<ol>\n<li>java中对各种变量、方法和类的命名使用的字符成为标识符。</li>\n</ol>\n<ul>\n<li>&#96;&#96;&#96;java<br>int num &#x3D;1;<br>&#x2F;&#x2F; num就是标识符<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 标识符的命名规则必须遵守</span><br><span class=\"line\">   * 标识符由26个字母的大小写，0-9，_或$符组成。</span><br><span class=\"line\">   * 不可以用数字开头</span><br><span class=\"line\">   * 不可以使用关键字和保留至，但能包含关键字和保留字</span><br><span class=\"line\">   * 标识符不能包含空格</span><br><span class=\"line\">3. 标识符命名规范</span><br><span class=\"line\">   * 包名：多单词组成时，所有字母都小写。例：aaa.bbb.ccc</span><br><span class=\"line\">   * 类名、接口名：多单词组成是，所有单词首字母大写，驼峰命名法</span><br><span class=\"line\">   * 变量名、方法名：多单词组成时，第一个单词首字母小写，后面单词的首字母大写。例：aaBbCc</span><br><span class=\"line\">   * 常量名：所有字母都大写。多单词时用下划线隔开。例：A_B_C</span><br><span class=\"line\"></span><br><span class=\"line\">##   键盘输入语句</span><br><span class=\"line\"></span><br><span class=\"line\">### 1.介绍</span><br><span class=\"line\"></span><br><span class=\"line\">在编程过程中需要接受用户的输入数据，可以使用键盘输入语句来获取。input.java，需要一个扫描器（对象），就是Scanner</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.步骤</span><br><span class=\"line\"></span><br><span class=\"line\">1）导入该类所在的包，java.utill.*</span><br><span class=\"line\"></span><br><span class=\"line\">2）创建该类对象（声明变量）</span><br><span class=\"line\"></span><br><span class=\"line\">3）调用里面的功能</span><br><span class=\"line\"></span><br><span class=\"line\">### 3.案例</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">public class KeyboardInput &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">//        创建Scanner对象</span><br><span class=\"line\">        Scanner scanner = new Scanner(System.in);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;请输入文本1&quot;);</span><br><span class=\"line\">//        z字符串类型</span><br><span class=\"line\">        scanner.next();</span><br><span class=\"line\">        System.out.println(&quot;请输入age&quot;);</span><br><span class=\"line\">//        nextint 代表接收一个int类型的输入</span><br><span class=\"line\">        scanner.nextInt();</span><br><span class=\"line\">//        接收double类型的</span><br><span class=\"line\">        scanner.nextDouble();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"进制\"><a href=\"#进制\" class=\"headerlink\" title=\"进制\"></a>进制</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>对于整数，有四种表达方式</p>\n<ul>\n<li><p>二进制（Bin&#x2F;B）：0,1，满2进1，以0b或0B开头</p>\n</li>\n<li><p>八进制（OCT&#x2F;O）：0-7，满8进1。以数字0开头表示</p>\n</li>\n<li><p>十进制（DEC&#x2F;D）：0-9，满10进1</p>\n</li>\n<li><p>十六进制（HEX&#x2F;H）：0-9及A(10)-F(15)，满16进1.以0x或0X开头表示。此处的A-F不区分大小写</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>int n1 &#x3D; 0b1010;<br>int n2 &#x3D; 01010;<br>int n3 &#x3D; 1010;<br>int n4 &#x3D; 0x10101;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">### 进制转换（基本功）*</span><br><span class=\"line\"></span><br><span class=\"line\">第一组</span><br><span class=\"line\"></span><br><span class=\"line\">1. 二进制转十进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     例</span><br><span class=\"line\">     0b 1011  =1*2^0+1*2^1+0*2^2+1*2^</span><br><span class=\"line\">     = 1+2+0+8</span><br><span class=\"line\">     =11</span><br><span class=\"line\">     </span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li><p>八进制转十进制</p>\n<ul>\n<li><p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和。</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>例：0234转成十进制<br>0 234<br>&#x3D;4<em>8^0 + 3</em>8^1 + 2*8^2<br>&#x3D;4+24+128<br>&#x3D;156</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 十六进制转十进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * 规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     例：0x 23A转成十六进制</span><br><span class=\"line\">     =10*16^0 + 3*16^1 + 2*16^2</span><br><span class=\"line\">     =10 + 48 + 512</span><br><span class=\"line\">     =570</span><br><span class=\"line\">     A(10),B(11),C(12),D(13),E(14),F(15)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p><a href=\"###%E8%BF%9B%E5%88%B6%E9%83%A8%E5%88%86\">第一部分练习</a></p>\n<p>第二组</p>\n<ol>\n<li><p>十进制转二进制</p>\n<ul>\n<li><p>规则：将该数不断除2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>将34转换成二进制<br>34%2\t余0<br>17%2  余1<br>8%2\t\t余0<br>4%2\t\t余0<br>2%2\t\t余0<br>1%2\t\t余1<br>反着读<br>结果：0b100010 &#x2F;&#x2F;前缀0b的意思为二进制<br>正确答案为：0b00100010<br>因为一个字节二进制的是八位，34的出的结果是六位所以前面需要多加两个0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 十进制转八进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * 规则：将该数不断除8，直到商为0为止，然后将每步得到的余数倒过来，就是对应的八进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     例：将131转为八进制</span><br><span class=\"line\">     131%8\t\t余3</span><br><span class=\"line\">     16%8\t\t余0</span><br><span class=\"line\">     2%8\t\t\t2</span><br><span class=\"line\">     结果为0203前面的0代表的意思是八进制</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>十进制转十六进制</p>\n<ul>\n<li><p>规则：将该数不断除16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的十六进制</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>例：237<br>答案为 ED</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   * ![image-20220216221217568](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220216221217568.png)</span><br><span class=\"line\"></span><br><span class=\"line\">第三组</span><br><span class=\"line\"></span><br><span class=\"line\">1. 二进制转八进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * 规则：从低位开始，将二进制数的每三位一组，转成对应的八进制数即可</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     例：0b 11010101 每三个转成十进制再拼起来</span><br><span class=\"line\">     =325</span><br><span class=\"line\">     11100101</span><br><span class=\"line\">     =345</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>二进制转十六进制</p>\n<ul>\n<li><p>从低位开始，将二进制数的每四位一组，转成对应的十六进制即可</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>11010101<br>&#x3D;0xD5<br>1110010110<br>&#x3D;0x396\t每四个转成十进制再拼起来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">第四组</span><br><span class=\"line\"></span><br><span class=\"line\">1. 八进制转二进制</span><br><span class=\"line\"></span><br><span class=\"line\">   * 规则：将八进制数每一位，转成对应的3位的二进制数</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     237  每位以十进制转二进制转成对应的3位二进制数再连起来</span><br><span class=\"line\">     2（010）3（011）7（111）</span><br><span class=\"line\">     =010011111</span><br><span class=\"line\">     </span><br><span class=\"line\">     1230</span><br><span class=\"line\">     =1(001)2(010)3(011)0(000)</span><br><span class=\"line\">     =001010011000</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>十六进制转二进制</p>\n<ul>\n<li><p>规则：将八进制数每一位，转成对应的4位的二进制数</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>23B<br>&#x3D;2(0010)3(0011)B(1011)<br>&#x3D;001000111011<br>AB29<br>&#x3D;A(1010)B(1011)2(0010)9(1001)<br>&#x3D;1010101100101001</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">源码，反码，补码（重点）</span><br><span class=\"line\"></span><br><span class=\"line\">对于有符号的数而言（八个规则）：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 二进制的最高位是符号位：0表示正数，1表示负数（口诀：0 - &gt;0   1-&gt; -）</span><br><span class=\"line\">2. 正数的原码，反码，补码都一样（三码合一）</span><br><span class=\"line\">3. 负数的反码 = 它的原码符号位不变，其他位取反（0-&gt;1,1-&gt;0）0变1,1变0.</span><br><span class=\"line\">4. 负数的补码 = 它的反码+1，负数的反码 = 负数的补码-1</span><br><span class=\"line\">5. 0的反码，补码都是0</span><br><span class=\"line\">6. java没有无符号的数，换而言之，java中的数都是有符号的</span><br><span class=\"line\">7. 计算机运算的时候，都是以 &lt;span style=&quot;color:white;background:red;font-size:文字大小;font-family:字体;&quot;&gt;补码的方式来运算的&lt;/span&gt;</span><br><span class=\"line\">8. &lt;span style=&quot;color:white;background:red;font-size:文字大小;font-family:字体;&quot;&gt;当我们看运算结果的时候，要看它的原码（！！！）&lt;/span&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 位运算</span><br><span class=\"line\"></span><br><span class=\"line\">* java中有七个位运算符（&amp;，|，^，~，&gt;&gt;，&lt;&lt;和&gt;&gt;&gt;）</span><br><span class=\"line\"></span><br><span class=\"line\">* 分别是：</span><br><span class=\"line\"></span><br><span class=\"line\">  * &amp;：按位与</span><br><span class=\"line\"></span><br><span class=\"line\">    * 规则：两位全为1，结果为1，否则为0</span><br><span class=\"line\"></span><br><span class=\"line\">    * ```</span><br><span class=\"line\">      例：</span><br><span class=\"line\">         10011010</span><br><span class=\"line\">        &amp;11011101</span><br><span class=\"line\">      -------------</span><br><span class=\"line\">        =10011000// 两个都1结果才为1</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>|：按位或</p>\n<ul>\n<li><p>规则：两位有一个为1，结果为1，否则为0</p>\n</li>\n<li><p>&#96;&#96;&#96;<br>10011010</p>\n<h2 id=\"amp-11011101\"><a href=\"#amp-11011101\" class=\"headerlink\" title=\"  &amp;11011101\"></a>  &amp;11011101</h2><p>  &#x3D;11011111&#x2F;&#x2F; 两个有一个1结果才为1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ^：按位异或</span><br><span class=\"line\"></span><br><span class=\"line\">  * 规则：两位一个为0，一个为1，结果为1，否则为0</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    10011010</span><br><span class=\"line\">    &amp;11011101</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<pre><code>=01000111// 两位一个为0，一个为1，结果为1，否则为0\n</code></pre>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>~：按位取反</p>\n<ul>\n<li>规则：0为1,1为0</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//位移运算</span><br><span class=\"line\">int a = 1&gt;&gt;2; // 1 向右位移2位</span><br><span class=\"line\">int b = -1&gt;&gt;2;</span><br><span class=\"line\">int c = 1&lt;&lt;2; //左移 2位</span><br><span class=\"line\">int d = -1&lt;&lt;2;</span><br><span class=\"line\">int e = 3&gt;&gt;&gt;2;//无符号右移</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"##%E4%BD%8D%E8%BF%90%E7%AE%97%E7%BB%83%E4%B9%A0\">练习部分</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2&amp;3计算机计算流程（计算机是按照补码进行计算的）</span><br><span class=\"line\">因为一个字节是八位，一个int类型有4个字节</span><br><span class=\"line\">1.先得到2的补码 ===&gt;* 源码00000000 00000000 00000000 00000010 //得到原码</span><br><span class=\"line\">* 转成补码（正数的三码都一样）</span><br><span class=\"line\">00000000 00000000 00000000 00000010</span><br><span class=\"line\">2. 得到3的补码 ====&gt;先获得原码00000000 00000000 00000000 00000011</span><br><span class=\"line\">得到3的补码</span><br><span class=\"line\">00000000 00000000 00000000 00000011</span><br><span class=\"line\"></span><br><span class=\"line\">3.计算2&amp;3</span><br><span class=\"line\">补码结果为：00000000 00000000 00000000 00000010</span><br><span class=\"line\">原码也为：00000000 00000000 00000000 00000010</span><br><span class=\"line\">最终结果为：2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~-2计算过程</span><br><span class=\"line\">1. 得到-2的原码10000000 00000000 00000000 00000010</span><br><span class=\"line\">2. 算出-2的反码11111111 11111111 11111111 11111101（原符号位保持不变，其他取反）</span><br><span class=\"line\">3. 算出-2的补码11111111 11111111 11111111 11111110</span><br><span class=\"line\">4.再进行~-2操作00000000 00000000 00000000 00000001//运算后的补码</span><br><span class=\"line\">5.转为原码00000000 00000000 00000000 00000001</span><br><span class=\"line\">6.结果为1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~2的计算过程</span><br><span class=\"line\">1.得到2的原码00000000 00000000 00000000 00000010</span><br><span class=\"line\">2.获取补码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">3.计算~2:11111111 11111111 11111111 11111101</span><br><span class=\"line\">3.转为反码（）负数的反码=补码-1</span><br><span class=\"line\">11111111 11111111 11111111 11111100</span><br><span class=\"line\">4.转为原码：10000000 00000000 00000000 00000011</span><br><span class=\"line\">5.结果为-3</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>运算符&gt;&gt;，&lt;&lt;和&gt;&gt;&gt;运算规则</p>\n<ul>\n<li><p>算数右移&gt;&gt;；低位溢出，符号位不变，并用符号位补溢出的高位</p>\n<ul>\n<li><p>&#96;&#96;&#96;<br>int a &#x3D; 1&gt;&gt;2;<br>1:00000000 00000000 00000000 00000001<br>1 &gt;&gt;2 &#x2F;&#x2F;相当于把最后边的01去掉用符号位补上<br>结果：00000000 00000000 00000000 00000000<br>最后结果为0</p>\n<p>简便的方法<br>1&gt;&gt;2 &#x3D; 1&#x2F;2&#x2F;2&#x3D; 0<br>15&gt;&gt;2 &#x3D; 15&#x2F;2&#x2F;2&#x3D;3  &#x2F;&#x2F;取整</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 算数左移&lt;&lt;; 符号位不变，低位补0</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```</span><br><span class=\"line\">    int a =1&lt;&lt;2;</span><br><span class=\"line\">    1:00000000 00000000 00000000 00000001</span><br><span class=\"line\">    1&lt;&lt;2</span><br><span class=\"line\">    00000000 00000000 00000000 00000100</span><br><span class=\"line\">    结果为4</span><br><span class=\"line\">    </span><br><span class=\"line\">    简便的方法</span><br><span class=\"line\">    1&lt;&lt;2 =1*2*2 = 4</span><br><span class=\"line\">    4&lt;&lt;3 = 4*2*2*2 = 32</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>3.&gt;&gt;&gt;逻辑右移，也叫无符号右移，运算规则是：低位溢出，高位补0</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"程序控制结构\"><a href=\"#程序控制结构\" class=\"headerlink\" title=\"程序控制结构\"></a>程序控制结构</h1><h2 id=\"顺序控制（if-else-switch）\"><a href=\"#顺序控制（if-else-switch）\" class=\"headerlink\" title=\"顺序控制（if,else,switch）\"></a>顺序控制（if,else,switch）</h2><h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>程序从上到下逐行执行，中间没有任何判断和跳转</p>\n<h3 id=\"分支控制\"><a href=\"#分支控制\" class=\"headerlink\" title=\"分支控制\"></a>分支控制</h3><h3 id=\"1）单分支\"><a href=\"#1）单分支\" class=\"headerlink\" title=\"1）单分支\"></a><strong>1）单分支</strong></h3><p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(条件表达式)&#123;</span><br><span class=\"line\">\t执行代码块;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说明：当条件表达式为true时，则执行{}内的代码。false就不执行。如果只有一条执行语句，可以省略{}。但不建议省略</p>\n<h3 id=\"2）双分支\"><a href=\"#2）双分支\" class=\"headerlink\" title=\"2）双分支\"></a><strong>2）双分支</strong></h3><p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(条件表达式)&#123;</span><br><span class=\"line\">\t执行代码块<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t执行代码块<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3）多分支\"><a href=\"#3）多分支\" class=\"headerlink\" title=\"3）多分支\"></a><strong>3）多分支</strong></h3><p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(条件表达式)&#123;</span><br><span class=\"line\">\t执行代码块<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(条件表达式)&#123;</span><br><span class=\"line\">\t执行代码块<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t执行代码块....;</span><br><span class=\"line\">&#125;.....</span><br></pre></td></tr></table></figure>\n\n<p>流程图：</p>\n<p>else只能有一个执行入口</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220222162201564.png\" alt=\"image-20220222162201564\"></p>\n<p>特别说明：</p>\n<ol>\n<li>多分支可以没有else，如果所有条件都不成立，则一个执行入口都没有</li>\n<li>如果有else，如果所有的条件表达式都不成立，则默认执行else代码块。</li>\n</ol>\n<p>练习：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ifChapter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入0-100的数字&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> scanner.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num&lt;<span class=\"number\">1</span> &amp;&amp; num&gt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num==<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;信用极好&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num&gt;<span class=\"number\">80</span> &amp;&amp; num &lt;= <span class=\"number\">99</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;信用优秀&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num &gt;= <span class=\"number\">60</span> &amp;&amp; num &lt;= <span class=\"number\">80</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;信用一般&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num &lt;<span class=\"number\">60</span>)&#123;<span class=\"comment\">//或直接不写这个条件语句，但这个会有bug</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;不及格&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;请输入合法数字&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;输入不合法&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4）嵌套分支\"><a href=\"#4）嵌套分支\" class=\"headerlink\" title=\"4）嵌套分支\"></a><strong>4）嵌套分支</strong></h3><p>介绍：</p>\n<p>一个分支完整的嵌套了另一个分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支。</p>\n<p>规范：不建议超过三层（可读性不好）</p>\n<p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>()&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>()&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>.....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5）switch分支\"><a href=\"#5）switch分支\" class=\"headerlink\" title=\"5）switch分支\"></a>5）switch分支</h3><p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(表达式)&#123; <span class=\"comment\">//表达式为具体的一个值</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> 常量<span class=\"number\">1</span>:</span><br><span class=\"line\">语句块<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> 常量<span class=\"number\">2</span>:</span><br><span class=\"line\">语句块<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ······:</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\"> ...........</span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"keyword\">default</span> :</span><br><span class=\"line\"><span class=\"keyword\">default</span>语句块</span><br><span class=\"line\"><span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>switch 关键字,表示swtich分支</li>\n<li>表达式   对应一个值</li>\n<li>case常量1：当表达式的值等于常量1，就执行语句块1</li>\n<li>break：表示退出switch</li>\n<li>如果case 常量1 匹配，就执行语句块1，如果没有则继续case 常量2；</li>\n<li>如果一个都没有匹配上，就执行default</li>\n</ol>\n<p>Switch流程图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220224155515378.png\" alt=\"image-20220224155515378\"></p>\n<p> 注意：</p>\n<ul>\n<li>穿透<ol>\n<li>如果case1 没有break</li>\n<li>则case不进行判断直接执行case2 的语句块</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> week;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入字母&quot;</span>);</span><br><span class=\"line\">        week = scanner.next().charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (week)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;a&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Monday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Tuesday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;c&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Wednesday&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;d&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Thursday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;e&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Friday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;f&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Saturday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;g&#x27;</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;sunday&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;输入有误，请输入a-g的字母&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意事项和细节</p>\n<ol>\n<li><p>表达式数据类型，应和case后的常量类型一致，或者是可以自动转换成可以相互比较的类型，比如输入的是字符，而常量是int</p>\n</li>\n<li><p>Switch(表达式)中表达式的返回值必须是：（byte，short，int，char，enum，String）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//比如下列例子，是不可以的</span></span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">1.1</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span>(a)&#123;<span class=\"comment\">//错误</span></span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"number\">1.1</span>:<span class=\"comment\">//case后面不可以有变量</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;···&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>case子句中的值必须是常量，不能是变量</p>\n</li>\n<li><p>default子句是可选的，当没有匹配的case时，执行default。default语句是可选的，当没有匹配的任何常量，则没有任何输出。</p>\n</li>\n<li><p>break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有则会出现穿透现象，使程序执行后面所有的case语句块，除非遇到break；</p>\n</li>\n<li><p><a href=\"##switch%E7%BB%83%E4%B9%A0\">练习</a></p>\n</li>\n</ol>\n<p><strong>switch 和if的比较</strong></p>\n<ol>\n<li>如果判断的具体数值不多，而且符合byte，short，int，char，enum，string类型虽然这两个语句都可以用，建议用switch</li>\n<li>其他情况，对区间判断，对结果为boolean配型判断，使用if，if的使用范围更广</li>\n</ol>\n<h2 id=\"循环控制（for-while-dowhile-多重循环-重点-）\"><a href=\"#循环控制（for-while-dowhile-多重循环-重点-）\" class=\"headerlink\" title=\"循环控制（for,while,dowhile,多重循环[重点]）\"></a>循环控制（for,while,dowhile,多重循环[重点]）</h2><h3 id=\"1）for循环\"><a href=\"#1）for循环\" class=\"headerlink\" title=\"1）for循环\"></a>1）for循环</h3><ol>\n<li><p>基本语法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(循环变量初始化；循环条件；循环变量迭代)&#123;</span><br><span class=\"line\">\t循环操作；(可多条语句)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>说明</p>\n<ol>\n<li>for关键字，表示循环控制</li>\n<li>for有四要素，1）循环变量初始化，2）循环条件，3）循环操作，4）循环变量迭代</li>\n<li>循环操作，这里可以有很多条语句，也就是我们要执行的代码块</li>\n<li>如果 循环操作(语句)只有一条语句，可以省略{}，建议不要省略</li>\n</ol>\n</li>\n</ol>\n<p>例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//练习： 打印100句“韩顺平教育”</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;韩顺平教育&quot;</span> +i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>for循环流程图<ul>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227123857620.png\" alt=\"image-20220227123857620\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"注意事项：\"><a href=\"#注意事项：\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h4><ul>\n<li><p>循环条件返回一个布尔值(Boolean)</p>\n</li>\n<li><p>for（；循环条件；）中的初始化和变量迭代可以写到其他地方，但两边的分号不能省略</p>\n<ul>\n<li><pre><code class=\"java\">//演示\nint i = 0;\nfor (i; i &lt; 10;) &#123;\n            System.out.println(&quot;韩顺平教育&quot; +i);\n             i++;\n        &#125;\n\n//补充\nfor(;;)&#123;//表示一个无限循环\n   System.out.println(&quot;韩顺平教育&quot; +i);\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 循环初始值，可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开</span><br><span class=\"line\"></span><br><span class=\"line\">  * ```java</span><br><span class=\"line\">    //例</span><br><span class=\"line\">    int count =3;</span><br><span class=\"line\">    for (i =0 ,j = 0 ;i&lt;count; i++, j+=2)&#123;</span><br><span class=\"line\">    \tSystem.out.println(&quot;i=&quot;+i &quot;j=&quot; +j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    输出 ：00 12 24</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>00 12 24</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"编程技巧\"><a href=\"#编程技巧\" class=\"headerlink\" title=\"编程技巧\"></a><strong>编程技巧</strong></h4><ul>\n<li>化繁为简：将复杂的需求拆解成简单的需求</li>\n<li>先死后活：先考虑固定的值，然后转成可以灵活变化的值</li>\n</ul>\n<p><strong>练习</strong></p>\n<ol>\n<li><p>打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]</p>\n<ul>\n<li><p>&#96;&#96;&#96;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```java</span><br><span class=\"line\">  //打印1-100之间所有9的倍数的整数，统计个数以及总和。[化繁为简，先死后活]</span><br><span class=\"line\">        //1、先输出1-100循环</span><br><span class=\"line\">        //2、在输出的过程中过滤9的倍数</span><br><span class=\"line\">        //3、定义一个变量来累计计算个数</span><br><span class=\"line\">        //4、定义一个变量来累计计算总和</span><br><span class=\"line\">  public static void main(String[] args) &#123;</span><br><span class=\"line\">          int count= 0;</span><br><span class=\"line\">          int sum =0;</span><br><span class=\"line\">          for (int i = 1; i &lt;=100 ; i++) &#123;</span><br><span class=\"line\">              if (i%9==0)&#123;</span><br><span class=\"line\">                  System.out.println(&quot;i=&quot;+i);</span><br><span class=\"line\">                  count++;</span><br><span class=\"line\">                  System.out.println(&quot;数量&quot;+count);</span><br><span class=\"line\">                  sum+=i;// = sum + i</span><br><span class=\"line\">                  System.out.println(&quot;sum=&quot;+sum);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">          &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2）while循环\"><a href=\"#2）while循环\" class=\"headerlink\" title=\"2）while循环\"></a>2）while循环</h3><p>基础语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>（循环条件）&#123;</span><br><span class=\"line\">\t循环体（语句）；</span><br><span class=\"line\">\t循环变量迭代；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<ol>\n<li>while循环也有四要素</li>\n<li>只是四要素放的位置，和for不一样</li>\n</ol>\n<p><strong>流程图</strong></p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227143009846.png\" alt=\"image-20220227143009846\"></p>\n<h4 id=\"注意事项：-1\"><a href=\"#注意事项：-1\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h4><ol>\n<li>循环条件是返回布尔值</li>\n<li>while循环是先判断再执行语句</li>\n</ol>\n<h3 id=\"3）do…while循环控制\"><a href=\"#3）do…while循环控制\" class=\"headerlink\" title=\"3）do…while循环控制\"></a>3）do…while循环控制</h3><p>基础语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">\t循环体(语句);</span><br><span class=\"line\">\t循环变量迭代;</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(循环条件);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 说明:</p>\n<ol>\n<li><p>do  while 是关键字</p>\n</li>\n<li><p>也有循环四要素，只是位置不一样</p>\n</li>\n<li><p>先执行，在判断，也就是说，一定会执行一次</p>\n</li>\n<li><p>最后有一个分号</p>\n</li>\n<li><p>while和do… while区别</p>\n<ul>\n<li><p>while是先判断再执行</p>\n</li>\n<li><p>do .. while是先执行再判断</p>\n</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;阿巴阿巴&quot;</span>);</span><br><span class=\"line\">            i++;<span class=\"comment\">//不要忘记加上，否则容易死循环</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span> (i&lt;=<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;exit dowhile&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>流程图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220227163555197.png\" alt=\"image-20220227163555197\"></p>\n<h4 id=\"注意事项：-2\"><a href=\"#注意事项：-2\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h4><ol>\n<li>循环条件是返回一个布尔值的表达式</li>\n<li>do…while 循环是先执行后判断，因此它至少执行一次</li>\n</ol>\n<h3 id=\"4）多重循环\"><a href=\"#4）多重循环\" class=\"headerlink\" title=\"4）多重循环\"></a>4）多重循环</h3><h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ol>\n<li><p>讲一个循环放在另一个循环体内，就形成了嵌套循环。其中，for,while,do …while均可以作为外层循环和内层循环 。【建议一般使用两层，最多不超过三层，否则代码可读性很差】</p>\n</li>\n<li><p>实质上，嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环</p>\n</li>\n<li><p>例：设外层循环次数为m次，内层为n次。则内层循环体实际上需要执行m*n次</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;i = &quot;</span>+i+ <span class=\"string\">&quot;,&quot;</span>+<span class=\"string\">&quot;j = &quot;</span>+j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------------------输出------------------------</span><br><span class=\"line\">i = <span class=\"number\">0</span> , j =<span class=\"number\">0</span></span><br><span class=\"line\">i = <span class=\"number\">0</span> , j =<span class=\"number\">1</span></span><br><span class=\"line\">i = <span class=\"number\">0</span> , j =<span class=\"number\">2</span></span><br><span class=\"line\">i = <span class=\"number\">1</span> , j =<span class=\"number\">0</span></span><br><span class=\"line\">i = <span class=\"number\">1</span> , j =<span class=\"number\">1</span></span><br><span class=\"line\">i = <span class=\"number\">1</span> , j =<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h4><ol>\n<li><p>统计3个班成绩情况，每个班有5名同学，求出各个班的平均成绩和所有班级的平均分【学生的成绩从键盘输入】</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>Scanner scanner &#x3D; new Scanner(System.in);<br>&#x2F;&#x2F;        int clss &#x3D; 1;<br>        int stu &#x3D;0;<br>        double sum &#x3D; 0;<br>    for (int i &#x3D; 1; i &lt;&#x3D;3 ; i++) {<br>        for ( int j &#x3D; 1;j&lt;&#x3D;5;j++){<br><br>            System.out.println(“请输入”+i+”班”+j+”成绩”);<br>            int s &#x3D; scanner.nextInt();<br>            sum &#x3D; sum + s;<br>        }<br>        System.out.println(i+”班的平均分为：”+(sum &#x2F; 5));<br>        sum &#x3D;0;<br>    }<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">     </span><br><span class=\"line\"></span><br><span class=\"line\">2. 打印99乘法表</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```java</span><br><span class=\"line\">     for (int i = 1; i &lt;=9 ; i++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">                 for (int j = 1; j &lt;=i ; j++) &#123;</span><br><span class=\"line\">                     System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+(i*j)+&quot;  &quot;);</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 System.out.println(&quot;&quot;);</span><br><span class=\"line\">             &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>打印空心金字塔</p>\n<ul>\n<li><pre><code class=\"java\">//        实心金字塔\n        for (int i = 1; i &lt;=5 ; i++) &#123;\n            for (int k = 1; k &lt;=5-i ; k++) &#123;\n//                在输出*之前，先输出对应的空格 = 总层数 - 当前层数\n                System.out.print(&quot; &quot;);\n            &#125;\n//            控制每个打印的*的层数\n            for (int j = 1; j &lt;=2*i-1 ; j++) &#123;\n\n                System.out.print(&quot;*&quot;);\n            &#125;\n            System.out.println(&quot; &quot;);\n        &#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* ```java</span><br><span class=\"line\">  空心金字塔 【难点】</span><br><span class=\"line\">          for (int i = 1; i &lt;=5 ; i++) &#123;</span><br><span class=\"line\">              for (int k = 1; k &lt;=5-i ; k++) &#123;</span><br><span class=\"line\">  //                在输出*之前，先输出对应的空格 = 总层数 - 当前层数</span><br><span class=\"line\">                  System.out.print(&quot; &quot;);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              </span><br><span class=\"line\">              </span><br><span class=\"line\">  //            控制每个打印的*的层数</span><br><span class=\"line\">              for (int j = 1; j &lt;=2*i-1 ; j++) &#123;</span><br><span class=\"line\">              </span><br><span class=\"line\">              </span><br><span class=\"line\">  \t\t\t\t//1.空心金字塔的第一层和最后一层的*全部输出</span><br><span class=\"line\">  \t\t\t\t//2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示</span><br><span class=\"line\">  \t\t\t\t//3.再加一个条件 i == 5</span><br><span class=\"line\">  \t\t\t\tif(j == 1 || j == 2*i-1 || i==5 )&#123;</span><br><span class=\"line\">  \t\t\t\t\t System.out.print(&quot;*&quot;);</span><br><span class=\"line\">  \t\t\t\t&#125;else&#123;</span><br><span class=\"line\">  \t\t\t\t\t System.out.print(&quot; &quot;);</span><br><span class=\"line\">  \t\t\t\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  //可以将其中的5 提出来换成变量，实时控制金字塔的层数</span><br><span class=\"line\">  </span><br><span class=\"line\">                 </span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              System.out.println(&quot; &quot;);</span><br><span class=\"line\">          &#125;</span><br></pre></td></tr></table></figure>\n\n</code></pre>\n</li>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;可手动修改的</p>\n<pre><code>  Scanner scanner = new Scanner(System.in);\n  System.out.println(&quot;请输入层数&quot;);\n  int layer = scanner.nextInt();\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 1; i &lt;=layer ; i++) &#123;</span><br><span class=\"line\">            for (int k = 1; k &lt;=layer-i ; k++) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">//                在输出*之前，先输出对应的空格 = 总层数 - 当前层数</span><br><span class=\"line\">                System.out.print(&quot; &quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">//            控制每个打印的*的层数</span><br><span class=\"line\">            for (int j = 1; j &lt;=2*i-1 ; j++) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">                //1.空心金字塔的第一层和最后一层的*全部输出</span><br><span class=\"line\">                //2.用if（j == 1 || j == 2*i-1）条件语句过滤掉，此时会出现最后一层不显示</span><br><span class=\"line\">                //3.再加一个条件 i == 5</span><br><span class=\"line\">                if(j == 1 || j == 2*i-1 || i==layer )&#123;</span><br><span class=\"line\">                    System.out.print(&quot;*&quot;);</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    System.out.print(&quot; &quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot; &quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure></li>\n<li><p>改为菱形</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## break</span><br><span class=\"line\"></span><br><span class=\"line\">介绍</span><br><span class=\"line\"></span><br><span class=\"line\">1. 跳转控制语句-----&gt;break</span><br><span class=\"line\">2. 当某个条件满足时，终止循环</span><br><span class=\"line\">3. break语句用于终止某个语句块的执行，一般用于switch或者循环中</span><br><span class=\"line\"></span><br><span class=\"line\">基本语法：</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">break;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p>以while循环为例流程图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228111326348.png\" alt=\"image-20220228111326348\"></p>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ol>\n<li><p>break语句出现在多层嵌套语句块时，可以通过标签指明要终止的是哪一层语句块</p>\n</li>\n<li><p>标签的基本使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label1:&#123;.....</span><br><span class=\"line\">label2:\t\t&#123;.....</span><br><span class=\"line\">label3:\t\t\t&#123;.....</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span> label2;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>break语句可以指定退出哪层</li>\n<li>label1是标签，由程序员决定</li>\n<li>break后指定到哪个label就退出到哪里</li>\n<li>在实际开发中，尽量不要使用标签</li>\n<li>如果没有指定break，默认退出最近的循环体</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"continue-跳转控制语句\"><a href=\"#continue-跳转控制语句\" class=\"headerlink\" title=\"continue-跳转控制语句\"></a>continue-跳转控制语句</h2><p>介绍：</p>\n<ol>\n<li><u><strong>continue语句用于结束本次循环，继续执行下次循环</strong>。</u></li>\n<li>continue语句多出现在多层嵌套的循环语句中时，可以用过标签指明要跳过的是哪一环，这个和前面的标签使用一样</li>\n</ol>\n<p>基本语法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">....</span><br><span class=\"line\"><span class=\"keyword\">continue</span>;</span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>流程图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220228153036178.png\" alt=\"image-20220228153036178\"></p>\n<h2 id=\"return-跳转控制语句\"><a href=\"#return-跳转控制语句\" class=\"headerlink\" title=\"return-跳转控制语句\"></a>return-跳转控制语句</h2><p>介绍：</p>\n<p>return使用在方法，表示跳出所在的方法</p>\n<p>注意：</p>\n<ol>\n<li>如果吧return放在main方法中会退出程序</li>\n</ol>\n<h1 id=\"数组【重点】\"><a href=\"#数组【重点】\" class=\"headerlink\" title=\"数组【重点】\"></a>数组【重点】</h1><h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p><strong>介绍</strong></p>\n<p>数组可以存放 <u>多个</u><em><u>同一类型</u></em> 的数据。数组也是一种数据类型，是引用数据类型。</p>\n<p>即：数（数据）组（一组）就是一组数据</p>\n<p><span id = \"数组案例01\">案例</span>（快速入门）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">   \t\t\t<span class=\"type\">double</span> <span class=\"variable\">totalWeght</span> <span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">double</span>[] hen = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">  <span class=\"comment\">//可以通过 for循环访问数组的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;hen.length ; i++) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//可以通过下标来访问数组的元素 hen[下标]</span></span><br><span class=\"line\">          <span class=\"comment\">//下标是从0开始的，比如【0，1，2，3】</span></span><br><span class=\"line\">          <span class=\"comment\">//第二个元素是hen[1]</span></span><br><span class=\"line\">    </span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span>+(i+<span class=\"number\">1</span>)+<span class=\"string\">&quot;个元素的值为&quot;</span>+hen[i]);</span><br><span class=\"line\">          totalWeght+=hen[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  \t\tSystem.out.println(<span class=\"string\">&quot;总体重为&quot;</span>+totalWeght+<span class=\"string\">&quot;平均体重为=&quot;</span>+(totalWeght/hen.length));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态初始化\"><a href=\"#动态初始化\" class=\"headerlink\" title=\"动态初始化\"></a>动态初始化</h3><h4 id=\"使用方式1\"><a href=\"#使用方式1\" class=\"headerlink\" title=\"使用方式1\"></a>使用方式1</h4><p>先new出一个数组，再动态的给它赋值。</p>\n<p>数组的定义：</p>\n<p>数据类型\t数组名[] &#x3D; new 数据类型[大小]</p>\n<p>数据类型[]\t数组名 &#x3D; new 数据类型[大小]</p>\n<p>以上两种写法的效果都是等价的</p>\n<p>例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个数组，名字为a，长度为5个int</span></span><br></pre></td></tr></table></figure>\n\n<p>内存图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302092916369.png\" alt=\"image-20220302092916369\"></p>\n<p>例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.smms.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">chapterArray01</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"comment\">//new数组类型时，记得加上数组的长度</span></span><br><span class=\"line\">        <span class=\"type\">double</span>[] doubles = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; doubles.length; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;请输入第&quot;</span>+(i+<span class=\"number\">1</span>)+<span class=\"string\">&quot;个数&quot;</span>);</span><br><span class=\"line\">            doubles[i] = scanner.nextDouble();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;========================================&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;doubles.length ; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;输入的数为&quot;</span>+doubles[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用方式2\"><a href=\"#使用方式2\" class=\"headerlink\" title=\"使用方式2\"></a>使用方式2</h4><ol>\n<li><em><strong><u>先声明数组</u></strong></em></li>\n</ol>\n<p>语法：</p>\n<ul>\n<li><p>数据类型 数组名[];\t或\t\t数据类型[] \t数组名;</p>\n</li>\n<li><p>int a[]  &#x2F; int[]  a;</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><em><strong><u>创建数组</u></strong></em></li>\n</ol>\n<p>语法：</p>\n<ul>\n<li>数组名 &#x3D; new 数据类型 [ 大小 ];</li>\n<li>a &#x3D; new int[5];</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//        double[] doubles = new double[5];</span></span><br><span class=\"line\"><span class=\"comment\">//相当于吧使用方法1给拆分成两个</span></span><br><span class=\"line\"><span class=\"comment\">//\t1.先声明</span></span><br><span class=\"line\">        <span class=\"type\">double</span> doubles[];</span><br><span class=\"line\">        <span class=\"comment\">//2.再创建</span></span><br><span class=\"line\">        doubles = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[<span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<p>解释：1.先声明，在内存中相当于创建了一个空的变量，这时没有任何左右</p>\n<p>2.再创建，才使得这个数组有意义。不写的话会报空指针异常</p>\n<h3 id=\"静态初始化\"><a href=\"#静态初始化\" class=\"headerlink\" title=\"静态初始化\"></a>静态初始化</h3><p>语法：</p>\n<p>数据类型\t数组名[] &#x3D; {元素值，元素值，元素值，……}</p>\n<p><a href=\"#%E6%95%B0%E7%BB%84%E6%A1%88%E4%BE%8B01\">案例</a>跳转</p>\n<h3 id=\"注意事项和细节\"><a href=\"#注意事项和细节\" class=\"headerlink\" title=\"注意事项和细节\"></a>注意事项和细节</h3><ol>\n<li>数组是多核相同的数据类型的组合，实现对这些数据的统一管理</li>\n<li>数组中的元素可以使任何数据类型，包括基本数据类型和引用数据类型，但不能混用</li>\n<li>数组创建后，如果没有赋值，会有默认值：int 0 , short 0 , byte 0 ,long 0, float 0 ,double 0.0 , char \\u0000, boolean false , String null;</li>\n<li>使用数组的步骤：<ol>\n<li>声明数组并开辟空间</li>\n<li>给数组各个元素赋值</li>\n<li>使用数组</li>\n</ol>\n</li>\n<li>数组的下表是从0开始的 </li>\n<li>数组下表必须在指定范围内使用，否则报：下标越界异常，比如: int[] arr &#x3D; new int [5] ; 则有效下标为0-4</li>\n<li>数组属于引用数据类型，数组行数据是对象（object）</li>\n<li>boolean 类型没有赋值的情况下默认false</li>\n</ol>\n<h3 id=\"数组赋值机制\"><a href=\"#数组赋值机制\" class=\"headerlink\" title=\"数组赋值机制\"></a>数组赋值机制</h3><ol>\n<li><p>基本数据类型赋值，这个值就是具体的数据，而且相互不影响</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本数据类型赋值，复制方式为值拷贝</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">2</span> ; </span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> n1 ;</span><br><span class=\"line\"></span><br><span class=\"line\">n2的变化不会影响n1</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数组再默认情况下是引用传递，赋的值是地址。赋值方式为引用传递</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] array1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"type\">int</span>[] array2 = array1; </span><br><span class=\"line\"></span><br><span class=\"line\">array2[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">//此时运行的结果 array1的第0个元素会变成10</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p> <img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302141207302.png\" alt=\"image-20220302141207302\"></p>\n<h3 id=\"数组拷贝\"><a href=\"#数组拷贝\" class=\"headerlink\" title=\"数组拷贝\"></a>数组拷贝</h3><p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] arr1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">//1. 创建一个新的数组arr2,开辟一个新的数据空间</span></span><br><span class=\"line\"><span class=\"comment\">//2. 大小 = arr1.length</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr2[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr1.length];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历arr1到对应的位置</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class=\"line\">    arr2[i] = arr1[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>jvm内存图分析:</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142048498.png\" alt=\"image-20220302142048498\"></p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220302142253236.png\" alt=\"image-20220302142253236\"></p>\n<h3 id=\"数组翻转\"><a href=\"#数组翻转\" class=\"headerlink\" title=\"数组翻转\"></a>数组翻转</h3><p>案例：</p>\n<p>要求：需要把数组的元素内容反转。</p>\n<p>arr { 1 , 2 , 3 , 4 , 5 }–&gt;{5 , 4 , 3 , 2 , 1}</p>\n<p>方式1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">11</span> , <span class=\"number\">22</span> , <span class=\"number\">33</span> , <span class=\"number\">44</span> , <span class=\"number\">55</span> , <span class=\"number\">66</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1. 把 arr[0] 和 arr[5] 进行交换</span></span><br><span class=\"line\"><span class=\"comment\">//2. 把 arr[1] 和 arr[4] 进行交换</span></span><br><span class=\"line\"><span class=\"comment\">//3. 把 arr[2] 和 arr[3] 进行交换</span></span><br><span class=\"line\"><span class=\"comment\">//4. 一共要交换 3 次 = arr.length</span></span><br><span class=\"line\"><span class=\"comment\">//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;len/<span class=\"number\">2</span> ; i++) &#123;</span><br><span class=\"line\">            temp = arr[len-<span class=\"number\">1</span>-i];</span><br><span class=\"line\">            arr[len-<span class=\"number\">1</span>-i] = arr[i];</span><br><span class=\"line\">            arr[i] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>方式2</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">11</span> , <span class=\"number\">22</span> , <span class=\"number\">33</span> , <span class=\"number\">44</span> , <span class=\"number\">55</span> , <span class=\"number\">66</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//1. 先创建一个arr2</span></span><br><span class=\"line\">        <span class=\"comment\">//2. 逆序遍历arr，再将每个元素赋给arr2的元素中</span></span><br><span class=\"line\">        <span class=\"comment\">//3. 增加一个循环变量j</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr.length];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,j=arr.length-<span class=\"number\">1</span> ; j&gt;=<span class=\"number\">0</span>; i++,j--) &#123;</span><br><span class=\"line\">            arr2[j] =arr[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//4.当for循环结束，arr2就是一个逆序数组，&#123;66 , 55 , 44 , 33 , 22 , 11&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//5. 让arr指向arr2数据空间,此时arr原来的数据空间就没有变量引用</span></span><br><span class=\"line\"><span class=\"comment\">//会被当做垃圾处理</span></span><br><span class=\"line\">arr = arr2</span><br><span class=\"line\">    <span class=\"comment\">//6. 遍历输出</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">            System.out.println(arr[i]);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"数组扩容\"><a href=\"#数组扩容\" class=\"headerlink\" title=\"数组扩容\"></a>数组扩容</h3><p>数组缩减同理</p>\n<p>数组添加</p>\n<p>要求：实现动态的给数组添加元素效果，实现对数组扩容</p>\n<p>1）原始数组使用静态分配int[] arr &#x3D; {1,2,3}</p>\n<p>2）增加的元素4，直接放在数组的最后 arr &#x3D; {1,2,3,4}</p>\n<p>3）用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y&#x2F;n</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.smms.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">chapterArrayAdd</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">char</span> key ;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span>[] arr2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr1.length+<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class=\"line\">                    arr2[i] = arr1[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;请输入一个要添加的值&quot;</span>);</span><br><span class=\"line\">                arr2[arr2.length - <span class=\"number\">1</span>] = scanner.nextInt();</span><br><span class=\"line\"></span><br><span class=\"line\">            arr1 = arr2;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;是否继续添加？请输入y/n&quot;</span>);</span><br><span class=\"line\">            key = scanner.next().charAt(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key==<span class=\"string\">&#x27;y&#x27;</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;继续增加&quot;</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key== <span class=\"string\">&#x27;n&#x27;</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;跳出&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span> ;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;输入不合法&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"><span class=\"comment\">//            将arry1的地址指定到arry2的地址，此时原arry1的地址被没有变量引用，所以被jvm销毁</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr1.length ; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;arr1 = &quot;</span>+arr1[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>介绍</p>\n<p>排序的分类：</p>\n<ol>\n<li>内部排序：</li>\n</ol>\n<ul>\n<li>指将需要处理的所有数据都加载到内部存储中进行排序。包括（交换式排序法，选择时排序法和插入式排序法）</li>\n</ul>\n<ol start=\"2\">\n<li>外部排序法：<ul>\n<li>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>基本思想：通过对待排序序列从后向前（从下标较大的元素开始），一次比较相邻元素的值若发现逆序则交换，使值较大的元素从前移向后部。像水下的气泡一样逐渐向上冒。</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220303105607719.png\" alt=\"image-20220303105607719\"></p>\n<p>特点：</p>\n<ol>\n<li><p>一共有五个元素</p>\n</li>\n<li><p>一共进行了四轮排序，可以看成外层循环</p>\n</li>\n<li><p>每1轮排序可以确定一个数的位置，比如第一轮排序确最大数，第二轮确定第二大的数 的位置，依次类推</p>\n</li>\n<li><p>当进行比较时，如果前面的数大于后面的数，就交换</p>\n</li>\n</ol>\n<p>案例说明:</p>\n<p>将五个无序：24,69,80,57,13使用冒泡排序，从小到大排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.smms.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">chapterBall</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] a  = &#123;<span class=\"number\">24</span>,<span class=\"number\">69</span>,<span class=\"number\">80</span>,<span class=\"number\">57</span>,<span class=\"number\">13</span>&#125;;</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.length-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; a.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j&gt;=a.length-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[j]&lt;a[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;不做交换&quot;</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    tmp = a[j];</span><br><span class=\"line\">                    a[j]  = a[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    a[j+<span class=\"number\">1</span>] = tmp;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;交换第&quot;</span>+j+<span class=\"string\">&quot;个数为&quot;</span>+a[j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;a.length ; i++) &#123;</span><br><span class=\"line\">            System.out.println(a[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><h3 id=\"1）顺序查找：\"><a href=\"#1）顺序查找：\" class=\"headerlink\" title=\"1）顺序查找：\"></a>1）顺序查找：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.smms.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">exercisesSequence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*有一个数列：</span></span><br><span class=\"line\"><span class=\"comment\">        * 白眉鹰王，金毛狮王，紫衫龙王，青翼蝠王猜数游戏</span></span><br><span class=\"line\"><span class=\"comment\">        * 从键盘任意输入一个名称，判断数列中是否包含此名称（顺序查找）</span></span><br><span class=\"line\"><span class=\"comment\">        * 要求：如果找到了，就提示找到，并给出下标</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        String[] a =&#123;<span class=\"string\">&quot;白眉鹰王&quot;</span>,<span class=\"string\">&quot;金毛狮王&quot;</span>,<span class=\"string\">&quot;紫衫龙王&quot;</span>,<span class=\"string\">&quot;青翼蝠王&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;请输入&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">        <span class=\"comment\">//用于判断是否没找到</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">nub</span> <span class=\"operator\">=</span>-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;a.length ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next.equals(a[i]))&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;找到了&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">//如果找到了就把i的值赋给sub</span></span><br><span class=\"line\">                nub = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">//如果nub==-1就代表没找到</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nub == -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;没找到&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2）二分查找：\"><a href=\"#2）二分查找：\" class=\"headerlink\" title=\"2）二分查找：\"></a>2）二分查找：</h3><p>算法部分讲解补充</p>\n<h2 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h2><p>介绍：一个数组内，还有数组</p>\n<p>要理解的点：</p>\n<ol>\n<li>看到定义形式就可知道是不是二维数组</li>\n<li>二维数组的每一个元素都是一维数组</li>\n<li>二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历</li>\n<li></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果需要访问第（i+<span class=\"number\">1</span>)个一维数组，第（j+<span class=\"number\">1</span>)个值。arr2d[i][j]</span><br><span class=\"line\"> 或需要访问第i个一维数组，第j个值。arr2d[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]   </span><br></pre></td></tr></table></figure>\n\n\n\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 请用二维数组输入如下图形</span></span><br><span class=\"line\"><span class=\"comment\">         0 0 0 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">         0 0 1 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">         0 2 0 3 0 0</span></span><br><span class=\"line\"><span class=\"comment\">         0 0 0 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        1. 定义形式 int[][]</span></span><br><span class=\"line\"><span class=\"comment\">//        2.可以理解为一个数组内的每个元素都是一个数组</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] arr2d= &#123;&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">                        &#123;<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">&quot;二维数组的元素个数&quot;</span>+arr2d.length);</span><br><span class=\"line\"><span class=\"comment\">//\t二维数组的每个元素是一维数组，所以如果需要得到每个一维数组的值，需要再次遍历</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//        获取多个少个一维数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr2d.length; i++) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            遍历二维数组的每一个元素（数组）,</span></span><br><span class=\"line\"><span class=\"comment\">//            arr2d[i].length  获取二维数组内对应的每一个一维数组的长度</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; arr2d[i].length; j++) &#123;</span><br><span class=\"line\">                System.out.print(arr2d[i][j]+<span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二维数组内存原理图：\"><a href=\"#二维数组内存原理图：\" class=\"headerlink\" title=\"二维数组内存原理图：\"></a>二维数组内存原理图：</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165024843.png\" alt=\"image-20220304165024843\"></p>\n<h3 id=\"二维数组的使用方式\"><a href=\"#二维数组的使用方式\" class=\"headerlink\" title=\"二维数组的使用方式\"></a>二维数组的使用方式</h3><p>方式1：动态初始化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.语法：类型[][] 数组名 = new 类型[大小][大小];</span><br><span class=\"line\">例如： int[][] = new int[2][3];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>方式2：动态初始化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 先声明：类型 数组名[][];</span><br><span class=\"line\">2. 再定义（开辟空间）： 数组名 = new 类型[大小][大小];</span><br><span class=\"line\">3. 赋值（有默认值，比如int 类型默认值就是0）</span><br></pre></td></tr></table></figure>\n\n<p>方式3：动态初始化</p>\n<ol>\n<li>列数不确定</li>\n<li>java不强制每个数组的长度都一样</li>\n<li>例：<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220304165929272.png\" alt=\"image-20220304165929272\"></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            动态创建下面二维数组，并输出</span></span><br><span class=\"line\"><span class=\"comment\">            i = 0 : 1</span></span><br><span class=\"line\"><span class=\"comment\">            i = 1 : 2 2</span></span><br><span class=\"line\"><span class=\"comment\">            i = 2 : 3 3 3</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">//1. 创建一个二维数组，因为数组内的每一堆数组的元素都是不确定的，所以不填。</span></span><br><span class=\"line\">        <span class=\"comment\">// 填了的话相当于固定了长度</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] arr= <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>][];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            给数组内的一维数组开辟空间</span></span><br><span class=\"line\"><span class=\"comment\">//            如果没有给一堆数组开辟空间，那么这个空间的就是null</span></span><br><span class=\"line\">            arr[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[i+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"comment\">//            遍历一维数组，给一堆数组的每个元素赋值</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; arr[i].length ; j++) &#123;</span><br><span class=\"line\">                arr[i][j]= i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        遍历出这个二维数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt;arr[i].length ; j++) &#123;</span><br><span class=\"line\">                System.out.print(arr[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>杨辉三角形</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220305143151743.png\" alt=\"image-20220305143151743\"></p>\n<p>提示：</p>\n<ol>\n<li><p>第一行有一个元素，第n行有n个元素</p>\n</li>\n<li><p>第一行的第一个元素和最后一个元素都是1</p>\n</li>\n<li><p>从第三行开始，对于非第一个元素和最后一个元素的元素的值，arr[i],[j]</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>中间的数为：<br>arr[i][j]  &#x3D; arr[i-1][j]+ arr[i-1][j-1]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">package basics.chapterArray;</span><br><span class=\"line\"></span><br><span class=\"line\">public class exerciseArrayYangHuiTriangle &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[][] arr =  new int[10][];</span><br><span class=\"line\">        for (int i = 0; i &lt;10 ; i++) &#123;</span><br><span class=\"line\">            arr[i] = new int[i+1];</span><br><span class=\"line\">            for (int j = 0; j &lt; arr[i].length; j++) &#123;</span><br><span class=\"line\">                if (j==0 || j == arr[i].length-1)&#123;</span><br><span class=\"line\">                    arr[i][j] = 1;</span><br><span class=\"line\">                &#125;else &#123;</span><br><span class=\"line\">                    arr[i][j] = arr[i-1][j]+arr[i-1][j-1];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt;arr[i].length ; j++) &#123;</span><br><span class=\"line\">                System.out.print(arr[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><h2 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h2><p>1）类是抽象的，概念的。代表一类事物，比如人类，猫类，狗类。。。。，即它是实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例：</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">cat</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//属性/也叫成员变量</span></span><br><span class=\"line\">   <span class=\"comment\">// 成员变量 =属性 = field(字段)</span></span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实例</span></span><br><span class=\"line\"><span class=\"type\">cat</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ca</span>();</span><br></pre></td></tr></table></figure>\n\n<p>2） 对象是具体的，实际的，代表一个具体事务，即是实例</p>\n<p>3） 类是对象的模板，对象是类的一个个体，对应一个实例</p>\n<p>属性可以使基本数据类型，也可以是引用数据类型(对象，数组)</p>\n<h3 id=\"对象在内存中存在的形式（重要）\"><a href=\"#对象在内存中存在的形式（重要）\" class=\"headerlink\" title=\"对象在内存中存在的形式（重要）\"></a>对象在内存中存在的形式（重要）</h3><p>java内存的结构分析：</p>\n<ol>\n<li>栈：一般存放基本数据类型（局部变量）</li>\n<li>堆：存放对象（Cat cat ，数组等）</li>\n<li>方法区：常量池（常量，比如字符串），类加载信息</li>\n<li>示意图：[Cat(name,age,price)]</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">p.name = <span class=\"string\">&quot;jack&quot;</span>;</span><br><span class=\"line\">p.age = <span class=\"number\">12</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>先加载Person类信息（属性和方法信息，只会加载一次）</span><br><span class=\"line\"><span class=\"number\">2.</span>在堆中分配空间，进行默认初始化（看规则），</span><br><span class=\"line\"><span class=\"number\">3.</span>把堆中的地址返回给p，p就指向对象</span><br><span class=\"line\"><span class=\"number\">4.</span>进行指定初始化，比如：p.name = <span class=\"string\">&quot;jack&quot;</span>,p.age = <span class=\"number\">12</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>对象和数组都是引用类型</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307112129768.png\" alt=\"image-20220307112129768\"></p>\n<p>如果存放的数据，类型是基本数据类型则存放在堆中，引用的数据类型则存放在方法区</p>\n<h3 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>1） 属性的定义语法同变量，示例：<span style=\"color:blue\">访问修饰符</span><span style= \"color:red\" > 属性类型  属性名;</span></p>\n<p>2） 属性的定义类型可以为任意类型，包含基本类型或引用类型</p>\n<p>3） 属性如果不赋值，有默认值，规则和数组一致</p>\n<h3 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h3><ol>\n<li><p>先声明在创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAT cat;</span><br><span class=\"line\">cat  = <span class=\"keyword\">new</span> <span class=\"title class_\">CAT</span>();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CAT</span> <span class=\"variable\">cat</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CAT</span>();</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>访问属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对象名.属性名；</span><br><span class=\"line\">cat.xxx;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类对象的内存分配机制\"><a href=\"#类对象的内存分配机制\" class=\"headerlink\" title=\"类对象的内存分配机制\"></a>类对象的内存分配机制</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307145803905.png\" alt=\"image-20220307145803905\"></p>\n<h2 id=\"成员方法\"><a href=\"#成员方法\" class=\"headerlink\" title=\"成员方法\"></a>成员方法</h2><p>介绍：</p>\n<p>用于描述对象的行为，成为方法</p>\n<p>案例：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220307161842380.png\" alt=\"image-20220307161842380\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.smms.demo.method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">exercisesMethod01</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">        person.speal();</span><br><span class=\"line\">        person.cal01();</span><br><span class=\"line\">        person.cal02(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">//        调用getSum方法，并给了1,3的值</span></span><br><span class=\"line\"><span class=\"comment\">//        用returnsum接收getSum返回的值</span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">returnsum</span> <span class=\"operator\">=</span> person.getSum(<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;returnsum=&quot;</span>+returnsum);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">speal</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是一个好人&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">cal01</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            sum+=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;1+~+1000=&quot;</span>+sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">cal02</span><span class=\"params\">(<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;=n ; i++) &#123;</span><br><span class=\"line\">            sum = sum+i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;1+n=&quot;</span>+sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getSum</span><span class=\"params\">(<span class=\"type\">double</span> a, <span class=\"type\">double</span> b)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        sum = a+b;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;a+b=&quot;</span>+sum);</span><br><span class=\"line\"><span class=\"comment\">//        表示返回sum</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内存分析流程图\"><a href=\"#内存分析流程图\" class=\"headerlink\" title=\"内存分析流程图\"></a>内存分析流程图</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220308162432089.png\" alt=\"image-20220308162432089\"></p>\n<p>方法的优点：</p>\n<ol>\n<li>提高了代码的复用性</li>\n<li>可将实现的细节封装起来，然后提供其他用户来调用</li>\n</ol>\n<h3 id=\"成员方法的定义\"><a href=\"#成员方法的定义\" class=\"headerlink\" title=\"成员方法的定义\"></a>成员方法的定义</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> 返回数据类型\\<span class=\"keyword\">void</span>（表示没有返回值）\t方法名(形参列表...)&#123;<span class=\"comment\">//方法体</span></span><br><span class=\"line\">语句;</span><br><span class=\"line\"><span class=\"keyword\">return</span>；<span class=\"comment\">//返回值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>参数列表：表示成员方法输入cal(int n)</li>\n<li>数据类型(返回类型)：表示成员方法输出，void表示没有返回值</li>\n<li>方法主体:表示为了实现某一功能代码块</li>\n<li>return语句不是必须的</li>\n</ol>\n<h3 id=\"注意事项-2\"><a href=\"#注意事项-2\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li><p>访问修饰符</p>\n</li>\n<li><p>&#96;&#96;&#96; java<br>访问修饰符 返回数据类型\\void（表示没有返回值）\t方法名(形参列表…){&#x2F;&#x2F;方法体<br>语句;<br>return；&#x2F;&#x2F;返回值<br>}</p>\n<ol>\n<li>访问修饰符（作用是控制 方法的适用范围）<br> 如果不写默认访问，[有四种：public protected 默认]</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\">3. 返回数据类型</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>一个方法最多有一个返回值<br> 返回多个结果，返回数组</p>\n</li>\n<li><p>返回类型可以为任意类型，包含基本类型和引用类型(数组，对象)</p>\n</li>\n<li><p>如果方法要求有返回数据类型，则方法体中最后执行的语句必须为return值；而且要求返回值类型必须和return的值的类型一致或兼容</p>\n</li>\n<li><p>如果方法是void，则方法体照片那个可以没有return语句，或者 只写 return；</p>\n</li>\n</ol>\n<p>方法命名；使用驼峰命名法，最好见名知意</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开。例：getSum(int a,int b)</span><br><span class=\"line\"></span><br><span class=\"line\">5. 参数类型可以为任意类型，包含基本类型或引用类型。</span><br><span class=\"line\"></span><br><span class=\"line\">6. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数</span><br><span class=\"line\"></span><br><span class=\"line\">7. 方法定义时的参数成为形式参数（形参）；方法调用时的参数成为实际参数，简称实参。实参和形参的类型要一致或兼容、个数、顺序必须一致</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```java</span><br><span class=\"line\">     public static void main()&#123;</span><br><span class=\"line\">     \tMethod a = new Method();</span><br><span class=\"line\">     \ta.input(123,345//这里成为实参);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     class Method&#123;</span><br><span class=\"line\">     \tpublic int input(int a,int b//这里成为形参)&#123;</span><br><span class=\"line\">     \tsystem.out.print(&quot;xxx&quot;);</span><br><span class=\"line\">     \treturn xxx;</span><br><span class=\"line\">     \t&#125;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法体</p>\n<p>​\t里面写完成功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义</p>\n<p>调用细节</p>\n<ol>\n<li><p>同一类中的方法调用：直接调用即可</p>\n<ul>\n<li>直接输入：方法名（参数）即可</li>\n</ul>\n</li>\n<li><p>跨类中的方法A类调用B类方法：需要通过对象名调用。比如：对象名.方法名(参数)</p>\n</li>\n</ol>\n<h2 id=\"成员方法传参（重要）\"><a href=\"#成员方法传参（重要）\" class=\"headerlink\" title=\"成员方法传参（重要）\"></a>成员方法传参（重要）</h2><p>基本数据类型</p>\n<ol>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310134944831.png\" alt=\"image-20220310134944831\"></li>\n<li><span style = \"color:red\">基本数据类型</span>，传递的值（拷贝），形参的任何改变不影响实参！</li>\n</ol>\n<p>引用数据类型</p>\n<ol>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310140041330.png\" alt=\"image-20220310140041330\"></li>\n<li>引用类型传递的是地址（传递也是值，但值是地址），可以通过形参影响实参。</li>\n</ol>\n<h2 id=\"递归机制（recursion）\"><a href=\"#递归机制（recursion）\" class=\"headerlink\" title=\"递归机制（recursion）\"></a>递归机制（recursion）</h2><p>递归调用的本质，是方法的调用</p>\n<ol>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310164428690.png\" alt=\"image-20220310164428690\"></li>\n<li>栈是先进后出，先出后进（所以图中的test栈2先输出，然后是3，4）</li>\n<li>每次这个栈内的方法执行完成后，外边的方法（图中test方法）都会执行一边</li>\n<li>哪里调用就返回给哪里</li>\n</ol>\n<h3 id=\"阶乘（factorial）\"><a href=\"#阶乘（factorial）\" class=\"headerlink\" title=\"阶乘（factorial）\"></a>阶乘（factorial）</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310203253490.png\" alt=\"image-20220310203253490\"></p>\n<h3 id=\"递归调用的规则\"><a href=\"#递归调用的规则\" class=\"headerlink\" title=\"递归调用的规则\"></a>递归调用的规则</h3><ol>\n<li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li>\n<li>方法的局部变量是独立的，不会相互影响，比如n变量</li>\n<li>如果方法中使用的是引用类型变量（比如数组，或者对象），就会共享该引用类型的数据。</li>\n<li>递归必须像退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:)</li>\n<li>当一个方法执行完毕，或者遇到return，就会执行完毕或者返回时，该方法也就执行</li>\n</ol>\n<h3 id=\"斐波拉契数练习\"><a href=\"#斐波拉契数练习\" class=\"headerlink\" title=\"斐波拉契数练习\"></a>斐波拉契数练习</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> basics;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">exerciseRecursion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">T</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">T</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> t.racursionNum(<span class=\"number\">4</span>);</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">racursionNum</span><span class=\"params\">(<span class=\"type\">int</span> n1)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n1 == <span class=\"number\">1</span> || n1 == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> racursionNum(n1 - <span class=\"number\">1</span>) + racursionNum(n1 - <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解析图</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220310225335626.png\" alt=\"image-20220310225335626\"></p>\n<h2 id=\"重载（overload）\"><a href=\"#重载（overload）\" class=\"headerlink\" title=\"重载（overload）\"></a>重载（overload）</h2><p>介绍：java允许同一个类中，多个同名方法的存在，但要求形参列表不一致！！！</p>\n<p>好处：</p>\n<ol>\n<li>减轻了起名的麻烦</li>\n<li>减轻了记名的麻烦</li>\n</ol>\n<p>注意细节：</p>\n<ol>\n<li>方法名：必须相同</li>\n<li>形参参列表：必须不同（参数类型或个数或顺序，至少有一样不同）</li>\n<li>返回类型：无要求</li>\n</ol>\n<h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><p>介绍：</p>\n<p>java允许将同一类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p>\n<p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">访问修饰符\t 返回类型\t方法名（数据类型 .... 参数名）&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">hasMestod</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    public int sum(int a,int b)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return a+b;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    public int sum(int a,int b,int c)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return a+b+c;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    public int sum(int a,int b,int c,int d)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        return a+b+c+d;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    ........以此类推</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    可变参数优化</span></span><br><span class=\"line\"><span class=\"comment\">//    上面三个方法名称相同，功能相同，只是参数个数不同----&gt;使用可变参数优化</span></span><br><span class=\"line\"><span class=\"comment\">//    1.int...表示接收的是可变参数，类型时int，即可以接收多个int（0-多）</span></span><br><span class=\"line\"><span class=\"comment\">//    2.使用可变参数时，可以当做数组；来使用，即nums 可以当做数组使用</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"type\">int</span> <span class=\"title function_\">sum1</span><span class=\"params\">(<span class=\"type\">int</span>... nums)</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;接收的个数为&quot;</span>+nums.length);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class=\"line\">            sum=sum+nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意事项：</p>\n<ol>\n<li><p>可变参数的实参可以为0或任意多个</p>\n</li>\n<li><p>可变参数的实参可以为数组</p>\n</li>\n<li><p>可变参数的本质就是数组</p>\n</li>\n<li><p>可变参数可以和普通类型的参数<u><em>一起放在形参列表</em></u>，但必须保证可变参数在最后</p>\n</li>\n<li><p>一个形参列表中只能出现一个可变参数</p>\n</li>\n</ol>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><ol>\n<li>在java中，主要的变量就是属性（成员变量）和局部变量</li>\n<li>我们说的局部变量一般是指在成员方法中定义的变量</li>\n<li>作用域的分类<ol>\n<li>全局变量：也就是属性，作用域为整个整体</li>\n<li>局部变量：也就是除了属性以外的其他变量，作用域为定义它的代码块中</li>\n</ol>\n</li>\n<li>全局变量可以不赋值，直接使用，因为有默认值（也可指定值），局部变量必须赋值后，才能使用，因为没有默认值。    、</li>\n</ol>\n<p>注意事项和细节</p>\n<ol>\n<li>属性和局部变量可以重名，访问时遵循就近原则</li>\n<li>在一个作用域中，比如在同一个成员方法中，两个局部变量，不能重</li>\n<li>属性生命周期较长，伴随对象的创建而创建，伴随对象的死亡而死亡。局部变量，生命周期较短，伴随它的代码块的执行而创建，伴随代码块的结束而死亡</li>\n<li>作用域范围不同：<ol>\n<li>全集变量&#x2F;属性：可以被本类使用，或其他类使用（通过对象调用）</li>\n<li>局部变量：智能在本类中对应的方法中使用</li>\n</ol>\n</li>\n<li>修饰符不同<ol>\n<li>全局变量&#x2F;属性可以加修饰符</li>\n<li>局部变量不可以加修饰符</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"构造器-constructor\"><a href=\"#构造器-constructor\" class=\"headerlink\" title=\"构造器(constructor)\"></a>构造器(constructor)</h2><p>基本介绍：构造方法又称构造器(constructor)，是类的一种特殊方法，它的主要作用是完成对<span style = \"color:red\">新的对象初始化。</span></p>\n<p>特点：</p>\n<ol>\n<li>方法和类名相同</li>\n<li>没有返回值</li>\n<li>在创建对象时，系统会自动调用该类的构造器完成对对象的初始化</li>\n</ol>\n<p>需求案例：</p>\n<p>案例1:创建一个人类的对象，显示把一个对象创建好后，再给他的年龄姓名等属性赋值，如果现在我要求，在创建人类对象的时候，就直接指定这个对象的年龄和姓名。 此时可以使用构造器</p>\n<p>基本语法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[修饰符] 方法名(形参列)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t方法体;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>构造器的修饰符可以默认，也可是public，protected，private</li>\n<li>构造器没有返回值,也不能写void</li>\n<li>方法名和类名必须一样</li>\n<li>参数列表和成员方法一样的规则</li>\n<li>构造器的调用<span style = \"color:red\">系统完成</span></li>\n</ol>\n<p>细节：</p>\n<ol>\n<li>一个类可以定义多个不同的构造器，即构造器的重载<ul>\n<li>比如：我们可以再给Person类定义一个构造器，用来创建对象的时候，只指定人名，不需要指定年龄</li>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314163037454.png\" alt=\"image-20220314163037454\"></li>\n</ul>\n</li>\n<li>构造器是完成对象的初始化，并不是创建对象</li>\n<li>如果程序员没有定义构造器，系统会自动生成一个默认的无参构造器(也叫默认构造方法),比如Person(){ }</li>\n<li>一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的午餐构造器，除非显示的定义一下，即自己再手写一边Person(){ }</li>\n</ol>\n<p>对象创建流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span><span class=\"number\">90</span>;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tPerson(String n , <span class=\"type\">int</span> a)&#123;</span><br><span class=\"line\">\tname = n;</span><br><span class=\"line\">\tage = a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Person</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;zhangsan&quot;</span> , <span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314215432778.png\" alt=\"image-20220314215432778\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 先在方法区加载Person类</span><br><span class=\"line\">2. 在堆中开辟一个空间，内部存放形参</span><br><span class=\"line\">   1. 先初始化默认值，0和null，然后再将值赋进去</span><br><span class=\"line\">   2. 当执行到构造器的时候，值才会赋进去</span><br><span class=\"line\">   3. 引用类型的话，会将数据存放在常量池，在堆中放入地址。此时堆中的空间才会有赋值</span><br><span class=\"line\">3. 最后再把堆的地址，赋给栈中的p对象引用 (xxx p = new  xxx;)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>加载Person.class，只会加载一次。</p>\n</li>\n<li><p>在堆中分配空间(地址)</p>\n</li>\n<li><p>完成对象初始化</p>\n<p>3.1 默认初始化 age&#x3D;0\tname &#x3D; null\t</p>\n<p>3.2 显示初始化 age&#x3D;90,name&#x3D;null,</p>\n<p>3.3 构造器的初始化 age&#x3D;20，name&#x3D;zhangsan</p>\n</li>\n<li><p>在对象堆中的地址，返回给p(也可理解成对象的引用)</p>\n</li>\n</ol>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\t<span class=\"type\">int</span> age;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t旧方法：</span></span><br><span class=\"line\"><span class=\"comment\">\t\tint age =90;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tString name;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tPerson(String n , int a)&#123; //此时形参的起名不能与属性名一致</span></span><br><span class=\"line\"><span class=\"comment\">\t\tname = n;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tage = a;</span></span><br><span class=\"line\"><span class=\"comment\">     1.如果可以将构造器的形参，直接写成属性名就好了</span></span><br><span class=\"line\"><span class=\"comment\">     2.但是会出现一个问题，根据变量的作用域原则</span></span><br><span class=\"line\"><span class=\"comment\">     3.构造器的name 是局部变量，而不是属性。相当于自己赋给自己</span></span><br><span class=\"line\"><span class=\"comment\">     4.构造器的age 是局部变量，而不是属性、</span></span><br><span class=\"line\"><span class=\"comment\">     5.==&gt;此时使用this关键字\t</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name,<span class=\"type\">int</span> age)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name<span class=\"comment\">/*表示当前对象的属性*/</span> = name;<span class=\"comment\">/*表示当前构造器的局部变量*/</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>介绍：</p>\n<p>java虚拟机会给每个对象分配this，代表当前对象。</p>\n<p>分析图：</p>\n<p>每一个对象都有一个隐藏的属性this</p>\n<p>这个this它指向自己</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220314222909415.png\" alt=\"image-20220314222909415\"></p>\n<p>简单说，哪个对象调用this就指向哪个对象</p>\n<p>注意事项：</p>\n<ol>\n<li><p>this关键字可以用来访问本类的属性，方法，构造器</p>\n</li>\n<li><p>this用于区分当前类的属性和局部变量</p>\n</li>\n<li><p>访问成员方法的语法：this.方法名(参数列表)；</p>\n</li>\n<li><p>访问构造器语法：this(参数列表);&#x2F;&#x2F;注意，只能在构造器中访问另外一个构造器(当有访问构造器的语法this时，必须放在构造器语句里的第一行 )</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>class T{<br>String name;<br>int age;<br>&#x2F;&#x2F;无参构造器<br>public T(){<br>    &#x2F;&#x2F;当执行无参构造器时，我们想去访问有参构造器<br>    this(“zhangsan”,12);&#x2F;&#x2F;这样访问有参构造器<br>   &#x2F;&#x2F;当有访问构造器的语法this时，必须放在构造器语句里的第一行<br><br>    System.out.println(“T() 构造器”);<br><br><br><br>}<br><br>&#x2F;&#x2F;有参构造器<br>public T(String name,int age){<br>    System.out.println(“T(String name,int age) 构造器”);<br>}<br>}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. this不能再类定义的外部使用，只能在类定义的范围中使用</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">package chapterObject;</span><br><span class=\"line\">/*</span><br><span class=\"line\">* 创建一个employee类</span><br><span class=\"line\">* 属性有（名字，性别，年龄，职位，薪水）</span><br><span class=\"line\">* 提供三个构造器</span><br><span class=\"line\">* 1.名字，性别，年龄，职位，薪水</span><br><span class=\"line\">* 2.名字，性别，年龄</span><br><span class=\"line\">* 3.职位，薪水*/</span><br><span class=\"line\">public class ObjectHomeWork06 &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Employee&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    char sex;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    String post;</span><br><span class=\"line\">    double salary;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Employee(String name,char sex,int age)&#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Employee(String post,double salary)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        this.post = post;</span><br><span class=\"line\">        this.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Employee(String name,char sex,int age,String post,double salary)&#123;</span><br><span class=\"line\">        this(name, sex, age);</span><br><span class=\"line\">//        因为构造器调用只能放在第一行，所以最多只能调用一个构造器</span><br><span class=\"line\">        this.post = post;</span><br><span class=\"line\">        this.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//    public Employee(String name,char sex,int age,String post,double salary)&#123;</span><br><span class=\"line\">//        this.name = name;</span><br><span class=\"line\">//        this.sex = sex;</span><br><span class=\"line\">//        this.age = age;</span><br><span class=\"line\">//        this.post = post;</span><br><span class=\"line\">//        this.salary = salary;</span><br><span class=\"line\">//</span><br><span class=\"line\">//    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h1 id=\"面向对象（中级）\"><a href=\"#面向对象（中级）\" class=\"headerlink\" title=\"面向对象（中级）\"></a>面向对象（中级）</h1><h2 id=\"idea\"><a href=\"#idea\" class=\"headerlink\" title=\"idea\"></a>idea</h2><h3 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自定义快捷键</span><br><span class=\"line\">settings - - &gt; Keymap</span><br><span class=\"line\">删除当前行 ctrl+y  自定义 alt+D</span><br><span class=\"line\">复制当前行 ctrl+d</span><br><span class=\"line\"></span><br><span class=\"line\">快速格式化代码 ctrl + alt + L</span><br><span class=\"line\">快速运行程序  自定义alt + R</span><br><span class=\"line\"></span><br><span class=\"line\">查看类的层级关系 ctrl + H</span><br><span class=\"line\">将光标放在一个方法上，输入ctrl+b，可以定位到该方法的上</span><br><span class=\"line\">自动分配变量名   在后面添加.var</span><br><span class=\"line\">例：new Scanner(System.in).var+回车</span><br><span class=\"line\">会生成Scanner scanner = new Scanner(System.in);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><p> 设置路径</p>\n<p>file -&gt; settings -&gt; editor -&gt; live templates-&gt;</p>\n<p>可以自己自定义，也可查看预设的模板</p>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>三大作用：</p>\n<ol>\n<li>区分相同名字的类</li>\n<li>当类不同的时候，可以很好的管理</li>\n<li>控制访问范围</li>\n</ol>\n<p>基本语法：</p>\n<p>package com.xxx;</p>\n<ol>\n<li>package 关键字，表示打包</li>\n<li>com.xxx:表示包名</li>\n</ol>\n<p>包的本质</p>\n<p>就是创建不同的文件&#x2F;目录保存文件</p>\n<h3 id=\"包的命名\"><a href=\"#包的命名\" class=\"headerlink\" title=\"包的命名\"></a>包的命名</h3><p>规则：</p>\n<p>智能包含数字，字母，下划线，小圆点，但不能用数字开头，不能是关键字或保留字</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demo.class.exec1 <span class=\"comment\">//falsee不允许有关键字class</span></span><br><span class=\"line\">demo<span class=\"number\">.12</span>\t\t<span class=\"comment\">//false,不能数字开头</span></span><br><span class=\"line\">demo.ad12.oa <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>规范</p>\n<p>一般是小写字母+小圆点</p>\n<p>com.公司名.项目名.业务模块名</p>\n<p>例：com.alibaba.taobao.login</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.sina.crm.user</span><br><span class=\"line\">等等</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"java常用的包\"><a href=\"#java常用的包\" class=\"headerlink\" title=\"java常用的包\"></a>java常用的包</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang <span class=\"comment\">// lang包是基础包，默认引入，不用手动输入</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.util <span class=\"comment\">//系统提供的工具包，工具类，例如Scanner类</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.net <span class=\"comment\">// 网络包，网络开发</span></span><br><span class=\"line\"></span><br><span class=\"line\">java.awt  <span class=\"comment\">// 是做java的界面开发，GUI</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>包的引入</p>\n<p>建议需要什么类就引入什么类，不建议(java.util.* )全部引入</p>\n<h2 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h2><p>介绍</p>\n<p>java提供了四种访问控制修饰符号控制方法和属性(成员变量)的访问权限(范围)</p>\n<ol>\n<li>公开级别：public 修饰，对外公开</li>\n<li>受保护级别：用protected修饰，对子类和统一包中的类公开</li>\n<li>默认级别：没有修饰符号，向同一包的内公开</li>\n<li>私有级别：用private修饰，只有类本身可以访问，不对外公开</li>\n</ol>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220317140746725.png\" alt=\"image-20220317140746725\"></p>\n<p>注意事项：</p>\n<ol>\n<li>修饰符可以用修饰类中的属性，成员方法以及类</li>\n<li>只有默认的和public才能修饰类，并且遵循上述访问权限的特点</li>\n<li>成员方法访问规则和属性完全一样</li>\n</ol>\n<h2 id=\"封装（重要）\"><a href=\"#封装（重要）\" class=\"headerlink\" title=\"封装（重要）\"></a><u><em>封装</em></u>（重要）</h2><p>封装（encapsulation）就是把抽象出来的数据[<strong>属性</strong>]和对数据的操作[<strong>方法</strong>]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[<strong>方法</strong>]，才能对数据进行操作。</p>\n<p><strong>封装的好处</strong></p>\n<ol>\n<li>隐藏实现细节  方法(连接数据库)&lt;—-调用(传入参数)</li>\n<li>可对数据进行验证，保证安全合理</li>\n</ol>\n<p>封装的实现步骤 ( 三 步 ) </p>\n<ol>\n<li><p>将属性进行私有化，private</p>\n</li>\n<li><p>提供一个公共的set方法，对属性进行判断并赋值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setXXX</span><span class=\"params\">(类型\t参数名)</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//加入数据验证的业务逻辑</span></span><br><span class=\"line\">属性 = 参数名；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提供一个公共的get方法，用于获取属性的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getXXX</span><span class=\"params\">(类型\t参数名)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> xx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"继承（重要）extends\"><a href=\"#继承（重要）extends\" class=\"headerlink\" title=\"继承（重要）extends\"></a><u><em>继承</em></u>（重要）extends</h2><h3 id=\"继承作用：\"><a href=\"#继承作用：\" class=\"headerlink\" title=\"继承作用：\"></a>继承作用：</h3><p>解决代码复用性</p>\n<h3 id=\"介绍：\"><a href=\"#介绍：\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>相当多个类存在相同的属性（变量）  和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有子类不需要重新定义这些属性和方法，只需通过extend来声明继承父类即可</p>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class 子类 extends 父类&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1.</span> 子类会自动拥有父类定义的方法</span><br><span class=\"line\"><span class=\"number\">2.</span> 父类又叫超类，基类</span><br><span class=\"line\"><span class=\"number\">3.</span> 子类又叫派生类</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>示意图</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318104942566.png\" alt=\"image-20220318104942566\"></p>\n<h3 id=\"注意事项-3\"><a href=\"#注意事项-3\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li><p>子类继承了所有的属性和方法，但是私有属性不能再子类直接访问，需要通过公共方法访问</p>\n</li>\n<li><p>子类必须调用父类的构造器，完成父类的初始化</p>\n</li>\n<li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中调用super去指定使用父类的那个构造器完成对父类的初始化工作，否则编译不通过</p>\n</li>\n<li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下{super ( 参数 ) }</p>\n</li>\n<li><p>super在使用时，需要放在第一行。super只能在构造器中使用</p>\n</li>\n<li><p>super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器</p>\n</li>\n<li><p>java所有类都是Object的子类，是所有类的基类   Ctrl+H可以看到类的继承关系</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220318165601997.png\" alt=\"image-20220318165601997\"></p>\n</li>\n<li><p>父类构造器的调用不限于直接父类！将一直往上追溯直到Object类(顶级父类)</p>\n</li>\n<li><p>子类对多只能继承一个父类(指直接传承)，即java中是单继承机制。</p>\n</li>\n<li><p>不能滥用继承，子类和父类之间必须满足is-a的逻辑关系</p>\n<ol>\n<li>person is a music</li>\n<li>person music</li>\n<li>music extends  person</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"继承的本质（分析）\"><a href=\"#继承的本质（分析）\" class=\"headerlink\" title=\"继承的本质（分析）\"></a>继承的本质（分析）</h3><p>当子类创建号对象以后，建立查找关系</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//案例：</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Grandpa</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;爷爷&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">hobby</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;旅游&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">GrandPa</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;大头爸爸&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> <span class=\"number\">30</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"keyword\">class</span> <span class=\"title class_\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Father</span>&#123;</span><br><span class=\"line\"> \t<span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;儿子&quot;</span>;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"type\">Son</span> <span class=\"variable\">son</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>();</span><br><span class=\"line\"> son.name=?      <span class=\"comment\">//儿子</span></span><br><span class=\"line\"> son.age = ?\t <span class=\"comment\">//30\t</span></span><br><span class=\"line\"> son.hobby = ?\t <span class=\"comment\">// 旅游</span></span><br><span class=\"line\"> <span class=\"comment\">//\t\t1. 此时请注意，要按照查找关系返回信息</span></span><br><span class=\"line\"> <span class=\"comment\">/*     2. 首先看子类是否有该属性</span></span><br><span class=\"line\"><span class=\"comment\"> \t\t3. 如果子类有这个属性，并且可以访问，则返回信息</span></span><br><span class=\"line\"><span class=\"comment\"> \t\t4. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回)</span></span><br><span class=\"line\"><span class=\"comment\"> \t\t5. 如果父类没有4的规则，继续找上级，直到object</span></span><br><span class=\"line\"><span class=\"comment\">   */</span>  </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内存原理图：\"><a href=\"#内存原理图：\" class=\"headerlink\" title=\"内存原理图：\"></a>内存原理图：</h3><p> <img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320170828664.png\" alt=\"image-20220320170828664\"></p>\n<h2 id=\"Super\"><a href=\"#Super\" class=\"headerlink\" title=\"Super\"></a>Super</h2><h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>super代表父类的构造器，用于访问父类的属性，方法，构造器</p>\n<h3 id=\"基本语法-1\"><a href=\"#基本语法-1\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><ol>\n<li>访问父类的属性，但不能访问父类的private属性[案例]<ul>\n<li>super.属性名；</li>\n</ul>\n</li>\n<li>访问父类的方法名，不能访问父类的private方法<ul>\n<li>super.方法名(参数列表);</li>\n</ul>\n</li>\n<li>访问父类的构造器(这点前面用过);<ul>\n<li>super(参数列表);</li>\n<li>只能放在构造器的第一句并只能出现一句</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"细节和注意事项\"><a href=\"#细节和注意事项\" class=\"headerlink\" title=\"细节和注意事项\"></a>细节和注意事项</h3><ol>\n<li><p>调用父类的构造器的好处（分工明确，弗雷属性由父类初始化，子类的属性由子类初始化）</p>\n</li>\n<li><p>当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>案例<br>class A{<br>public void cal(){<br>    System.out.println(“a类的cal方法”);<br>}<br>}<br>class B{<br>public void sum(){<br>    System.out.println(“b类的sum方法”);<br>&#x2F;*\t<br>    此时有三种方法调用cal<br>    1. 找cal方法时，顺序是：先找本类，如果有，开始调用。<br>    2. 如果没有。则找父类（如果有则调用）<br>    3. 如果父类没有则继续找父类的父类。以此类推。直到Object类‘<br><br>    提示：如果查找的过程中找到了，但不能访问，则报错<br>         如果查找的过程中没找到。则提示没找到<br><em>&#x2F;<br>    cal();<br><br><br>    this.cal();&#x2F;&#x2F;等价cal（）；<br><br>     &#x2F;</em><br>    跳过本类直接查找父类<br>    其他规则一样<br>    *&#x2F;<br>    super.cal();<br><br>}<br>}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。（相当于跳过本类，从父类开始按规则找。父类找不到找爷爷类·····）</span><br><span class=\"line\"></span><br><span class=\"line\">### super和this的比较</span><br><span class=\"line\"></span><br><span class=\"line\">![image-20220320190806497](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190806497.png)</span><br><span class=\"line\"></span><br><span class=\"line\">![image-20220320190935663](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320190935663.png)</span><br><span class=\"line\"></span><br><span class=\"line\">## 重写（overwrite）</span><br><span class=\"line\"></span><br><span class=\"line\">### 基本介绍</span><br><span class=\"line\"></span><br><span class=\"line\">简单地说：方法覆盖(重写)就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这方法覆盖了父类的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">### 案例</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">\tpublic void cry()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;叫&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*</span><br><span class=\"line\">\t1. 因为dog是Animal的子类</span><br><span class=\"line\">    2. Dog的cry方法和Animal的cry方法定义形式一样(名称，返回类型，参数)</span><br><span class=\"line\">    3. 这时我们就说Dog的cry方法，重写了Animal的cry方法</span><br><span class=\"line\">  */      </span><br><span class=\"line\">class dog extends Animal&#123;</span><br><span class=\"line\">\tpublic void cry()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;汪汪汪&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"注意事项和使用细节\"><a href=\"#注意事项和使用细节\" class=\"headerlink\" title=\"注意事项和使用细节\"></a>注意事项和使用细节</h3><ol>\n<li><p>子类的方法的形参列表，方法名称，要和父类的方法的参数，方法名称完全一样。</p>\n</li>\n<li><p>子类方法的返回类型和父类方法返回类型一样，或者父类返回类型的子类</p>\n<p>比如 父类返回类型是Object，子类方法返回类型是String</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">getInfo</span><span class=\"params\">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">getInfo</span><span class=\"params\">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>子类方法不能缩小父类方法的访问权限public &gt; protected &gt; 默认(default ) &gt; private </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">sayOk</span><span class=\"params\">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayOk</span><span class=\"params\">()</span>&#123;&#125;<span class=\"comment\">//这样是可以的，但不能缩小</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"重写与重载的区别\"><a href=\"#重写与重载的区别\" class=\"headerlink\" title=\"重写与重载的区别\"></a>重写与重载的区别</h3><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320211941817.png\" alt=\"image-20220320211941817\"></p>\n<p>练习</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> seatWork;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">override</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    * 1. 编写一个Person类，包括属性/private（name,age），</span></span><br><span class=\"line\"><span class=\"comment\">    * 构造器，方法say（返回组我介绍的字符串）</span></span><br><span class=\"line\"><span class=\"comment\">    * 2. 编写一个student类，继承Person类，增加id，score属性/private，</span></span><br><span class=\"line\"><span class=\"comment\">    * 以及构造器，定义say方法（返回自我介绍信息）</span></span><br><span class=\"line\"><span class=\"comment\">    * 3. 在main方法中，分别创建Person和Student对象，调用say方法输出自我介绍*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&quot;lisi&quot;</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">say1</span> <span class=\"operator\">=</span> person.say();</span><br><span class=\"line\">        System.out.println(say1);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">student</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">12</span>,<span class=\"number\">12345</span>,<span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">say</span> <span class=\"operator\">=</span> student.say();</span><br><span class=\"line\">        System.out.println(say);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name, <span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;我是父类&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(&quot;name&quot;+getName()+&quot;\\t&quot;+&quot;age&quot;+getAge()+&quot;\\t&quot;);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;name&quot;</span>+getName()+<span class=\"string\">&quot;\\t&quot;</span>+<span class=\"string\">&quot;age&quot;</span>+getAge()+<span class=\"string\">&quot;\\t&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">double</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Student</span><span class=\"params\">(String name, <span class=\"type\">int</span> age, <span class=\"type\">int</span> id, <span class=\"type\">double</span> score)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setId</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.id = id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getScore</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setScore</span><span class=\"params\">(<span class=\"type\">double</span> score)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.say()+<span class=\"string\">&quot;id&quot;</span>+getId()+<span class=\"string\">&quot;\\t&quot;</span>+<span class=\"string\">&quot;score&quot;</span>+getScore()+<span class=\"string\">&quot;\\t&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(&quot;name&quot;+getName()+&quot;\\t&quot;+&quot;age&quot;+getAge()+&quot;\\t&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//        +&quot;id&quot;+getId()+&quot;\\t&quot;+&quot;score&quot;+getScore()+&quot;\\t&quot;);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多态（重要）\"><a href=\"#多态（重要）\" class=\"headerlink\" title=\"多态（重要）\"></a><u><em>多态</em></u>（重要）</h2><p> 多态可以提高代码的复用性</p>\n<h3 id=\"基本介绍-1\"><a href=\"#基本介绍-1\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>多态(多种)（状态）</p>\n<ol>\n<li>方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承的基础之上的额</li>\n</ol>\n<h3 id=\"多态的具体体现\"><a href=\"#多态的具体体现\" class=\"headerlink\" title=\"多态的具体体现\"></a>多态的具体体现</h3><h4 id=\"方法上体现\"><a href=\"#方法上体现\" class=\"headerlink\" title=\"方法上体现\"></a>方法上体现</h4><ol>\n<li><p>方法的多态</p>\n<p>重写和重载就体现多态</p>\n</li>\n<li><p>案例说明</p>\n</li>\n<li><p>重载上体现</p>\n<ol>\n<li>对某一方法，传入不同的参数，调用不同的方法</li>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220320215939959.png\" alt=\"image-20220320215939959\"></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"对象的多态（核心，难点，重点）\"><a href=\"#对象的多态（核心，难点，重点）\" class=\"headerlink\" title=\"对象的多态（核心，难点，重点）\"></a>对象的多态（核心，难点，重点）</h3><p>要记住几点：</p>\n<ol>\n<li><p>一个对象的编译类型和运行类型可以不一致</p>\n<ul>\n<li>&#96;&#96;&#96;<br>例如：<br>Animal animal &#x3D; new Dog();【animal编译类型时Animal，运行类型是Dog】<br>animal  &#x3D; new Cat(); \t【animal的运行类型变成了Cat，编译类型仍然是Animal】<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 编译类型在定义对象时，就确定了，不能改变</span><br><span class=\"line\"></span><br><span class=\"line\">   * ```</span><br><span class=\"line\">     Animal animal = new Dog()   编译类型在定以后就不能改变，所以可以直接用引用接收其他的运行类型</span><br><span class=\"line\">     animal  = new Cat();</span><br><span class=\"line\">     animal  = new PIG();`````</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>运行类型是可以变化的</p>\n</li>\n<li><p>编译类型看定义时 &#x3D; 号的左边，运行类型看 &#x3D; 号的右边</p>\n<ul>\n<li>&#96;&#96;&#96;<br>Animal animal &#x3D; new Dog()  animal就是变异类型，dog就是运行类型<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">//编译类型和运行类型的体现</span><br><span class=\"line\">class Animal&#123;</span><br><span class=\"line\">\tpublic void say()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;动物在叫&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Cat extends Animal&#123;</span><br><span class=\"line\">\tpublic void say()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;猫在叫&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Dog extends Animal&#123;</span><br><span class=\"line\">\tpublic void say()&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;狗在叫&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class test&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\t//animal编译类型就是Animal，运行类型Dog</span><br><span class=\"line\">\t\tAnimal animal = new Dog();</span><br><span class=\"line\">\t\tanimal.say();//因为运行类型是dog，animal的运行类型是dog，所以输出dog类的say方法。</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        animal = new Cat();</span><br><span class=\"line\">        animal.say();//此时animal的运行类型是cat，所以输出cat类的say方法；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"注意事项和细节-1\"><a href=\"#注意事项和细节-1\" class=\"headerlink\" title=\"注意事项和细节\"></a>注意事项和细节</h3><p>多态的前提是：两个对象(类)存在继承关系</p>\n<h4 id=\"多态的向上转型\"><a href=\"#多态的向上转型\" class=\"headerlink\" title=\"多态的向上转型\"></a>多态的向上转型</h4><ol>\n<li><p>本质：父类的引用指向了子类的对象</p>\n</li>\n<li><p>语法：父类类型    引用名 &#x3D; new    子类类型()；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Father</span> <span class=\"variable\">father</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Son</span>();</span><br><span class=\"line\"><span class=\"comment\">//此时可称为向上转型</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特点：编译类型看左边，运行类型看右边</p>\n<p><span style=\"color:red;\">可以调用父类中的所有成员(需要遵循访问权限),</span></p>\n<p><span style=\"color:red;\">不能调用子类中特有成员</span></p>\n<p>（<span style=\"color:red;\">因为在编译阶段，不能调用那些成员，是由编译类型来决定的。</span>）</p>\n<p>最终运行效果按子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法</p>\n<p>然后调用，与前面的方法调用规则一致</p>\n</li>\n</ol>\n<h4 id=\"多态的向下转型\"><a href=\"#多态的向下转型\" class=\"headerlink\" title=\"多态的向下转型\"></a>多态的向下转型</h4><p>语法：子类类型   引用名 &#x3D; (子类类型) 父类引用;</p>\n<ol>\n<li><p>只能强转父类的引用，不能强转父类的对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//此时的向上转型</span></span><br><span class=\"line\"><span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">adimal.a();</span><br><span class=\"line\"><span class=\"comment\">//等等方法，这些方法只能调用父类子类的共同拥有的方法，不能调用子类的特殊方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//此时这样写</span></span><br><span class=\"line\"><span class=\"comment\">//强转一下，上述父类的引用</span></span><br><span class=\"line\"><span class=\"type\">Cat</span> <span class=\"variable\">cat</span> <span class=\"operator\">=</span>  (Cat)animal；</span><br><span class=\"line\">    cat.catchMouse();</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>要求父类的引用必须指向的是当前目标类型的对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//也就是说animal必须是指向对应的子类</span></span><br><span class=\"line\"><span class=\"type\">Animal</span> <span class=\"variable\">animal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();<span class=\"comment\">//必须有这句话</span></span><br><span class=\"line\"><span class=\"type\">Cat</span> <span class=\"variable\">cat</span> <span class=\"operator\">=</span>  (Cat)animal；<span class=\"comment\">//才能强转成cat类型</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>可以调用子类类型中所有的成员</p>\n</li>\n</ol>\n<h4 id=\"属性没有重写之说\"><a href=\"#属性没有重写之说\" class=\"headerlink\" title=\"属性没有重写之说\"></a>属性没有重写之说</h4><p>属性的值看编译类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例:</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] atgs)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">A</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">B</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span>.out.print(a.count);</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">//此时输入的值为1</span></span><br><span class=\"line\">        <span class=\"comment\">//因为属性的值是看编译类型</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"type\">B</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">B</span>();</span><br><span class=\"line\">        <span class=\"keyword\">public</span>.out.print(a.count);</span><br><span class=\"line\">        <span class=\"comment\">//此时输出2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"instanceOf比较操作符，\"><a href=\"#instanceOf比较操作符，\" class=\"headerlink\" title=\"instanceOf比较操作符，\"></a>instanceOf比较操作符，</h4><p>用于判断对象的类型是否为xx类型或xx类型的子类型</p>\n<p>判断对象的运行类型是否为xx类型，或这个xx类型的子类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t count = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">test</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] atgs)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">BB</span> <span class=\"variable\">bb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BB</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">public</span>.out.print(bb <span class=\"keyword\">instanceof</span> BB);<span class=\"comment\">//true</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span>.out.print(bb <span class=\"keyword\">instanceof</span> AA);<span class=\"comment\">//true</span></span><br><span class=\"line\">       </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//编译类型AA ，运行类型BB</span></span><br><span class=\"line\">     <span class=\"type\">AA</span> <span class=\"variable\">aa</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AA</span>();</span><br><span class=\"line\">        <span class=\"keyword\">public</span>.out.print(aa <span class=\"keyword\">instanceof</span> AA);<span class=\"comment\">//true</span></span><br><span class=\"line\">       <span class=\"keyword\">public</span>.out.print(aa <span class=\"keyword\">instanceof</span> BB);<span class=\"comment\">//true </span></span><br><span class=\"line\">        \t</span><br><span class=\"line\">     <span class=\"type\">Object</span> <span class=\"variable\">obj</span>   <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">public</span>.out.print(obj <span class=\"keyword\">instanceof</span> AA);<span class=\"comment\">//false,因为obj不是AA类，也不是AA的子类</span></span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;&#125;\t</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"java动态绑定机制-重要\"><a href=\"#java动态绑定机制-重要\" class=\"headerlink\" title=\"java动态绑定机制(重要)\"></a>java动态绑定机制(重要)</h4><ol>\n<li>当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</li>\n<li>当调用对象属性时，没有动态绑定机制，哪里声明，那里使用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//2</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sum</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//3  </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> geti()+<span class=\"number\">10</span>;<span class=\"comment\">//5</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sum1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i+<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">geti</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sum1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i+<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//4</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">geti</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">A</span> <span class=\"variable\">a</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">B</span>()</span><br><span class=\"line\">   <span class=\"comment\">//1</span></span><br><span class=\"line\">a.sum <span class=\"comment\">//40</span></span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">//因为执行到sum方法，开始准备执行geti方法时，因为有java动态绑定的机制，会跳到b类的geti方法执行</span></span><br><span class=\"line\">    <span class=\"comment\">//再根据继承跳回去</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"多态的应用\"><a href=\"#多态的应用\" class=\"headerlink\" title=\"多态的应用\"></a>多态的应用</h4><p>1）多态数组</p>\n<p>数组的定义类型为父类类型，里面保存的实际元素类型为子类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> seatWork;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.PrivateKey;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">polySeatwork</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 要求创建一个person对象name ，age</span></span><br><span class=\"line\"><span class=\"comment\">        * 两个student 对象和2个teacher对象，统一放在数组中，</span></span><br><span class=\"line\"><span class=\"comment\">        * 并调用每个对象的say方法</span></span><br><span class=\"line\"><span class=\"comment\">        * */</span></span><br><span class=\"line\">        Person1[] person1s = <span class=\"keyword\">new</span> <span class=\"title class_\">Person1</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\">        person1s[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Person1</span>(<span class=\"string\">&quot;human&quot;</span>,<span class=\"number\">00</span>);</span><br><span class=\"line\">        person1s[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Student1</span>(<span class=\"string\">&quot;tom1&quot;</span>,<span class=\"number\">12</span>,<span class=\"number\">150</span>);</span><br><span class=\"line\">        person1s[<span class=\"number\">2</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">Student1</span>(<span class=\"string\">&quot;tom2&quot;</span>,<span class=\"number\">13</span>,<span class=\"number\">143</span>);</span><br><span class=\"line\">        person1s[<span class=\"number\">3</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">teacher</span>(<span class=\"string\">&quot;zhangsan&quot;</span>,<span class=\"number\">30</span>,<span class=\"number\">4000</span>);</span><br><span class=\"line\">        person1s[<span class=\"number\">4</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">teacher</span>(<span class=\"string\">&quot;lisi&quot;</span>,<span class=\"number\">28</span>,<span class=\"number\">5000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//循环遍历多态数组，调用say方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; person1s.length ; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//老韩提示， person1s[i]的编译类型是Person，</span></span><br><span class=\"line\">            <span class=\"comment\">// 运行类型是根据实际情况而变化</span></span><br><span class=\"line\">            System.out.println(person1s[i].say());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person1</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Person1</span><span class=\"params\">(String name, <span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;name = &quot;</span>+name+<span class=\"string\">&quot;age = &quot;</span>+age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student1</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Person1</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">double</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Student1</span><span class=\"params\">(String name, <span class=\"type\">int</span> age, <span class=\"type\">double</span> score)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getScore</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setScore</span><span class=\"params\">(<span class=\"type\">double</span> score)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">say</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.say()+<span class=\"string\">&quot;score = &quot;</span>+score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">study</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(getName()+<span class=\"string\">&quot;学习······&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">teacher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Person1</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">double</span> salary;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">teacher</span><span class=\"params\">(String name, <span class=\"type\">int</span> age, <span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, age);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">getSalary</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setSalary</span><span class=\"params\">(<span class=\"type\">double</span> salary)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">say</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.say()+<span class=\"string\">&quot;salary = &quot;</span>+salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">teach</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(getName()+<span class=\"string\">&quot;教书·············&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>案例升级：如何调用子类的特有方法，比如Teacher 有一个teach，Student有一个study方法。如何调用?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//循环遍历多态数组，调用say方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; person1s.length ; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//老韩提示， person1s[i]的编译类型是Person，</span></span><br><span class=\"line\">            <span class=\"comment\">// 运行类型是根据实际情况而变化</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//判断person1s[i]的运行类型</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( person1s[i] <span class=\"keyword\">instanceof</span> Student1)&#123;</span><br><span class=\"line\">               <span class=\"type\">Student1</span> <span class=\"variable\">student1</span> <span class=\"operator\">=</span>  (Student1)person1s[i];</span><br><span class=\"line\">               student1.say();</span><br><span class=\"line\">               <span class=\"comment\">//也可以写成一条语句</span></span><br><span class=\"line\">               ((Student1)person1s[i]).study();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (person1s[i] <span class=\"keyword\">instanceof</span> teacher)&#123;</span><br><span class=\"line\">                ((teacher)person1s[i]).teach();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;============类型有误==============&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(person1s[i].say());</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多态参数\"><a href=\"#多态参数\" class=\"headerlink\" title=\"多态参数\"></a>多态参数</h4><p>方法定义的形参类型为父类型，实参类型允许为子类类型</p>\n<ul>\n<li><p>polyParameter.java</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>package seatWork;</p>\n<p>public class polyParameter {<br>&#x2F;*<br>* 定义员工类Employee，包含姓名和月工资[private]，以及计算年工资getAnnual的方法。<br>* 普通员工和经理继承了员工，经理类多了奖金bonus属性和管理manage方法，<br>* 普通员工类多了work方法，普通员工和经理类要求分别重写getAnnual方法<br>*<br>*<br>* 测试类中添加一个方法showEmployAnnual（Employee e ),<br>* 实现获取任何员工对象的年工资，<br>* 并在main方法中调用该方法[e.getAnnual()]<br>*<br>* 测试类中添加一个方法，testWork，如果是普通员工，<br>* 则调用work方法，如果是经理，则调用manage方法<br><em>&#x2F;<br>public static void main(String[] args) {<br>    GeneralStaff staff &#x3D; new GeneralStaff(“zhangsan”, 5000);<br>    Manager manager &#x3D; new Manager(“lisi”, 5000, 10000);<br>    polyParameter polyParameter &#x3D; new polyParameter();<br>    polyParameter.showEmployAnnual(staff);<br>    polyParameter.showEmployAnnual(manager);<br><br>    polyParameter.testWork(staff);<br>    polyParameter.testWork(manager);<br><br>}<br>public void showEmployAnnual(Emplyee e){<br><br>    System.out.println(e.getAnnual());<br>}<br>&#x2F;</em><br>* 添加一个方法，testwork<br>* 如果是普通员工，则调用work方法<br>* 如果是经理则调用manage方法<br>* <em>&#x2F;<br>public void testWork(Emplyee e){<br>    if (e instanceof GeneralStaff){<br>        ((GeneralStaff) e).work();&#x2F;&#x2F;向下转型<br>    }else if (e instanceof Manager){<br>        ((Manager) e).manage();&#x2F;&#x2F;向下转型<br>    }<br>}<br>}<br>class Emplyee {<br>private String name;<br>private double salary;<br><br>public Emplyee(String name, double salary) {<br>    this.name &#x3D; name;<br>    this.salary &#x3D; salary;<br>}<br><br>public String getName() {<br>    return name;<br>}<br><br>public void setName(String name) {<br>    this.name &#x3D; name;<br>}<br><br>public double getSalary() {<br>    return salary;<br>}<br><br>public void setSalary(double salary) {<br>    this.salary &#x3D; salary;<br>}<br><br>public double getAnnual(){<br>    double tmp &#x3D; 12</em>salary;<br><br>    return tmp;<br>}<br>}</p>\n<p>class GeneralStaff extends Emplyee{</p>\n<pre><code>public GeneralStaff(String name, double salary) &#123;\n    super(name, salary);\n&#125;\n\n@Override\npublic double getAnnual() &#123;\n    return super.getAnnual();\n&#125;\n\npublic void work()&#123;\n    System.out.println(&quot;work method&quot;);\n&#125;\n</code></pre>\n<p>}<br>class Manager extends Emplyee{<br>private double bonus;<br><br>public Manager(String name, double salary,double bonus) {<br>    super(name, salary);<br>    this.bonus &#x3D; bonus;<br>}<br><br>public void manage(){<br>    System.out.println(“manage method”);<br>}<br><br>@Override<br>public double getAnnual() {<br>    return super.getAnnual()+bonus;<br>}<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## Obeject类详解</span><br><span class=\"line\"></span><br><span class=\"line\">类Object是类的层次结构的根类，每个类都使用Object作为超类，所有对象(包括数组)都实现了这个类的方法</span><br><span class=\"line\"></span><br><span class=\"line\">#### equals</span><br><span class=\"line\"></span><br><span class=\"line\">==和equals的对比</span><br><span class=\"line\"></span><br><span class=\"line\">==是一个比较运算符</span><br><span class=\"line\"></span><br><span class=\"line\">1. 既可以判断基本类型，又可以判断引用类型</span><br><span class=\"line\">2. 如果判断基本类型，判断值是否相等。例如：int i = 10; double b = 10.0;</span><br><span class=\"line\">3. 如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">equals：是Object类中的方法，只能判断引用类型，</span><br><span class=\"line\"></span><br><span class=\"line\">判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等</span><br><span class=\"line\"></span><br><span class=\"line\">案例：</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">package seatWork;</span><br><span class=\"line\"></span><br><span class=\"line\">public class equalsExercise &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Person02 person02 = new Person02(&quot;zhangsan&quot;, 123, &#x27;男&#x27;);</span><br><span class=\"line\">        Person02 person03 = new Person02(&quot;zhangsan&quot;, 123, &#x27;男&#x27;);</span><br><span class=\"line\">        //在没有重写equals方法时是不相等，此时的方法时比对是否指向同一对象</span><br><span class=\"line\">        System.out.println(person02.equals(person03));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Person02&#123;</span><br><span class=\"line\">//    判断两个Person是否相等</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\">    private int age;</span><br><span class=\"line\">    private char gender;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Person02(String name, int age, char gender) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.gender = gender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getName() &#123;</span><br><span class=\"line\">        return name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(String name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int getAge() &#123;</span><br><span class=\"line\">        return age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setAge(int age) &#123;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public char getGender() &#123;</span><br><span class=\"line\">        return gender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setGender(char gender) &#123;</span><br><span class=\"line\">        this.gender = gender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean equals(Object obj) &#123;</span><br><span class=\"line\">//        1. 先判断两个是否指向同一对象</span><br><span class=\"line\">        if (this == obj)&#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">//        2.进行类型判断</span><br><span class=\"line\">        if (obj instanceof Person02) &#123;</span><br><span class=\"line\">//            3.向下转型，得到所有的属性信息进行比对</span><br><span class=\"line\">            Person02 person02 = (Person02) obj;</span><br><span class=\"line\">            return this.name.equals(person02.name)&amp;&amp;this.age== person02.age&amp;&amp;this.gender==person02.gender;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">//        如果不是Person类型，则直接返回false</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"hashCode\"><a href=\"#hashCode\" class=\"headerlink\" title=\"hashCode\"></a>hashCode</h4><p>介绍：</p>\n<p>返回对象的哈希码值，支持此方法是为了提高哈希表的性能</p>\n<p>实际上，由object类定义的hashCode方法确定会针对不同的对象返回不同的证书，(这一般是通过将该对象的内部地址转移换成一个整数来实现的，但是java编程语言不需要这种实现技巧)</p>\n<p>老韩六小结：</p>\n<ol>\n<li><p>提高具有哈希结构容器的效率</p>\n</li>\n<li><p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</p>\n</li>\n<li><p>两个引用，如果指向的是不同的对象，则哈希值是不一样的（极大概率不一样）</p>\n</li>\n<li><p>哈希值主要根据地址号来的！，不能完全将哈希值等价于地址</p>\n</li>\n<li><p>案例演示obj.hashCode() [测试 A obj1 &#x3D; new A(); A obj2 &#x3D; new A(); A obj3 &#x3D; obj1]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> seatWork;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">hashCodeExcise</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">A</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">        <span class=\"type\">A</span> <span class=\"variable\">a1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>();</span><br><span class=\"line\">        <span class=\"type\">A</span> <span class=\"variable\">a3</span> <span class=\"operator\">=</span> a;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;a.hashCode() = &quot;</span>+a.hashCode());       System.out.println(<span class=\"string\">&quot;a1.hashCode() = &quot;</span>+a1.hashCode());       System.out.println(<span class=\"string\">&quot;a3.hashCode() = &quot;</span>+a3.hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220323164744164.png\" alt=\"image-20220323164744164\"></p>\n</li>\n<li><p>后面在集合，中hashCode如果需要的话，也会重写</p>\n</li>\n</ol>\n<h4 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h4><p>介绍：</p>\n<p>默认返回：全类名+@+哈希值的十六进制，[查看object的tostring方法]</p>\n<p>子类往往会重写toString方法，用于<span style=\"color:red;background:yellow\">返回对象的属性信息</span></p>\n<p>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。</p>\n<p>当直接输出一个对象时，toString方法会被默认的调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(xxx);</span><br><span class=\"line\">等价于System.out.print(xxx.toString);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"finalize\"><a href=\"#finalize\" class=\"headerlink\" title=\"finalize()\"></a>finalize()</h4><p>介绍：</p>\n<p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法</p>\n<ol>\n<li>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作</li>\n<li>什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制销毁该对象，在销毁该对象前，会先调用finalize方法</li>\n<li>垃圾回收机制的调用，是由系统来决定的(即有自己的GC算法 )，也可以通过System.gc()主动触犯垃圾回收机制</li>\n</ol>\n<h2 id=\"断点调试（debug）\"><a href=\"#断点调试（debug）\" class=\"headerlink\" title=\"断点调试（debug）\"></a>断点调试（debug）</h2><h4 id=\"提示：\"><a href=\"#提示：\" class=\"headerlink\" title=\"提示：\"></a>提示：</h4><p>在断点调试的过程中，是运行状态，是以对象运行类型来执行的</p>\n<h4 id=\"介绍：-1\"><a href=\"#介绍：-1\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h4><p>​\t断点调试是指程序在的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步一步往下调，调试过程中可以看到各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug。</p>\n<h4 id=\"快捷键-1\"><a href=\"#快捷键-1\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h4><ul>\n<li>F7（跳入）<ul>\n<li>跳入方法内</li>\n</ul>\n</li>\n<li>F8（跳过）<ul>\n<li>逐行执行代码</li>\n</ul>\n</li>\n<li>shift+F8（跳出）<ul>\n<li>跳出方法</li>\n</ul>\n</li>\n<li>F9（resume，执行到下一个断点）</li>\n</ul>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220324141333874.png\" alt=\"image-20220324141333874\"></p>\n<h1 id=\"面向对象（高级）\"><a href=\"#面向对象（高级）\" class=\"headerlink\" title=\"面向对象（高级）\"></a>面向对象（高级）</h1><h2 id=\"类变量和类方法\"><a href=\"#类变量和类方法\" class=\"headerlink\" title=\"类变量和类方法\"></a>类变量和类方法</h2><h3 id=\"一、类变量\"><a href=\"#一、类变量\" class=\"headerlink\" title=\"一、类变量\"></a>一、类变量</h3><p>案例理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Child&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//定义一个变量count，是一个类变量（静态变量）static静态</span></span><br><span class=\"line\">    <span class=\"comment\">//该变量最大的特点就是会被Child类的所有的对象实例共享</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> Child （String name）&#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">join</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(name+<span class=\"string\">&quot;加入了游戏····&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">main()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义一个变量count，统计多少小孩加入了游戏</span></span><br><span class=\"line\">    <span class=\"comment\">//传统方法，定义一个count然后统计</span></span><br><span class=\"line\">    <span class=\"comment\">//int count  = 0;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">Child</span> <span class=\"variable\">child0</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&quot;xiaoming&quot;</span>)；</span><br><span class=\"line\">        child0.join();</span><br><span class=\"line\">    \t<span class=\"comment\">//count++;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//改进后</span></span><br><span class=\"line\">    \tchild0.count++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">Child</span> <span class=\"variable\">child1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&quot;xiaoming&quot;</span>)；</span><br><span class=\"line\">        child1.join();</span><br><span class=\"line\">    \tchild1.count++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">Child</span> <span class=\"variable\">child2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>(<span class=\"string\">&quot;xiaoming&quot;</span>)；</span><br><span class=\"line\">        child2.join();</span><br><span class=\"line\">    \tchild2.count++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//类变量可以通过类名来访问</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;共有&quot;</span>+child.count+<span class=\"string\">&quot;小孩加入了游戏&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>static变量会开辟一个独立的空间，所以new的对象空间不会再单独创建一个static变量的空间。所以这个static变量空间对于这个类的所有实例是共享的</p>\n<h4 id=\"内存分析\"><a href=\"#内存分析\" class=\"headerlink\" title=\"内存分析\"></a>内存分析</h4><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220402161426676.png\" alt=\"image-20220402161426676\"></p>\n<ol>\n<li>static变量是对象共享的</li>\n<li>不管static变量在哪<ol>\n<li>static变量是同一个类，所有对象共享</li>\n<li>static类变量，在类加载的时候就生成了</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"定义语法\"><a href=\"#定义语法\" class=\"headerlink\" title=\"定义语法\"></a>定义语法</h4><p>访问修饰符\tstatic\t数据类型\t变量名；【推荐】</p>\n<p>static\t访问修饰符\t数据类型\t变量名；</p>\n<h4 id=\"类变量访问\"><a href=\"#类变量访问\" class=\"headerlink\" title=\"类变量访问\"></a>类变量访问</h4><p>类名.类变量名【推荐】</p>\n<p>或者\t</p>\n<p>对象名.类变量名 [静态变量的访问修饰符的访问权限和范围和普通属性是一样的]</p>\n<p>推荐使用第一种</p>\n<h4 id=\"使用细节\"><a href=\"#使用细节\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h4><ol>\n<li>什么时候使用类变量？<ul>\n<li>当我们需要让某个类的所有对象都共享一个变量时，就可以使用类变量（静态变量）：比如上述的统计人数的案例</li>\n</ul>\n</li>\n<li>类变量与实际变量的区别<ul>\n<li>变量是该类的所有对象共享的</li>\n<li>实例变量是每个对象独享的</li>\n</ul>\n</li>\n<li>加上static成为类变量或静态变量，否则称为实例变量&#x2F;普通变量&#x2F;非静态变量</li>\n<li>类变量可以通过<span style=\"color:red\">类名.类变量名</span>或者<span style=\"color:red\">对象名.类变量名</span>来访问。推荐第一种方式访问（前提是得满足访问权限）</li>\n<li>实例变量不能通过<span style=\"color:red\">类名.类变量名</span>方式访问</li>\n<li>类变量是在类加载时就初始化了，也就是说，及时没有创建对象，只要加载类了，就可使用类变量了</li>\n<li>类变量的声明周期是随类的加载开始，随着类的消亡而销毁</li>\n</ol>\n<h3 id=\"二、类方法\"><a href=\"#二、类方法\" class=\"headerlink\" title=\"二、类方法\"></a>二、类方法</h3><h4 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>类方法也称静态方法</p>\n<h3 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">访问修饰符\t<span class=\"keyword\">static</span>\t数据源返回类型\t方法名()&#123;&#125;\t【推荐】</span><br><span class=\"line\"><span class=\"keyword\">static</span>\t访问修饰符\t数据返回类型\t方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"类方法调用\"><a href=\"#类方法调用\" class=\"headerlink\" title=\"类方法调用\"></a>类方法调用</h4><p>使用方式：</p>\n<p><span style=\"color:red\">类名.类方法名</span></p>\n<p>或</p>\n<p><span style=\"color:red\">对象名.类方法名</span></p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。</p>\n<p>比如：工具类中的方法utils</p>\n<p>Math类、Arrays类、Collections集合类</p>\n<h4 id=\"使用细节-1\"><a href=\"#使用细节-1\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h4><ol>\n<li>类方法和普通方法都是随着类的加载而加载，将结构信息储存在方法区：<ul>\n<li>类方法中无this的参数</li>\n<li>普通方法中隐含this参数</li>\n</ul>\n</li>\n<li>类方法可以通过类名调用，也可以通过对象名调用</li>\n<li>普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用</li>\n<li>类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以</li>\n<li>类方法(静态方法)中，只能访问 静态变量和静态方法</li>\n<li>普通成员方法，既可以访问静态的成员，非静态的方法。可以访问静态成员和非静态成员</li>\n</ol>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>静态方法，只能访问静态的成员，</p>\n<p>非静态方法，可以访问静态的 成员和非静态的成员</p>\n<p>（前提是必须遵守访问权限规则）</p>\n<h2 id=\"理解main方法语法\"><a href=\"#理解main方法语法\" class=\"headerlink\" title=\"理解main方法语法\"></a>理解main方法语法</h2><h4 id=\"深入理解main方法\"><a href=\"#深入理解main方法\" class=\"headerlink\" title=\"深入理解main方法\"></a>深入理解main方法</h4><p>解释main方法的形式：public static void main(String[] args){}</p>\n<p>main方法是java虚拟机调用的</p>\n<ol>\n<li><p>java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public</p>\n</li>\n<li><p>java虚拟机在执行main()方法是不必创建对象，所有该方法必须是static</p>\n</li>\n<li><p>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</p>\n</li>\n<li><p>java执行的程序 参数1 参数2  参数3</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220403184106869.png\" alt=\"image-20220403184106869\"></p>\n</li>\n</ol>\n<h4 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h4><ol>\n<li><p>在main（）方法中我们可以直接调用main方法所在类的静态方法或静态属性</p>\n</li>\n<li><p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，再能通过这个对象去访问类中的非静态成员</p>\n</li>\n<li><p>例：</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>class A{<br>private int a;<br>private static int b;<br><br>private void a(){<br>    System.out.println(“非静态方法a”);<br>}<br>private static void b(){<br>    System.out.println(“静态方法a”);<br>}<br><br><br><br>public static void main(String[] args){<br>    System.out.println(“id &#x3D; “ +a);&#x2F;&#x2F;错误 a是非静态变量，得实例一个对象才能调用<br>    System.out.println(“id &#x3D; “ +new A().a);&#x2F;&#x2F;这样是正确的，创建了个匿名对象调用<br>    System.out.println(“id &#x3D; “ +b);&#x2F;&#x2F;正确， 因为b是静态变量，可以直接调用<br>    System.out.println(“id &#x3D; “ +a());&#x2F;&#x2F;错误，和上述a的非静态变量的原因相同<br>    System.out.println(“id &#x3D; “ +new A().a());&#x2F;&#x2F;改成这样就是正确的，因为a()是非静态的方法<br><br>    A a &#x3D; new A();<br>    System.out.println(“id &#x3D; “ +a.a());&#x2F;&#x2F;同理<br>}<br>}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   * </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 代码块</span><br><span class=\"line\"></span><br><span class=\"line\">#### 介绍</span><br><span class=\"line\"></span><br><span class=\"line\">代码块又称初始化块，属于类中的成员【即 是类的一部分】。类似于方法，将罗技语句封装在方法体中，通过&#123;&#125;包围起来</span><br><span class=\"line\"></span><br><span class=\"line\">和方法不同，没有方法名，没有返回，没有参数，只有方法体。而且不用通过对象或类显式调用，而是在家类是，或创建对象时隐式调用。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 基本语法</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">[修饰符]&#123;</span><br><span class=\"line\">\t代码</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><ol>\n<li>修饰符 可选，要写的话，也只能写static</li>\n<li>代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块</li>\n<li>逻辑语句可以为任何罗技语句（输入，输出，方法调用，循环，判断等）</li>\n<li>; 号可以写上，也可以省略。</li>\n</ol>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作</li>\n<li>如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</li>\n</ol>\n<h4 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Movie</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">double</span> price;</span><br><span class=\"line\">\tpricate String director;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    使用场景</span></span><br><span class=\"line\"><span class=\"comment\">    1. 下面三个构造器都有相同的语句</span></span><br><span class=\"line\"><span class=\"comment\">    2. 这样重写大量的代码</span></span><br><span class=\"line\"><span class=\"comment\">    3. 可以吧相同语句提取出来，放到一个代码块中</span></span><br><span class=\"line\"><span class=\"comment\">    4. 我们不管调用哪个构造器，创建对象，都会先执行代码块</span></span><br><span class=\"line\"><span class=\"comment\">    5. 代码块调用的顺序都是优先于构造器</span></span><br><span class=\"line\"><span class=\"comment\">    </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;电影屏幕打开···&quot;</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;广告···&quot;</span>);</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;开始播放电影···&quot;</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Movie</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        System.out.println(&quot;电影屏幕打开···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;广告···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;开始播放电影···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Movie</span><span class=\"params\">(String name,<span class=\"type\">double</span> price)</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        System.out.println(&quot;电影屏幕打开···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;广告···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;开始播放电影···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Movie</span><span class=\"params\">(String name,<span class=\"type\">double</span> price,String director)</span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        System.out.println(&quot;电影屏幕打开···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;广告···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tSystem.out.println(&quot;开始播放电影···&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.price = price;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.director = director;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用细节-2\"><a href=\"#使用细节-2\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h4><ol>\n<li><p>static代码块也叫静态代码块，作用就是对类进行初始化，</p>\n<p>而且它随着类的加载而执行</p>\n<p>并且只会执行一次。</p>\n<p>如果是普通代码块，每创建一个对象，就执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//静态代码块</span></span><br><span class=\"line\"><span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">\txxxx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//普通代码块</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\txxxx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类什么时候被加载？[重要]</p>\n<ol>\n<li>创建对象实例时（new xxx)</li>\n<li>创建子类对象实例，父类也会被加载<ol>\n<li>先在家父类的代码块，再执行子类的</li>\n</ol>\n</li>\n<li>使用类的静态成员时（静态属性，静态方法）</li>\n</ol>\n<p>案例：A类 extends B类的静态块</p>\n<p>​\t\t\t先执行a的静态块，然后再执行b的</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220404151232983.png\" alt=\"image-20220404151232983\"></p>\n</li>\n<li><p>普通代码块，在创建对象实例时，会被隐式调用。</p>\n<p>被创建一次，就会调用一次</p>\n<p>如果只是使用类的静态成员时，普通代码块并不会执行</p>\n</li>\n<li><p>创建一个对象时，在一个类 调用顺序是（重点，难点）</p>\n<ol>\n<li><p>调用静态代码块和静态属性初始化</p>\n<p>（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例理解</span><br><span class=\"line\">    </span><br><span class=\"line\">    因为<span class=\"keyword\">static</span>的优先级一样，</span><br><span class=\"line\">    所以哪个写在前面，哪个就先执行</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> getn1();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;A&#x27;s static codeBlock&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getn1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;use getn1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">============================================</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">============================================</span><br><span class=\"line\">use getn1</span><br><span class=\"line\">A<span class=\"string\">&#x27;s static codeBlock</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">=========================分割线=========================</span></span><br><span class=\"line\"><span class=\"string\">//如果更换顺序</span></span><br><span class=\"line\"><span class=\"string\">class A&#123;</span></span><br><span class=\"line\"><span class=\"string\">    static &#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;A&#x27;</span>s <span class=\"keyword\">static</span> codeBlock<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    private static  int n1 = getn1();</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    public static int getn1()&#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;</span>use getn1<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">        return 100;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;   </span></span><br><span class=\"line\"><span class=\"string\">============================================</span></span><br><span class=\"line\"><span class=\"string\">输出结果：</span></span><br><span class=\"line\"><span class=\"string\">============================================</span></span><br><span class=\"line\"><span class=\"string\"> A&#x27;s static codeBlock</span></span><br><span class=\"line\"><span class=\"string\">use getn1</span></span><br><span class=\"line\"><span class=\"string\">   </span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>调用普通代码块和普通属性的初始化</p>\n<p>（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义的顺序调用） </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先执行静态的，和上述的一样，</span></span><br><span class=\"line\"><span class=\"comment\">//然后再执行非静态的，规则也是和上述一样，谁写前面先执行谁</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> getn2();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;普通代码块被执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;A&#x27;s static codeBlock&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> getn1();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getn1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;use getn1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getn2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;getn2 被调用&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">============================================</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">============================================</span><br><span class=\"line\">A<span class=\"string\">&#x27;s static codeBlock</span></span><br><span class=\"line\"><span class=\"string\">use getn1</span></span><br><span class=\"line\"><span class=\"string\">getn2 被调用</span></span><br><span class=\"line\"><span class=\"string\">普通代码块被执行</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">=========================分割线=========================</span></span><br><span class=\"line\"><span class=\"string\">class A&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;普通代码块被执行&quot;);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    private int b = getn2();</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    static &#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;A&#x27;</span>s <span class=\"keyword\">static</span> codeBlock<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    private static  int n1 = getn1();</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    public static int getn1()&#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;</span>use getn1<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">        return 100;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    public int getn2()&#123;</span></span><br><span class=\"line\"><span class=\"string\">        System.out.println(&quot;</span>getn2 被调用<span class=\"string\">&quot;);</span></span><br><span class=\"line\"><span class=\"string\">        return 1;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;    </span></span><br><span class=\"line\"><span class=\"string\">============================================</span></span><br><span class=\"line\"><span class=\"string\">输出结果：</span></span><br><span class=\"line\"><span class=\"string\">============================================</span></span><br><span class=\"line\"><span class=\"string\">A&#x27;s static codeBlock</span></span><br><span class=\"line\"><span class=\"string\">use getn1</span></span><br><span class=\"line\"><span class=\"string\">普通代码块被执行</span></span><br><span class=\"line\"><span class=\"string\">getn2 被调用</span></span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>调用构造器</p>\n<p>构造器优先级最低，上述的两个规则执行完成后<br>才会执行构造器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">A</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;构造器被执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;普通代码块被执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> getn2();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;A&#x27;s static codeBlock&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> getn1();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getn1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;use getn1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getn2</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;getn2 被调用&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">============================================</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">============================================</span><br><span class=\"line\">A<span class=\"string\">&#x27;s static codeBlock</span></span><br><span class=\"line\"><span class=\"string\">use getn1</span></span><br><span class=\"line\"><span class=\"string\">普通代码块被执行</span></span><br><span class=\"line\"><span class=\"string\">getn2 被调用</span></span><br><span class=\"line\"><span class=\"string\">构造器被执行</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>构造器 的最前面其实隐含了super() 和调用普通代码块</p>\n<p>静态相关的代码块，属性初始化，在类加载时，就执行完毕。因此是优先于 构造器和普通代码块执行的</p>\n<p>演示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">A</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里存在隐藏的调用</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//(1) super();</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//(2) 调用普通代码块</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t System.out.println(<span class=\"string\">&quot;xxxx&quot;</span>);\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AAA</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">AAA</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这里存在隐藏的调用</span></span><br><span class=\"line\">        <span class=\"comment\">//(1) super();</span></span><br><span class=\"line\">        <span class=\"comment\">//(2) 调用普通代码块</span></span><br><span class=\"line\">        <span class=\"comment\">//因为Object的代码块没有输出</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//1.先输出</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;AAA的构造器被调用&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BBB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AAA</span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"><span class=\"comment\">//        根据规则父类的输出完毕后，再调用方法区</span></span><br><span class=\"line\"><span class=\"comment\">//        2. 再执行普通代码块</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;bbb的普通代码块执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BBB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这里存在隐藏的调用</span></span><br><span class=\"line\">        <span class=\"comment\">//(1) super();</span></span><br><span class=\"line\">        <span class=\"comment\">//(2) 调用普通代码块</span></span><br><span class=\"line\"><span class=\"comment\">//        等上述执行完毕后，最后执行该语句</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;BBB的无参构造被执行&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个子类对象时(继承关系),他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：</p>\n<ol>\n<li>父类的静态代码块和静态属性（优先级一样，按定义的顺序执行）</li>\n<li>子类的静态代码块和静态属性（优先级一样，按定义的顺序执行）</li>\n<li>父类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）</li>\n<li>父类的构造器</li>\n<li>子类的普通代码块和普通属性初始化（优先级一样，按定义的顺序执行）</li>\n<li>子类的构造器</li>\n</ol>\n</li>\n<li><p>静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任何成员</p>\n</li>\n</ol>\n<h2 id=\"单例设计模式\"><a href=\"#单例设计模式\" class=\"headerlink\" title=\"单例设计模式\"></a>单例设计模式</h2><h4 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ol>\n<li>所谓单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且只提供一个取得对象实例的方法</li>\n<li>单例模式有两种方式：1）饿汉式 2）懒汉式<ol>\n<li>二者最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例,而懒汉式在使用时才创建</li>\n<li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li>\n<li>饿汉式存在浪费资源的可能。（因为如果程序员一个对象实例都没使用，那么饿汉式创建的对象就是浪费了，懒汉式是使用时才创建，就不存在这个问题</li>\n<li>在javaSE标准类中，java.lang.Runtim就是经典的单例设计模式</li>\n</ol>\n</li>\n</ol>\n<p>演示：</p>\n<ol>\n<li><p>恶汉式</p>\n<p>类加载的时候，对象就被创建实例对象，可能会出现创建了，但是没有使用</p>\n<p>步骤：</p>\n<ol>\n<li><p>构造器私有化 &#x3D;&gt; 防止直接new</p>\n</li>\n<li><p>类的内部创建对象</p>\n</li>\n<li><p>向外露出一个静态的公共方法。</p>\n</li>\n<li><p>代码实现</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>public class singleDesign {<br>public static void main(String[] args) {<br>    System.out.println(GirlFriend.info());<br>}<br>}<br>&#x2F;&#x2F;有一个女朋友类<br>&#x2F;&#x2F;只能有一个女朋友<br>class GirlFriend{<br>private String name;<br>&#x2F;&#x2F;    2.创建一个对象<br>&#x2F;&#x2F;    3.为了能够接收静态方法，需要修饰为static<br>private static GirlFriend girl &#x3D; new GirlFriend(info());<br>&#x2F;&#x2F;    如何保证只能有一个对象实例<br>&#x2F;&#x2F;    public girlFriend(String name) {<br>&#x2F;&#x2F;        this.name &#x3D; name;<br>&#x2F;&#x2F;    }<br>&#x2F;&#x2F;    1. 改成私有的构造器<br>private GirlFriend(String name) {<br>    this.name &#x3D; name;<br>}<br>&#x2F;&#x2F;    4.创建一个静态方法，用于接收实例对象<br>public static String info(){<br>    return “g”;<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 懒汉式</span><br><span class=\"line\"></span><br><span class=\"line\">   使用时才创建实例</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 构造器私有化=&gt; 防止直接new</span><br><span class=\"line\"></span><br><span class=\"line\">   2. 类的内部创建对象</span><br><span class=\"line\"></span><br><span class=\"line\">   3. 向外暴露一个静态的公共方法</span><br><span class=\"line\"></span><br><span class=\"line\">   4. ```java</span><br><span class=\"line\">      public class SingleDesign01 &#123;</span><br><span class=\"line\">          public static void main(String[] args) &#123;</span><br><span class=\"line\">              System.out.println(Cat.i);</span><br><span class=\"line\">      //        此时只是初始化了cat ，但没有创建对象，其他的静态参数可以直接调用</span><br><span class=\"line\">              System.out.println(Cat.getCat());</span><br><span class=\"line\">      //        当只有调用了这个方法时，才会创建对象(通过判断发现没有cat类，此时创建后返回)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      //懒汉式</span><br><span class=\"line\">      //希望在程序运行中，只创建一个cat</span><br><span class=\"line\">      </span><br><span class=\"line\">      class Cat&#123;</span><br><span class=\"line\">          private String name;</span><br><span class=\"line\">          public static int i =1;</span><br><span class=\"line\">      //    2.定义一个静态属性static</span><br><span class=\"line\">          private  static Cat cat;</span><br><span class=\"line\">      </span><br><span class=\"line\">      //    3.提供一个公共的static方法 可以返回一个Cat对象</span><br><span class=\"line\">          public  static  Cat getCat()&#123;</span><br><span class=\"line\">              if (cat == null)&#123; //如果还没创建对象</span><br><span class=\"line\">                  cat = new Cat(&quot;little cute&quot;);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              return cat;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">      //    1.创建私有构造器</span><br><span class=\"line\">          private Cat(String name)&#123;</span><br><span class=\"line\">              this.name = name;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"final关键字\"><a href=\"#final关键字\" class=\"headerlink\" title=\"final关键字\"></a>final关键字</h2><h4 id=\"介绍-5\"><a href=\"#介绍-5\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>final &#x2F; 最后的，最终的</p>\n<p>fianl 可以修饰类、属性、方法和局部变量</p>\n<p>某些情况下，程序员可能有以下需求，就会使用到final：</p>\n<ol>\n<li>当不希望类被继承时，可以用final修饰</li>\n<li>当不希望父类的某个方法可以被子类覆盖&#x2F;重写（override）时，可以用final关键字修饰</li>\n<li>当不希望类的某个属性的值被修改，可以使用final修饰</li>\n<li>当不希望某个局部变量被修改，可以使用final修饰</li>\n</ol>\n<h4 id=\"使用细节-3\"><a href=\"#使用细节-3\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h4><ol>\n<li><p>final修饰的属性又叫常量，一般用XX_XX_XX来命名</p>\n</li>\n<li><p>final修饰的属性在定义时，必须赋初始值，并且以后都不能修改，赋值可以在如下位置之一（选择一个位置赋初始值即可）</p>\n<ol>\n<li><p>定义时：例如  public final double TAX_PATE&#x3D;0.09;</p>\n</li>\n<li><p>在构造器中</p>\n</li>\n<li><p>在代码块中</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>class A{<br>&#x2F;&#x2F;定义时赋值<br>public final double ATX_A &#x3D; 0.9;<br>&#x2F;&#x2F;在构造器中赋值<br>public final double ATX_B；<br>public A{<br>    ATX_B&#x3D;0.8；<br>}<br>&#x2F;&#x2F;在代码块中赋值<br>public final double ATX_C；<br>{<br>    ATX_C&#x3D;0.2；<br>}<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 如果final修饰的属性是静态的，则初始化的位置只能是</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 定义时</span><br><span class=\"line\">   2. 在静态代码块 </span><br><span class=\"line\">   3. 不能再构造器中赋值</span><br><span class=\"line\"></span><br><span class=\"line\">4. final类不能被继承，但是可以实例化对象</span><br><span class=\"line\"></span><br><span class=\"line\">5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</span><br><span class=\"line\"></span><br><span class=\"line\">6. 一般来说，如果一个类已经是final类，就没有必要再将方法修饰成final方法。</span><br><span class=\"line\"></span><br><span class=\"line\">7. final不能修饰构造方法（即构造器）</span><br><span class=\"line\"></span><br><span class=\"line\">8. final和static 往往搭配使用，效率更高，不会导致类的加载。底层编译器做了优化处理</span><br><span class=\"line\"></span><br><span class=\"line\">9. 包装类(integer,Double,Float,Boolean等等都是final),String 也是final类</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 抽象类</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">编写一个父类</span><br><span class=\"line\">//class Animal&#123;</span><br><span class=\"line\">abstract Animal&#123;</span><br><span class=\"line\">\tString name;</span><br><span class=\"line\">\tpublic Animal(String name)&#123;</span><br><span class=\"line\">\t this.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t这里的eat方法 实现了，没有什么意义</span><br><span class=\"line\">\t即父类中的方法不确定性的问题</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t1.考虑将该方法设计为抽象(abstract)方法</span><br><span class=\"line\">\t2.所谓抽象方法就是没有实现的方法</span><br><span class=\"line\">\t3.所谓的没有实现就是没有方法体</span><br><span class=\"line\">\t4.当一个类存在抽象方法时，就需要将该类声明为abstract类</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t一般来说，抽象类会被继承，有其子类来实现抽象方法</span><br><span class=\"line\">\t*/</span><br><span class=\"line\">    </span><br><span class=\"line\">\t//public void eat()&#123;</span><br><span class=\"line\">\t//\tSystem.out.println(&quot;这个是一个吃方法，但不知道吃啥&quot;);</span><br><span class=\"line\">\t//&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tpublic abstract void eat();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"介绍-6\"><a href=\"#介绍-6\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ol>\n<li><p>用abstract 关键字修饰的类时，这个类就是抽象类</p>\n<ol>\n<li>&#96;&#96;&#96;java<br>访问修饰符 abstract 类名{<br>}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 用abstract 关键字来修饰一个方法时，这个方法就是抽象方法</span><br><span class=\"line\"></span><br><span class=\"line\">   1. ```java</span><br><span class=\"line\">      访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()</p>\n</li>\n</ol>\n<h4 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h4><ol>\n<li>抽象类不能被实例化</li>\n<li>抽象类不一定包含abstract方法。也就是说，抽象类可以没有abstract方法</li>\n<li>一旦包含了abstract方法，则这个类必须声明为abstract </li>\n<li>abstract 只能修饰类和方法，不能修饰属性和其他的</li>\n<li>抽象类可以有任意成员【抽象类的本质还是类】，比如：非抽象方法、构造器、静态属性等等</li>\n<li>抽象方法不能有主体，即不能实现。例如：abstract void method()；不能有{}</li>\n<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract 类（所谓实现就是有那个{}就可，具体内容不管）</li>\n<li>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</li>\n</ol>\n<h4 id=\"抽象类实践-模板设计模式\"><a href=\"#抽象类实践-模板设计模式\" class=\"headerlink\" title=\"抽象类实践-模板设计模式\"></a>抽象类实践-模板设计模式</h4><p>现有个需求</p>\n<ol>\n<li>有多个类，完成不同的任务job</li>\n<li>要求能得到各自完成任务的时间</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> seatWork;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Template</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">son1</span> <span class=\"variable\">son1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">son1</span>();</span><br><span class=\"line\">        son1.getCurrentTime();</span><br><span class=\"line\">        <span class=\"type\">son2</span> <span class=\"variable\">son2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">son2</span>();</span><br><span class=\"line\">        son2.getCurrentTime();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Father</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//在抽象类中定义一个抽象方法，这个方法后期会填入不同子类的不同不同方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">job</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"comment\">//创建一个子类中的公共部分，在其中添加 不同的部分抽象类(方法)，</span></span><br><span class=\"line\"><span class=\"comment\">// 由于动态绑定机制，当调用该方法时，根据实例不同的子类实现不同的输出结果</span></span><br><span class=\"line\"><span class=\"comment\">//    也就是说相当于创建了个模板，不同的类用填不同的内容</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getCurrentTime</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        job();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;用时：&quot;</span>+(end-start));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">son1</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Father</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">job</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            sum+=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">son2</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Father</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">job</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">60000</span>; i++) &#123;</span><br><span class=\"line\">            sum+=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接口（重要）\"><a href=\"#接口（重要）\" class=\"headerlink\" title=\"接口（重要）\"></a>接口（重要）</h2><h4 id=\"介绍-7\"><a href=\"#介绍-7\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>接口就是给出一些没有实现的方法，封装到一起，起到某个类要使用的时候，在根据具体情况吧这些方法写出来</p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface 类名 implements 接口&#123;</span><br><span class=\"line\"> 自己的属性；</span><br><span class=\"line\"> 自己的方法；</span><br><span class=\"line\"> 必须实现的接口的抽象方法；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>小结:</p>\n<ol>\n<li>jdk7之前，接口中所有方法否是抽象方法</li>\n<li>jdk8之后，接口中可以有实现方法，但需要使用default关键字修饰</li>\n<li>jdk8之后可以有静态方法</li>\n<li>abstract关键字可以省略</li>\n</ol>\n<h4 id=\"注意事项-4\"><a href=\"#注意事项-4\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ol>\n<li><p>接口不能被实例化</p>\n</li>\n<li><p>接口中所有的方法是public方法，接口中抽象方法，可以不用填写abstract，因为默认修饰的就是public abstract xxx。</p>\n</li>\n<li><p>一个普通类实现接口，就必须将该接口的所有方法都实现</p>\n</li>\n<li><p>抽象类实现接口，可以不用实现接口的方法</p>\n</li>\n<li><p>一个类同时可以实现多个接口</p>\n</li>\n<li><p>接口的属性，只能是final的，而且public static final 修饰符，比如：int a &#x3D;1; 实际上是public static final int a &#x3D;1；（必须）初始化</p>\n</li>\n<li><p>接口中属性的访问形式：接口名.属性名</p>\n</li>\n<li><p>一个接口不能继承其他的类，但是可以继承多个别的接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">A</span> extend B,c,d...&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接口的修饰符只能是public和默认，这点和类的修饰符是一样的。</p>\n</li>\n</ol>\n<p>小结：</p>\n<p>继承vs接口</p>\n<ol>\n<li>当子类继承了父类，就自动拥有了父类的功能</li>\n<li>如果子类需要拓展功能，可以通过实现接口的方式扩展</li>\n<li>可以理解，接口是对java单继承机制的一个补充</li>\n</ol>\n<p>继承的价值：解决代码的复用性和可维护性</p>\n<p>接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。更加的灵活</p>\n<h2 id=\"内部类（重点）\"><a href=\"#内部类（重点）\" class=\"headerlink\" title=\"内部类（重点）\"></a>内部类（重点）</h2><h4 id=\"介绍：-2\"><a href=\"#介绍：-2\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h4><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类成为内部类（inner class)，嵌套其他类的类成为外部类(out class)。是我们类的第五大成员</p>\n<p>类的五大成员：</p>\n<ol>\n<li>属性</li>\n<li>方法</li>\n<li>构造器</li>\n<li>代码块</li>\n<li>内部类</li>\n</ol>\n<h4 id=\"基本语法-2\"><a href=\"#基本语法-2\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span>&#123;<span class=\"comment\">//外部类</span></span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">inner</span>&#123;<span class=\"comment\">//内部类</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">other</span>&#123;<span class=\"comment\">//外部其他类</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内部类的分类\"><a href=\"#内部类的分类\" class=\"headerlink\" title=\"内部类的分类\"></a>内部类的分类</h4><p>定义在外部类局部位置上（比如方法内）</p>\n<h5 id=\"1）局部内部类（有类名）\"><a href=\"#1）局部内部类（有类名）\" class=\"headerlink\" title=\"1）局部内部类（有类名）\"></a>1）局部内部类（有类名）</h5><p>​\t\t说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//例</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">outclass</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"comment\">//局部内部类师是定义在外部类的局部位置，通常在方法内</span></span><br><span class=\"line\"> <span class=\"comment\">// 1.第一种在局部位置</span></span><br><span class=\"line\"> \t<span class=\"keyword\">class</span> <span class=\"title class_\">innerClass</span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">//2. 在方法内，（局部内部类）</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">mehtod</span><span class=\"params\">()</span>&#123;<span class=\"comment\">//局部内部类（本质仍然是一个类）</span></span><br><span class=\"line\">    \t<span class=\"keyword\">class</span> <span class=\"title class_\">innerClass</span>&#123;</span><br><span class=\"line\">        System.out.print(<span class=\"string\">&quot;n=&quot;</span>+n);</span><br><span class=\"line\">      &#125;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>可以直接访问外部类的所有成员，包括私有的</p>\n</li>\n<li><p>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但可以使用final修饰，因为局部变量也可以使用final修饰符的</p>\n</li>\n<li><p>作用域：仅仅在定义它的方法或代码块中</p>\n</li>\n<li><p>局部内部类—访问—-&gt;外部类的成员【访问方式：直接访问】</p>\n</li>\n<li><p>外部类—-访问—-&gt;局部内部类的成员</p>\n<p>访问方式：创建对象，再访问（注意：必须在作用域内）</p>\n</li>\n<li><p>外部其它类—-&gt;不能访问—-&gt;局部内部类（因为 局部内部类地位是一个局部变量）</p>\n</li>\n<li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>class Outer{<br>private int n1 &#x3D; 10;<br>private static String name &#x3D; “张三”;<br>public void say(){<br>    int n3 &#x3D; 30;<br>  &#x2F;&#x2F;局部内部类是定义在外部类的局部位置，通常在方法<br>    &#x2F;&#x2F;不能添加访问修饰符，可以使用final修饰<br>  class localInner{&#x2F;&#x2F;局部内部类（本质仍然是一个类）<br>int n1 &#x3D; 100;<br>   int n2 &#x3D; 40;<br>    &#x2F;&#x2F;可以直接访问外部类的所有成员，包括私有的<br>  public void show(){<br>  &#x2F;&#x2F;默认输入内部类的n1的值 100<br>    System.out.print(“n1&#x3D;”+n1);<br>  &#x2F;&#x2F;输入outer.this.n1 输出的才是外部类的n1<br>  System.out.print(“n1&#x3D;”+outer.this.n1);<br><br>  }<br>}<br>}<br>  &#x2F;&#x2F;外部类使用内部类<br>  localInner inner &#x3D; new localInner();<br>  inner.show();<br> }</p>\n<p>&#x2F;&#x2F;外部其他类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">9. </span><br><span class=\"line\"></span><br><span class=\"line\">##### 2）匿名内部类（没有类名，重点！！！！）</span><br><span class=\"line\"></span><br><span class=\"line\">###### 介绍：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 本质是类</span><br><span class=\"line\">2. 是一个内部类</span><br><span class=\"line\">3. 该类没有名字</span><br><span class=\"line\">4. 同时还是一个对象</span><br><span class=\"line\"></span><br><span class=\"line\">匿名内部类是定义在外部类的局部位置</span><br><span class=\"line\"></span><br><span class=\"line\">比如在方法中，并且没有类名</span><br><span class=\"line\"></span><br><span class=\"line\">###### 基本语法</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">new 类 或 接口（参数列表）&#123;</span><br><span class=\"line\">\t类体</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">anonymous</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h6 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> chapterObjectHeightLevel;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AnonymousClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">outer</span> <span class=\"variable\">outer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">outer</span>();</span><br><span class=\"line\">        outer.method();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">outer</span>&#123;<span class=\"comment\">//外部类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//现有一个需求，使用IA接口，并创建对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        传统方法：新建一个类tiger 实现IA接口，并new tiger调用</span></span><br><span class=\"line\"><span class=\"comment\">//        IA tiger = new Tiger();</span></span><br><span class=\"line\"><span class=\"comment\">//        tiger.cry();</span></span><br><span class=\"line\"><span class=\"comment\">//        当此时的需求是只需要这个Tiger类使用一次，并且以后再也不使用</span></span><br><span class=\"line\"><span class=\"comment\">//        如果再用传统方法的话，会造成资源浪费，而且没有必要再去新建一个类</span></span><br><span class=\"line\"><span class=\"comment\">//        此时就需要匿名内部类来简化开发，如下</span></span><br><span class=\"line\">        <span class=\"type\">IA</span> <span class=\"variable\">tiger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IA</span>()&#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             *此时底层是这样的</span></span><br><span class=\"line\"><span class=\"comment\">             * class xxx(该类名是系统自动创建的) implements IA&#123;</span></span><br><span class=\"line\"><span class=\"comment\">             *     <span class=\"doctag\">@Override</span></span></span><br><span class=\"line\"><span class=\"comment\">             *     public void cry() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">             *         System.out.println(&quot;老虎叫`````&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">             *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">             * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">             *</span></span><br><span class=\"line\"><span class=\"comment\">             * 之后在让tiger指向xxx的地址</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;老虎叫`````&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        tiger.cry();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//演示基于类的匿名内部类</span></span><br><span class=\"line\"><span class=\"comment\">//        1. father的编译类型 Father(不加&#123;&#125;号)</span></span><br><span class=\"line\"><span class=\"comment\">//        2. father的编译类型 xxx$2(加&#123;&#125;号）</span></span><br><span class=\"line\"><span class=\"comment\">//        2.1 底层会创建匿名内部类</span></span><br><span class=\"line\">        <span class=\"type\">Father</span> <span class=\"variable\">father</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Father</span>(<span class=\"string\">&quot;tiger&quot;</span>)&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;override test method&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">            * 相当于创建了哥匿名内部类重写了test方法</span></span><br><span class=\"line\"><span class=\"comment\">            * class xxx implement test&#123;</span></span><br><span class=\"line\"><span class=\"comment\">             *      <span class=\"doctag\">@Override</span></span></span><br><span class=\"line\"><span class=\"comment\">             *      public void test() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">             *          System.out.println(&quot;override test method&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">             *       &#125;</span></span><br><span class=\"line\"><span class=\"comment\">             * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">             * 然后再将father指向xxx的地址</span></span><br><span class=\"line\"><span class=\"comment\">            * */</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        father.test();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//class Tiger implements IA&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//    @Override</span></span><br><span class=\"line\"><span class=\"comment\">//    public void cry() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(&quot;老虎叫`````&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Father</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"注意细节\"><a href=\"#注意细节\" class=\"headerlink\" title=\"注意细节\"></a>注意细节</h6><ol>\n<li><p>匿名内部类既是一个类的定义，同事它也是一个对象，因此从语法上来看，它既有定义类的特征，也有创建对象的特征，对前面的代码分析可以看出这个特点，因此调用匿名内部类方法有两种</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.第一种方式</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tSystem.out.print(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;.cry();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.第二种方式</span></span><br><span class=\"line\">A a=<span class=\"keyword\">new</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\tSystem.out.print(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.cry();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以访问外部类的所有成员，包括私有的</p>\n</li>\n<li><p>不能添加访问修饰符，因为它的地位就是一个局部变量</p>\n</li>\n<li><p>作用域：方法或代码块中</p>\n</li>\n<li><p>匿名内部类—&gt;范围跟—&gt;外部类成员</p>\n</li>\n<li><p>外部其他类—&gt;不能访问—&gt;匿名内部类（因为 匿名内部类地位是一个局部变量）</p>\n</li>\n<li><p>如果外部类和内部类的成员变量重名时，内部类访问的话，默认就是就近原则，如果想访问外部，可以使用（外部类名.this.成员）去访问</p>\n</li>\n</ol>\n<p>定义在外部类的成员位置上</p>\n<h5 id=\"1）成员内部类（没用static修饰）\"><a href=\"#1）成员内部类（没用static修饰）\" class=\"headerlink\" title=\"1）成员内部类（没用static修饰）\"></a>1）成员内部类（没用static修饰）</h5><p>介绍：</p>\n<ol>\n<li><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">outer</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;zhangsan&quot;</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">class</span> <span class=\"title class_\">inner</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t\t\tSystem.out.print(<span class=\"string\">&quot;outer n1 = &quot;</span>+n1+<span class=\"string\">&quot;outer name = &quot;</span>+name);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位是一个成员</p>\n</li>\n<li><p>作用域</p>\n<p>和外部类的其他成员一样，为整个类体比如前面的案例，在外部类的成员方法中创建成员内部类对象，再调用方法</p>\n</li>\n<li><p>成员内部类–&gt;访问—&gt;外部类成员</p>\n<p>(比如属性)【访问方式：直接访问】</p>\n</li>\n<li><p>外部类 —访问—内部类</p>\n<p>访问方式：创建对象，再访问</p>\n</li>\n<li><p>外部其他类—–访问—–成员内部类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//三种方式:</span></span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\">outer.<span class=\"type\">inner</span> <span class=\"variable\">class</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">outer</span>.<span class=\"keyword\">new</span> <span class=\"title class_\">inner</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种方式</span></span><br><span class=\"line\"> <span class=\"number\">1.</span>定义一个方法，用于创建内部类并返回内部类的实例</span><br><span class=\"line\">   <span class=\"keyword\">public</span> inner <span class=\"title function_\">getInner</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">   <span class=\"type\">Inner</span> <span class=\"variable\">inner</span>  <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\">   <span class=\"keyword\">return</span> inner;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"number\">2.</span> 在需要的地方<span class=\"keyword\">new</span>一个外部类.这个方法</span><br><span class=\"line\">  Outer.<span class=\"type\">Inner</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer</span>.getInner();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3这个方法不建议使用</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">Outer</span>().<span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409142725630.png\" alt=\"image-20220409142725630\"></p>\n</li>\n</ol>\n<h5 id=\"2）静态内部类（使用static修饰）\"><a href=\"#2）静态内部类（使用static修饰）\" class=\"headerlink\" title=\"2）静态内部类（使用static修饰）\"></a>2）静态内部类（使用static修饰）</h5><h6 id=\"介绍-8\"><a href=\"#介绍-8\" class=\"headerlink\" title=\"介绍\"></a>介绍</h6><p>静态内部类定义在外部类的成员位置，并且有static修饰</p>\n<ol>\n<li>可以直接访问外部的所有静态成员，包含私有的，但不能直接访问非静态成员</li>\n<li>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员</li>\n<li>作用域：同其他的成员，为整个类体</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">outer</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> n1=<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;zhangsan&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//inner就是静态内部类</span></span><br><span class=\"line\">  <span class=\"comment\">//1. 放在外部类的成员位置</span></span><br><span class=\"line\">  <span class=\"comment\">//2. 使用static修饰</span></span><br><span class=\"line\">  <span class=\"comment\">//3. 不能直接访问非静态成员</span></span><br><span class=\"line\">  <span class=\"comment\">//4. 可以添加修饰符</span></span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      \tSystem.out.println(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>静态内部类—访问—-外部类</p>\n<p>（比如：静态属性）[访问方式：直接访问所有静态成员]</p>\n</li>\n<li><p>外部类–访问—静态内部类 </p>\n<p>访问方式：创建对象，再访问</p>\n</li>\n<li><p>外部其他类 –访问 –内部类</p>\n<p>访问方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//访问方式1</span></span><br><span class=\"line\"><span class=\"comment\">//因为静态内部类，是可以通过类名直接访问（前提是满足访问权限）</span></span><br><span class=\"line\">Outer.<span class=\"type\">Inner</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer</span>.Inner();</span><br><span class=\"line\">inner.xxx();</span><br><span class=\"line\"><span class=\"comment\">//访问方式2</span></span><br><span class=\"line\"><span class=\"comment\">//写一个方法，返回静态内部类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Inner <span class=\"title function_\">getInner</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Outer.<span class=\"type\">Inner</span> <span class=\"variable\">inner</span> <span class=\"operator\">=</span> Outer.getInner();</span><br><span class=\"line\"></span><br><span class=\"line\">inner.xxx();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者将方法换成静态</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Inner <span class=\"title function_\">getInner</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Inner</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果外部类和静态内部类的成员重名时，静态内部访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问</p>\n</li>\n</ol>\n<h1 id=\"枚举和注解\"><a href=\"#枚举和注解\" class=\"headerlink\" title=\"枚举和注解\"></a>枚举和注解</h1><h2 id=\"枚举（enum）\"><a href=\"#枚举（enum）\" class=\"headerlink\" title=\"枚举（enum）\"></a>枚举（enum）</h2><h3 id=\"介绍-9\"><a href=\"#介绍-9\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>1）枚举对应的英文（enumeration,简写enum）</p>\n<p>2）枚举是一组常量的集合</p>\n<p>3）可以理解：枚举属于一种特殊的类，里面只包含一组有限的特定对象（比如一年只有四个季节，建一个季节类的话只能有四个，而且有被添加其他季节的风险）</p>\n<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><h4 id=\"1）自定义枚举\"><a href=\"#1）自定义枚举\" class=\"headerlink\" title=\"1）自定义枚举\"></a>1）自定义枚举</h4><ol>\n<li>不需要提供set方法，因为枚举对象通常为只读</li>\n<li>对枚举对象&#x2F;属性使用final +static共同修饰，实现底层优化</li>\n<li>枚举对象通常使用大写，常量的命名规范</li>\n<li>枚举对象根据需要，也可以有多个属性</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> chapterEnum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">understandForEnum</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">season</span> <span class=\"variable\">autumn</span> <span class=\"operator\">=</span> season.AUTUMN;</span><br><span class=\"line\">        System.out.println(autumn.getSeasonName()+autumn.getSeasonDescription());</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//定义一个季节类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">season</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String seasonName;<span class=\"comment\">//季节名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String seasonDescription;<span class=\"comment\">//季节描述</span></span><br><span class=\"line\">  <span class=\"comment\">//1.将构造器私有化</span></span><br><span class=\"line\">  <span class=\"comment\">//2.去掉setxx方法，防止属性被修改</span></span><br><span class=\"line\">  <span class=\"comment\">//3.在season内部，直接创建固定的对象</span></span><br><span class=\"line\">  <span class=\"comment\">//4.优化，添加final</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getSeasonName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seasonName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getSeasonDescription</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seasonDescription;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">season</span><span class=\"params\">(String seasonName, String seasonDescription)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.seasonName = seasonName;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.seasonDescription = seasonDescription;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//定义了四个对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">season</span> <span class=\"variable\">SPRING</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">season</span>(<span class=\"string\">&quot;春天&quot;</span>,<span class=\"string\">&quot;温暖&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">season</span> <span class=\"variable\">SUMMER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">season</span>(<span class=\"string\">&quot;夏天&quot;</span>,<span class=\"string\">&quot;炎热&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">season</span> <span class=\"variable\">AUTUMN</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">season</span>(<span class=\"string\">&quot;秋天&quot;</span>,<span class=\"string\">&quot;凉爽&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">season</span> <span class=\"variable\">WINTER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">season</span>(<span class=\"string\">&quot;冬天&quot;</span>,<span class=\"string\">&quot;寒冷&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>总结：定义枚举类型有一下几个特点</p>\n<ol>\n<li>构造器私有化</li>\n<li>本类内部创建一组对象</li>\n<li>对外暴露对象（添加public final static 修饰）</li>\n<li>可以提供get方法，但不需要提供set方法</li>\n</ol>\n<h4 id=\"2）使用enum关键字实现\"><a href=\"#2）使用enum关键字实现\" class=\"headerlink\" title=\"2）使用enum关键字实现\"></a>2）使用enum关键字实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> chapterEnum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">understandForEnum02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(season02.SPRING);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">season02</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 实现步骤</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.使用enum代替class</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.直接使用 常量名(实参列表)</span></span><br><span class=\"line\"><span class=\"comment\">     *   SPRING(&quot;春天&quot;,&quot;温暖&quot;),</span></span><br><span class=\"line\"><span class=\"comment\">     *   如果有多个常量则用,号隔开</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * enum修饰必须将常量对象写在第一行</span></span><br><span class=\"line\"><span class=\"comment\">     *  必须写在定义的变量和方法前面</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.编写常量，私有构造器和get方法</span></span><br><span class=\"line\"><span class=\"comment\">     * */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    SPRING(<span class=\"string\">&quot;春天&quot;</span>,<span class=\"string\">&quot;温暖&quot;</span>),</span><br><span class=\"line\">    SUMMER(<span class=\"string\">&quot;夏天&quot;</span>,<span class=\"string\">&quot;炎热&quot;</span>),</span><br><span class=\"line\">    AUTUMN(<span class=\"string\">&quot;秋天&quot;</span>,<span class=\"string\">&quot;凉爽&quot;</span>),</span><br><span class=\"line\">    WINTER(<span class=\"string\">&quot;冬天&quot;</span>,<span class=\"string\">&quot;寒冷&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String seasonName;<span class=\"comment\">//季节名称</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String seasonDescription;<span class=\"comment\">//季节描述</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getSeasonName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seasonName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getSeasonDescription</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> seasonDescription;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">season02</span><span class=\"params\">(String seasonName, String seasonDescription)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.seasonName = seasonName;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.seasonDescription = seasonDescription;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;season02&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;, seasonDescription=&#x27;&quot;</span> + seasonDescription + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//定义四个固定对象</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    public final static season02 SPRING = new season02(&quot;春天&quot;,&quot;温暖&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    public final static season02 SUMMER = new season02(&quot;夏天&quot;,&quot;炎热&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    public final static season02 AUTUMN = new season02(&quot;秋天&quot;,&quot;凉爽&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">    public final static season02 WINTER = new season02(&quot;冬天&quot;,&quot;寒冷&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意事项-5\"><a href=\"#注意事项-5\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><ol>\n<li>当我们使用enum关键字开发一个枚举类时，默认会继承Enum类</li>\n<li>传统的public static final SPRING &#x3D; new season(“春天”,”温暖”);简化成SPRING(“春天”,”温暖”),这里必须知道，它调用的是哪个构造器</li>\n<li>如果使用无参构造器 创建枚举对象，则实参列表和小括号都可以省略</li>\n<li>当有多个枚举对象时，使用，号间隔，最后一个分号结尾</li>\n<li>枚举对象必须放在枚举的行首</li>\n</ol>\n<h3 id=\"enum常用方法说明\"><a href=\"#enum常用方法说明\" class=\"headerlink\" title=\"enum常用方法说明\"></a>enum常用方法说明</h3><p>使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类的相关方法</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220409204654918.png\" alt=\"image-20220409204654918\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//        使用season02 枚举类，演示各个方法</span></span><br><span class=\"line\">        <span class=\"type\">season02</span> <span class=\"variable\">summer</span> <span class=\"operator\">=</span> season02.SUMMER;</span><br><span class=\"line\"><span class=\"comment\">//        输出枚举对象的名字</span></span><br><span class=\"line\"><span class=\"comment\">//        summer.name();</span></span><br><span class=\"line\">        System.out.println(summer.name());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        ordinal()输出的是该枚举对象的次序/编号，按枚举的顺序从0开始编号</span></span><br><span class=\"line\"><span class=\"comment\">//        summer枚举对象时第二个，因此返回 1</span></span><br><span class=\"line\">        System.out.println(summer.ordinal());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        从反编译可以看出values方法，返货season02[]</span></span><br><span class=\"line\"><span class=\"comment\">//        含有定义所有的枚举对象</span></span><br><span class=\"line\">        season02[] values = season02.values();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;values.length ; i++) &#123;</span><br><span class=\"line\">            System.out.println(values[i].name());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        增强for循环演示</span></span><br><span class=\"line\"><span class=\"comment\">//        每执行一次values就会扔一个对象给season、</span></span><br><span class=\"line\"><span class=\"comment\">//        简单来说就是依次取出数组赋给season</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;==========增强for=========&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(season02 season:values)&#123;</span><br><span class=\"line\">            System.out.println(season.name());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        valueOf:将字符串转换成枚举对象，要求字符串必须VT为己有的常量名，否则会报错</span></span><br><span class=\"line\"><span class=\"comment\">//        1.根据输入的&quot;xia&quot;到season02中的枚举对象去查找</span></span><br><span class=\"line\"><span class=\"comment\">//        2.如果找到了，就返回，如果没有找到就报错，如下这个例子</span></span><br><span class=\"line\">        <span class=\"comment\">/*season02 vaof = chapterEnum.season02.valueOf(&quot;xia&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">        System.out.println(&quot;vaof = &quot;+ vaof);*/</span></span><br><span class=\"line\"><span class=\"comment\">//        3.只要valueOf()中的参数和枚举对象一致才能正常返回，如下</span></span><br><span class=\"line\">        <span class=\"type\">season02</span> <span class=\"variable\">xia</span> <span class=\"operator\">=</span> chapterEnum.season02.valueOf(<span class=\"string\">&quot;SUMMER&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;xia = &quot;</span> +xia);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        compareTo:比较两个枚举常量，比较的是编号</span></span><br><span class=\"line\"><span class=\"comment\">//        就是把season02.SPRING和season02.SUMMER的编号进行比较</span></span><br><span class=\"line\"><span class=\"comment\">//        底层是第一个的编号减去第二的编号，</span></span><br><span class=\"line\"><span class=\"comment\">//        如果=0则是相等的，</span></span><br><span class=\"line\"><span class=\"comment\">//        如果大于1，则代表前面那个编号大于后面一个编号</span></span><br><span class=\"line\"><span class=\"comment\">//        如果小于1，则反之</span></span><br><span class=\"line\">        System.out.println(season02.SPRING.compareTo(season02.SUMMER));<span class=\"comment\">//= -1</span></span><br><span class=\"line\">        System.out.println(season02.SPRING.compareTo(season02.WINTER));<span class=\"comment\">//= -3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用细节-4\"><a href=\"#使用细节-4\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h3><ol>\n<li>enum修饰的类不能在继承其他父类，因为enum会隐式继承一个Enum类</li>\n<li>enum实现的类，仍然是一个类，所以还是可以实现接口的</li>\n</ol>\n<h3 id=\"Switch中使用枚举\"><a href=\"#Switch中使用枚举\" class=\"headerlink\" title=\"Switch中使用枚举\"></a>Switch中使用枚举</h3><p>案例</p>\n<ol>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410224921752.png\" alt=\"image-20220410224921752\"></p>\n</li>\n<li><pre><code class=\"java\">package homeWork.Annotation;\n\npublic class AnnotationHomeWork08 &#123;\n    public static void main(String[] args) &#123;\n//        Color.BLACK.show();\n//        Color.RED.show();\n    Color red = Color.RED;\n//    在小（）内放入枚举对象\n//        在每个case后，直接写上枚举类，定义枚举对象即可\n        switch (red)&#123;\n            case RED:\n                System.out.println(&quot;红色&quot;);\n                break;\n            case BLUE:\n                System.out.println(&quot;蓝色&quot;);\n                break;\n            case BLACK:\n                System.out.println(&quot;黑色&quot;);\n                break;\n            case YELLOW:\n                System.out.println(&quot;黄色&quot;);\n                break;\n            case GREEN:\n                System.out.println(&quot;绿色&quot;);\n                break;\n            default:\n                System.out.println(&quot;没匹配到&quot;);\n\n        &#125;\n    &#125;\n&#125;\ninterface Tint&#123;\n    public void show();\n&#125;\nenum Color implements Tint&#123;\n    RED(255,0,0),\n    BLUE(0,0,255),\n    BLACK(0,0,0),\n    YELLOW(255,255,0),\n    GREEN(0,255,0);\n\n    private int redValue;\n    private int greenValue;\n    private int blueValue;\n\n    Color(int redValue, int greenValue, int blueValue) &#123;\n        this.redValue = redValue;\n        this.greenValue = greenValue;\n        this.blueValue = blueValue;\n    &#125;\n\n    @Override\n    public void show() &#123;\n        System.out.println(redValue+&quot;\\t&quot;+greenValue+&quot;\\t&quot;+blueValue);\n    &#125;\n&#125;\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 注解</span><br><span class=\"line\"></span><br><span class=\"line\">#### 介绍</span><br><span class=\"line\"></span><br><span class=\"line\">1. 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息</span><br><span class=\"line\">2. 和注解一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</span><br><span class=\"line\">3. 在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等，在javase中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替javaee旧版中所遗留 的繁冗代码和xml配置等</span><br><span class=\"line\"></span><br><span class=\"line\">使用Annotation时，前面要加@符号，并把Annotation当成一个修饰符使用。用于修饰它支持的程序元素</span><br><span class=\"line\"></span><br><span class=\"line\">1. @Override：限定某个方法，是重写父类方法，该注解只能用于方法</span><br><span class=\"line\"></span><br><span class=\"line\">   ```java</span><br><span class=\"line\">   class son extends father&#123;</span><br><span class=\"line\">   //1.@Override注解方法fly方法上，表示子类fly方法重写了父类的fly</span><br><span class=\"line\">   //2.如果这里没有写@Override ，还是重写了fly</span><br><span class=\"line\">   //3.如果写了@Override注解，编译器就会去检查该方法是否真的重写了fly方法，</span><br><span class=\"line\">   \t如果的确重写了，则编译通过。如果没有构成重写，则编译错误</span><br><span class=\"line\">   @Override</span><br><span class=\"line\">   public void fly()&#123;</span><br><span class=\"line\">    System.out.println(&quot;son fly...&quot;);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n@Override只能修饰方法，不能修饰其他类\n</code></pre>\n</li>\n<li><p>@Deprecated：用于表示某个程序元素(类、方法等)已过时</p>\n</li>\n<li><p>@SuppressWarnings：抑制编译器警告</p>\n<ol>\n<li><p>当写一些方法时，会出现一些无关不影响运行的警告。</p>\n<p>可以使用@SuppressWarnings来抑制警告信息</p>\n</li>\n<li><p>可以在@SuppressWarnings{“”}中写入希望抑制的警告信息</p>\n</li>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410190809537.png\" alt=\"image-20220410190809537\"></p>\n</li>\n<li><p>位置在哪就屏蔽哪里</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"元注解（了解）\"><a href=\"#元注解（了解）\" class=\"headerlink\" title=\"元注解（了解）\"></a>元注解（了解）</h3><p>@Target是修饰注解的注解，称为元注解  （了解）</p>\n<p>元注解的种类（使用不多，要求看到直到是干啥的）</p>\n<h4 id=\"1）Retention-x2F-x2F-指定注解的作用范围，三种SOURCE-CLASS-RUNTIME\"><a href=\"#1）Retention-x2F-x2F-指定注解的作用范围，三种SOURCE-CLASS-RUNTIME\" class=\"headerlink\" title=\"1）Retention &#x2F;&#x2F;指定注解的作用范围，三种SOURCE,CLASS,RUNTIME\"></a>1）Retention &#x2F;&#x2F;指定注解的作用范围，三种SOURCE,CLASS,RUNTIME</h4><p>说明：</p>\n<p>只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，</p>\n<p>@Rentention包含一个RententionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值</p>\n<p>@Rentention的三种值：</p>\n<p>RententionPolicy.SOURCE &#x2F;&#x2F;编译器使用后，直接丢弃这种策略的注释</p>\n<p>RententionPolicy.CLASS &#x2F;&#x2F; 编译器将把注释记录在class文件中，当运行java程序时，JVM不会保留注释，这是默认值</p>\n<p>RententionPolicy.RUNTIME  &#x2F;&#x2F;编译器将把注解记录在class文件中，当运行java程序时，JVM会保留注释，程序可以通过反射获取该注释</p>\n<p>示意图：</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220410203107921.png\" alt=\"image-20220410203107921\"></p>\n<h4 id=\"2）Target-x2F-x2F-指定注解可以在哪些地方使用\"><a href=\"#2）Target-x2F-x2F-指定注解可以在哪些地方使用\" class=\"headerlink\" title=\"2）Target     &#x2F;&#x2F;指定注解可以在哪些地方使用\"></a>2）Target     &#x2F;&#x2F;指定注解可以在哪些地方使用</h4><p>用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素</p>\n<p>简单来说就是在哪些元素上使用</p>\n<p>@Target   也包含一个名为value的成员变量\t</p>\n<p>Target(value &#x3D; CONSTRUCTOR（构造器）, FIELD（field） , LOACL_VARIABLE（局部变量）, METHOD（方法）,PACKAGE（包）,PARAMETER ,TYPE )</p>\n<h4 id=\"3）Documented-x2F-x2F-指定该注解是否会在javadoc中体现\"><a href=\"#3）Documented-x2F-x2F-指定该注解是否会在javadoc中体现\" class=\"headerlink\" title=\"3）Documented    &#x2F;&#x2F;指定该注解是否会在javadoc中体现\"></a>3）Documented    &#x2F;&#x2F;指定该注解是否会在javadoc中体现</h4><p>@Documented   用于指定该元注解修饰的Annotation类将被Javadoc 工具提取成文档，即在生成文档时，可以看到注解</p>\n<p>定义Documented  注解必须设置Retention 值为RUNTIME</p>\n<h4 id=\"4）Inherited-x2F-x2F-子类会继承父类注解\"><a href=\"#4）Inherited-x2F-x2F-子类会继承父类注解\" class=\"headerlink\" title=\"4）Inherited    &#x2F;&#x2F;子类会继承父类注解\"></a>4）Inherited    &#x2F;&#x2F;子类会继承父类注解</h4><h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><h2 id=\"异常的概念\"><a href=\"#异常的概念\" class=\"headerlink\" title=\"异常的概念\"></a>异常的概念</h2><h3 id=\"介绍-10\"><a href=\"#介绍-10\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>java语言中，将程序执行中发生的不正常情况成为“异常”。（开发过程中的语法错误和逻辑错误不属于异常）</p>\n<p>执行过程中所发生的异常事件可分为两类</p>\n<ol>\n<li>Error（错误）：java虚拟机无法解决的严重问题。例如：JVM系统内部错误，资源耗尽等严重情况。例：StackOverflowError[栈溢出]和OOM（out of memory),Error是严重错误，程序会崩溃。</li>\n<li>Exception：因为，其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对想的代码进行处理，例如空指针访问，视图读取不存在的文件，网络连接中断等等，Exception分为两大类，运行时异常[程序运行发生的异常]和编译时异常[编译时，编译器查出的异常]</li>\n</ol>\n<h2 id=\"异常体系图（重要）\"><a href=\"#异常体系图（重要）\" class=\"headerlink\" title=\"异常体系图（重要）\"></a>异常体系图（重要）</h2><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411214601035.png\" alt=\"image-20220411214601035\"></p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411215335526.png\" alt=\"image-20220411215335526\"></p>\n<p>小结：</p>\n<ol>\n<li><p>异常分为两大类，运行时异常和编译时异常</p>\n</li>\n<li><p>运行时异常，编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该避免出现的异常。java.lang.RuntimeException类及它的子类都是运行程序</p>\n</li>\n<li><p>对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影像</p>\n</li>\n<li><p>编译时异常，是编译器要求必须处置的异常</p>\n</li>\n</ol>\n<h2 id=\"常见的异常\"><a href=\"#常见的异常\" class=\"headerlink\" title=\"常见的异常\"></a>常见的异常</h2><h3 id=\"常见的运行异常\"><a href=\"#常见的运行异常\" class=\"headerlink\" title=\"常见的运行异常\"></a>常见的运行异常</h3><h4 id=\"1）NullPoniterException-空指针异常\"><a href=\"#1）NullPoniterException-空指针异常\" class=\"headerlink\" title=\"1）NullPoniterException 空指针异常\"></a>1）NullPoniterException 空指针异常</h4><ol>\n<li>当程序试图在需要对象的地方使用 null时，抛出该异常</li>\n</ol>\n<h4 id=\"2-ArithmeticException数字运算异常\"><a href=\"#2-ArithmeticException数字运算异常\" class=\"headerlink\" title=\"2 ) ArithmeticException\t数字运算异常\"></a>2 ) ArithmeticException\t数字运算异常</h4><ol>\n<li>当出现异常的运行条件时，抛出此异常</li>\n<li>例如 一个整数”除以零”时，抛出此类的一个实例</li>\n</ol>\n<h4 id=\"3）ArrayIndexOutOfBoundsException数组下标异常\"><a href=\"#3）ArrayIndexOutOfBoundsException数组下标异常\" class=\"headerlink\" title=\"3）ArrayIndexOutOfBoundsException\t数组下标异常\"></a>3）ArrayIndexOutOfBoundsException\t数组下标异常</h4><ol>\n<li>用非法索引访问数组时抛出的异常，如果索引为负或者大于等于数组大小，则该索引为非法索引</li>\n</ol>\n<h4 id=\"4）ClassCastException类型转换异常\"><a href=\"#4）ClassCastException类型转换异常\" class=\"headerlink\" title=\"4）ClassCastException\t类型转换异常\"></a>4）ClassCastException\t类型转换异常</h4><ol>\n<li>当试图将对象强制转换为不是实例的子类时，抛出该异常</li>\n</ol>\n<h4 id=\"5）NumberFormatException数字格式不正确异常\"><a href=\"#5）NumberFormatException数字格式不正确异常\" class=\"headerlink\" title=\"5）NumberFormatException\t数字格式不正确异常[]\"></a>5）NumberFormatException\t数字格式不正确异常[]</h4><ol>\n<li>当应用程序试图将字符串转换成一种数值类型，但该字符不能转换为适当格式时，抛出该异常</li>\n<li>使用该异常我们可以确保输入的是满足条件的数字</li>\n</ol>\n<h3 id=\"常见的编译异常\"><a href=\"#常见的编译异常\" class=\"headerlink\" title=\"常见的编译异常\"></a>常见的编译异常</h3><h4 id=\"介绍-11\"><a href=\"#介绍-11\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>编译异常是指在编译期间。就必须处理的异常，否则代码不能通过编译</p>\n<h4 id=\"常见的编译异常-1\"><a href=\"#常见的编译异常-1\" class=\"headerlink\" title=\"常见的编译异常\"></a>常见的编译异常</h4><ol>\n<li>SQLException\t&#x2F;&#x2F;操作数据库时，查询表可能发生的异常</li>\n<li>IOException\t\t&#x2F;&#x2F;操作文件时，发生的异常</li>\n<li>FileNotFoundException\t&#x2F;&#x2F;当操作一个不存在的文件时，发生异常</li>\n<li>ClassNotFoundException\t&#x2F;&#x2F;加载类，该类不存在时，异常</li>\n<li>EOFException\t\t&#x2F;&#x2F;操作文件，到文件末尾，发生异常</li>\n<li>IIIegalArguementException\t&#x2F;&#x2F;参数异常</li>\n</ol>\n<h2 id=\"异常处理概念\"><a href=\"#异常处理概念\" class=\"headerlink\" title=\"异常处理概念\"></a>异常处理概念</h2><h3 id=\"基本介绍-2\"><a href=\"#基本介绍-2\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>异常处理就是当异常发生时，对异常处理的方式</p>\n<h3 id=\"异常处理方式\"><a href=\"#异常处理方式\" class=\"headerlink\" title=\"异常处理方式\"></a>异常处理方式</h3><h4 id=\"1）try-catch-finally\"><a href=\"#1）try-catch-finally\" class=\"headerlink\" title=\"1）try-catch-finally\"></a>1）try-catch-finally</h4><p>程序员在代码中捕获发生的异常，自行处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\t代码/可能有异常</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\"><span class=\"comment\">//捕获的异常，传给e</span></span><br><span class=\"line\"><span class=\"comment\">//1.当异常发生时</span></span><br><span class=\"line\"><span class=\"comment\">//2.系统将异常封装成Exception对象e，传递给catch</span></span><br><span class=\"line\"><span class=\"comment\">//3.得到异常对象后，程序员自己处理</span></span><br><span class=\"line\"><span class=\"comment\">//4.如果没有发生异常，则catch代码块不执行</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不管try代码块是否有异常发生，始终都要执行finally</span></span><br><span class=\"line\">    <span class=\"comment\">//通常将释放资源的代码方法finally代码块中</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2）throws\"><a href=\"#2）throws\" class=\"headerlink\" title=\"2）throws\"></a>2）throws</h4><p>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p>\n<h5 id=\"处理机制图\"><a href=\"#处理机制图\" class=\"headerlink\" title=\"处理机制图\"></a>处理机制图</h5><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220411224543192.png\" alt=\"image-20220411224543192\"></p>\n<p>throws处理机制</p>\n<ol>\n<li>try-catch-finally和throws二选一</li>\n<li>如果程序员，没有显示是处理异常，默认throws</li>\n</ol>\n<h2 id=\"异常处理分类\"><a href=\"#异常处理分类\" class=\"headerlink\" title=\"异常处理分类\"></a>异常处理分类</h2><h3 id=\"try-catch方式处理异常说明\"><a href=\"#try-catch方式处理异常说明\" class=\"headerlink\" title=\"try-catch方式处理异常说明\"></a>try-catch方式处理异常说明</h3><h4 id=\"1）java提供try和catch块来处理异常。\"><a href=\"#1）java提供try和catch块来处理异常。\" class=\"headerlink\" title=\"1）java提供try和catch块来处理异常。\"></a>1）java提供try和catch块来处理异常。</h4><p>try块用于包含可能出错的代码块。catch用于处理try块中发生的异常，可以根据需要在程序中有多个数量的try…catch块</p>\n<h4 id=\"2）基本语法\"><a href=\"#2）基本语法\" class=\"headerlink\" title=\"2）基本语法\"></a>2）基本语法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//可疑代码</span></span><br><span class=\"line\"><span class=\"comment\">//将异常生成对应的异常对象，传递给catch块</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(异常)&#123;</span><br><span class=\"line\"><span class=\"comment\">//对异常的处理</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//没有finally是可以通过的</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用案例</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;糖&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">a</span>  <span class=\"operator\">=</span> Integer.parseInt(str);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;数字=&quot;</span>+a);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;异常信息=&quot;</span>+e.getMessage());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意事项-6\"><a href=\"#注意事项-6\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ol>\n<li><p>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块</p>\n</li>\n<li><p>如果异常没有发生，则顺序执行try代码块，不会进入到catch块</p>\n</li>\n<li><p>如果希望不管是否能发生异常，都执行某段代码块（比如关闭链接，释放资源等）、</p>\n</li>\n<li><p>可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求是父类异异常在后，子类异常在前，比如（Exception 在后，NullPointerException 在前）如果发生异常，只会匹配一个catch</p>\n<ol>\n<li><p>&#96;&#96;&#96;java<br>例:<br>try{</p>\n<p>}catch(NullPointerException e){</p>\n<p>}catch(Exception e){</p>\n<p>}finally{</p>\n<p>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. 可以记性try-finally配合使用，这种方法相当于没有捕获异常，因此程序会直接崩掉</span><br><span class=\"line\"></span><br><span class=\"line\">   1. 应用场景：就是执行一段代码，不论是否发生异常，都必须执行某个业务逻辑</span><br><span class=\"line\"></span><br><span class=\"line\">#### 小结</span><br><span class=\"line\"></span><br><span class=\"line\">1. 如果没有出现异常，则执行try块中所有语句，不执行catch块中的语句，如果有finally，最后还要执行finally语句</span><br><span class=\"line\">2. 如果出现异常，则try块异常发生后，剩下的语句不在执行，将执行catch块中的语句，如果有finally，最后还要执行finally里面的语句</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### throws异常处理</span><br><span class=\"line\"></span><br><span class=\"line\">#### 介绍：</span><br><span class=\"line\"></span><br><span class=\"line\">1）如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理异常，则此方法应显示的声明抛出异常，表明该方法将不对这些异常进行处理，而且由该方法的调用者负责处理</span><br><span class=\"line\"></span><br><span class=\"line\">2）在方法声明throws语句可以声明排除异常的列表，throws后面的异常类型可以是方法产生的异常类型，也可以是它的父类</span><br><span class=\"line\"></span><br><span class=\"line\">#### 注意事项</span><br><span class=\"line\"></span><br><span class=\"line\">1. 对于编译异常，程 序必须处理，比如try-catch或者throws</span><br><span class=\"line\">2. 对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</span><br><span class=\"line\">3. 子类重写父类的方法是，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一直，要么为父类抛出的异常的类型和子类型</span><br><span class=\"line\">4. 在throws过程中，如果有try-catch，就相当于处理异常，就可以不必throws</span><br><span class=\"line\">5. ![image-20220412135104986](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412135104986.png)</span><br><span class=\"line\">6. </span><br><span class=\"line\"></span><br><span class=\"line\">## 自定义异常  </span><br><span class=\"line\"></span><br><span class=\"line\">### 介绍：</span><br><span class=\"line\"></span><br><span class=\"line\">当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述错误信息。</span><br><span class=\"line\"></span><br><span class=\"line\">### 自定义异常的步骤</span><br><span class=\"line\"></span><br><span class=\"line\">1. 定义类：自定义异常类名（程序员自己写）继承Exceotion或RuntimeException</span><br><span class=\"line\">2. 如果继承Ecxeption，属于编译异常</span><br><span class=\"line\">3. 如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">//当我们接受Person对象年龄时，要求范围在18-120之间，否则抛出一个自定义异常（要求继承RuntimeException），并提示</span><br><span class=\"line\">public class CustomException &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int age =30;</span><br><span class=\"line\">//        结果取反</span><br><span class=\"line\">        if (!(age&gt;=18&amp;&amp;age&lt;=120))&#123;</span><br><span class=\"line\">//            通过构造器设置输出信息</span><br><span class=\"line\">            throw new AgeException(&quot;年龄需要在18-120之间&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;你的年龄为&quot;+age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//定义一个异常类继承RuntimeException</span><br><span class=\"line\">//一般情况下，我们自定义异常都继承RuntimeException</span><br><span class=\"line\">//也就是说大都是定义为运行时异常，好处是我们可以使用默认处理机制</span><br><span class=\"line\">//即比较方便</span><br><span class=\"line\">class AgeException extends RuntimeException&#123;</span><br><span class=\"line\">//    定义一个构造器</span><br><span class=\"line\">    public AgeException(String message) &#123;</span><br><span class=\"line\">        super(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"throw和throws的对比\"><a href=\"#throw和throws的对比\" class=\"headerlink\" title=\"throw和throws的对比\"></a>throw和throws的对比</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>意义</th>\n<th>位置</th>\n<th align=\"center\">后面跟的东西</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>throws</td>\n<td>异常处理的一种方式</td>\n<td>方法声明处</td>\n<td align=\"center\">异常类型</td>\n</tr>\n<tr>\n<td>throw</td>\n<td>手动生成异常对象的关键字</td>\n<td>方法体中</td>\n<td align=\"center\">异常对象</td>\n</tr>\n</tbody></table>\n<p>throws</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">xxx</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">    <span class=\"comment\">//throws通常放在定义方法的末尾</span></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>throw</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//throw后面跟的是异常对象</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AgeException</span>(<span class=\"string\">&quot;年龄需要在18-120之间&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h1><h2 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h2><h3 id=\"包装类的分类-Wrapper\"><a href=\"#包装类的分类-Wrapper\" class=\"headerlink\" title=\"包装类的分类   Wrapper\"></a>包装类的分类   Wrapper</h3><p>1、针对八种基本数据类型相应类型的引用类型—包装类</p>\n<p>2、有了类的特点，就可以调用类中的方法</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">基本数据类型</th>\n<th align=\"center\">包装类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">Boolean</td>\n</tr>\n<tr>\n<td align=\"center\">char</td>\n<td align=\"center\">Character</td>\n</tr>\n<tr>\n<td align=\"center\">byte</td>\n<td align=\"center\"><code>Byte</code></td>\n</tr>\n<tr>\n<td align=\"center\">short</td>\n<td align=\"center\"><code>Short</code></td>\n</tr>\n<tr>\n<td align=\"center\">int</td>\n<td align=\"center\"><code>Integer</code></td>\n</tr>\n<tr>\n<td align=\"center\">long</td>\n<td align=\"center\"><code>Long</code></td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\"><code>Float</code></td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\"><code>Doble</code></td>\n</tr>\n</tbody></table>\n<p>上述标出来的6个数据类型父类均为Number</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220412164154544.png\" alt=\"image-20220412164154544\"></p>\n<h3 id=\"包装类和基本数据的转换\"><a href=\"#包装类和基本数据的转换\" class=\"headerlink\" title=\"包装类和基本数据的转换\"></a>包装类和基本数据的转换</h3><h4 id=\"案例-1\"><a href=\"#案例-1\" class=\"headerlink\" title=\"案例\"></a>案例</h4><p>演示包装类和基本数据类型的相互转换，以int和integer演示</p>\n<p>1）jdk5前的手动装箱和拆箱方式，装箱：基本类型-&gt;包装类型,反之拆箱</p>\n<p>2）jdk5以后（包括jdk5）的自动装箱和拆箱方式</p>\n<p>3）自动装箱底层调用的是valueOf方法，比如integer.valueOf();</p>\n<p>4）其他类型同理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本类型——————&gt;包装类型[手动装箱]</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(i);</span><br><span class=\"line\"><span class=\"type\">integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> Integer.value(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//包装类型————————&gt;基本类型[手动拆箱]</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">99</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">j1</span> <span class=\"operator\">=</span> j.intValue();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//jdk5.0之后的方式</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">m2</span> <span class=\"operator\">=</span>m;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">99</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> n;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;n+100&quot;</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;n*2&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(n&gt;<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"包装类型和String类型的相互转换\"><a href=\"#包装类型和String类型的相互转换\" class=\"headerlink\" title=\"包装类型和String类型的相互转换\"></a>包装类型和String类型的相互转换</h3><h4 id=\"案例-2\"><a href=\"#案例-2\" class=\"headerlink\" title=\"案例\"></a>案例</h4><p>以integer和String转为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//包装类型----&gt;String类型</span></span><br><span class=\"line\"><span class=\"type\">integer</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">//方式1</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> i.toString();</span><br><span class=\"line\"><span class=\"comment\">//方式2</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> String.valueOf(i);</span><br><span class=\"line\"><span class=\"comment\">//方式3</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s3</span> <span class=\"operator\">=</span> i+<span class=\"string\">&quot;&quot;</span>; </span><br><span class=\"line\">System.out.println(s3);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//String ---&gt;包装类</span></span><br><span class=\"line\"><span class=\"comment\">//方式1</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(s1);</span><br><span class=\"line\"><span class=\"comment\">//方式2</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">j2</span> <span class=\"operator\">=</span> Integer.valueOf(s2);</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">Integer.parseInt(s3);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Integer类和Character类常方法\"><a href=\"#Integer类和Character类常方法\" class=\"headerlink\" title=\"Integer类和Character类常方法\"></a>Integer类和Character类常方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.MIN_VALUE <span class=\"comment\">//返回最小值</span></span><br><span class=\"line\">Integer.MAX_VALUE <span class=\"comment\">//返回最大值</span></span><br><span class=\"line\"></span><br><span class=\"line\">Character.isDigit(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//判断是不是数字</span></span><br><span class=\"line\">Character.isLetter(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//判断是不是字母</span></span><br><span class=\"line\">Character.isUpperCase(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//判断是不是大写</span></span><br><span class=\"line\">Character.inLowerCase(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//判断是不是小写</span></span><br><span class=\"line\"></span><br><span class=\"line\">Character.isWhitespace(<span class=\"string\">&#x27;a&#x27;</span>)；<span class=\"comment\">//判断是不是空格</span></span><br><span class=\"line\">Character.toUpperCase(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//转成大写</span></span><br><span class=\"line\">Character.toLowerCase(<span class=\"string\">&#x27;a&#x27;</span>);<span class=\"comment\">//转成小写</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Integer面试题\"><a href=\"#Integer面试题\" class=\"headerlink\" title=\"Integer面试题\"></a>Integer面试题</h3><p>1.看代码输出什么，为啥</p>\n<ol>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164815801.png\" alt=\"image-20220413164815801\"></p>\n</li>\n<li><p>因为integer的原码定义好了从-128-127之间不返回一个对象</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413164729185.png\" alt=\"image-20220413164729185\"></p>\n<p>2.integer面试题总结</p>\n<p>看下列代码输出什么结果</p>\n<p><span style=\"color:red;background:yellow \" >只要有基本数据类型会自动拆箱，比对的是数值。判断的是值是否相等</span></p>\n<p>如下的示例六和七，比对的是</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413205739995.png\" alt=\"image-20220413205739995\"></p>\n</li>\n</ol>\n<h2 id=\"String-重要\"><a href=\"#String-重要\" class=\"headerlink\" title=\"String(重要)\"></a>String(重要)</h2><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220413213320195.png\" alt=\"image-20220413213320195\"></p>\n<p>String实现了三个接口并继承了Object类</p>\n<ul>\n<li>Serializable接口：说明String可以串行化。（可以在网络传输）</li>\n<li>Comparable接口：说明String对象可以相互比较</li>\n<li>CharSequence接口：字符序列</li>\n</ul>\n<p><span style=\"color:blue;background:pink\">String类是final类，String类不能被其他类继承</span></p>\n<p><span style=\"color:blue;background:pink\">String 有属性，private final char value[];用于存放字符串内容（字符串的本质就是char数组）</span></p>\n<p><span style=\"color:red;background:pink\">(注意：value是一个final类型，不可修改（即：value不能指向新的地址，但是单个字符内容时可以变化的）)</span></p>\n<h3 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h3><p>1）String对象用于保存字符串，也就是一组字符序列</p>\n<p>2）字符串常量对象时用双引号括起来的字符序列。例如：”你好”，”21.213”，”boy”等等</p>\n<p>3）字符串的字符使用Unicode字符编码，一个字符（不区分字幕还是汉字）占两个字节</p>\n<p>4）String类较常用的构造方法（其他手册）</p>\n<ul>\n<li>String s1 &#x3D; new String();</li>\n<li>String s2 &#x3D; new String(String original);</li>\n<li>String s3 &#x3D; new String(char[] a);</li>\n<li>String s4 &#x3D; new String(char[] a,int startIndex, int count)</li>\n</ul>\n<h3 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h3><h4 id=\"1）方式一：直接赋值String-s-x3D-“xxx”\"><a href=\"#1）方式一：直接赋值String-s-x3D-“xxx”\" class=\"headerlink\" title=\"1）方式一：直接赋值String s &#x3D; “xxx”;\"></a>1）方式一：直接赋值String s &#x3D; “xxx”;</h4><p>创建流程：</p>\n<p>先从常量池查看是否有”xxx”数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</p>\n<h4 id=\"2）方式二：调用构造器-String-s-x3D-new-String-“xxx”-；\"><a href=\"#2）方式二：调用构造器-String-s-x3D-new-String-“xxx”-；\" class=\"headerlink\" title=\"2）方式二：调用构造器 String s &#x3D; new String(“xxx”)；\"></a>2）方式二：调用构造器 String s &#x3D; new String(“xxx”)；</h4><p>流程：现在堆中创建空间，里面维护了value属性，指向常量池的xxx空间。如果常量池没有”xxx”，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414101904944.png\" alt=\"image-20220414101904944\"></p>\n<h3 id=\"String字符串的特性\"><a href=\"#String字符串的特性\" class=\"headerlink\" title=\"String字符串的特性\"></a>String字符串的特性</h3><p>1）String是一个final类，代表不可变的字符序列</p>\n<p>2）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的 </p>\n<h4 id=\"面试题、\"><a href=\"#面试题、\" class=\"headerlink\" title=\"面试题、\"></a>面试题、</h4><p>1）String a &#x3D; “hello”+”abc”;创建了几个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编译器会在后台会进行优化，判断创建的常量池对象，是否有引用指向</span><br><span class=\"line\">优化等价于<span class=\"type\">String</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;helloabc&quot;</span>；</span><br><span class=\"line\"></span><br><span class=\"line\">所以答案是创建了一个对象</span><br><span class=\"line\">不是创建了三个</span><br></pre></td></tr></table></figure>\n\n<p>2）String a &#x3D; “hello”;</p>\n<p>String b &#x3D; “abc”;</p>\n<p>String c &#x3D; a+b;</p>\n<p>总共创建了几个对象</p>\n<p>所以只创建了一个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行流程</span><br><span class=\"line\"><span class=\"number\">1.</span> 先创建了一个<span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> StringBuilder();</span><br><span class=\"line\"><span class=\"number\">2.</span>执行sb.append(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"><span class=\"number\">3.</span>sb.append(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\"><span class=\"number\">4.</span><span class=\"type\">String</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> sb.toString();</span><br><span class=\"line\">最后其实是c指向了堆中的对象（String）value[],堆中的对象指向了池中的“helloabc”</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414140922725.png\" alt=\"image-20220414140922725\"></p>\n<p>小结:底层是StringBuilder sb &#x3D; new StringBuilder();sb.append(a);sb.append(b);sb是在堆中，并append是在原来的字符串的基础上追加的。</p>\n<p>重要规则：String c1 &#x3D; “sb”+”cd”;常量相加，看的是池。String c1 &#x3D; a+b;变量相加，是在堆中</p>\n<h3 id=\"String类的常见方法\"><a href=\"#String类的常见方法\" class=\"headerlink\" title=\"String类的常见方法\"></a>String类的常见方法</h3><h4 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h4><p>​\tString类是保存字符串常量的。每次更新都需要重新开辟空间，效率低，因此java设计者还提供StringBuilder和StringBuffer来增强String的功能，并提高效率。</p>\n<h4 id=\"Strng常见的方法\"><a href=\"#Strng常见的方法\" class=\"headerlink\" title=\"Strng常见的方法\"></a>Strng常见的方法</h4><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220414145929644.png\" alt=\"image-20220414145929644\"></p>\n<ul>\n<li><p>equals\t\t&#x2F;&#x2F;区分大小写，判断是否相等</p>\n</li>\n<li><p>equalsIgnoreCase   &#x2F;&#x2F;忽略大小写，判断内容是否相等</p>\n</li>\n<li><p>length  &#x2F;&#x2F;获取字符的个数，字符窜长度                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </p>\n</li>\n<li><p>indexOf  &#x2F;&#x2F;获取字符在字符串中第一次出现的索引，索引从0开始，如果找不到返回-1</p>\n</li>\n<li><p>lastIndexOf   &#x2F;&#x2F;获取字符在字符串中最后一次出现的索引，索引从0开始，如果找不到，返回-1</p>\n</li>\n<li><p>substring &#x2F;&#x2F;截取指定范围字符串</p>\n</li>\n<li><p>trim  &#x2F;&#x2F;去前后空格</p>\n</li>\n<li><p>charAt &#x2F;&#x2F;获取某索引处的字符，之一不能使用Str[index]这种方式</p>\n</li>\n<li><p>toUpperCase  &#x2F;&#x2F;字符串转换成大写</p>\n</li>\n<li><p>toLowerCase  &#x2F;&#x2F;字符串转换成小写</p>\n</li>\n<li><p>concat  &#x2F;&#x2F;拼接字符串</p>\n</li>\n<li><p>replace  替换字符串中字符</p>\n</li>\n<li><p>split 分割字符串，罪域某些分割字符，我们需要转义</p>\n<p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">poem</span> <span class=\"operator\">=</span><span class=\"string\">&quot;锄禾日当午，汗滴禾下土，谁知盘中餐，粒粒皆辛苦&quot;</span>;</span><br><span class=\"line\">String[] split = poem.split(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//以，号为标准，分割上述整个字符串</span></span><br><span class=\"line\"><span class=\"comment\">//上述字符串被分割为4个部分用数组接收</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在堆字符串进行分割时，如f</span></span><br><span class=\"line\">poem = <span class=\"string\">&quot;E:\\\\aaa\\\\bbb&quot;</span>;</span><br><span class=\"line\">split  = poem.split(<span class=\"string\">&quot;\\\\\\\\&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>和 文件路径</p>\n</li>\n<li><p>compareTo &#x2F;&#x2F;比较两个字符串的大小，如果前者大则返回正数，如果后者大则返回负数，</p>\n<p>如果相等（</p>\n<p>1.如果长度相同，并且字符串也相同返回0。</p>\n<p>2.如果长度相同或者不相同，但是在进行比较时，可以区分大小就返回if(c1 !&#x3D; c2）{</p>\n<p>​\t\treturn c1 - c2;</p>\n<p>}</p>\n<p>3.如果前面的部分都相同，就返回str1.len - str2.len）</p>\n</li>\n<li><p>toCharArray &#x2F;&#x2F;字符串转成字符数组</p>\n</li>\n<li><p>format&#x2F;&#x2F;格式化字符串，%s字符串，%c字符，%d 整型，%.2f 浮点型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  %s%d%.2f%c成为占位符</span></span><br><span class=\"line\"><span class=\"comment\">//  这些占位符由后面的变量来替换</span></span><br><span class=\"line\"><span class=\"comment\">//  %s表示后面由字符串替换</span></span><br><span class=\"line\"><span class=\"comment\">//  %d表示整数替换</span></span><br><span class=\"line\"><span class=\"comment\">//  %.2f表示使用小数来替换，替换后，只会保留小数两位，并且会进行四舍五入的处理</span></span><br><span class=\"line\"><span class=\"comment\">//  %c是char类型替换</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span><span class=\"string\">&quot;jack&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">double</span> <span class=\"variable\">score</span> <span class=\"operator\">=</span> <span class=\"number\">98.3</span> /<span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> <span class=\"variable\">gender</span> <span class=\"operator\">=</span><span class=\"string\">&#x27;男&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//传统方法拼接</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">info</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;名字是&quot;</span>+name+<span class=\"string\">&quot;年龄是&quot;</span>+age+<span class=\"string\">&quot;成绩是&quot;</span>+score+<span class=\"string\">&quot;性别：&quot;</span>+gender<span class=\"string\">&quot;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">//使用format拼接</span></span><br><span class=\"line\"><span class=\"string\">String info2 =String.format(&quot;</span>姓名是%s年龄是%d成绩是%d性别时%c<span class=\"string\">&quot;,name,age,score,gender);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">//可以做成一个模板后面直接调用</span></span><br><span class=\"line\"><span class=\"string\">String formatstr = &quot;</span>姓名是%s年龄是%d成绩是%d性别时%c<span class=\"string\">&quot;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">String info2 =String.format(formatstr,name,age,score,gender);</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">System.out.println(&quot;</span>info2 =<span class=\"string\">&quot;+info2);</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"StringBuffer-重要\"><a href=\"#StringBuffer-重要\" class=\"headerlink\" title=\"StringBuffer(重要)\"></a>StringBuffer(重要)</h2><p><span style=\"color:red;background:pink\">串行化（对象可以网络传输，可以保存到文件）</span></p>\n<h3 id=\"基本介绍-3\"><a href=\"#基本介绍-3\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>java.lang.StringBuffer代表可变字符序列，可以对字符串内容进行增删</p>\n<p>很多方法与String相同，但StringBuffer是可变长度的</p>\n<p>StringBuffer是一个容器</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415090614911.png\" alt=\"image-20220415090614911\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">StringBuffer</span> <span class=\"variable\">stringBuffer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//1.StringBuffer 的直接父类是 AbstractStringBuilder</span></span><br><span class=\"line\"><span class=\"comment\">//2.StringBuffer 实现了Serializable，即StringBuffer的对象可以串行化</span></span><br><span class=\"line\"><span class=\"comment\">//3.在父类中，AbstractStringBuilder 有属性 char[] value ，不是final</span></span><br><span class=\"line\">\t该value 数组存放祖父穿内容，因数存放在堆中的</span><br><span class=\"line\"><span class=\"comment\">//4.StringBuffer是一个final类， 不能被继承</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"String-对比StringBuffer\"><a href=\"#String-对比StringBuffer\" class=\"headerlink\" title=\"String 对比StringBuffer\"></a>String 对比StringBuffer</h3><p>1）String保存的是字符串常量，里面的值不能更改，每次String类的更新实际是更改地址，效率较低&#x2F;&#x2F;private final char value[]；</p>\n<p>2）StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用更新地址，效率较高&#x2F;&#x2F;char[] value &#x2F;&#x2F;这个放在堆</p>\n<h3 id=\"StringBuffer构造器\"><a href=\"#StringBuffer构造器\" class=\"headerlink\" title=\"StringBuffer构造器\"></a>StringBuffer构造器</h3><p>StringBuffer()</p>\n<ul>\n<li><p>构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;创建一个大小为16的char[]，用于存放字符串内容<br>StringBuffer stringBuffer &#x3D; new StringBuffer();</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">StringBuffer(CharSequence seq)</span><br><span class=\"line\"></span><br><span class=\"line\">* public java.lang.StringBuffer(CharSequence seq)构造一个字符串缓冲区，它包含与指定的CharSequence 相同的字符</span><br><span class=\"line\"></span><br><span class=\"line\">StringBuffer(int capacity)//capacity[容量]</span><br><span class=\"line\"></span><br><span class=\"line\">* 构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对char[]大小进行指定</span><br><span class=\"line\"></span><br><span class=\"line\">* ```java</span><br><span class=\"line\">  //通过构造器指定 char[]大小</span><br><span class=\"line\">  StringBuffer stringBuffer = new StringBuffer(100);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>StringBuffer(String str)</p>\n<ul>\n<li><p>构造一个字符串缓冲器，并将其内容初始化为指定的字符串内容</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;通过给一个String 创建StringBuffer,char[] 大小就是str.length()+16<br>StringBuffer stringBuffer &#x3D; new StringBuffer(“hello”);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### String和StringBuffer</span><br><span class=\"line\"></span><br><span class=\"line\">#### String-&gt;StringBuffer</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">//        String-&gt;StringBuffer</span><br><span class=\"line\">//        方式一</span><br><span class=\"line\">        String str =&quot;xxx&quot;;</span><br><span class=\"line\">//        注意：返回的是StringBuffer对象，对str本身是没有影响的</span><br><span class=\"line\">        StringBuffer stringBuffer = new StringBuffer(str);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//        方式二，使用append方法</span><br><span class=\"line\">        StringBuffer stringBuffer1 = new StringBuffer();</span><br><span class=\"line\">        stringBuffer1 = stringBuffer1.append(str);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"StringBuffer-gt-String\"><a href=\"#StringBuffer-gt-String\" class=\"headerlink\" title=\"StringBuffer-&gt;String\"></a>StringBuffer-&gt;String</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        StringBuffer-&gt;String</span></span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">stringBuffer2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(<span class=\"string\">&quot;xxxxxx&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        方式一,使用StringBuffer提供的 toString方法;</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> stringBuffer2.toString();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        方式二,使用构造器搞定</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(stringBuffer2);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"StirngBuffer类常见方法\"><a href=\"#StirngBuffer类常见方法\" class=\"headerlink\" title=\"StirngBuffer类常见方法\"></a>StirngBuffer类常见方法</h3><ol>\n<li>增 append</li>\n<li>删 delete(start,end)</li>\n<li>改 replace(start,end,string)&#x2F;&#x2F;将start—end间的内容替换掉，不含end</li>\n<li>查 indexOf &#x2F;&#x2F;查询字符串第1次出现的索引，如果找不回返回-1</li>\n<li>插 insert</li>\n<li>获取长度 length</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       <span class=\"type\">StringBuffer</span> <span class=\"variable\">stringBuffer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        stringBuffer.append(<span class=\"string\">&#x27;x&#x27;</span>);</span><br><span class=\"line\">        stringBuffer.append(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">        stringBuffer.append(<span class=\"string\">&quot;wangwu&quot;</span>).append(<span class=\"literal\">true</span>).append(<span class=\"number\">10.2</span>);</span><br><span class=\"line\">        System.out.println(stringBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        删除</span></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        * 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span></span><br><span class=\"line\"><span class=\"comment\">        * 解读：删除11~14的字符[11,14)</span></span><br><span class=\"line\"><span class=\"comment\">        * */</span></span><br><span class=\"line\">        stringBuffer.delete(<span class=\"number\">11</span>,<span class=\"number\">14</span>);</span><br><span class=\"line\">        System.out.println(stringBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//    改</span></span><br><span class=\"line\"><span class=\"comment\">//        修改本质就是替换</span></span><br><span class=\"line\"><span class=\"comment\">//        使用fff替换索引11-14的字符</span></span><br><span class=\"line\">        stringBuffer.replace(<span class=\"number\">11</span>,<span class=\"number\">14</span>,<span class=\"string\">&quot;fff&quot;</span>);</span><br><span class=\"line\">        System.out.println(stringBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        查</span></span><br><span class=\"line\"><span class=\"comment\">//        查找指定的子串在字符串出现的索引.如果找不到返回-1</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> stringBuffer.indexOf(<span class=\"string\">&quot;zhang&quot;</span>);</span><br><span class=\"line\">        System.out.println(index);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        插入</span></span><br><span class=\"line\"><span class=\"comment\">//        指定一个位置插入</span></span><br><span class=\"line\"><span class=\"comment\">//        在索引为9的位置插入&quot;老王&quot;，原来索引为9的内容自动后移</span></span><br><span class=\"line\">        stringBuffer.insert(<span class=\"number\">9</span>,<span class=\"string\">&quot;老王&quot;</span>);</span><br><span class=\"line\">        System.out.println(stringBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        获取长度</span></span><br><span class=\"line\">        System.out.println(stringBuffer.length());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 输入商品名称和商品价格，要求打印效果示例，实用前面学习的方法完成</span></span><br><span class=\"line\"><span class=\"comment\">         * 商品名  商品价格</span></span><br><span class=\"line\"><span class=\"comment\">         * 手机123，456.56  //比如 价格价格1,456,786.5</span></span><br><span class=\"line\"><span class=\"comment\">         * 要求：价格的小数点前面每三位用,号隔开，再输出</span></span><br><span class=\"line\"><span class=\"comment\">        * */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String prices;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">price</span> <span class=\"operator\">=</span> scanner.next();</span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">stringBuffer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>(price);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        先完成最简单的实现21,312,412.32</span></span><br><span class=\"line\"><span class=\"comment\">//        找到小数点的索引,然后再该位置的前三位插入,</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> stringBuffer.lastIndexOf(<span class=\"string\">&quot;.&quot;</span>)-<span class=\"number\">3</span>; j &gt;<span class=\"number\">0</span> ; j-=<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            stringBuffer = stringBuffer.insert(j, <span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(stringBuffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"StringBuilder-重要\"><a href=\"#StringBuilder-重要\" class=\"headerlink\" title=\"StringBuilder(重要)\"></a>StringBuilder(重要)</h2><h3 id=\"基本介绍-4\"><a href=\"#基本介绍-4\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>1）一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(StringBuilder 不是线程安全)。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快（单线程的情况下，优先使用StringBuilder）</p>\n<p>2）在StringBuilder上主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据</p>\n<h3 id=\"StringBuilder常用方法\"><a href=\"#StringBuilder常用方法\" class=\"headerlink\" title=\"StringBuilder常用方法\"></a>StringBuilder常用方法</h3><p>StringBuilder和StringBuffer均代表可变字符序列，方法是一样的，所以使用和StringBuffer一样。</p>\n<ol>\n<li>StringBuilder是final类，不能被继承</li>\n<li>StringBuilder对象可以串行化</li>\n<li>继承了AbstractStringBuilder属性 char[] value，内容存到value</li>\n<li>实现了Serializable接口，序列化（所谓系列化既可以保存类型和数据本身）</li>\n</ol>\n<h2 id=\"String、StringBuffer、StringBuilder的比较☆\"><a href=\"#String、StringBuffer、StringBuilder的比较☆\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder的比较☆\"></a>String、StringBuffer、StringBuilder的比较☆</h2><p>1）StringBuilder和StringBuffer非常类似，均代表可变字符序列，而且方法也一样</p>\n<p>2）String：不可变字符序列，效率低，但是复用率高。</p>\n<p>3）StringBuffer：可变字符序列、效率较高（增删）、线程安全</p>\n<p>4）StringBuilder：可变字符序列、效率最高、线程不安全</p>\n<p>5）String使用注意事项：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s=<span class=\"string\">&quot;a&quot;</span>; <span class=\"comment\">//创建了一个字符串</span></span><br><span class=\"line\">s+= <span class=\"string\">&quot;b&quot;</span>;   <span class=\"comment\">//实际上原来的&quot;a&quot;字符串对象已经丢弃了，现在又产生了一个转字符串s+&quot;b&quot;（也就是&quot;ab&quot;).如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=》</span></span><br><span class=\"line\"><span class=\"comment\">//结论：如果我们对Stirng做大量修改，不要使用String</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h3><p>StringBuilder  &gt; StringBuffer &gt;String </p>\n<h3 id=\"使用原则，结论\"><a href=\"#使用原则，结论\" class=\"headerlink\" title=\"使用原则，结论\"></a>使用原则，结论</h3><ol>\n<li>如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder</li>\n<li>如果字符串存在大量的修改操作，并且在单线程的情况下使用StringBuilder</li>\n<li>如果字符串存在大量的修改操作，并且在多线程的情况下使用StringBuffer</li>\n<li>如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等</li>\n</ol>\n<p>StringBuffer和StringBuilder的方法使用一样</p>\n<h2 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h2><h3 id=\"基本介绍-5\"><a href=\"#基本介绍-5\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>Math类包含用于执行基本数学运算方法，如初等指数，对数，平方根和三角函数</p>\n<p>方法一览（均为静态方法）<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220415145338171.png\" alt=\"image-20220415145338171\"></p>\n<h3 id=\"Match常用的方法\"><a href=\"#Match常用的方法\" class=\"headerlink\" title=\"Match常用的方法\"></a>Match常用的方法</h3><ol>\n<li><p>abs  绝对值</p>\n</li>\n<li><p>pow  求幂</p>\n</li>\n<li><p>ceil   向上取整  (返回&gt;&#x3D;该参数的最小整数)</p>\n</li>\n<li><p>floor   向下取整  (返回&lt;&#x3D;该参数的最大整数)</p>\n</li>\n<li><p>round   四舍五入</p>\n</li>\n<li><p>sqrt  求开方</p>\n</li>\n<li><p>random  求随机数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        random随机数</span></span><br><span class=\"line\"><span class=\"comment\">        random默认返回 0&lt;= x &lt;1之间的一个随机小数</span></span><br><span class=\"line\"><span class=\"comment\">        请写出a-b之间的一个随机整数，a,b均为整数比如a=2,b=7</span></span><br><span class=\"line\"><span class=\"comment\">        即返回一个2 - 7 之间的随机数</span></span><br><span class=\"line\"><span class=\"comment\">        * */</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * random返回的是0&lt;=x &lt;1之间的一个随机小数</span></span><br><span class=\"line\"><span class=\"comment\">         * Math.random()*(b-a)返回的就是0&lt;= 数 &lt;=b-a</span></span><br><span class=\"line\"><span class=\"comment\">         * (1)(int)(a)&lt;= x &lt;(int)(a+Math.random() * (b-a +1))</span></span><br><span class=\"line\"><span class=\"comment\">        * (2)集体使用解析</span></span><br><span class=\"line\"><span class=\"comment\">         * (int)(a+Math.random() * (b-a +1))</span></span><br><span class=\"line\"><span class=\"comment\">         *  = (int)(2+Math.random() * 6)</span></span><br><span class=\"line\"><span class=\"comment\">         *  Math.random() * 6返回的就是0&lt;= x &lt;6小数</span></span><br><span class=\"line\"><span class=\"comment\">         *  2+Math.random() * 6返回的就是2&lt;= x &lt;8小数</span></span><br><span class=\"line\"><span class=\"comment\">         *  (int)(2+Math.random() * 6) = 2 &lt;=x &lt;=7</span></span><br><span class=\"line\"><span class=\"comment\">        * */</span></span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//      公式就是：(int)(a+Math.random() * (b-a +1))</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println((<span class=\"type\">int</span>) (<span class=\"number\">2</span> +Math.random()*(<span class=\"number\">7</span>-<span class=\"number\">2</span>+<span class=\"number\">1</span>)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>max   求两个数的最大值</p>\n</li>\n<li><p>min    求两个数的最小值</p>\n</li>\n</ol>\n<h2 id=\"Date-Calender-LoaclDate\"><a href=\"#Date-Calender-LoaclDate\" class=\"headerlink\" title=\"Date,Calender,LoaclDate.\"></a>Date,Calender,LoaclDate.</h2><h3 id=\"Date-知道怎么查，怎么用即可\"><a href=\"#Date-知道怎么查，怎么用即可\" class=\"headerlink\" title=\"Date[知道怎么查，怎么用即可]\"></a>Date[知道怎么查，怎么用即可]</h3><h4 id=\"第一代日期类\"><a href=\"#第一代日期类\" class=\"headerlink\" title=\"第一代日期类\"></a>第一代日期类</h4><p>Date：精确到毫秒，代表特定的瞬间</p>\n<p>SimpleDateFormat：格式和解析日期的类SimpleDateFormat 格式化和解析日期的具体类。它允许进行格式（日期-&gt;文本、解析（文本-&gt;日期）和规范化</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420110144786.png\" alt=\"image-20220420110144786\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取当前时间</span></span><br><span class=\"line\"><span class=\"comment\">//默认输出的格式是国外的格式</span></span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();、</span><br><span class=\"line\"><span class=\"comment\">//因此需要对格式进行转换</span></span><br><span class=\"line\"><span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">simpleDateFormat</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//其他格式的字母意思，查看手册</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">foramt</span> <span class=\"operator\">=</span> d1.format(d1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取某个时间对应的毫秒数</span></span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">d2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(<span class=\"number\">23123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//可以吧一个格式化的字符串转成对应的date</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;2000年7月五日 20:12:20 星期一&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">pares</span> <span class=\"operator\">=</span> simpleDateFormat.parse(s);</span><br><span class=\"line\"><span class=\"comment\">//接收的格式必须个定义的格式一样</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Calendar-日历\"><a href=\"#Calendar-日历\" class=\"headerlink\" title=\"Calendar(日历)\"></a>Calendar(日历)</h3><h4 id=\"第二代日期类\"><a href=\"#第二代日期类\" class=\"headerlink\" title=\"第二代日期类\"></a>第二代日期类</h4><p>主要就是Calendar类（日历）</p>\n<p>1）public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable&lt;Calendar</p>\n<p>2)calendar类是一个抽象类，他为特定瞬间为一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等，日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建日历对象，</span></span><br><span class=\"line\"><span class=\"type\">Calendar</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span>Calendar.getInstance();</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;年&quot;</span>+c.get(Calendar.YEAR))；</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;月&quot;</span>+c.get(Calendar.MONTH)+<span class=\"number\">1</span>)；</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;日&quot;</span>+c.get(Calendar.DAY_OF_MONTH))；</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;小时&quot;</span>+c.get(Calendar.HOUR))；</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;分钟&quot;</span>+c.get(Calendar.MINUTE))；</span><br><span class=\"line\">System.out.print(<span class=\"string\">&quot;秒&quot;</span>+c.get(Calendar.SECOND))；</span><br><span class=\"line\"><span class=\"comment\">//Calendar没有专门的格式化方法，所以程序员自己组合</span></span><br><span class=\"line\">System.out.print(c.get(Calendar.SECOND)+<span class=\"string\">&quot;年&quot;</span>+(c.get(Calendar.MONTH)+<span class=\"number\">1</span>)+<span class=\"string\">&quot;月&quot;</span>+c.get(Calendar.DAY_OF_MONTH)+<span class=\"string\">&quot;日&quot;</span>)；</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第三代日期类\"><a href=\"#第三代日期类\" class=\"headerlink\" title=\"第三代日期类\"></a>第三代日期类</h3><p>前面两代的不足分析</p>\n<p>（jdk1.0中包含了一个java.Util.Date类，但是他的大多数方法已经存在JDK1.1引入Calendar类之后被弃用。Calendar也存在着很多问题</p>\n<ol>\n<li>可变性：像日期和时间这样的类应该是不可变的。</li>\n<li>偏移性：Date中年份是从1900开始的，而月份是从0开始的</li>\n<li>格式化：格式化只对Date有用，Calendar则不行</li>\n<li>此外，他们不是线程安全的，不能处理闰秒等（每隔两天多出1s）</li>\n</ol>\n<h4 id=\"第三代日期类-1\"><a href=\"#第三代日期类-1\" class=\"headerlink\" title=\"第三代日期类\"></a>第三代日期类</h4><p>1）LoaclDate（日期）、localTime（时间）、loacalDateTime（日期和时间内）</p>\n<p>JDK8</p>\n<p>LoaclDate：只包含日期，可以获取日期字段</p>\n<p>localTime：包含时间，可以获取时间字段</p>\n<p>loacalDateTime包含日期和时间，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">loacalDateTime</span> <span class=\"variable\">ln</span> <span class=\"operator\">=</span> loacalDateTime.now();</span><br><span class=\"line\">ln.getYear();</span><br><span class=\"line\">ln.getMonth();</span><br><span class=\"line\">ln.getMonthValue();<span class=\"comment\">//输出数字版的月份</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2）DateTimeFormatter格式日期类\"><a href=\"#2）DateTimeFormatter格式日期类\" class=\"headerlink\" title=\"2）DateTimeFormatter格式日期类\"></a>2）DateTimeFormatter格式日期类</h5><p>类似于SimpleDateFormat</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">dtf</span> <span class=\"operator\">=</span> DateTimeFormatter.ofPattern(格式);<span class=\"comment\">//(yyyyMMdd....)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">srt</span> <span class=\"operator\">=</span> dtf.format(日期对象);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Instant-时间戳\"><a href=\"#Instant-时间戳\" class=\"headerlink\" title=\"Instant 时间戳\"></a>Instant 时间戳</h4><p>类似于Date</p>\n<p>提供了一系列和Date类转换的方式</p>\n<p>Instant—-&gt;Date;</p>\n<p>Date date &#x3D; Date.from(instant);</p>\n<p>Date —&gt;Instant;</p>\n<p>Instant instant &#x3D; date.toInstant();</p>\n<p>案例演示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Instant</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> Instant.now();</span><br><span class=\"line\">System.out.print(now);</span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> Date.from(now);</span><br><span class=\"line\"><span class=\"type\">Instant</span> <span class=\"variable\">instant</span> <span class=\"operator\">=</span> date.toInstant();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h2 id=\"System\"><a href=\"#System\" class=\"headerlink\" title=\"System\"></a>System</h2><h3 id=\"常见方法\"><a href=\"#常见方法\" class=\"headerlink\" title=\"常见方法\"></a>常见方法</h3><p>1）exit 退出当前程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.exit(0);表示退出</span><br><span class=\"line\">//0代表一个正常状态状态  。</span><br></pre></td></tr></table></figure>\n\n<p>2）Arraycopy：复制数组元素，比较合适底层调用，一般使用Arrays.copyOf完成数组复制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] src = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span>[] dest = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">3</span>];</span><br><span class=\"line\">System.arraycopy(src,<span class=\"number\">0</span>,dest,<span class=\"number\">0</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"> \tsrc:源数组</span><br><span class=\"line\">    srcpos：从原数组的哪个索引位置开始开始拷贝</span><br><span class=\"line\">    dest:目标数组，即吧原数组的数据拷贝到哪个数组</span><br><span class=\"line\">    destpos：把原数组的数据拷贝到 目标数组的哪个索引</span><br><span class=\"line\">    length:从原数组拷贝多少个数据到目标数组</span><br></pre></td></tr></table></figure>\n\n<p>3）currentTimeMillens：返回当前时间距离1970-1-1(1970年1月1日到现在) 的毫秒数</p>\n<p>4）gc：运行垃圾回收机制System.gc();</p>\n<h2 id=\"Arrays类\"><a href=\"#Arrays类\" class=\"headerlink\" title=\"Arrays类\"></a>Arrays类</h2><h3 id=\"介绍-12\"><a href=\"#介绍-12\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Arrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><h4 id=\"1）-toString返回数组的字符串形式，将数组拼接成字符串返回\"><a href=\"#1）-toString返回数组的字符串形式，将数组拼接成字符串返回\" class=\"headerlink\" title=\"1） toString返回数组的字符串形式，将数组拼接成字符串返回\"></a>1） toString返回数组的字符串形式，将数组拼接成字符串返回</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.ToString(arr)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-sort排序（自然排序和定制排序）\"><a href=\"#2-sort排序（自然排序和定制排序）\" class=\"headerlink\" title=\"2)sort排序（自然排序和定制排序）\"></a>2)sort排序（自然排序和定制排序）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer arr[] = &#123;<span class=\"number\">1</span>,-<span class=\"number\">1</span>,<span class=\"number\">7</span>,<span class=\"number\">0</span>,<span class=\"number\">89</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//可以直接使用该方法进行排序。不用再动手去敲方法</span></span><br><span class=\"line\"><span class=\"comment\">//因为数组时引用类型，所以通过sort排序后，会影响到实参arr</span></span><br><span class=\"line\">Arrays.sort(arr);<span class=\"comment\">//正序排序</span></span><br><span class=\"line\"><span class=\"comment\">//sort重载的，也可以通过传入一个接口Comparator实现定制排序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>、调用定制排序时，传入两个参数</span><br><span class=\"line\">    (<span class=\"number\">1</span>)排序数组的参数</span><br><span class=\"line\">    (<span class=\"number\">2</span>)实现Comparator接口的匿名内部类。要求实现Compare方法</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//      这里体现了接口编程的方式</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        倒序排序</span></span><br><span class=\"line\">        Arrays.sort(a, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Object o1, Object o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> (Integer) o1;</span><br><span class=\"line\">                <span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> (Integer) o2;</span><br><span class=\"line\"><span class=\"comment\">//                return大于0 就是正序排序，小于0就是倒序</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i2 -i1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(Arrays.toString(a));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       bubble(a,<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Object o1, Object o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> (Integer) o1;</span><br><span class=\"line\">                <span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> (Integer) o2;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i1 -i2 ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;定制类&quot;</span>+Arrays.toString(a));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//    定制排序</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bubble</span><span class=\"params\">(Integer[] arr,Comparator c)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr.length-<span class=\"number\">1</span> ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt;arr.length-<span class=\"number\">1</span>-i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c.compare(arr[j],arr[j+<span class=\"number\">1</span>])&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    temp =arr[j];</span><br><span class=\"line\">                    arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    arr[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3）binarySearch-二分搜索\"><a href=\"#3）binarySearch-二分搜索\" class=\"headerlink\" title=\"3）binarySearch 二分搜索\"></a>3）binarySearch 二分搜索</h4><p>binarySearch 通过二分搜索法进行查找，要求必须排好序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//如果这个数组是有序的，可以通过该方法查找知否有这个数</span></span><br><span class=\"line\"> <span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">1</span>,<span class=\"number\">23</span>,<span class=\"number\">45</span>,<span class=\"number\">65</span>,<span class=\"number\">78</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//如果不存在该元素就返回，return -(low +1)//意思就是返回负的他该出现的位置的下标+1</span></span><br><span class=\"line\"> <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> Arrays.binarySearch(arr,<span class=\"number\">3</span>);<span class=\"comment\">//返回-2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4）copyOf数组元素的复制\"><a href=\"#4）copyOf数组元素的复制\" class=\"headerlink\" title=\"4）copyOf数组元素的复制\"></a>4）copyOf数组元素的复制</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//表示从arr数组中拷贝arr.length个长度的元素到新的arr数组中</span></span><br><span class=\"line\">Integer[] newArr = Arrays.copyOf(arr,arr.length);</span><br><span class=\"line\">Integer[] newArr = Arrays.copyOf(arr,arr.length-<span class=\"number\">1</span>);就是拷贝原数组长度-<span class=\"number\">1</span></span><br><span class=\"line\">Integer[] newArr = Arrays.copyOf(arr,arr.length+<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">//如果长度超出原数组的长度，则多出来的部分元素为null   </span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-fill数组元素的填充\"><a href=\"#5-fill数组元素的填充\" class=\"headerlink\" title=\"5)fill数组元素的填充\"></a>5)fill数组元素的填充</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] num = <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>[]&#123;<span class=\"number\">9</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//使用99去填充num数组</span></span><br><span class=\"line\"><span class=\"comment\">//可以理解成替换原来的元素</span></span><br><span class=\"line\">Arrays.fill(num,<span class=\"number\">99</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">==========运行结果======</span><br><span class=\"line\">    [<span class=\"number\">99</span>,<span class=\"number\">99</span>,<span class=\"number\">99</span>]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-equals-比较两个数组元素内容是否完全一致\"><a href=\"#6-equals-比较两个数组元素内容是否完全一致\" class=\"headerlink\" title=\"6)equals 比较两个数组元素内容是否完全一致\"></a>6)equals 比较两个数组元素内容是否完全一致</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">equals</span>  <span class=\"operator\">=</span> Arrays.equals(arr,arr2);</span><br><span class=\"line\"><span class=\"comment\">//如果两个数组元素一样，则返回true。不一样返回false</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-asList-将一组值，转换成list\"><a href=\"#7-asList-将一组值，转换成list\" class=\"headerlink\" title=\"7)asList 将一组值，转换成list\"></a>7)asList 将一组值，转换成list</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; asList = Arrays.asList(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;asList&quot;</span>+asList);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"Integer和BigDecimal类\"><a href=\"#Integer和BigDecimal类\" class=\"headerlink\" title=\"Integer和BigDecimal类\"></a>Integer和BigDecimal类</h2><h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>1）BigInteger适合保存比较大的整型(整数)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当编程中需要处理很大的整数。long不够用可以使用BigInteger类</span></span><br><span class=\"line\"><span class=\"comment\">//使用</span></span><br><span class=\"line\"><span class=\"type\">BigInteger</span> <span class=\"variable\">bigInteger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigInteger</span>(<span class=\"string\">&quot;2222222222222222222222222222222222222222&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运算</span></span><br><span class=\"line\"><span class=\"comment\">//在对BigInteger进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）</span></span><br><span class=\"line\">    </span><br><span class=\"line\">BigInteger bigInteger <span class=\"number\">2</span>=bigInteger.add(<span class=\"number\">10</span>)；<span class=\"comment\">//加</span></span><br><span class=\"line\">    <span class=\"comment\">//也可再创建一个BigInteger相加</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>2）BigDecimal适合保存精度高的浮点型(小数)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当我们需要保存一个精度很高的值时，double不够用</span></span><br><span class=\"line\"><span class=\"comment\">//可以使用BigDecimal</span></span><br><span class=\"line\"><span class=\"type\">BigDecimal</span> <span class=\"variable\">bigDecimal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(<span class=\"string\">&quot;22.22222222222222222222222222&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//运算</span></span><br><span class=\"line\"><span class=\"comment\">//在对BigDecimal进行加减乘除的时候，需要使用对应的方法，不能直接使用符号（+-*/）</span></span><br><span class=\"line\"><span class=\"comment\">//需要创建一个需要操作的BigDecimal，然后调用即可</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal bigDecimal=bigDecimal.add(<span class=\"number\">2.3</span>);</span><br><span class=\"line\">    <span class=\"comment\">//使用删除方法时，可能会出现除不尽的情况，会抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">//解决办法：在调用divede(删除)方法是，指定精度即可</span></span><br><span class=\"line\">bigDecimal.divide(<span class=\"number\">1.11</span>,BigDecimal.ROUND_CEILING)</span><br><span class=\"line\"><span class=\"comment\">//如果有无限循环小数，就会保留到分子的精度</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><h2 id=\"集合框架体系\"><a href=\"#集合框架体系\" class=\"headerlink\" title=\"集合框架体系\"></a>集合框架体系</h2><h3 id=\"集合体系图\"><a href=\"#集合体系图\" class=\"headerlink\" title=\"集合体系图\"></a>集合体系图</h3><p>背下来</p>\n<p>1）单例集合（在集合里面放单个的对象）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163040446.png\" alt=\"image-20220420163040446\"></p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163624872.png\" alt=\"image-20220420163624872\"></p>\n<p>2）双列集合（存放键值对形式的）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163100945.png\" alt=\"image-20220420163100945\"></p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420163609594.png\" alt=\"image-20220420163609594\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//存放单个数据的成为单例</span></span><br><span class=\"line\"><span class=\"type\">ArrayList</span>  <span class=\"variable\">arrayList</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">arrayList.add(<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">arrayList.add(<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//存放双列数据的成为双例集合</span></span><br><span class=\"line\"><span class=\"type\">HashMap</span> <span class=\"variable\">hashMap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">hashMap.put(<span class=\"string\">&quot;no1&quot;</span>,<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//key,value</span></span><br><span class=\"line\">hashMap.put(<span class=\"string\">&quot;no2&quot;</span>,<span class=\"string\">&quot;李四&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><p>Collection接口</p>\n<h4 id=\"Collection接口实现类的特点\"><a href=\"#Collection接口实现类的特点\" class=\"headerlink\" title=\"Collection接口实现类的特点\"></a>Collection接口实现类的特点</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Public <span class=\"keyword\">interface</span> <span class=\"title class_\">Collection</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">Iterable</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Collection实现子类可以存放多个元素，每个元素可以是 Object</li>\n<li>有些Collection的实现类，可以存放重复的元素，有些不可以</li>\n<li>有些Collection的实现类，有些是有序的（List），有些不是有序（Set）</li>\n<li>Collection接口没有直接实现子类，是通过它的子接口Set和List来实现的</li>\n</ol>\n<h4 id=\"Collection接口和常用方法\"><a href=\"#Collection接口和常用方法\" class=\"headerlink\" title=\"Collection接口和常用方法\"></a>Collection接口和常用方法</h4><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420165341922.png\" alt=\"image-20220420165341922\"></p>\n<p>常用方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>)add :添加单个元素</span><br><span class=\"line\"><span class=\"number\">2</span>)remove:删除指定元素</span><br><span class=\"line\"><span class=\"number\">3</span>)contains:查找元素是否存在</span><br><span class=\"line\"><span class=\"number\">4</span>）size：获取元素个数</span><br><span class=\"line\"><span class=\"number\">5</span>）isEempty：判断是否为空</span><br><span class=\"line\"><span class=\"number\">6</span>）clear：清空</span><br><span class=\"line\"><span class=\"number\">7</span>）addAll：添加多个元素</span><br><span class=\"line\"><span class=\"number\">8</span>）containsAll：查找多个元素是否都存在</span><br><span class=\"line\"><span class=\"number\">9</span>）removeAll：删除多个元素</span><br><span class=\"line\">说明：以ArrayList实现类演示</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ArrayList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\"><span class=\"comment\">//        1.添加单个元素</span></span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;hahah&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"number\">123</span>);<span class=\"comment\">//等价于list.add(new Integer(123);</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;数组增加&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//      remove：删除指定元素</span></span><br><span class=\"line\">        list.remove(<span class=\"number\">0</span>);<span class=\"comment\">//删除第一个元素,下标从0开始</span></span><br><span class=\"line\">        list.remove(<span class=\"string\">&quot;123&quot;</span>);<span class=\"comment\">//删除指定元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;数组删除&quot;</span>+list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//       contains 查找元素是否存在</span></span><br><span class=\"line\">        System.out.println(list.contains(<span class=\"string\">&quot;zhangsan&quot;</span>));<span class=\"comment\">//F</span></span><br><span class=\"line\"><span class=\"comment\">//        size,显示元素的个数</span></span><br><span class=\"line\">        System.out.println(list.size());</span><br><span class=\"line\"><span class=\"comment\">//      isEmpty判断是否为空</span></span><br><span class=\"line\">        System.out.println(list.isEmpty());</span><br><span class=\"line\"><span class=\"comment\">//        clear清空</span></span><br><span class=\"line\">        list.clear();<span class=\"comment\">//清空集合</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;list清空=&quot;</span>+list);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ArrayList</span> <span class=\"variable\">list1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\"><span class=\"comment\">//        addAll:添加多个元素</span></span><br><span class=\"line\">        list1.add(<span class=\"string\">&quot;xxx&quot;</span>);</span><br><span class=\"line\">        list1.add(<span class=\"string\">&quot;xxxxxx&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        list.addAll(list1);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;addAll&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//        containsAll:查找多个元素知否存在</span></span><br><span class=\"line\">        System.out.println(list.containsAll(list1));</span><br><span class=\"line\"><span class=\"comment\">//        removeAll：删除多个元素</span></span><br><span class=\"line\">        list.removeAll(list1);</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用Iterator（迭代器）\"><a href=\"#使用Iterator（迭代器）\" class=\"headerlink\" title=\"使用Iterator（迭代器）\"></a>使用Iterator（迭代器）</h4><p>Collection接口遍历元素的方式1-使用Iterator（迭代器）</p>\n<h5 id=\"基本介绍-6\"><a href=\"#基本介绍-6\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h5><p>1）Iterator对象成为迭代器，主要用于遍历Collection集合中的元素</p>\n<p>2）所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可返回一个迭代器</p>\n<p>3）Iterator的结构<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220420231917444.png\" alt=\"image-20220420231917444\"></p>\n<p>4）Iterator仅用于遍历集合，Iterator本身并不存放对象</p>\n<h6 id=\"迭代器的运行原\"><a href=\"#迭代器的运行原\" class=\"headerlink\" title=\"迭代器的运行原\"></a>迭代器的运行原</h6><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220421160914060.png\" alt=\"image-20220421160914060\"></p>\n<p>hasNext用于判断</p>\n<p>next（）；下移，并返回指向的元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Iteraor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Collection</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">HomeWork</span>(<span class=\"string\">&quot;zhansgan&quot;</span>,<span class=\"number\">12313</span>));</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">HomeWork</span>(<span class=\"string\">&quot;haha&quot;</span>,<span class=\"number\">231</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        使用迭代器遍历</span></span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> list.iterator();</span><br><span class=\"line\"><span class=\"comment\">//        while循环  快捷方式输入 itit</span></span><br><span class=\"line\"><span class=\"comment\">//        ctrl+j提示所有快捷键</span></span><br><span class=\"line\">     <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            返回下一个元素，是Object类型</span></span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span>  iterator.next();</span><br><span class=\"line\">            System.out.println(next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//      当退出while循环后，这是iterator迭代器，指向最后一个元素</span></span><br><span class=\"line\"><span class=\"comment\">//        iterator.next()  ，此时再让往下移指针会报异常：NuSuchElementException</span></span><br><span class=\"line\"><span class=\"comment\">//        如果希望再次遍历，需要我们重置迭代器</span></span><br><span class=\"line\">        iterator = list.iterator();<span class=\"comment\">//相当于指向了第一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HomeWork</span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    Integer phoneNum;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HomeWork</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HomeWork</span><span class=\"params\">(String name, Integer phoneNum)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.phoneNum = phoneNum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;HomeWork&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;, phoneNum=&quot;</span> + phoneNum +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"for循环增强\"><a href=\"#for循环增强\" class=\"headerlink\" title=\"for循环增强\"></a>for循环增强</h4><p>Collection接口遍历元素的方式2-</p>\n<p>增强for循环，可以代替iterator迭代器</p>\n<p>特点：增强for就是简化版的iterator，本质一样。只能用于<span style=\"color:red\">遍历集合或数组</span></p>\n<h6 id=\"基本语法-3\"><a href=\"#基本语法-3\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(元素类型 元素名 : 集合名或数组)&#123;</span><br><span class=\"line\">\t访问元素</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>案例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">for</span> (Object homeWork:list) &#123;</span><br><span class=\"line\">            System.out.println(homeWork);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        增强也可以在数组中使用</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] a = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">45</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i: a)&#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>增强for底层是迭代器</li>\n<li>可以理解成增强for是简化版的迭代器</li>\n</ol>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><p>基本介绍：</p>\n<p>List接口是Collection接口的子接口</p>\n<p>1）list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</p>\n<p>2）list集合中的每个元素都有其对应的顺序索引，即支持索引</p>\n<p>3）list容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p>\n<p>4）JDK API中的List接口实现类有：ArrayList、LinkedList和Vector</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//        list集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</span></span><br><span class=\"line\">        <span class=\"type\">List</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;jack&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;tom&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        此时不会有冲突，相当于会认为有两个tom</span></span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;tom&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        此时输出的顺序就是存进去的顺序</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;list&quot;</span>+list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        2）list集合中的每个元素都有其对应的顺序索引，即支持索引</span></span><br><span class=\"line\"><span class=\"comment\">//        索引从0开始</span></span><br><span class=\"line\">        System.out.println(list.get(<span class=\"number\">3</span>));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"List接口的常用方法\"><a href=\"#List接口的常用方法\" class=\"headerlink\" title=\"List接口的常用方法\"></a>List接口的常用方法</h5><ol>\n<li>void add（int index,Object ele）在index位置插入ele元素</li>\n<li>boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来</li>\n<li>Object get (int index)获取固定index位置的元素</li>\n<li>int indexOf(Object obj)  返回obj在几个中首次出现的位置</li>\n<li>int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置</li>\n<li>Object remove(int index) 移除指定index位置的元素，并返回此元素</li>\n<li>Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换</li>\n<li>List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">List</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;no1&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;no2&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        1. void add（int index,Object ele）在index位置插入ele元素</span></span><br><span class=\"line\"><span class=\"comment\">//        在index=1的位置插入一个对象</span></span><br><span class=\"line\">        list.add(<span class=\"number\">1</span>,<span class=\"string\">&quot;add(index,ele)&quot;</span>);</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\"><span class=\"comment\">//        2. boolean addAll(int index,Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class=\"line\">        <span class=\"type\">List</span> <span class=\"variable\">list2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        list2.add(<span class=\"string\">&quot;lno2&quot;</span>);</span><br><span class=\"line\">        list2.add(<span class=\"string\">&quot;lno3&quot;</span>);</span><br><span class=\"line\">        list2.add(<span class=\"string\">&quot;lno3&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        在1的位置插入list2的集合</span></span><br><span class=\"line\">        list.addAll(<span class=\"number\">1</span>,list2);</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\"><span class=\"comment\">//        3. Object get (int index)获取固定index位置的元素</span></span><br><span class=\"line\"><span class=\"comment\">//        4. int indexOf(Object obj)  返回obj在几个中首次出现的位置</span></span><br><span class=\"line\">        System.out.println(list.indexOf(<span class=\"string\">&quot;no1&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//        5. int lastIndexOf(Object obj) 返回obj在当前集合末次出现的位置</span></span><br><span class=\"line\">        System.out.println(list.lastIndexOf(<span class=\"string\">&quot;lno3&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//        6. Object remove(int index) 移除指定index位置的元素，并返回此元素</span></span><br><span class=\"line\">        list.remove(<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println( list);</span><br><span class=\"line\"><span class=\"comment\">//        7. Object set(int index ,Object ele) 设置指定index位置的元素为ele，相当于替换</span></span><br><span class=\"line\"><span class=\"comment\">//        将索引为1的改为尼诺</span></span><br><span class=\"line\">        list.set(<span class=\"number\">1</span>,<span class=\"string\">&quot;尼诺&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        8. List subList (int fromIndex,int toIndex) 返回从fromIndex到toIndex位置的子集合</span></span><br><span class=\"line\">        <span class=\"type\">List</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> list.subList(<span class=\"number\">0</span>, <span class=\"number\">2</span>);<span class=\"comment\">//相当于选择了下标为0的和下标为2-1之间的元素</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;result&quot;</span>+result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注意事项-7\"><a href=\"#注意事项-7\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h5><ol>\n<li>permits all elements,including null , ArrayList 可以加入null，并且多个</li>\n<li>ArrayList 是由数组来实现数据存储的</li>\n<li>ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高）看源码，在多线程情况下，不建议使用ArrayList</li>\n</ol>\n<h4 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h4><h5 id=\"ArrayList底层机制和源码分析（重点）\"><a href=\"#ArrayList底层机制和源码分析（重点）\" class=\"headerlink\" title=\"ArrayList底层机制和源码分析（重点）\"></a>ArrayList底层机制和源码分析（重点）</h5><p>1）ArrayList中维护了一个Object类型的数组elementData</p>\n<p>​\t\ttransient Object[] elementData </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transient 表示瞬间，短暂的，表示该属性不会被序列化</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2）当创建对象ArrayList时，如果使用的是无参构造器，则初始elementData容量为0</p>\n<p>3）当添加元素时，先判断是否需要扩容，则调用grow方法，否则直接添加元素到合适位置</p>\n<p>4）如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍</p>\n<p>5）如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity</p>\n<p>6）如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍</p>\n<h4 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h4><h5 id=\"介绍-13\"><a href=\"#介绍-13\" class=\"headerlink\" title=\"介绍\"></a>介绍</h5><p>Vevtor底层也是一个对象数组。protected Object[] elementData;</p>\n<p>Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized</p>\n<p>在开发过程中，需要线程同步安全时，考虑使用Vector</p>\n<h5 id=\"Vector-和ArrayList比较\"><a href=\"#Vector-和ArrayList比较\" class=\"headerlink\" title=\"Vector 和ArrayList比较\"></a>Vector 和ArrayList比较</h5><table>\n<thead>\n<tr>\n<th></th>\n<th>底层结构</th>\n<th>版本</th>\n<th>线程安全（同步）效率</th>\n<th>扩容倍数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList</td>\n<td>可变数组</td>\n<td>jdk1.2</td>\n<td>不安全，效率高</td>\n<td>如果有参构造1.5倍如果无参1.第一次是10，第二次按1.5扩</td>\n</tr>\n<tr>\n<td>Vector</td>\n<td>可变数组</td>\n<td>jdk1.0</td>\n<td>安全，效率不高</td>\n<td>如果是无参默认10，满后，就按两倍扩容。如果指定大小（创建）有参，则每次直接按2倍扩容</td>\n</tr>\n</tbody></table>\n<h4 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h4><h5 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h5><p>1）LinkedList实现了双向链表和双端队列特点</p>\n<p>2）可以添加任意元素（元素可以重复），包括null</p>\n<p>3）线程不安全，没有实现同步</p>\n<h5 id=\"LinkedList底层机制\"><a href=\"#LinkedList底层机制\" class=\"headerlink\" title=\"LinkedList底层机制\"></a>LinkedList底层机制</h5><ol>\n<li><p>LinkedList底层维护了一个双向链表</p>\n</li>\n<li><p>LinkedList中维护了两个属性first和last分别指向首节点和尾结点</p>\n</li>\n<li><p>每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点。最终实现双向链表</p>\n</li>\n<li><p>所以LinkedList的元素的 添加和删除，不是通过该数组完成的，相对来说效率较高</p>\n</li>\n<li><p>模拟一个简单双向链表理解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//        模拟一个简单的双向链表</span></span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">jack</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"string\">&quot;jack&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">tom</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"string\">&quot;tom&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">zhangshan</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(<span class=\"string\">&quot;zhangshan&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        链接是三个结点，形成双向链表</span></span><br><span class=\"line\"><span class=\"comment\">//        jack-&gt;tom -&gt;zhangsan</span></span><br><span class=\"line\">        jack.next = tom;</span><br><span class=\"line\">        tom.next =zhangshan;</span><br><span class=\"line\"><span class=\"comment\">//        zhangsan-&gt;tom-&gt;jack</span></span><br><span class=\"line\">        zhangshan.pre = tom;</span><br><span class=\"line\">        tom.pre = jack;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">first</span> <span class=\"operator\">=</span> jack;<span class=\"comment\">//让first引用指向jack，就是双向链表的头结点</span></span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">last</span> <span class=\"operator\">=</span>zhangshan;<span class=\"comment\">//让last引用指向zhangshan，就是双向链表的尾结点</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        演示从头到尾进行遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"><span class=\"comment\">//            输出first信息</span></span><br><span class=\"line\">            System.out.println(first);</span><br><span class=\"line\">            first = first.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        从未到头遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (last == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(last);</span><br><span class=\"line\">            last = last.pre;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义一个Node类，node对象 表示双向链表的一个结点</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object item;<span class=\"comment\">//真正存放数据</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node next;<span class=\"comment\">//指向下一个结点</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node pre;<span class=\"comment\">//指向前一个结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Node</span><span class=\"params\">(Object item)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.item = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Node&#123;&quot;</span> +</span><br><span class=\"line\">                <span class=\"string\">&quot;item=&quot;</span> + item +</span><br><span class=\"line\">                <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429152321935.png\" alt=\"image-20220429152321935\"></p>\n<h5 id=\"ArrayList-和LinkedList的比较\"><a href=\"#ArrayList-和LinkedList的比较\" class=\"headerlink\" title=\"ArrayList 和LinkedList的比较\"></a>ArrayList 和LinkedList的比较</h5><table>\n<thead>\n<tr>\n<th></th>\n<th>底层结构</th>\n<th>增删的效率</th>\n<th>改查的效率</th>\n<th>线程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList</td>\n<td>可变数组</td>\n<td>较低；数组扩容</td>\n<td>较高</td>\n<td>不安全</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td>双向链表</td>\n<td>较高，通过链表追加</td>\n<td>较低</td>\n<td>不安全</td>\n</tr>\n</tbody></table>\n<p>何如选择</p>\n<p>1）如果我们改查的操作较多，选择ArrayList</p>\n<p>2）如果我们增删的操作多，选择LinkedList</p>\n<p>3）一般来说，在程序中80%-90%都是查询，因此大部分情况下会选择ArrayList</p>\n<p>4）在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说根据业务来进行合理选择</p>\n<h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><p>介绍</p>\n<p>1）无序（添加和取出的顺序不一致），没有索引</p>\n<p>2）不允许重复元素，所以最多包含和一个null</p>\n<p>3）JDK API中Set接口的实现类有<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220429173926895.png\" alt=\"image-20220429173926895\"></p>\n<h5 id=\"Set接口和常用方法\"><a href=\"#Set接口和常用方法\" class=\"headerlink\" title=\"Set接口和常用方法\"></a>Set接口和常用方法</h5><p>和List接口一样，Set接口也是Collection的子接口，因此常用方法和Collection接口一样</p>\n<h5 id=\"set接口遍历方式\"><a href=\"#set接口遍历方式\" class=\"headerlink\" title=\"set接口遍历方式\"></a>set接口遍历方式</h5><p>同Collection的遍历方式一样，因为Set接口是Collection接口的子接口</p>\n<ul>\n<li>使用迭代器</li>\n<li>增强for</li>\n<li>不能使用索引的方式获取</li>\n</ul>\n<h5 id=\"案例-3\"><a href=\"#案例-3\" class=\"headerlink\" title=\"案例\"></a>案例</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//        以set接口实现类HashSet来讲解Set接口的方法</span></span><br><span class=\"line\"><span class=\"comment\">//        set接口的实现类的对象（set接口对象）</span></span><br><span class=\"line\"><span class=\"comment\">//        重复添加的数据只会存进去一个，null值也是只能存放一个</span></span><br><span class=\"line\">    <span class=\"comment\">//输出结果是无序的（存放的数据是无序的，即（添加的顺序和取出的顺序不一致））</span></span><br><span class=\"line\">    <span class=\"comment\">//虽然取出的顺序和添加的顺序不一致，但取出的顺序是固定的，不会一直变化</span></span><br><span class=\"line\">        <span class=\"type\">Set</span> <span class=\"variable\">set</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>();</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;zhansgan&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;wa&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;zhansgan&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        set.add(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        System.out.println(set);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        遍历</span></span><br><span class=\"line\"><span class=\"comment\">//        迭代器</span></span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> set.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span>  iterator.next();</span><br><span class=\"line\">            System.out.println(next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        增强for</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o :set) &#123;</span><br><span class=\"line\">            System.out.println(o);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">----------------输出结果----------------------</span><br><span class=\"line\">    [<span class=\"literal\">null</span>, lisi, wa, zhansgan]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h4><p>1)HashSet实现了Set接口</p>\n<p>2）HashSet实际上是HashMap，看源码</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430145947382.png\" alt=\"image-20220430145947382\"></p>\n<p>3）可以存放null值，但是只能有一个null</p>\n<p>4）HashSet不保证元素时有序的，取决于hash之后，在确定索引的结果（即：不保证存放元素的顺序和取出的一致  ）</p>\n<p>5）不能有重复元素&#x2F;对象。在前面Set接口使用已经标明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.执行add方法后，会返回一个Boolean值</span></span><br><span class=\"line\"><span class=\"comment\">//2.如果添加成功,返回true，否则返回false</span></span><br><span class=\"line\"><span class=\"comment\">//3.可以通过remove指定删除哪个对象</span></span><br><span class=\"line\">        <span class=\"type\">HashSet</span> <span class=\"variable\">set</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>();</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;zhansgan&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;wa&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"string\">&quot;zhansgan&quot;</span>);</span><br><span class=\"line\">        set.add(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        set.add(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        set.remove(<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        set.add(<span class=\"keyword\">new</span> <span class=\"title class_\">HHHH</span>(<span class=\"string\">&quot;zzz&quot;</span>));<span class=\"comment\">//添加成功</span></span><br><span class=\"line\">        set.add(<span class=\"keyword\">new</span> <span class=\"title class_\">HHHH</span>(<span class=\"string\">&quot;zzz&quot;</span>));<span class=\"comment\">//添加成功</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HHHH</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HHHH</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"HashSet底层机制说明\"><a href=\"#HashSet底层机制说明\" class=\"headerlink\" title=\"HashSet底层机制说明\"></a>HashSet底层机制说明</h5><p>1）HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树）</p>\n<ol>\n<li>HashSet底层是HashMap</li>\n<li>添加一个元素时，先得到hash值 -会转成-索引值</li>\n<li>找到储存数据表table，看这个索引位置是否已经存放的有元素</li>\n<li>如果没有，直接加入</li>\n<li>如果有调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</li>\n<li>在java8中，如果一条链表的元素个数到了TREEEIFY_THRESHOLD(默认是8)个，并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树）</li>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220430160350549.png\" alt=\"image-20220430160350549\"></li>\n</ol>\n<p>源码分析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent,</span></span><br><span class=\"line\"><span class=\"params\">                   <span class=\"type\">boolean</span> evict)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义了一个辅助变量</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"type\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">//table就是HashMap的一个属性，类型是Node[]</span></span><br><span class=\"line\">     <span class=\"comment\">//if语句表示如果当前table是null，或者大小=0</span></span><br><span class=\"line\">    <span class=\"comment\">//就是第一次扩容，到16个空间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">   <span class=\"comment\">//（1）根据key，得到hash值去计算key应该存放到table表的哪个索引位置</span></span><br><span class=\"line\">    <span class=\"comment\">//并且把这个位置的对象赋给p</span></span><br><span class=\"line\">    <span class=\"comment\">//（2）判断p是否为null</span></span><br><span class=\"line\">    <span class=\"comment\">//（2.1）如果为null，表示还没有存放元素，就创建了一个Node</span></span><br><span class=\"line\">    <span class=\"comment\">//（2.1）就放在该位置 tab[i] = newNode(hash, key, value, null); </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            tab[i] = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">          <span class=\"comment\">//如果当前索引位置对应的链表的第一个元素和准备谈价的key的hash值一样</span></span><br><span class=\"line\">            <span class=\"comment\">//并且满足下面条件之一</span></span><br><span class=\"line\">            <span class=\"comment\">//1.准备加入的key和p指向的Node结点和key是同一个对象 </span></span><br><span class=\"line\">            <span class=\"comment\">//2.p指向的Node结点的key的equals（）和准备加入的key比较后相同</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">            <span class=\"comment\">//如果上述条件不满足，再判断p是不是一个红黑树</span></span><br><span class=\"line\">            <span class=\"comment\">//如果是一颗红黑树，就调用putTreeVal，来进行添加判断</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"built_in\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//依次比较链表内的内容</span></span><br><span class=\"line\">                <span class=\"comment\">//如果table对应索引的额位置，已经是一个链表，就是用for循环比较</span></span><br><span class=\"line\">                <span class=\"comment\">//(1)依次和链表的每一个元素比较后都不相同，则加入到该链表的最后</span></span><br><span class=\"line\">                  <span class=\"comment\">//然后立即判断该链表是否已经达到8个结点，就调用   treeifyBin()对当前这个链表进行树化（转成红黑树）</span></span><br><span class=\"line\">                <span class=\"comment\">//注意，在转成红黑树时，要进行判断，判断条件&#123;if(tab == null ||(n = tab.length)&lt;MIN_TREEIEY_CAPACITY)</span></span><br><span class=\"line\">                <span class=\"comment\">//resize();   //table数组是否小于64，结点是否到达8个并不为空      &#125;</span></span><br><span class=\"line\">                <span class=\"comment\">//如果上面条件成立，先table扩容</span></span><br><span class=\"line\">                <span class=\"comment\">//如果上面条件不成立，才进行树化</span></span><br><span class=\"line\">                <span class=\"comment\">//(2)依次和该链表的每一个元素比较过程中，如果有相同的情况，就直接break；</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                </span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"HashSet的扩容和转成红黑树机制\"><a href=\"#HashSet的扩容和转成红黑树机制\" class=\"headerlink\" title=\"HashSet的扩容和转成红黑树机制\"></a>HashSet的扩容和转成红黑树机制</h5><ol>\n<li>HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（localFactor）是0.75 &#x3D;12</li>\n<li>如果table数组实用到了临界值12，就会扩容到16*2&#x3D;32，新的临界值就是32 * 0.75 &#x3D; 24,依次类推</li>\n<li>在java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8),并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64),就会进行树化（红黑树），否则仍然采用数组扩容机制</li>\n</ol>\n<h3 id=\"LinkedHashSet\"><a href=\"#LinkedHashSet\" class=\"headerlink\" title=\"LinkedHashSet\"></a>LinkedHashSet</h3><p><strong>说明</strong></p>\n<p>1）LinkedHashSet是HashSet的子类</p>\n<p>2）LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表</p>\n<p>3）LinkedHashSet根据元素的hashCode值来决定元素的储存位置，同时使用链表维护元素的次序（图），这使得元素看起来是以插入顺序保存的<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220501174705977.png\" alt=\"image-20220501174705977\"></p>\n<p>4）LinkedHashSet不允许添加重复元素 </p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220502111826275.png\" alt=\"image-20220502111826275\"></p>\n<p>可以理解成不同索引的数，构成双向链表</p>\n<ol>\n<li><p>在LinkedHashSet中维护了一个hash表和双向链表（LinkedHashSet有head和tail）</p>\n</li>\n<li><p>每一个结点有pre和next属性，这样可以形成双向链表</p>\n</li>\n<li><p>在添加一个元素时，先求hash值，在求索引。确定该元素在hashtable的位置，然后将添加的元素加入到双向链表（如果已经存在，不添加[原则和hashset一样])</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail.next = newElement <span class=\"comment\">//简单指定</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Element</span>.pre = <span class=\"type\">tail</span></span><br><span class=\"line\"><span class=\"variable\">tail</span> <span class=\"operator\">=</span> newElement;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p>\n</li>\n</ol>\n<h4 id=\"TreeSet\"><a href=\"#TreeSet\" class=\"headerlink\" title=\"TreeSet\"></a>TreeSet</h4><ol>\n<li><p>当使用无参构造器创建treeset的时候仍然是无序的</p>\n</li>\n<li><p>需求：希望添加的元素按字符串大小来排序?</p>\n<ol>\n<li><p>使用TreeSet提供的一个构造器,可以传入一个比较器（匿名内部类）</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>public class TreeSetDemo {<br>public static void main(String[] args) {<br>&#x2F;&#x2F;        TreeSet treeSet &#x3D; new TreeSet();<br>    TreeSet treeSet &#x3D; new TreeSet(new Comparator() {<br>        @Override<br>        public int compare(Object o1, Object o2) {<br>&#x2F;&#x2F;                调用String的compareTo方法比较字符串大小<br>            return ((String)o1).compareTo((String) o2);<br>        }<br>    });<br>    treeSet.add(“d”);<br>    treeSet.add(“b”);<br>    treeSet.add(“a”);<br>    treeSet.add(“c”);<br><br>    System.out.println(treeSet);<br>}}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   3. </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## Map</span><br><span class=\"line\"></span><br><span class=\"line\">Map**结构**</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;img src=&quot;https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220503163901620.png&quot; alt=&quot;image-20220503163901620&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">Map接口的特点（JDK8之后的）</span><br><span class=\"line\"></span><br><span class=\"line\">1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）</span><br><span class=\"line\"></span><br><span class=\"line\">2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&amp;Node对象中</span><br><span class=\"line\"></span><br><span class=\"line\">3）Map中的key不允许重复，原因和HashSet一样，前面分析过</span><br><span class=\"line\"></span><br><span class=\"line\">4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）</span><br><span class=\"line\"></span><br><span class=\"line\">5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个</span><br><span class=\"line\"></span><br><span class=\"line\">6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）</span><br><span class=\"line\"></span><br><span class=\"line\">7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\"> Map map = new HashMap();</span><br><span class=\"line\">//        1）Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素, 遍历出是无序的）</span><br><span class=\"line\">//        2）Map中的key和value可以是任何引用数据类型，会封装到HashMap&amp;Node对象中</span><br><span class=\"line\">//        3）Map中的key不允许重复，原因和HashSet一样，前面分析过</span><br><span class=\"line\">//        4）Map中的value可以重复（key不能重复，当有相同的key时新的key的value会替换旧的value）</span><br><span class=\"line\">        map.put(&quot;no1&quot;,&quot;zhangsan&quot;);</span><br><span class=\"line\">        map.put(&quot;no2&quot;,&quot;lisi&quot;);</span><br><span class=\"line\">        map.put(&quot;no1&quot;,&quot;lisi&quot;);</span><br><span class=\"line\">//        5）Map的key可以为null，value可以为null，注意key为null，只能有一个，value 为null，可以多个</span><br><span class=\"line\">        map.put(null,null);</span><br><span class=\"line\">        map.put(null,null);</span><br><span class=\"line\">        map.put(&quot;no3&quot;,null);</span><br><span class=\"line\">        map.put(&quot;no4&quot;,null);</span><br><span class=\"line\">        //        6）常使用String类作为Map的key（只要是Object的子类都可以，不范于srting类）</span><br><span class=\"line\">        map.put(new Object(),&quot;zhangsan&quot;);</span><br><span class=\"line\">//        7）key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</span><br><span class=\"line\">//        通过get方法传入key，会返回对应的value</span><br><span class=\"line\">        System.out.println(map.get(&quot;no2&quot;));</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">=============输出==================</span><br><span class=\"line\">  lisi</span><br><span class=\"line\">&#123;no2=lisi, null=null, no1=lisi, no4=null, no3=null, java.lang.Object@1540e19d=zhangsan&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<p>8）Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，有因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry（如图）</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220504165516988.png\" alt=\"image-20220504165516988\"></p>\n<p>数据存放在HashMap中，将set和collection作为一组对象放在Entry里面（其中不存放数据只是存放HashMap的引用）</p>\n<ol>\n<li>将HashMap中的key和value数据 存放到一个entrySet集合（该集合不存放数据，存放的都是引用）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"type\">Map</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no1&quot;</span>,<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no2&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);<span class=\"comment\">//k-v</span></span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no1&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);<span class=\"comment\">//k-v</span></span><br><span class=\"line\"><span class=\"comment\">//        1.k-v最后是HashMap$Node node = newNode(hash ,key,value,null);</span></span><br><span class=\"line\"><span class=\"comment\">//        2.k-v为了方便程序员遍历，还会创建EntrySet集合，该集合存放的元素类型（Entry），</span></span><br><span class=\"line\"><span class=\"comment\">//        而一个Entry对象就有k-v，EntrySet&lt;Entry&lt;k,v&gt;&gt;，即：transient Set&lt;Map.Entry&lt;k,v&gt;&gt; entrySet;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        3.在entrySet中，定义的类型是Map.Entry，但是实际上存放的是HashMap$Node类型</span></span><br><span class=\"line\"><span class=\"comment\">//        因为HashMap$Node implement Map.Entry 因为实现了Map.Entry接口，那么这个类的对象实例可以赋给这个接口类型</span></span><br><span class=\"line\"><span class=\"comment\">//        4.当吧HashMap$Node存放到entrySet后就方便我们的遍历，因为Map.Entry提供了两个重要的方法，getKey()和getValue方法</span></span><br><span class=\"line\">        <span class=\"type\">Set</span> <span class=\"variable\">set</span> <span class=\"operator\">=</span> map.entrySet();</span><br><span class=\"line\">        System.out.println(set.getClass());</span><br><span class=\"line\"><span class=\"comment\">//        输出：class java.util.HashMap$EntrySet</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o :set) &#123;</span><br><span class=\"line\">            System.out.println(o.getClass());</span><br><span class=\"line\"><span class=\"comment\">//            输出：class java.util.HashMap$Node</span></span><br><span class=\"line\"><span class=\"comment\">//            从HashMap$Node取出k-v</span></span><br><span class=\"line\"><span class=\"comment\">//            先做一个向下转型</span></span><br><span class=\"line\">            Map.<span class=\"type\">Entry</span> <span class=\"variable\">entry</span> <span class=\"operator\">=</span> (Map.Entry) o;</span><br><span class=\"line\">            System.out.println(entry.getKey() +<span class=\"string\">&quot;&quot;</span>+ entry.getValue());</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"map接口和常用方法\"><a href=\"#map接口和常用方法\" class=\"headerlink\" title=\"map接口和常用方法\"></a>map接口和常用方法</h4><p>1）put：添加</p>\n<p>2）remove：根据键删除映射关系</p>\n<p>3）get：根据键获取值</p>\n<p>4）size：获取元素个数</p>\n<p>5）isEmpty：判断个数是否为0</p>\n<p>6）clear；清楚</p>\n<p>7）containsKey：查找键值否存在</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Map</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no1&quot;</span>,<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no2&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"literal\">null</span>,<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no3&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no4&quot;</span>,<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        map.remove(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">lisi</span> <span class=\"operator\">=</span> map.get(<span class=\"string\">&quot;no2&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;lisi==&quot;</span>+lisi);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(map.size());</span><br><span class=\"line\"></span><br><span class=\"line\">        map.isEmpty();</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">        map.clear();</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(map.containsKey(<span class=\"string\">&quot;no3&quot;</span>));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"Map遍历方法\"><a href=\"#Map遍历方法\" class=\"headerlink\" title=\"Map遍历方法\"></a>Map遍历方法</h4><p>1）containsKey：查找键是否存在</p>\n<p>2）KeySet：获取所有的键</p>\n<p>3）entrySet：获取所有关系</p>\n<p>4）values：获取所有的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"type\">Map</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no1&quot;</span>,<span class=\"string\">&quot;zhangsan&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no2&quot;</span>,<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"literal\">null</span>,<span class=\"string\">&quot;sss&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no3&quot;</span>,<span class=\"string\">&quot;lisdsdsi&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;no4&quot;</span>,<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        第一粗：先取出所有的key，通过key取出对应的value</span></span><br><span class=\"line\">        <span class=\"type\">Set</span> <span class=\"variable\">set</span> <span class=\"operator\">=</span> map.keySet();</span><br><span class=\"line\"><span class=\"comment\">//        增强for</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o :set) &#123;</span><br><span class=\"line\">            System.out.println(map.get(o));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;迭代器&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        （2） 使用迭代器</span></span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">iterator</span> <span class=\"operator\">=</span> set.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span>  iterator.next();</span><br><span class=\"line\">            System.out.println(map.get(next));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;=========第二中=========&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//      第二组：吧所有的values取出</span></span><br><span class=\"line\">        <span class=\"type\">Collection</span> <span class=\"variable\">values</span> <span class=\"operator\">=</span> map.values();</span><br><span class=\"line\"><span class=\"comment\">//        这里可以使用所有的collections使用的遍历方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object o :values) &#123;</span><br><span class=\"line\">            System.out.println(o);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        迭代器</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;迭代器&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">iterator1</span> <span class=\"operator\">=</span> values.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator1.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span>  iterator1.next();</span><br><span class=\"line\">            System.out.println(next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;=========第三中=========&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        通过entryset获取</span></span><br><span class=\"line\">        <span class=\"type\">Set</span> <span class=\"variable\">set1</span> <span class=\"operator\">=</span> map.entrySet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object entry :set1) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            将entry转为map.entry</span></span><br><span class=\"line\">            Map.Entry  entry1= (Map.Entry) entry;</span><br><span class=\"line\">            System.out.println(entry1.getKey()+<span class=\"string\">&quot; &quot;</span>+entry1.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;迭代器&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">iterator2</span> <span class=\"operator\">=</span> set1.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator2.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span>  iterator2.next();</span><br><span class=\"line\">            Map.<span class=\"type\">Entry</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> (Map.Entry) next;</span><br><span class=\"line\">            System.out.println(m.getKey()+<span class=\"string\">&quot; itit &quot;</span>+ m.getValue());</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><ol>\n<li>Map接口的常用实现类：HashMap、Hashtable和Properties</li>\n<li>HashMap是Map接口使用频率最高的实现类</li>\n<li>HashMap是以key-value对的方式来存储数据（HashMap$Node类型）</li>\n<li>key不能重复，但值可以，允许使用null键和null值</li>\n<li>如果添加相同的 key，则会覆盖原来的k-v，等同于修改，（key不会替换，val会替换）</li>\n<li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来储存的</li>\n<li>HashMap没有实现同步，因此线程不安全 的</li>\n</ol>\n<h4 id=\"HashMap底层机制\"><a href=\"#HashMap底层机制\" class=\"headerlink\" title=\"HashMap底层机制\"></a>HashMap底层机制</h4><p>1）HashMap底层维护了Node类型的数组table，默认为null</p>\n<p>2）当创建对象时，将加载银子（loadfactor）初始化为0.75</p>\n<p>3）当添加key-value时，通过key的哈希值得到在table的索引，然后判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是连链表结构，做出相应处理。如果添加时发现容量不够则需扩容</p>\n<p>4）第一次添加，则需扩容table容量为16，临界值(threshold)为12</p>\n<p>5）以后再扩容，需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推</p>\n<p>6）在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小&gt;&#x3D;MIN_TREEIFY_CAPACITY(默认64)，就会进行树化。</p>\n<h4 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h4><p><strong>基本介绍</strong></p>\n<p>1）存放的元素时键值对：key-value</p>\n<p>2）hashTable的键和值都不能为null，否则会抛出空指针异常</p>\n<p>3）hashTable使用方法基本上和HashMap一样</p>\n<p>4）hashTable是线程安全的，HashMap是线程不安全的</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220506160740866.png\" alt=\"image-20220506160740866\"></p>\n<h4 id=\"Properties\"><a href=\"#Properties\" class=\"headerlink\" title=\"Properties\"></a>Properties</h4><p><strong>基本介绍</strong></p>\n<ol>\n<li>properties类继承了Hashtable类并实现了Map接口，也是使用一种键值对(key-value)的形式来保存数据</li>\n<li>它的使用特点和Hashtable类似</li>\n<li>properties还可用于从xxx.properties文件中，加载数据到properties类对象，并进行读取和修改</li>\n<li>说明：工作后 xxx.properties文件常用作配置文件，io流部分(详细讲解)[<a href=\"http://www.cnblogs.com/xudong-bupt/p/3758136.html]\">www.cnblogs.com/xudong-bupt/p/3758136.html]</a></li>\n</ol>\n<h2 id=\"Collections\"><a href=\"#Collections\" class=\"headerlink\" title=\"Collections\"></a>Collections</h2><h3 id=\"Collections工具类\"><a href=\"#Collections工具类\" class=\"headerlink\" title=\"Collections工具类\"></a>Collections工具类</h3><p>1）Collections是一个操作Set、List和Map等集合的工具类</p>\n<p>2）Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</p>\n<h3 id=\"排序操作（均为static方法）\"><a href=\"#排序操作（均为static方法）\" class=\"headerlink\" title=\"排序操作（均为static方法）\"></a>排序操作（均为static方法）</h3><ol>\n<li><p>reverse（List）：反转List中元素的顺序</p>\n</li>\n<li><p>shuffle（List）：对List集合元素进行随机排序</p>\n</li>\n<li><p>sort（List）：根据元素的自然顺序对指定List集合元素按升序排序</p>\n</li>\n<li><p>sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序</p>\n</li>\n<li><p>swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换</p>\n</li>\n<li><p>案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Collectionsdemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ArrayList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;zhansgan&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;lisi&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;wngwu&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;laoliu&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;dasima&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;list=&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//        1. reverse（List）：反转List中元素的顺序</span></span><br><span class=\"line\">        Collections.reverse(list);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;reverse=&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//        2. shuffle（List）：对List集合元素进行随机排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            Collections.shuffle(list);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;随机&quot;</span>+list);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        3. sort（List）：根据元素的自然顺序对指定List集合元素按升序排序</span></span><br><span class=\"line\">        Collections.sort(list);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;sort&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//        4. sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序</span></span><br><span class=\"line\">        Collections.sort(list, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Object o1, Object o2)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((String)o1).length()-((String)o2).length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;字符串长度排序&quot;</span>+list);</span><br><span class=\"line\"><span class=\"comment\">//        5. swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Collections.swap(list,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;位置交换&quot;</span>+list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"查找、替换\"><a href=\"#查找、替换\" class=\"headerlink\" title=\"查找、替换\"></a>查找、替换</h3><ol>\n<li><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p>\n</li>\n<li><p>Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素</p>\n</li>\n<li><p>Object min（Collection)</p>\n</li>\n<li><p>Object min (Collection，Comparator)</p>\n</li>\n<li><p>int frequency （Collection，Object）：染回指定集合中指定元素的出现次数</p>\n</li>\n<li><p>void copy（List dest，List src）：将src中的内容复制到dest中</p>\n</li>\n<li><p>boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>public static void main(String[] args) {<br>    ArrayList list &#x3D; new ArrayList();<br>    list.add(“zhansgan”);<br>    list.add(“lisi”);<br>    list.add(“wngwu”);<br>    list.add(“laoliu”);<br>    list.add(“dasima”);<br>    System.out.println(“list&#x3D;”+list);<br>&#x2F;&#x2F;        1. Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>    System.out.println(“max num&#x3D;”+Collections.max(list));<br>&#x2F;&#x2F;        2. Object max（Collection，Comparator）：根据Comparator指定的顺序，返回给定集合中最大的元素<br>&#x2F;&#x2F;            获取最大长度的值<br>    &#x2F;&#x2F;        3. Object min（Collection)<br>&#x2F;&#x2F;        4. Object min (Collection，Comparator)同理<br>    Object max &#x3D; Collections.max(list, new Comparator() {<br><br>        @Override<br>        public int compare(Object o1, Object o2) {<br>            return ((String) o1).length() - ((String) o2).length();<br>        }<br>    });<br>    System.out.println(“字符串最大的值为&#x3D;”+max);<br>&#x2F;&#x2F;        5. int frequency （Collection，Object）：染回指定集合中指定元素的出现次数</p>\n<pre><code>    System.out.println(&quot;lailiu=&quot;+ Collections.frequency(list,&quot;lailiu&quot;));\n</code></pre>\n<p>&#x2F;&#x2F;        6. void copy（List dest，List src）：将src中的内容复制到dest中<br>       ArrayList oldList &#x3D;  new ArrayList();<br>&#x2F;&#x2F;           为了完成一个拷贝，我们需要先给oldList赋值，大小和list一样,不然会报错<br>    for (int i &#x3D; 0; i &lt; list.size(); i++) {<br>        oldList.add(“”);<br>    }<br>&#x2F;&#x2F;        拷贝<br>    Collections.copy(oldList,list);<br>    System.out.println(“oldList&#x3D;”+oldList);<br>&#x2F;&#x2F;        7. boolean replaceAll（List list，Object oldVal，Object newVal）：使用新值替换List对象的所有旧值<br>    Collections.replaceAll(list,”laoliu”,”老六”);<br>    System.out.println(“替换后&#x3D;”+list);<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 总结</span><br><span class=\"line\"></span><br><span class=\"line\">在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择分析如下</span><br><span class=\"line\"></span><br><span class=\"line\">1）先判断储存类型（一组对象或一组键值对）</span><br><span class=\"line\"></span><br><span class=\"line\">2）一组对象[单列]：Collection接口</span><br><span class=\"line\"></span><br><span class=\"line\">* 允许重复：List</span><br><span class=\"line\">  * 增删多：LinkedList（底层维护了一个双向链表）</span><br><span class=\"line\">  * 改查多：ArrayList（底层维护了Object类型的可变数组）</span><br><span class=\"line\">* 不允许重复：Set</span><br><span class=\"line\">  * 无序：HashSet（底层是HashMap，维护了一个哈希表 即（数组+链表+红黑树））</span><br><span class=\"line\">  * 排序：TreeSet</span><br><span class=\"line\">  * 插入和取出顺序一直：LinkedHashSet，维护数组+双向链表</span><br><span class=\"line\"></span><br><span class=\"line\">3）一组键值对[双列]：Map</span><br><span class=\"line\"></span><br><span class=\"line\">* 键无序：HashMap（底层是：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树）</span><br><span class=\"line\">* 键排序：TreeSet</span><br><span class=\"line\">* 键插入和取出顺序一致：LinkedHashMap</span><br><span class=\"line\">* 读取文件：Properties</span><br><span class=\"line\"></span><br><span class=\"line\"># 泛型</span><br><span class=\"line\"></span><br><span class=\"line\">## 泛型语法</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">//        1.当我们ArrayList&lt;Dog&gt;表示放到ArrayList集合中的元素只能是Dog类型</span><br><span class=\"line\">//        2.如果编译器发现添加的类型不满足，就会报错</span><br><span class=\"line\">        ArrayList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();</span><br><span class=\"line\">        dogs.add(new Dog(&quot;laogou&quot;,12));</span><br><span class=\"line\">        dogs.add(new Dog(&quot;xiaogou&quot;,1));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">//       方便遍历</span><br><span class=\"line\">        for (Dog dog : dogs) &#123;</span><br><span class=\"line\">            System.out.println(dog);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>好处：</p>\n<ol>\n<li>编译时，检查添加元素的类型，提高了安全性</li>\n<li>减少了类型转换的次数，提高效率</li>\n<li>不再提示编译警告</li>\n</ol>\n<h3 id=\"介绍-14\"><a href=\"#介绍-14\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>理解：泛（广泛）型（类型）&#x3D;&#x3D;&gt; integer，String</p>\n<p>可以表示数据类型的数据类型<img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171057972.png\" alt=\"image-20220509171057972\"></p>\n<p>1）泛型又称参数化类型，时jdk5.0出现的新特性，解决数据类型的安全性问题</p>\n<p>2）在类声明或实例化时只要制定好需要的具体的类型即可</p>\n<p>3）java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮</p>\n<p>4）泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220509171249826.png\" alt=\"image-20220509171249826\"></p>\n<p>（此时E称为泛型，那么Dog-&gt;E（此时E为 ））</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cat&lt;String&gt; tianyuanmao = <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>&lt;&gt;(<span class=\"string\">&quot;tianyuanmao&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    E e;<span class=\"comment\">//E表示 e的数据类型，改数据类型在定义Cat对象时指定的，即在编译期间，就确定是什么类型了</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Cat</span><span class=\"params\">(E e)</span> &#123;<span class=\"comment\">//E也可在参数类型体现</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.e = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> E <span class=\"title function_\">method</span><span class=\"params\">()</span>&#123;<span class=\"comment\">//返回类型也可体现</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>泛型的声明</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface 接口&lt;T&gt; &#123;&#125;</span><br><span class=\"line\">class类&lt;K,V,...&gt;&#123;&#125;(可以接收多个泛型等等)</span><br><span class=\"line\">说明：</span><br><span class=\"line\">    <span class=\"number\">1.</span>其中K,V,T不代表值，而是表示类型</span><br><span class=\"line\">    <span class=\"number\">2.</span>任意字母都可以。常用T表示，是type的缩写</span><br></pre></td></tr></table></figure>\n\n<p>泛型的实例化</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">要在类名后面指定类型参数的值（类型）。如</span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\">List &lt;String&gt; strList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\">Iterator &lt;Customer&gt; iterator = coustomers.iterator();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用细节-5\"><a href=\"#使用细节-5\" class=\"headerlink\" title=\"使用细节\"></a>使用细节</h3><ol>\n<li><p>interface List<T>{},public class HashSet<E>{}….等等</p>\n<ol>\n<li>说明：T，E只能是引用类型</li>\n<li>不能是基本数据类型（八大基本数据类型,int,double 等等）</li>\n</ol>\n</li>\n<li><p>在指定泛型具体类型后，可以传入该类型或者其子类类型</p>\n</li>\n<li><p>泛型适用形式</p>\n<ol>\n<li><p>&#96;&#96;&#96;java<br>List<integer> list1 &#x3D;new ArrayList<Integer>{}</p>\n<p>List<Integer> list2 &#x3D; new ArrayList&lt;&gt;();</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 如果我们这样写List list3 = new ArrayList（）；默认给它的泛型是[&lt;E&gt; E就是Object 类型]</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 自定义泛型</span><br><span class=\"line\"></span><br><span class=\"line\">### 泛型类</span><br><span class=\"line\"></span><br><span class=\"line\">**基本语法**</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">class 类名&lt;T,R....&gt;&#123;</span><br><span class=\"line\">成员</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<p>细节：</p>\n<ol>\n<li><p>普通成员可以使用泛型（属性，方法）</p>\n</li>\n<li><p>使用泛型的数组，不能初始化</p>\n</li>\n<li><p>静态方法中不能使用类的泛型‘</p>\n<ol>\n<li>因为静态是和类相关的，在类加载时，对象还没创建</li>\n<li>所以，如果静态方法和静态属性使用泛型时 ，JVM就无法完成初始化</li>\n</ol>\n</li>\n<li><p>泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）</p>\n</li>\n<li><p>如果在创建对象时，没有指定类型，默认为object</p>\n</li>\n<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;1.demo后面有泛型，所以我们吧demo就称为自定义泛型类<br>&#x2F;&#x2F;2.T,R,M泛型的标识符，一般是单个大写字母<br>&#x2F;&#x2F;3.泛型标识符可以有多个<br>&#x2F;&#x2F;4.普通成员可以使用泛型 （属性，方法）<br>&#x2F;&#x2F;5.使用泛型的数组，不能初始化<br>&#x2F;&#x2F;（因为数组在new的<br>class demo&lt;T,R,M&gt;{<br>String name;<br>T t;<br>R r;<br>M m;<br>T[] t1;&#x2F;&#x2F;可以声明<br><br>public demo11(String name, T t, R r, M m) {&#x2F;&#x2F;构造器使用泛型<br>    this.name &#x3D; name;<br>    this.t &#x3D; t;<br>    this.r &#x3D; r;<br>    this.m &#x3D; m;<br>}<br>&#x2F;&#x2F;方法使用泛型<br> public String getName() {<br>    return name;<br>}<br><br>public void setName(String name) {<br>    this.name &#x3D; name;<br>}<br><br>public T getT() {<br>    return t;<br>}<br><br>public void setT(T t) {<br>    this.t &#x3D; t;<br>}<br><br>public R getR() {<br>    return r;<br>}<br><br>public void setR(R r) {<br>    this.r &#x3D; r;<br>}<br><br>public M getM() {<br>    return m;<br>}<br><br>public void setM(M m) {<br>    this.m &#x3D; m;<br>}<br>}</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 泛型接口</span><br><span class=\"line\"></span><br><span class=\"line\">**基本语法**</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">interface  接口名 &lt;T,R...&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>细节：</p>\n<ol>\n<li><p>接口中，静态成员也不能使用泛型</p>\n</li>\n<li><p>泛型接口的类型，在继承接口或者实现接口时确定</p>\n</li>\n<li><p>没有指定类型，默认为Object</p>\n</li>\n</ol>\n<h3 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h3><p><strong>基本语法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">修饰符&lt;T,R...&gt;返回类型 方法名（番薯列表）&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意细节</strong>：</p>\n<ol>\n<li><p>反省方法，可以定义在普通类中，也可以定义在泛型类中</p>\n</li>\n<li><p>当泛型方法被调用时，类型会确定</p>\n</li>\n<li><p>public void eat（E e）{}，修饰符后没有&lt;T,R..&gt;eat方法不是泛型方法，而是使用了泛型</p>\n</li>\n<li><pre><code class=\"java\">//泛型方法，可以定义在普通类中，也可以定义在泛型类中\nclass Car&#123;\n    public void run()&#123;//普通方法\n\n    &#125;\n//    1.T,R就是泛型标识符\n//    2.提供给fly方法使用的\n    public &lt;T,R&gt; void  fly(T t, R r)&#123;//泛型方法\n\n    &#125;\n\n&#125;\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">5. ```java</span><br><span class=\"line\">   class Car2&lt;T,R&gt;&#123;//泛型类</span><br><span class=\"line\">       public &lt;U,M&gt; void  fly(U u, M m)&#123;//泛型方法</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       public void  fly2(T t)&#123;</span><br><span class=\"line\">   //        1.该方法不是泛型方法</span><br><span class=\"line\">   //        2.是fly2方法使用了类声明的泛型</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>&#96;&#96;&#96;java<br>Car car &#x3D; new Car();<br>    car.fly(“baoma”,2000);<br>    &#x2F;&#x2F;在调用方法是，编译器会自动识别传入的参数的类型，就会确定型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">7. 泛型方法可以使用类声明的泛型，也可使用自己声明的泛型</span><br><span class=\"line\"></span><br><span class=\"line\">## 泛型继承和通配符</span><br><span class=\"line\"></span><br><span class=\"line\">**介绍**</span><br><span class=\"line\"></span><br><span class=\"line\">1)泛型不具备继承性</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">List&lt;Object&gt; list = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">//是错误的，因为泛型中没有继承性</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>2）&lt;?&gt;:支持任意泛型类型</p>\n<p>3）&lt;? extend A&gt;:支持A类以及 A类的子类，规定了泛型的上限</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142709072.png\" alt=\"image-20220511142709072\"></p>\n<p>4）&lt;? super A&gt;:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</p>\n<p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220511142730306.png\" alt=\"image-20220511142730306\"></p>\n<h1 id=\"知识点补充\"><a href=\"#知识点补充\" class=\"headerlink\" title=\"知识点补充\"></a>知识点补充</h1><h2 id=\"JUnit\"><a href=\"#JUnit\" class=\"headerlink\" title=\"JUnit\"></a>JUnit</h2><ol>\n<li>一个类有很多功能代码需要测试，为了测试，就需要写入main方法中</li>\n<li>如果有很多个功能代码测试，就需要来回注销，切换很麻烦</li>\n<li>如果可以直接运行一个方法，就会方便很多</li>\n</ol>\n<h3 id=\"介绍：-3\"><a href=\"#介绍：-3\" class=\"headerlink\" title=\"介绍：\"></a>介绍：</h3><p>1. </p>\n<h1 id=\"练习部分\"><a href=\"#练习部分\" class=\"headerlink\" title=\"练习部分\"></a>练习部分</h1><h2 id=\"快速入门部分\"><a href=\"#快速入门部分\" class=\"headerlink\" title=\"快速入门部分\"></a>快速入门部分</h2><ol>\n<li><p>开发一个hello.java文件，输出：老王 is studying java！</p>\n<ol>\n<li>&#96;&#96;&#96;java<br>public class hello{<br>public static void main(String[] args) {<br>System.out.println(“lao wang is studying java”);<br><br>}<br>}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   2. 需注意的事项：记得吧类部分带上public class 带上，不要只写个方法</span><br><span class=\"line\"></span><br><span class=\"line\">## 制表符部分</span><br><span class=\"line\"></span><br><span class=\"line\">1. ![image-20220204140604059](https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220204140604059.png)</span><br><span class=\"line\"></span><br><span class=\"line\">   1. ```java</span><br><span class=\"line\">      public class ChangeChar &#123;</span><br><span class=\"line\">          public static void main(String[] args) &#123;</span><br><span class=\"line\">              System.out.println(&quot;书名\\t作者\\t价格\\t销量\\n三国\\t罗贯中\\t120\\t1000&quot;);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"进制部分\"><a href=\"#进制部分\" class=\"headerlink\" title=\"进制部分\"></a>进制部分</h2><ul>\n<li><p>第一部分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 0b110001100</span><br><span class=\"line\">   =0*2^0 + 0*2^1 + 1*2^2 + 1*2^3 + 0*2^4 + 0*2^5 + 0*2^6 + 1*2^7 + 1*2^8</span><br><span class=\"line\">   =0+0+4+8+0+0+0+128+256</span><br><span class=\"line\">   =396</span><br><span class=\"line\">02456</span><br><span class=\"line\">=6*8^0 + 5*8^1 + 4*8^2 + 2*8^3</span><br><span class=\"line\">=6+40+256+1024</span><br><span class=\"line\">=1326</span><br><span class=\"line\"></span><br><span class=\"line\">0xA45</span><br><span class=\"line\">=5*16^0 + 4*16^1 + 10*16^2</span><br><span class=\"line\">=5 + 64 + 2560</span><br><span class=\"line\">=2629</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"位运算练习\"><a href=\"#位运算练习\" class=\"headerlink\" title=\"位运算练习\"></a>位运算练习</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2|3</span><br><span class=\"line\">1. 2的原码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">2. 2的补码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">3. 3的原码：00000000 00000000 00000000 00000011</span><br><span class=\"line\">4. 3的补码：00000000 00000000 00000000 00000011</span><br><span class=\"line\">5.2|3：00000000 00000000 00000000 00000010（都为1结果为1否则为0）</span><br><span class=\"line\">6. 转为原码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">7.结果为：2</span><br><span class=\"line\"></span><br><span class=\"line\">2^3</span><br><span class=\"line\">1. 2的原码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">2. 2的补码：00000000 00000000 00000000 00000010</span><br><span class=\"line\">3. 3的原码：00000000 00000000 00000000 00000011</span><br><span class=\"line\">4. 3的补码：00000000 00000000 00000000 00000011</span><br><span class=\"line\">5.2^3:00000000 00000000 00000000 00000001(两位一个为0，一个为1，结果为1，否则为0)</span><br><span class=\"line\">6.转为原码：00000000 00000000 00000000 00000001</span><br><span class=\"line\">7.结果为1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"switch练习\"><a href=\"#switch练习\" class=\"headerlink\" title=\"switch练习\"></a>switch练习</h2><ol>\n<li><p><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162131420.png\" alt=\"image-20220225162131420\"></p>\n<ul>\n<li><img src=\"https://imagebed-1306275532.cos.ap-shanghai.myqcloud.com/img/image-20220225162214945.png\" alt=\"image-20220225162214945\"></li>\n</ul>\n</li>\n<li><p>3,4,5为春季。6，7，8，为夏季，9,10,11位秋季。12,1,2为冬季</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>Scanner scanner &#x3D; new Scanner(System.in);<br>    System.out.println(“请输入月份”);<br>    int month &#x3D; scanner.nextInt();<br>    if (month&gt;0 &amp;&amp; month&lt;&#x3D;12){<br>        switch (month){<br>            case 3:<br>            case 4:<br>            case 5:<br>                System.out.println(“春季”);<br>                break;<br>            case 6:<br>            case 7:<br>            case 8:<br>                System.out.println(“夏季”);<br>                break;<br>            case 9:<br>            case 10:<br>            case 11:<br>                System.out.println(“秋季”);<br>                break;<br>            case 12:<br>            case 1:<br>            case 2:<br>                System.out.println(“冬季”);<br>                break;<br>        }<br>    }else {<br>        System.out.println(“输入不合法”);<br>    }<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 数组部分</span><br><span class=\"line\"></span><br><span class=\"line\">* 已知数组&#123;10,12,45,90&#125;。添加一个数使该数组依然是升序的</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">//方法1：数组扩容➕冒泡排序</span><br><span class=\"line\"></span><br><span class=\"line\">package basics.chapterArray;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.time.OffsetDateTime;</span><br><span class=\"line\">import java.util.Scanner;</span><br><span class=\"line\">import java.util.concurrent.ForkJoinPool;</span><br><span class=\"line\"></span><br><span class=\"line\">public class exercisesArryHomeWork &#123;</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    * 已知数组&#123;10,12,45,90&#125;</span><br><span class=\"line\">    * 添加一个数使该数组依然是升序的</span><br><span class=\"line\">    * */</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] arr = &#123;10,12,45,90&#125;;</span><br><span class=\"line\">        char key;</span><br><span class=\"line\">        Scanner scanner = new Scanner(System.in);</span><br><span class=\"line\">        int inputnum;</span><br><span class=\"line\">        int tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">        do &#123;</span><br><span class=\"line\">            int[] arr2 = new int[arr.length+1];</span><br><span class=\"line\">            for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">                arr2[i] = arr[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;请输入添加一个数&quot;);</span><br><span class=\"line\">            inputnum = scanner.nextInt();</span><br><span class=\"line\">            arr2[arr2.length-1] = inputnum;</span><br><span class=\"line\">            arr = arr2;</span><br><span class=\"line\">            for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">                System.out.print(arr[i]+&quot;\\t&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(&quot;是否继续输入? y/n&quot;);</span><br><span class=\"line\">            key = scanner.next().charAt(0);</span><br><span class=\"line\">            if (key == &#x27;y&#x27;)&#123;</span><br><span class=\"line\">                System.out.println(&quot;continue&quot;);</span><br><span class=\"line\">            &#125;else if (key == &#x27;n&#x27;)&#123;</span><br><span class=\"line\">                System.out.println(&quot;end&quot;);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                System.out.println(&quot;input error&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;while (true);</span><br><span class=\"line\">        System.out.println(&quot;============数组排序==============&quot;);</span><br><span class=\"line\">        for (int i = 0; i &lt; arr.length-1; i++) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt;arr.length ; j++) &#123;</span><br><span class=\"line\">                if (j&gt;=arr.length-1)&#123;</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;else if (arr[j]&lt;=arr[j+1])&#123;</span><br><span class=\"line\">                    System.out.println(&quot;no change&quot;);</span><br><span class=\"line\">                &#125;else if (arr[j]&gt;=arr[j+1])&#123;</span><br><span class=\"line\">                    tmp = arr[j+1];</span><br><span class=\"line\">                    arr[j+1] = arr[j];</span><br><span class=\"line\">                    arr[j] = tmp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;=============输出==============&quot;);</span><br><span class=\"line\">        for (int i = 0; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">            System.out.print(arr[i]+&quot;\\t&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p>方法二：定位➕扩容</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1. 先定义原数组 </span><br><span class=\"line\">//2. 遍历数组，如果发现insertnum &lt; arr[i] ,说明i就是要插入的位置</span><br><span class=\"line\">//3. 如果index 保留 index =i</span><br><span class=\"line\">//4. 如果遍历完后，没有发现inserNum&lt;=arr[i] ，说明index = arr.length</span><br><span class=\"line\">即：添加到arr的最后</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> basics.chapterArray;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">exercisesArrayHomeWorkmethod2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = &#123;<span class=\"number\">10</span>,<span class=\"number\">12</span>,<span class=\"number\">45</span>,<span class=\"number\">90</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">insertNum</span> <span class=\"operator\">=</span> <span class=\"number\">23</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">//          数组定位</span></span><br><span class=\"line\"><span class=\"comment\">//        1.遍历数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            2. 如果arr[i]的这个数大于insertNum则表示这个数的位置是要添加的数的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (insertNum&lt;=arr[i])&#123;</span><br><span class=\"line\"><span class=\"comment\">//                3. 用index接受这个位置信息</span></span><br><span class=\"line\">                index = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        4. 数组扩容添加</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr2 = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr.length+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"comment\">//        创建一个j，当插入前半部分时，j指向arr的数组的数不变。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,j=<span class=\"number\">0</span>; i &lt;arr2.length; i++) &#123;</span><br><span class=\"line\"><span class=\"comment\">//            如果i不等于上面得到的i的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ( i != index)&#123;</span><br><span class=\"line\"><span class=\"comment\">//                则将arr的数赋给对应的新数组</span></span><br><span class=\"line\">                arr2[i] = arr[j];</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                arr2[i] = insertNum;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr = arr2;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;arr.length ; i++) &#123;</span><br><span class=\"line\">            System.out.print(arr[i]+<span class=\"string\">&quot;\\t&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"二维数组部分\"><a href=\"#二维数组部分\" class=\"headerlink\" title=\"二维数组部分\"></a>二维数组部分</h3><ol>\n<li>&#96;&#96;&#96;java<br>&#x2F;&#x2F;            int[][] arr &#x3D;</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl9qmes790000iorfguxec5lk","category_id":"cl9qmes7h0002iorf04umejyt","_id":"cl9qmes7n0008iorf6a3r8pkm"},{"post_id":"cl9qmes7j0004iorf71th1l8o","category_id":"cl9qmes7h0002iorf04umejyt","_id":"cl9qmes7n000biorffyum8hcs"},{"post_id":"cl9qmes7j0004iorf71th1l8o","category_id":"cl9qmes7n000aiorf9wd1fxqr","_id":"cl9qmes7n000ciorfhzo491ai"},{"post_id":"cl9qmes7o000diorf8olee8va","category_id":"cl9qmes7p000eiorf9pfeewj1","_id":"cl9qmes7q000iiorfg2chea45"},{"post_id":"cl9qmes7o000diorf8olee8va","category_id":"cl9qmes7q000hiorfd8kt0562","_id":"cl9qmes7q000jiorfett8atn9"}],"PostTag":[{"post_id":"cl9qmes790000iorfguxec5lk","tag_id":"cl9qmes7i0003iorf7u0d8qn6","_id":"cl9qmes7m0007iorfekl3fu9x"},{"post_id":"cl9qmes7j0004iorf71th1l8o","tag_id":"cl9qmes7i0003iorf7u0d8qn6","_id":"cl9qmes7n0009iorf4xrt5h9r"},{"post_id":"cl9qmes7o000diorf8olee8va","tag_id":"cl9qmes7p000fiorf89x38qp9","_id":"cl9qmes7q000giorf6e8ygimi"}],"Tag":[{"name":"安装","_id":"cl9qmes7i0003iorf7u0d8qn6"},{"name":"java","_id":"cl9qmes7p000fiorf89x38qp9"}]}}